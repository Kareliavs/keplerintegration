{
  "version": 3,
  "sources": ["../../@deck.gl/layers/src/arc-layer/arc-layer-vertex.glsl.js", "../../@deck.gl/layers/src/arc-layer/arc-layer-fragment.glsl.js", "../../@deck.gl/layers/src/arc-layer/arc-layer.js", "../../@deck.gl/layers/src/bitmap-layer/create-mesh.js", "../../@deck.gl/layers/src/bitmap-layer/bitmap-layer-vertex.js", "../../@deck.gl/layers/src/bitmap-layer/bitmap-layer-fragment.js", "../../@deck.gl/layers/src/bitmap-layer/bitmap-layer.js", "../../@deck.gl/layers/src/icon-layer/icon-layer-vertex.glsl.js", "../../@deck.gl/layers/src/icon-layer/icon-layer-fragment.glsl.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/utils/assert.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/utils/globals.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/category-api/image-type.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/category-api/parsed-image-api.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/parsers/svg-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/parsers/parse-to-image.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/parsers/parse-to-image-bitmap.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/category-api/binary-image-api.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/parsers/parse-to-node-image.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/parsers/parse-image.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/image-loader.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/encoders/encode-image.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/image-writer.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/env-utils/assert.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/env-utils/globals.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-utils/get-transfer-list.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-loader-utils/validate-loader-version.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-loader-utils/create-worker.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-utils/get-worker-url.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-utils/worker-thread.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-utils/worker-pool.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/worker-utils/worker-farm.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/library-utils/library-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/binary-utils/get-first-characters.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/parser-utils/parse-json.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/binary-utils/buffer-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/binary-utils/array-buffer-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/binary-utils/memory-copy-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/binary-utils/binary-copy-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/binary-utils/encode-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/path-utils/path.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/path-utils/file-aliases.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/iterator-utils/async-iteration.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/request-utils/request-scheduler.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/process-utils/process-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/lib/process-utils/child-process-proxy.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/categories/mesh/mesh-utils.js", "../../@deck.gl/layers/node_modules/@loaders.gl/loader-utils/src/index.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/texture-api/generate-url.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/texture-api/deep-load.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/texture-api/load-image.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/texture-api/load-image-array.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/texture-api/load-image-cube.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/lib/deprecated/binary-image-api-deprecated.js", "../../@deck.gl/layers/node_modules/@loaders.gl/images/src/index.js", "../../@deck.gl/layers/src/icon-layer/icon-manager.js", "../../@deck.gl/layers/src/icon-layer/icon-layer.js", "../../@deck.gl/layers/src/line-layer/line-layer-vertex.glsl.js", "../../@deck.gl/layers/src/line-layer/line-layer-fragment.glsl.js", "../../@deck.gl/layers/src/line-layer/line-layer.js", "../../@deck.gl/layers/src/point-cloud-layer/point-cloud-layer-vertex.glsl.js", "../../@deck.gl/layers/src/point-cloud-layer/point-cloud-layer-fragment.glsl.js", "../../@deck.gl/layers/src/point-cloud-layer/point-cloud-layer.js", "../../@deck.gl/layers/src/scatterplot-layer/scatterplot-layer-vertex.glsl.js", "../../@deck.gl/layers/src/scatterplot-layer/scatterplot-layer-fragment.glsl.js", "../../@deck.gl/layers/src/scatterplot-layer/scatterplot-layer.js", "../../@deck.gl/layers/src/column-layer/column-geometry.js", "../../@deck.gl/layers/src/column-layer/column-layer-vertex.glsl.js", "../../@deck.gl/layers/src/column-layer/column-layer-fragment.glsl.js", "../../@deck.gl/layers/src/column-layer/column-layer.js", "../../@deck.gl/layers/src/column-layer/grid-cell-layer.js", "../../@math.gl/polygon/src/polygon-utils.ts", "../../@math.gl/polygon/src/polygon.ts", "../../@math.gl/polygon/src/earcut.ts", "../../@math.gl/polygon/src/utils.ts", "../../@math.gl/polygon/src/lineclip.ts", "../../@math.gl/polygon/src/cut-by-grid.ts", "../../@math.gl/polygon/src/cut-by-mercator-bounds.ts", "../../@math.gl/polygon/src/index.ts", "../../@deck.gl/layers/src/path-layer/path.js", "../../@deck.gl/layers/src/path-layer/path-tesselator.js", "../../@deck.gl/layers/src/path-layer/path-layer-vertex.glsl.js", "../../@deck.gl/layers/src/path-layer/path-layer-fragment.glsl.js", "../../@deck.gl/layers/src/path-layer/path-layer.js", "../../earcut/src/earcut.js", "../../@deck.gl/layers/src/solid-polygon-layer/polygon.js", "../../@deck.gl/layers/src/solid-polygon-layer/polygon-tesselator.js", "../../@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js", "../../@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js", "../../@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js", "../../@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js", "../../@deck.gl/layers/src/solid-polygon-layer/solid-polygon-layer.js", "../../@deck.gl/layers/src/utils.js", "../../@deck.gl/layers/src/polygon-layer/polygon-layer.js", "../../@deck.gl/layers/src/geojson-layer/geojson.js", "../../@deck.gl/layers/src/geojson-layer/geojson-layer.js", "../../@deck.gl/layers/src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js", "../../@deck.gl/layers/src/text-layer/multi-icon-layer/multi-icon-layer.js", "../../@deck.gl/layers/node_modules/@mapbox/tiny-sdf/index.js", "../../@deck.gl/layers/src/text-layer/utils.js", "../../@deck.gl/layers/src/text-layer/lru-cache.js", "../../@deck.gl/layers/src/text-layer/font-atlas-manager.js", "../../@deck.gl/layers/src/text-layer/text-layer.js", "../../@deck.gl/layers/src/index.js"],
  "sourcesContent": ["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n  // d: distance on the xy plane\n  // r: ratio of the current point\n  // p: ratio of the peak of the arc\n  // h: height multiplier\n  // z = f(r) = sqrt(r * (p * 2 - r)) * d * h\n  // f(0) = 0\n  // f(1) = dz\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  float unitZ = dh == 0.0 ? 0.0 : deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n\n  // sqrt does not deal with negative values, manually flip source and target if delta.z < 0\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\n\n/* Great circle interpolation\n * http://www.movable-type.co.uk/scripts/latlong.html\n */\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\n/* END GREAT CIRCLE */\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  // if it's the first point, use next - current as direction\n  // otherwise use current - prev\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    vec3 source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    vec3 target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n  \n    float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n    float nextSegmentRatio = getSegmentRatio(min(numSegments, segmentIndex + 1.0));\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      // split at the 180th meridian\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source = project_position(instanceSourcePositions, instanceSourcePositions64Low);\n    vec3 target = project_position(instanceTargetPositions, instanceTargetPositions64Low);\n\n    float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n\n  // Multiply out width and clamp to limits\n  // mercator pixels are interpreted as screen pixels\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n\n  // extrude\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking} from '@deck.gl/core';\n\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './arc-layer-vertex.glsl';\nimport fs from './arc-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  getSourcePosition: {type: 'accessor', value: x => x.sourcePosition},\n  getTargetPosition: {type: 'accessor', value: x => x.targetPosition},\n  getSourceColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getTargetColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1},\n  getHeight: {type: 'accessor', value: 1},\n  getTilt: {type: 'accessor', value: 0},\n\n  greatCircle: false,\n\n  widthUnits: 'pixels',\n  widthScale: {type: 'number', value: 1, min: 0},\n  widthMinPixels: {type: 'number', value: 0, min: 0},\n  widthMaxPixels: {type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0}\n};\n\nexport default class ArcLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]}); // 'project' module added by default.\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceSourcePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getSourcePosition'\n      },\n      instanceTargetPositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getTargetPosition'\n      },\n      instanceSourceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getSourceColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceTargetColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getTargetColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getWidth',\n        defaultValue: 1\n      },\n      instanceHeights: {\n        size: 1,\n        transition: true,\n        accessor: 'getHeight',\n        defaultValue: 1\n      },\n      instanceTilts: {\n        size: 1,\n        transition: true,\n        accessor: 'getTilt',\n        defaultValue: 0\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    // Re-generate model if geometry changed\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({uniforms}) {\n    const {viewport} = this.context;\n    const {widthUnits, widthScale, widthMinPixels, widthMaxPixels, greatCircle} = this.props;\n\n    const widthMultiplier = widthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        greatCircle,\n        widthScale: widthScale * widthMultiplier,\n        widthMinPixels,\n        widthMaxPixels\n      })\n      .draw();\n  }\n\n  _getModel(gl) {\n    let positions = [];\n    const NUM_SEGMENTS = 50;\n    /*\n     *  (0, -1)-------------_(1, -1)\n     *       |          _,-\"  |\n     *       o      _,-\"      o\n     *       |  _,-\"          |\n     *   (0, 1)\"-------------(1, 1)\n     */\n    for (let i = 0; i < NUM_SEGMENTS; i++) {\n      positions = positions.concat([i, 1, 0, i, -1, 0]);\n    }\n\n    const model = new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_STRIP,\n          attributes: {\n            positions: new Float32Array(positions)\n          }\n        }),\n        isInstanced: true\n      })\n    );\n\n    model.setUniforms({numSegments: NUM_SEGMENTS});\n\n    return model;\n  }\n}\n\nArcLayer.layerName = 'ArcLayer';\nArcLayer.defaultProps = defaultProps;\n", "import {lerp} from 'math.gl';\n\nconst DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);\nconst DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);\n\n/*\n  1 ---- 2\n  |      |\n  |      |\n  0 ---- 3\n*/\n/* eslint-disable max-statements */\nexport default function createMesh(bounds, resolution) {\n  if (!resolution) {\n    return createQuad(bounds);\n  }\n  const maxXSpan = Math.max(\n    Math.abs(bounds[0][0] - bounds[3][0]),\n    Math.abs(bounds[1][0] - bounds[2][0])\n  );\n  const maxYSpan = Math.max(\n    Math.abs(bounds[1][1] - bounds[0][1]),\n    Math.abs(bounds[2][1] - bounds[3][1])\n  );\n  const uCount = Math.ceil(maxXSpan / resolution) + 1;\n  const vCount = Math.ceil(maxYSpan / resolution) + 1;\n\n  const vertexCount = (uCount - 1) * (vCount - 1) * 6;\n  const indices = new Uint32Array(vertexCount);\n  const texCoords = new Float32Array(uCount * vCount * 2);\n  const positions = new Float64Array(uCount * vCount * 3);\n\n  // Tesselate\n  let vertex = 0;\n  let index = 0;\n  for (let u = 0; u < uCount; u++) {\n    const ut = u / (uCount - 1);\n    for (let v = 0; v < vCount; v++) {\n      const vt = v / (vCount - 1);\n      const p = interpolateQuad(bounds, ut, vt);\n\n      positions[vertex * 3 + 0] = p[0];\n      positions[vertex * 3 + 1] = p[1];\n      positions[vertex * 3 + 2] = p[2] || 0;\n\n      texCoords[vertex * 2 + 0] = ut;\n      texCoords[vertex * 2 + 1] = 1 - vt;\n\n      if (u > 0 && v > 0) {\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - vCount - 1;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex - vCount;\n        indices[index++] = vertex - 1;\n        indices[index++] = vertex;\n      }\n\n      vertex++;\n    }\n  }\n  return {\n    vertexCount,\n    positions,\n    indices,\n    texCoords\n  };\n}\n\nfunction createQuad(bounds) {\n  const positions = new Float64Array(12);\n  // [[minX, minY], [minX, maxY], [maxX, maxY], [maxX, minY]]\n  for (let i = 0; i < bounds.length; i++) {\n    positions[i * 3 + 0] = bounds[i][0];\n    positions[i * 3 + 1] = bounds[i][1];\n    positions[i * 3 + 2] = bounds[i][2] || 0;\n  }\n\n  return {\n    vertexCount: 6,\n    positions,\n    indices: DEFAULT_INDICES,\n    texCoords: DEFAULT_TEX_COORDS\n  };\n}\n\nfunction interpolateQuad(quad, ut, vt) {\n  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);\n}\n", "export default `\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n`;\n", "export default `\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor, vec4(color, 1.0), alpha);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global HTMLVideoElement */\nimport GL from '@luma.gl/constants';\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport {Model, Geometry, Texture2D} from '@luma.gl/core';\nimport createMesh from './create-mesh';\n\nimport vs from './bitmap-layer-vertex';\nimport fs from './bitmap-layer-fragment';\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nconst defaultProps = {\n  image: {type: 'object', value: null, async: true},\n  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},\n\n  desaturate: {type: 'number', min: 0, max: 1, value: 0},\n  // More context: because of the blending mode we're using for ground imagery,\n  // alpha is not effective when blending the bitmap layers with the base map.\n  // Instead we need to manually dim/blend rgb values with a background color.\n  transparentColor: {type: 'color', value: [0, 0, 0, 0]},\n  tintColor: {type: 'color', value: [255, 255, 255]}\n};\n\n/*\n * @class\n * @param {object} props\n * @param {number} props.transparentColor - color to interpret transparency to\n * @param {number} props.tintColor - color bias\n */\nexport default class BitmapLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    attributeManager.remove(['instancePickingColors']);\n    const noAlloc = true;\n\n    attributeManager.add({\n      indices: {\n        size: 1,\n        isIndexed: true,\n        update: attribute => (attribute.value = this.state.mesh.indices),\n        noAlloc\n      },\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        update: attribute => (attribute.value = this.state.mesh.positions),\n        noAlloc\n      },\n      texCoords: {\n        size: 2,\n        update: attribute => (attribute.value = this.state.mesh.texCoords),\n        noAlloc\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    // setup model first\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (props.image !== oldProps.image) {\n      this.loadTexture(props.image);\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (props.bounds !== oldProps.bounds) {\n      const oldMesh = this.state.mesh;\n      const mesh = this._createMesh();\n      this.state.model.setVertexCount(mesh.vertexCount);\n      for (const key in mesh) {\n        if (oldMesh && oldMesh[key] !== mesh[key]) {\n          attributeManager.invalidate(key);\n        }\n      }\n      this.setState({mesh});\n    }\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    if (this.state.bitmapTexture) {\n      this.state.bitmapTexture.delete();\n    }\n  }\n\n  _createMesh() {\n    const {bounds} = this.props;\n\n    let normalizedBounds = bounds;\n    // bounds as [minX, minY, maxX, maxY]\n    if (Number.isFinite(bounds[0])) {\n      /*\n        (minX0, maxY3) ---- (maxX2, maxY3)\n               |                  |\n               |                  |\n               |                  |\n        (minX0, minY1) ---- (maxX2, minY1)\n     */\n      normalizedBounds = [\n        [bounds[0], bounds[1]],\n        [bounds[0], bounds[3]],\n        [bounds[2], bounds[3]],\n        [bounds[2], bounds[1]]\n      ];\n    }\n\n    return createMesh(normalizedBounds, this.context.viewport.resolution);\n  }\n\n  _getModel(gl) {\n    if (!gl) {\n      return null;\n    }\n\n    /*\n      0,0 --- 1,0\n       |       |\n      0,1 --- 1,1\n    */\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          vertexCount: 6\n        }),\n        isInstanced: false\n      })\n    );\n  }\n\n  draw(opts) {\n    const {uniforms} = opts;\n    const {bitmapTexture, model} = this.state;\n    const {image, desaturate, transparentColor, tintColor} = this.props;\n\n    // Update video frame\n    if (\n      bitmapTexture &&\n      image instanceof HTMLVideoElement &&\n      image.readyState > HTMLVideoElement.HAVE_METADATA\n    ) {\n      const sizeChanged =\n        bitmapTexture.width !== image.videoWidth || bitmapTexture.height !== image.videoHeight;\n      if (sizeChanged) {\n        // note clears image and mipmaps when resizing\n        bitmapTexture.resize({width: image.videoWidth, height: image.videoHeight, mipmaps: true});\n        bitmapTexture.setSubImageData({\n          data: image,\n          paramters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      } else {\n        bitmapTexture.setSubImageData({\n          data: image\n        });\n      }\n\n      bitmapTexture.generateMipmap();\n    }\n\n    // // TODO fix zFighting\n    // Render the image\n    if (bitmapTexture && model) {\n      model\n        .setUniforms(\n          Object.assign({}, uniforms, {\n            bitmapTexture,\n            desaturate,\n            transparentColor: transparentColor.map(x => x / 255),\n            tintColor: tintColor.slice(0, 3).map(x => x / 255)\n          })\n        )\n        .draw();\n    }\n  }\n\n  loadTexture(image) {\n    const {gl} = this.context;\n\n    if (this.state.bitmapTexture) {\n      this.state.bitmapTexture.delete();\n    }\n\n    if (image instanceof Texture2D) {\n      this.setState({bitmapTexture: image});\n    } else if (image instanceof HTMLVideoElement) {\n      // Initialize an empty texture while we wait for the video to load\n      this.setState({\n        bitmapTexture: new Texture2D(gl, {\n          width: 1,\n          height: 1,\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\n          mipmaps: false\n        })\n      });\n    } else if (image) {\n      // Browser object: Image, ImageData, HTMLCanvasElement, ImageBitmap\n      this.setState({\n        bitmapTexture: new Texture2D(gl, {\n          data: image,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        })\n      });\n    }\n  }\n}\n\nBitmapLayer.layerName = 'BitmapLayer';\nBitmapLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  // convert size in meters to pixels, then scaled and clamp\n \n  // project meters to pixels and clamp to limits \n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n\n  // scale icon height to match instanceSize\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n\n  // scale and rotate vertex in \"pixel\" value and convert back to fraction in clipspace\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n\n  // if colorMode == 0, use pixel color from the texture\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  // Take the global opacity and the alpha from vColor into account for the alpha component\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "export default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n/* eslint-disable no-restricted-globals */\n/* global process, window, global, document, self, importScripts */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  // @ts-ignore\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n", "/* global ImageBitmap, Image */\nimport {global, isBrowser} from '../utils/globals';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_parseImageNode} = global;\n\nconst IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: \"false\" positives if jsdom is installed\nconst IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';\nconst NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);\nconst DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;\n\n// Checks if a loaders.gl image type is supported\nexport function isImageTypeSupported(type) {\n  switch (type) {\n    case 'auto':\n      // Should only ever be false in Node.js, if polyfills have not been installed...\n      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;\n\n    case 'imagebitmap':\n      return IMAGE_BITMAP_SUPPORTED;\n    case 'image':\n      return IMAGE_SUPPORTED;\n    case 'data':\n      return DATA_SUPPORTED;\n\n    // DEPRECATED types\n    case 'html':\n      return IMAGE_SUPPORTED;\n    case 'ndarray':\n      return DATA_SUPPORTED;\n\n    default:\n      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);\n  }\n}\n\n// Returns the best loaders.gl image type supported on current run-time environment\nexport function getDefaultImageType() {\n  if (IMAGE_BITMAP_SUPPORTED) {\n    return 'imagebitmap';\n  }\n  if (IMAGE_SUPPORTED) {\n    return 'image';\n  }\n  if (DATA_SUPPORTED) {\n    return 'data';\n  }\n\n  // This should only happen in Node.js\n  throw new Error(`Install '@loaders.gl/polyfills' to parse images under Node.js`);\n}\n", "/* global Image, ImageBitmap */\nimport assert from '../utils/assert';\n\nexport function isImage(image) {\n  return Boolean(getImageTypeOrNull(image));\n}\n\nexport function deleteImage(image) {\n  switch (getImageType(image)) {\n    case 'imagebitmap':\n      image.close();\n      break;\n    default:\n    // Nothing to do for images and image data objects\n  }\n}\n\nexport function getImageType(image) {\n  const format = getImageTypeOrNull(image);\n  if (!format) {\n    throw new Error('Not an image');\n  }\n  return format;\n}\n\nexport function getImageData(image) {\n  switch (getImageType(image)) {\n    case 'data':\n      return image;\n\n    case 'image':\n    case 'imagebitmap':\n      // Extract the image data from the image via a canvas\n      /* global document */\n      const canvas = document.createElement('canvas');\n      // TODO - reuse the canvas?\n      const context = canvas.getContext('2d');\n      if (context) {\n        canvas.width = image.width;\n        canvas.height = image.height;\n        context.drawImage(image, 0, 0);\n        return context.getImageData(0, 0, image.width, image.height);\n      }\n    // eslint-disable no-fallthrough\n    default:\n      return assert(false);\n  }\n}\n\n// TODO DEPRECATED not needed (use getImageData)\nexport {getImageData as getImageSize};\n\n// PRIVATE\n\n// eslint-disable-next-line complexity\nfunction getImageTypeOrNull(image) {\n  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    return 'imagebitmap';\n  }\n  if (typeof Image !== 'undefined' && image instanceof Image) {\n    return 'image';\n  }\n  if (image && typeof image === 'object' && image.data && image.width && image.height) {\n    return 'data';\n  }\n  return null;\n}\n", "/* global TextDecoder, Blob, btoa */\n// SVG parsing has limitations, e.g:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n\nconst SVG_DATA_URL_PATTERN = /^data:image\\/svg\\+xml/;\nconst SVG_URL_PATTERN = /\\.svg((\\?|#).*)?$/;\n\nexport function isSVG(url) {\n  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));\n}\n\nexport function getBlobOrSVGDataUrl(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // Prepare a properly tagged data URL, and load using normal mechanism\n    const textDecoder = new TextDecoder();\n    const xmlText = textDecoder.decode(arrayBuffer);\n    // TODO Escape in browser to support e.g. Chinese characters\n    // if (typeof unescape === 'function' && typeof encodeURLComponent === 'function') {\n    //   xmlText = unescape(encodeURLComponent(xmlText));\n    // }\n    // base64 encoding is safer. utf-8 fails in some browsers\n    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;\n    return src;\n  }\n  return getBlob(arrayBuffer, url);\n}\n\nexport function getBlob(arrayBuffer, url) {\n  if (isSVG(url)) {\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319\n    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});\n    throw new Error('SVG cannot be parsed directly to imagebitmap');\n  }\n  // TODO - how to determine mime type? Param? Sniff here?\n  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?\n}\n", "/* global self, Image */\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n", "/* global createImageBitmap */\nimport {isSVG, getBlob} from './svg-utils';\nimport parseToImage from './parse-to-image';\n\nconst EMPTY_OBJECT = {};\n\nlet imagebitmapOptionsSupported = true;\n\n/**\n * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari\n * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\n *\n * TODO - createImageBitmap supports source rect (5 param overload), pass through?\n */\nexport default async function parseToImageBitmap(arrayBuffer, options, url) {\n  let blob;\n\n  // Cannot parse SVG directly to ImageBitmap, parse to Image first\n  if (isSVG(url)) {\n    // Note: this only works on main thread\n    const image = await parseToImage(arrayBuffer, options, url);\n    blob = image;\n  } else {\n    // Create blob from the array buffer\n    blob = getBlob(arrayBuffer, url);\n  }\n\n  const imagebitmapOptions = options && options.imagebitmap;\n\n  return await safeCreateImageBitmap(blob, imagebitmapOptions);\n}\n\n/**\n * Safely creates an imageBitmap with options\n * *\n * Firefox crashes if imagebitmapOptions is supplied\n * Avoid supplying if not provided or supported, remember if not supported\n */\nasync function safeCreateImageBitmap(blob, imagebitmapOptions = null) {\n  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {\n    imagebitmapOptions = null;\n  }\n\n  if (imagebitmapOptions) {\n    try {\n      // @ts-ignore Options\n      return await createImageBitmap(blob, imagebitmapOptions);\n    } catch (error) {\n      console.warn(error); // eslint-disable-line\n      imagebitmapOptionsSupported = false;\n    }\n  }\n\n  return await createImageBitmap(blob);\n}\n\nfunction isEmptyObject(object) {\n  for (const key in object || EMPTY_OBJECT) {\n    return false;\n  }\n  return true;\n}\n", "// Attributions\n// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng\n\n// TODO: make these functions work for Node.js buffers?\n// Quarantine references to Buffer to prevent bundler from adding big polyfills\n// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';\n// TODO - this should be handled in @loaders.gl/polyfills\n\nconst BIG_ENDIAN = false;\nconst LITTLE_ENDIAN = true;\n\nexport function getBinaryImageMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  return (\n    getPngMetadata(dataView) ||\n    getJpegMetadata(dataView) ||\n    getGifMetadata(dataView) ||\n    getBmpMetadata(dataView)\n  );\n}\n\n// PNG\n\nfunction getPngMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the first 4 bytes of the PNG signature.\n  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;\n  if (!isPng) {\n    return null;\n  }\n\n  // Extract size from a binary PNG file\n  return {\n    mimeType: 'image/png',\n    width: dataView.getUint32(16, BIG_ENDIAN),\n    height: dataView.getUint32(20, BIG_ENDIAN)\n  };\n}\n\n// GIF\n\n// Extract size from a binary GIF file\n// TODO: GIF is not this simple\nfunction getGifMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check first 4 bytes of the GIF signature (\"GIF8\").\n  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;\n  if (!isGif) {\n    return null;\n  }\n\n  // GIF is little endian.\n  return {\n    mimeType: 'image/gif',\n    width: dataView.getUint16(6, LITTLE_ENDIAN),\n    height: dataView.getUint16(8, LITTLE_ENDIAN)\n  };\n}\n\n// BMP\n\n// TODO: BMP is not this simple\nexport function getBmpMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check magic number is valid (first 2 characters should be \"BM\").\n  // The mandatory bitmap file header is 14 bytes long.\n  const isBmp =\n    dataView.byteLength >= 14 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&\n    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;\n\n  if (!isBmp) {\n    return null;\n  }\n\n  // BMP is little endian.\n  return {\n    mimeType: 'image/bmp',\n    width: dataView.getUint32(18, LITTLE_ENDIAN),\n    height: dataView.getUint32(22, LITTLE_ENDIAN)\n  };\n}\n\n// JPEG\n\n// Extract width and height from a binary JPEG file\nfunction getJpegMetadata(binaryData) {\n  const dataView = toDataView(binaryData);\n  // Check file contains the JPEG \"start of image\" (SOI) marker\n  // followed by another marker.\n  const isJpeg =\n    dataView.byteLength >= 3 &&\n    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&\n    dataView.getUint8(2) === 0xff;\n\n  if (!isJpeg) {\n    return null;\n  }\n\n  const {tableMarkers, sofMarkers} = getJpegMarkers();\n\n  // Exclude the two byte SOI marker.\n  let i = 2;\n  while (i + 9 < dataView.byteLength) {\n    const marker = dataView.getUint16(i, BIG_ENDIAN);\n\n    // The frame that contains the width and height of the JPEG image.\n    if (sofMarkers.has(marker)) {\n      return {\n        mimeType: 'image/jpeg',\n        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines\n        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line\n      };\n    }\n\n    // Miscellaneous tables/data preceding the frame header.\n    if (!tableMarkers.has(marker)) {\n      return null;\n    }\n\n    // Length includes size of length parameter but not the two byte header.\n    i += 2;\n    i += dataView.getUint16(i, BIG_ENDIAN);\n  }\n\n  return null;\n}\n\nfunction getJpegMarkers() {\n  // Tables/misc header markers.\n  // DQT, DHT, DAC, DRI, COM, APP_n\n  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);\n  for (let i = 0xffe0; i < 0xfff0; ++i) {\n    tableMarkers.add(i);\n  }\n\n  // SOF markers and DHP marker.\n  // These markers are after tables/misc data.\n  const sofMarkers = new Set([\n    0xffc0,\n    0xffc1,\n    0xffc2,\n    0xffc3,\n    0xffc5,\n    0xffc6,\n    0xffc7,\n    0xffc9,\n    0xffca,\n    0xffcb,\n    0xffcd,\n    0xffce,\n    0xffcf,\n    0xffde\n  ]);\n\n  return {tableMarkers, sofMarkers};\n}\n\n// TODO - move into image module?\nfunction toDataView(data) {\n  if (data instanceof DataView) {\n    return data;\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new DataView(data.buffer);\n  }\n\n  // TODO: make these functions work for Node.js buffers?\n  // if (bufferToArrayBuffer) {\n  //   data = bufferToArrayBuffer(data);\n  // }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (data instanceof ArrayBuffer) {\n    return new DataView(data);\n  }\n  throw new Error('toDataView');\n}\n", "import {global} from '../utils/globals';\nimport assert from '../utils/assert';\nimport {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Use polyfills if installed to p[arsed image using get-pixels\nexport default function parseToNodeImage(arrayBuffer, options) {\n  const {mimeType} = getBinaryImageMetadata(arrayBuffer) || {};\n\n  // @ts-ignore\n  const {_parseImageNode} = global;\n  assert(_parseImageNode); // '@loaders.gl/polyfills not installed'\n\n  return _parseImageNode(arrayBuffer, mimeType, options);\n}\n", "import assert from '../utils/assert';\nimport {isImageTypeSupported, getDefaultImageType} from '../category-api/image-type';\nimport {getImageData} from '../category-api/parsed-image-api';\nimport parseToImage from './parse-to-image';\nimport parseToImageBitmap from './parse-to-image-bitmap';\nimport parseToNodeImage from './parse-to-node-image';\n\n// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)\n// eslint-disable-next-line complexity\nexport default async function parseImage(arrayBuffer, options, context) {\n  options = options || {};\n  const imageOptions = options.image || {};\n\n  // The user can request a specific output format via `options.image.type`\n  const imageType = imageOptions.type || 'auto';\n\n  const {url} = context || {};\n\n  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`\n  const loadType = getLoadableImageType(imageType);\n\n  let image;\n  switch (loadType) {\n    case 'imagebitmap':\n      image = await parseToImageBitmap(arrayBuffer, options, url);\n      break;\n    case 'image':\n      image = await parseToImage(arrayBuffer, options, url);\n      break;\n    case 'data':\n      // Node.js loads imagedata directly\n      image = await parseToNodeImage(arrayBuffer, options);\n      break;\n    default:\n      assert(false);\n  }\n\n  // Browser: if options.image.type === 'data', we can now extract data from the loaded image\n  if (imageType === 'data') {\n    image = getImageData(image);\n  }\n\n  return image;\n}\n\n// Get a loadable image type from image type\nfunction getLoadableImageType(type) {\n  switch (type) {\n    case 'auto':\n    case 'data':\n      // Browser: For image data we need still need to load using an image format\n      // Node: the default image type is `data`.\n      return getDefaultImageType();\n    default:\n      // Throw an error if not supported\n      isImageTypeSupported(type);\n      return type;\n  }\n}\n", "import parseImage from './lib/parsers/parse-image';\nimport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n\nconst EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];\nconst MIME_TYPES = [\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/bmp',\n  'image/vnd.microsoft.icon',\n  'image/svg+xml'\n];\n\n// Loads a platform-specific image type that can be used as input data to WebGL textures\n/** @type {LoaderObject} */\nconst ImageLoader = {\n  id: 'image',\n  name: 'Images',\n  version: VERSION,\n  mimeTypes: MIME_TYPES,\n  extensions: EXTENSIONS,\n  parse: parseImage,\n  // TODO: byteOffset, byteLength;\n  tests: [arrayBuffer => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],\n  options: {\n    image: {\n      type: 'auto',\n      decode: true // if format is HTML\n    }\n    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor\n  }\n};\n\nexport default ImageLoader;\n", "// Image loading/saving for browser and Node.js\n/* global document, ImageBitmap, ImageData */\nimport {global} from '../utils/globals';\nimport {getImageSize} from '../category-api/parsed-image-api';\n\n// @ts-ignore TS2339: Property does not exist on type\nconst {_encodeImageNode} = global;\n\nexport async function encodeImage(image, options) {\n  options = options || {};\n  options.image = options.image || {};\n\n  return _encodeImageNode\n    ? _encodeImageNode(image, {type: options.image.mimeType})\n    : encodeImageInBrowser(image, options);\n}\n\n// In case we get exceptions from canvas.toBlob(resolve, type, quality)\nlet qualityParamSupported = true;\n\n/**\n *\n * @param image\n * @param options\n * @note Based on canvas.toBlob\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n */\nasync function encodeImageInBrowser(image, options) {\n  const {mimeType, jpegQuality} = options.image;\n\n  const {width, height} = getImageSize(image);\n\n  // create a canvas and resize it to the size of our image\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n\n  drawImageToCanvas(image, canvas);\n\n  // The actual encoding is done asynchronously with `canvas.toBlob()`\n  const blob = await new Promise((resolve, reject) => {\n    // get it back as a Blob\n    if (jpegQuality && qualityParamSupported) {\n      try {\n        canvas.toBlob(resolve, mimeType, jpegQuality);\n        return;\n      } catch (error) {\n        qualityParamSupported = false;\n      }\n    }\n    canvas.toBlob(resolve, mimeType);\n  });\n\n  return await blob.arrayBuffer();\n}\n\nfunction drawImageToCanvas(image, canvas, x = 0, y = 0) {\n  // Try optimized path for ImageBitmaps via bitmaprenderer context\n  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const context = canvas.getContext('bitmaprenderer');\n    if (context) {\n      // transfer the ImageBitmap to it\n      context.transferFromImageBitmap(image);\n      return canvas;\n    }\n  }\n\n  // Available on most platforms, except IE11 and Andriod WebViews...\n  const context = canvas.getContext('2d');\n  if (image.data) {\n    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...\n    const clampedArray = new Uint8ClampedArray(image.data);\n    const imageData = new ImageData(clampedArray, image.width, image.height);\n    context.putImageData(imageData, 0, 0);\n    return canvas;\n  }\n\n  // Fall back to generic image/image bitmap rendering path\n  context.drawImage(image, 0, 0);\n  return canvas;\n}\n", "import {encodeImage} from './lib/encoders/encode-image';\n\nexport default {\n  name: 'Images',\n  extensions: ['jpeg'],\n  options: {\n    image: {\n      mimeType: 'image/png',\n      jpegQuality: null\n    }\n  },\n  encode: encodeImage\n};\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport default function assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Purpose: include this in your module to avoids adding dependencies on\n// micro modules like 'global' and 'is-browser';\n\n// @ts-nocheck\n/* eslint-disable no-restricted-globals */\n/* global process, window, global, document, self, importScripts */\nconst globals = {\n  self: typeof self !== 'undefined' && self,\n  window: typeof window !== 'undefined' && window,\n  global: typeof global !== 'undefined' && global,\n  document: typeof document !== 'undefined' && document\n};\n\nconst self_ = globals.self || globals.window || globals.global;\nconst window_ = globals.window || globals.self || globals.global;\nconst global_ = globals.global || globals.self || globals.window;\nconst document_ = globals.document || {};\n\nexport {self_ as self, window_ as window, global_ as global, document_ as document};\n\nexport const isBrowser =\n  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;\n\nexport const isWorker = typeof importScripts === 'function';\n\n// Extract node major version\nconst matches =\n  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);\nexport const nodeVersion = (matches && parseFloat(matches[1])) || 0;\n", "// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n\n/* global MessagePort, ImageBitmap, OffscreenCanvas */\n\n// Returns an array of Transferrable objects that can be used with postMessage\n// https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\nexport function getTransferList(object, recursive = true, transfers) {\n  // Make sure that items in the transfer list is unique\n  const transfersSet = transfers || new Set();\n\n  if (!object) {\n    // ignore\n  } else if (isTransferable(object)) {\n    transfersSet.add(object);\n  } else if (isTransferable(object.buffer)) {\n    // Typed array\n    transfersSet.add(object.buffer);\n  } else if (ArrayBuffer.isView(object)) {\n    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n    // Do not iterate through the content in this case\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfersSet);\n    }\n  }\n\n  // If transfers is defined, is internal recursive call\n  // Otherwise it's called by the user\n  return transfers === undefined ? Array.from(transfersSet) : [];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object) {\n  if (!object) {\n    return false;\n  }\n  if (object instanceof ArrayBuffer) {\n    return true;\n  }\n  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n    return true;\n  }\n  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n    return true;\n  }\n  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n    return true;\n  }\n  return false;\n}\n", "import assert from '../env-utils/assert';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : '';\n\n// Returns `true` if the two versions are compatible\nexport function validateLoaderVersion(loader, coreVersion = VERSION) {\n  assert(loader, 'no loader provided');\n\n  let loaderVersion = loader.version;\n  if (!coreVersion || !loaderVersion) {\n    return;\n  }\n\n  coreVersion = parseVersion(coreVersion);\n  loaderVersion = parseVersion(loaderVersion);\n\n  // TODO enable when fix the __version__ injection\n  // assert(\n  //   coreVersion.major === loaderVersion.major && coreVersion.minor <= loaderVersion.minor,\n  //   `loader: ${loader.name} is not compatible. ${coreVersion.major}.${\n  //     coreVersion.minor\n  //   }+ is required.`\n  // );\n}\n\nfunction parseVersion(version) {\n  const parts = version.split('.').map(Number);\n  return {major: parts[0], minor: parts[1]};\n}\n", "/* eslint-disable no-restricted-globals */\n/* global TextDecoder, self */\n\nimport {getTransferList} from '../worker-utils/get-transfer-list';\nimport {validateLoaderVersion} from './validate-loader-version';\n\nexport default function createWorker(loader) {\n  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  let requestId = 0;\n  const parse = (arraybuffer, options = {}, url) =>\n    new Promise((resolve, reject) => {\n      const id = requestId++;\n\n      const onMessage = ({data}) => {\n        if (!data || data.id !== id) {\n          // not ours\n          return;\n        }\n        switch (data.type) {\n          case 'parse-done':\n            self.removeEventListener('message', onMessage);\n            resolve(data.result);\n            break;\n\n          case 'parse-error':\n            self.removeEventListener('message', onMessage);\n            reject(data.message);\n            break;\n\n          default:\n          // ignore\n        }\n      };\n      self.addEventListener('message', onMessage);\n      // Ask the main thread to decode data\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'parse', id, arraybuffer, options, url}, [arraybuffer]);\n    });\n\n  self.onmessage = async evt => {\n    const {data} = evt;\n\n    try {\n      if (!isKnownMessage(data, loader.name)) {\n        return;\n      }\n\n      validateLoaderVersion(loader, data.source.split('@')[1]);\n\n      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;\n\n      const result = await parseData({\n        loader,\n        arraybuffer,\n        byteOffset,\n        byteLength,\n        options,\n        context: {parse}\n      });\n      const transferList = getTransferList(result);\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'done', result}, transferList);\n    } catch (error) {\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'error', message: error.message});\n    }\n  };\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arraybuffer, byteOffset, byteLength, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arraybuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arraybuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(data, name) {\n  return data && data.type === 'parse' && data.source && data.source.startsWith('loaders.gl');\n}\n\n/*\nfunction checkMessage(evt, name) {\n  switch (evt.data && evt.data.source) {\n    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...\n    case 'react-devtools-bridge':\n    case 'react-devtools-content-script':\n    case 'react-devtools-detector':\n      return false;\n    default:\n      // fall through\n  }\n\n  switch (evt.data && evt.data.type) {\n    case 'webpackProgress':\n    case 'webpackOk':\n      return false;\n    default:\n      // Enable to debug messages\n      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;\n      // console.log(message, evt.data, evt); // eslint-disable-line\n      return false;\n  }\n}\n*/\n", "/* global URL, Blob */\nimport assert from '../env-utils/assert';\n\nconst workerURLCache = new Map();\n\n// Creates a URL from worker source that can be used to create `Worker` instances\n// Packages (and then caches) the result of `webworkify` as an \"Object URL\"\nexport function getWorkerURL(workerSource, workerName = 'Worker') {\n  assert(typeof workerSource === 'string', 'worker source');\n\n  // CASE: url(./worker.js)\n  // This pattern is used to differentiate worker urls from worker source code\n  // Load from url is needed for testing, when using Webpack & webworker target\n  if (workerSource.startsWith('url(') && workerSource.endsWith(')')) {\n    const workerUrl = workerSource.match(/^url\\((.*)\\)$/)[1];\n\n    // A local script url, we can use it to initialize a Worker directly\n    if (workerUrl && !workerUrl.startsWith('http')) {\n      return workerUrl;\n    }\n\n    // Per spec, worker cannot be initialized with a script from a different origin\n    // However a local worker script can still import scripts from other origins,\n    // so we simply build a wrapper script\n    workerSource = buildScript(workerUrl);\n  }\n\n  let workerURL = workerURLCache.get(workerSource);\n\n  if (!workerURL) {\n    // NOTE: webworkify was previously used\n    // const blob = webworkify(workerSource, {bare: true});\n    const blob = new Blob([workerSource], {type: 'application/javascript'});\n    workerURL = URL.createObjectURL(blob);\n    workerURLCache.set(workerSource, workerURL);\n  }\n\n  return workerURL;\n}\n\n// Only use trusted sources!\nfunction buildScript(workerUrl) {\n  return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n}`;\n}\n", "/* global Worker */\nimport {getWorkerURL} from './get-worker-url';\nimport {getTransferList} from './get-transfer-list';\n\nlet count = 0;\n\n// By default resolves to the first message the worker sends back\nfunction defaultOnMessage({data, resolve}) {\n  resolve(data);\n}\n\nexport default class WorkerThread {\n  constructor({source, name = `web-worker-${count++}`, onMessage}) {\n    const url = getWorkerURL(source, name);\n    this.worker = new Worker(url, {name});\n    this.name = name;\n    this.onMessage = onMessage || defaultOnMessage;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  async process(data) {\n    return new Promise((resolve, reject) => {\n      this.worker.onmessage = event => {\n        this.onMessage({worker: this.worker, data: event.data, resolve, reject});\n      };\n      this.worker.onerror = error => {\n        // Note Error object does not have the expected fields if loading failed completely\n        // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers\n        // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent\n        let message = `${this.name}: WorkerThread.process() failed`;\n        if (error.message) {\n          message += ` ${error.message} ${error.filename}:${error.lineno}:${error.colno}`;\n        }\n        const betterError = new Error(message);\n        console.error(error); // eslint-disable-line\n        reject(betterError);\n      };\n      const transferList = getTransferList(data);\n      this.worker.postMessage(data, transferList);\n    });\n  }\n\n  destroy() {\n    this.worker.terminate();\n    // @ts-ignore\n    this.worker = null;\n  }\n}\n", "import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  constructor({\n    source,\n    name = 'unnamed',\n    maxConcurrency = 1,\n    onMessage,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    // @ts-ignore\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    try {\n      job.resolve(await worker.process(job.data));\n    } catch (error) {\n      job.reject(error);\n    } finally {\n      this._onWorkerDone(worker);\n    }\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n      return;\n    }\n\n    if (this.reuseWorkers) {\n      this.idleQueue.push(worker);\n    } else {\n      worker.destroy();\n      this.count--;\n    }\n\n    this._startQueuedJob();\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n", "import WorkerPool from './worker-pool';\n\nconst DEFAULT_MAX_CONCURRENCY = 5;\n\n/**\n * Process multiple data messages with a \"farm\" of different workers (in worker pools)\n */\nexport default class WorkerFarm {\n  static isSupported() {\n    return typeof Worker !== 'undefined';\n  }\n\n  constructor({\n    maxConcurrency = DEFAULT_MAX_CONCURRENCY,\n    onMessage = null,\n    onDebug = () => {},\n    reuseWorkers = true\n  }) {\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n    this.workerPools = new Map();\n    this.reuseWorkers = reuseWorkers;\n  }\n\n  setProps(props) {\n    if ('maxConcurrency' in props) {\n      this.maxConcurrency = props.maxConcurrency;\n    }\n\n    if ('onDebug' in props) {\n      this.onDebug = props.onDebug;\n    }\n\n    if ('reuseWorkers' in props) {\n      this.reuseWorkers = props.reuseWorkers;\n    }\n  }\n\n  destroy() {\n    this.workerPools.forEach(workerPool => workerPool.destroy());\n  }\n\n  /**\n   * Process binary data in a worker\n   * @param {any} data - data (containing binary typed arrays) to be transferred to worker\n   * @returns a Promise with data containing typed arrays transferred back from work\n   */\n  async process(workerSource, workerName, data) {\n    const workerPool = this._getWorkerPool(workerSource, workerName);\n    return workerPool.process(data);\n  }\n\n  // PRIVATE\n\n  _getWorkerPool(workerSource, workerName) {\n    let workerPool = this.workerPools.get(workerName);\n    if (!workerPool) {\n      workerPool = new WorkerPool({\n        source: workerSource,\n        name: workerName,\n        onMessage: onWorkerMessage.bind(null, this.onMessage),\n        maxConcurrency: this.maxConcurrency,\n        onDebug: this.onDebug,\n        reuseWorkers: this.reuseWorkers\n      });\n      this.workerPools.set(workerName, workerPool);\n    }\n    return workerPool;\n  }\n}\n\nfunction onWorkerMessage(onMessage, {worker, data, resolve, reject}) {\n  if (onMessage) {\n    onMessage({worker, data, resolve, reject});\n    return;\n  }\n\n  switch (data.type) {\n    case 'done':\n      resolve(data.result);\n      break;\n\n    case 'error':\n      reject(data.message);\n      break;\n\n    default:\n  }\n}\n", "/* global fetch, document */\nimport {global, isBrowser, isWorker} from '../env-utils/globals';\nimport * as node from '../node/require-utils.node';\nimport assert from '../env-utils/assert';\n\n// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...\nconst LATEST = 'beta';\n\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : LATEST;\n\nconst loadLibraryPromises = {}; // promises\n\n// Dynamically loads a library (\"module\")\nexport async function loadLibrary(libraryUrl, moduleName = null, options = {}) {\n  if (moduleName) {\n    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);\n  }\n\n  // Ensure libraries are only loaded once\n  loadLibraryPromises[libraryUrl] =\n    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);\n  return await loadLibraryPromises[libraryUrl];\n}\n\n// TODO - sort out how to resolve paths for main/worker and dev/prod\nexport function getLibraryUrl(library, moduleName, options) {\n  // Allow application to import and supply libraries through `options.modules`\n  const modules = options.modules || {};\n  if (modules[library]) {\n    return modules[library];\n  }\n\n  // Load from local files, not from CDN scripts in Node.js\n  // TODO - needs to locate the modules directory when installed!\n  if (!isBrowser) {\n    return `modules/${moduleName}/dist/libs/${library}`;\n  }\n\n  // In browser, load from external scripts\n  if (options.CDN) {\n    assert(options.CDN.startsWith('http'));\n    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;\n  }\n\n  // TODO - loading inside workers requires paths relative to worker script location...\n  if (isWorker) {\n    return `../src/libs/${library}`;\n  }\n\n  return `modules/${moduleName}/src/libs/${library}`;\n}\n\nasync function loadLibraryFromFile(libraryUrl) {\n  if (libraryUrl.endsWith('wasm')) {\n    const response = await fetch(libraryUrl);\n    return await response.arrayBuffer();\n  }\n\n  if (!isBrowser) {\n    return node.requireFromFile && node.requireFromFile(libraryUrl);\n  }\n  if (isWorker) {\n    /* global importScripts */\n    return importScripts(libraryUrl);\n  }\n  // TODO - fix - should be more secure than string parsing since observes CORS\n  // if (isBrowser) {\n  //   return await loadScriptFromFile(libraryUrl);\n  // }\n\n  const response = await fetch(libraryUrl);\n  const scriptSource = await response.text();\n  return loadLibraryFromString(scriptSource, libraryUrl);\n}\n\n/*\nasync function loadScriptFromFile(libraryUrl) {\n  const script = document.createElement('script');\n  script.src = libraryUrl;\n  return await new Promise((resolve, reject) => {\n    script.onload = data => {\n      resolve(data);\n    };\n    script.onerror = reject;\n  });\n}\n*/\n\n// TODO - Needs security audit...\n//  - Raw eval call\n//  - Potentially bypasses CORS\n// Upside is that this separates fetching and parsing\n// we could create a`LibraryLoader` or`ModuleLoader`\nfunction loadLibraryFromString(scriptSource, id) {\n  if (!isBrowser) {\n    return node.requireFromString && node.requireFromString(scriptSource, id);\n  }\n\n  if (isWorker) {\n    // Use lvalue trick to make eval run in global scope\n    eval.call(global, scriptSource); // eslint-disable-line no-eval\n    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript\n    // http://perfectionkills.com/global-eval-what-are-the-options/\n    return null;\n  }\n\n  const script = document.createElement('script');\n  script.id = id;\n  // most browsers like a separate text node but some throw an error. The second method covers those.\n  try {\n    script.appendChild(document.createTextNode(scriptSource));\n  } catch (e) {\n    script.text = scriptSource;\n  }\n  document.body.appendChild(script);\n  return null;\n}\n\n// TODO - technique for module injection into worker, from THREE.DracoLoader...\n/*\nfunction combineWorkerWithLibrary(worker, jsContent) {\n  var fn = wWorker.toString();\n  var body = [\n    '// injected',\n    jsContent,\n    '',\n    '// worker',\n    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))\n  ].join('\\n');\n  this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n}\n*/\n", "export function getFirstCharacters(data, length = 5) {\n  if (typeof data === 'string') {\n    return data.slice(0, length);\n  } else if (ArrayBuffer.isView(data)) {\n    // Typed Arrays can have offsets into underlying buffer\n    return getMagicString(data.buffer, data.byteOffset, length);\n  } else if (data instanceof ArrayBuffer) {\n    const byteOffset = 0;\n    return getMagicString(data, byteOffset, length);\n  }\n  return '';\n}\n\nexport function getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n", "import {getFirstCharacters} from '../binary-utils/get-first-characters';\n\n// Minimal JSON parser with a meaningful error message\nexport function parseJSON(string) {\n  try {\n    return JSON.parse(string);\n  } catch (_) {\n    throw new Error(`Failed to parse JSON from data starting with \"${getFirstCharacters(string)}\"`);\n  }\n}\n", "/** @typedef {import('./buffer-utils')} types */\nimport * as node from '../node/buffer-utils.node';\n\n/** @type {types['isBuffer']} */\nexport function isBuffer(x) {\n  return x && typeof x === 'object' && x.isBuffer;\n}\n\n/** @type {types['toBuffer']} */\nexport function toBuffer(data) {\n  return node.toBuffer ? node.toBuffer(data) : data;\n}\n\n/** @type {types['bufferToArrayBuffer']} */\nexport function bufferToArrayBuffer(data) {\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    return node.toArrayBuffer(data);\n  }\n  return data;\n}\n", "/** @typedef {import('./array-buffer-utils')} types */\n/* global TextEncoder */\nimport assert from '../env-utils/assert';\nimport * as node from '../node/buffer-utils.node';\n\n/** @type {types['toArrayBuffer']} */\nexport function toArrayBuffer(data) {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  return assert(false);\n}\n\n/** @type {types['compareArrayBuffers']} */\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Concatenate ArrayBuffers\n/** @type {types['concatenateArrayBuffers']} */\nexport function concatenateArrayBuffers(...sources) {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map(\n    source2 => (source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2)\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n", "import {sliceArrayBuffer} from './array-buffer-utils';\n\nexport function padTo4Bytes(byteLength) {\n  return (byteLength + 3) & ~3;\n}\n\nexport function getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  return sliceArrayBuffer(arrayBuffer, byteOffset, byteLength);\n}\n\n/* Creates a new Uint8Array based on two different ArrayBuffers\n * @private\n * @param {ArrayBuffers} buffer1 The first buffer.\n * @param {ArrayBuffers} buffer2 The second buffer.\n * @return {ArrayBuffers} The new ArrayBuffer created out of the two.\n */\nexport function copyArrayBuffer(\n  targetBuffer,\n  sourceBuffer,\n  byteOffset,\n  byteLength = sourceBuffer.byteLength\n) {\n  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);\n  const sourceArray = new Uint8Array(sourceBuffer);\n  targetArray.set(sourceArray);\n  return targetBuffer;\n}\n\n/**\n * Copy from source to target at the targetOffset\n *\n * @param {ArrayBuffer|any} source - The data to copy\n * @param {any} target - The destination to copy data into\n * @param {Number} targetOffset - The start offset into target to place the copied data\n *\n * @return {Number} Returns the new offset taking into account proper padding\n */\nexport function copyToArray(source, target, targetOffset) {\n  let sourceArray;\n\n  if (source instanceof ArrayBuffer) {\n    sourceArray = new Uint8Array(source);\n  } else {\n    // Pack buffer onto the big target array\n    //\n    // 'source.data.buffer' could be a view onto a larger buffer.\n    // We MUST use this constructor to ensure the byteOffset and byteLength is\n    // set to correct values from 'source.data' and not the underlying\n    // buffer for target.set() to work properly.\n    const srcByteOffset = source.byteOffset;\n    const srcByteLength = source.byteLength;\n    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);\n  }\n\n  // Pack buffer onto the big target array\n  target.set(sourceArray, targetOffset);\n\n  return targetOffset + padTo4Bytes(sourceArray.byteLength);\n}\n", "/* global TextEncoder */\nimport {padTo4Bytes} from './memory-copy-utils';\n\nexport function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer) {\n  const paddedLength = padTo4Bytes(sourceBuffer.byteLength);\n  const padLength = paddedLength - sourceBuffer.byteLength;\n\n  if (dataView) {\n    // Copy array\n    const targetArray = new Uint8Array(\n      dataView.buffer,\n      dataView.byteOffset + byteOffset,\n      sourceBuffer.byteLength\n    );\n    const sourceArray = new Uint8Array(sourceBuffer);\n    targetArray.set(sourceArray);\n\n    // Add PADDING\n    for (let i = 0; i < padLength; ++i) {\n      // json chunk is padded with spaces (ASCII 0x20)\n      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);\n    }\n  }\n  byteOffset += paddedLength;\n  return byteOffset;\n}\n\nexport function copyPaddedStringToDataView(dataView, byteOffset, string) {\n  const textEncoder = new TextEncoder();\n  // PERFORMANCE IDEA: We encode twice, once to get size and once to store\n  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy\n  const stringBuffer = textEncoder.encode(string);\n\n  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer);\n\n  return byteOffset;\n}\n", "// UTILITIES\n\n// PERFORMANCE IDEA: No need to copy string twice...\nexport function padStringToByteAlignment(string, byteAlignment) {\n  const length = string.length;\n  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment\n  const padding = paddedLength - length;\n  let whitespace = '';\n  for (let i = 0; i < padding; ++i) {\n    whitespace += ' ';\n  }\n  return string + whitespace;\n}\n\nexport function copyStringToDataView(dataView, byteOffset, string, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, string.charCodeAt(i));\n    }\n  }\n  return byteOffset + byteLength;\n}\n\nexport function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {\n  if (dataView) {\n    for (let i = 0; i < byteLength; i++) {\n      dataView.setUint8(byteOffset + i, binary[i]);\n      byteOffset++;\n    }\n  }\n  return byteOffset + byteLength;\n}\n", "// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.\nexport function dirname(url) {\n  const slashIndex = url && url.lastIndexOf('/');\n  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';\n}\n", "// Simple file alias mechanisms for tests.\n\nlet pathPrefix = '';\nconst fileAliases = {};\n\n/*\n * Set a relative path prefix\n */\nexport function setPathPrefix(prefix) {\n  pathPrefix = prefix;\n}\n\nexport function getPathPrefix() {\n  return pathPrefix;\n}\n\n// Note: addAliases are an experimental export,\nexport function addAliases(aliases) {\n  Object.assign(fileAliases, aliases);\n}\n\nexport function resolvePath(filename) {\n  for (const alias in fileAliases) {\n    if (filename.startsWith(alias)) {\n      const replacement = fileAliases[alias];\n      filename = filename.replace(alias, replacement);\n    }\n  }\n  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {\n    filename = `${pathPrefix}${filename}`;\n  }\n  return filename;\n}\n", "import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\nimport assert from '../env-utils/assert';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * Supports strings and ArrayBuffers\n *\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateChunksAsync(asyncIterator) {\n  /** @type {ArrayBuffer[]} */\n  const arrayBuffers = [];\n  /** @type {string[]} */\n  const strings = [];\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      strings.push(chunk);\n    } else {\n      arrayBuffers.push(chunk);\n    }\n  }\n\n  if (strings.length > 0) {\n    assert(arrayBuffers.length === 0);\n    return strings.join('');\n  }\n\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n", "// TODO - this should move to core when test cases are more complete\n\n/* global setTimeout */\nimport {Stats} from '@probe.gl/stats';\n\nconst STAT_QUEUED_REQUESTS = 'Queued Requests';\nconst STAT_ACTIVE_REQUESTS = 'Active Requests';\nconst STAT_CANCELLED_REQUESTS = 'Cancelled Requests';\nconst STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';\nconst STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';\n\nconst DEFAULT_PROPS = {\n  id: 'request-scheduler',\n  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing\n  throttleRequests: true,\n  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.\n  maxRequests: 6\n};\n\n// TODO - Track requests globally, across multiple servers\nexport default class RequestScheduler {\n  constructor(props = {}) {\n    this.props = {...DEFAULT_PROPS, ...props};\n\n    // Tracks the number of active requests and prioritizes/cancels queued requests.\n    this.requestQueue = [];\n    this.activeRequestCount = 0;\n    this.requestMap = new Map();\n\n    // Returns the statistics used by the request scheduler.\n    this.stats = new Stats({id: props.id});\n    this.stats.get(STAT_QUEUED_REQUESTS);\n    this.stats.get(STAT_ACTIVE_REQUESTS);\n    this.stats.get(STAT_CANCELLED_REQUESTS);\n    this.stats.get(STAT_QUEUED_REQUESTS_EVER);\n    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);\n\n    this._deferredUpdate = null;\n  }\n\n  // Called by an application that wants to issue a request, without having it deeply queued\n  // Parameter `getPriority` will be called when request \"slots\" open up,\n  //    allowing the caller to update priority or cancel the request\n  //    Highest priority executes first, priority < 0 cancels the request\n  // Returns: a promise that resolves to a request token when the request can be issued without queueing,\n  //    or `false` if the request has been cancelled (by getPriority)\n  scheduleRequest(handle, getPriority = () => 0) {\n    // Allows throttling to be disabled\n    if (!this.props.throttleRequests) {\n      return Promise.resolve({done: () => {}});\n    }\n\n    // dedupe\n    if (this.requestMap.has(handle)) {\n      return this.requestMap.get(handle);\n    }\n\n    const request = {handle, getPriority};\n    const promise = new Promise(resolve => {\n      request.resolve = resolve;\n      return request;\n    });\n\n    this.requestQueue.push(request);\n    this.requestMap.set(handle, promise);\n    this._issueNewRequests();\n    return promise;\n  }\n\n  // PRIVATE\n\n  _issueRequest(request) {\n    const {handle, resolve} = request;\n    let isDone = false;\n\n    const done = () => {\n      // can only be called once\n      if (!isDone) {\n        isDone = true;\n\n        // Stop tracking a request - it has completed, failed, cancelled etc\n        this.requestMap.delete(handle);\n        this.activeRequestCount--;\n        // A slot just freed up, see if any queued requests are waiting\n        this._issueNewRequests();\n      }\n    };\n\n    // Track this request\n    this.activeRequestCount++;\n\n    return resolve ? resolve({done}) : Promise.resolve({done});\n  }\n\n  // We check requests asynchronously, to prevent multiple updates\n  _issueNewRequests() {\n    if (!this._deferredUpdate) {\n      this._deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);\n    }\n  }\n\n  // Refresh all requests and\n  _issueNewRequestsAsync() {\n    this._deferredUpdate = null;\n\n    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);\n\n    if (freeSlots === 0) {\n      return;\n    }\n\n    this._updateAllRequests();\n\n    // Resolve pending promises for the top-priority requests\n    for (let i = 0; i < freeSlots; ++i) {\n      if (this.requestQueue.length > 0) {\n        const request = this.requestQueue.shift();\n        this._issueRequest(request);\n      }\n    }\n\n    // Uncomment to debug\n    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);\n  }\n\n  // Ensure all requests have updated priorities, and that no longer valid requests are cancelled\n  _updateAllRequests() {\n    const requestQueue = this.requestQueue;\n    for (let i = 0; i < requestQueue.length; ++i) {\n      const request = requestQueue[i];\n      if (!this._updateRequest(request)) {\n        // Remove the element and make sure to adjust the counter to account for shortened array\n        requestQueue.splice(i, 1);\n        this.requestMap.delete(request.handle);\n        i--;\n      }\n    }\n\n    // Sort the remaining requests based on priority\n    requestQueue.sort((a, b) => a.priority - b.priority);\n  }\n\n  // Update a single request by calling the callback\n  _updateRequest(request) {\n    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return\n\n    // by returning a negative priority, the callback cancels the request\n    if (request.priority < 0) {\n      request.resolve(null);\n      return false;\n    }\n    return true;\n  }\n}\n", "import ChildProcess from 'child_process';\n\n// Get an available port\n// Works on Unix systems\nexport function getAvailablePort(defaultPort = 3000) {\n  return new Promise((resolve, reject) => {\n    // Get a list of all ports in use\n    ChildProcess.exec('lsof -i -P -n | grep LISTEN', (error, stdout, stderr) => {\n      if (error) {\n        // likely no permission, e.g. CI\n        resolve(defaultPort);\n        return;\n      }\n\n      const portsInUse = [];\n      const regex = /:(\\d+) \\(LISTEN\\)/;\n      stdout.split('\\n').forEach(line => {\n        const match = line.match(regex);\n        if (match) {\n          portsInUse.push(Number(match[1]));\n        }\n      });\n      let port = defaultPort;\n      while (portsInUse.includes(port)) {\n        port++;\n      }\n      resolve(port);\n    });\n  });\n}\n", "// Forked from probe.gl under MIT license, Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n\n/* eslint-disable no-console */\n/* global process, setTimeout, clearTimeout, console */\nimport ChildProcess from 'child_process';\nimport assert from '../env-utils/assert';\nimport {getAvailablePort} from './process-utils';\n\nconst DEFAULT_PROCESS_OPTIONS = {\n  command: null,\n  arguments: [],\n  portArg: null,\n  port: 'auto',\n  basePort: 5000,\n  wait: 2000,\n  nodeSpawnOptions: {maxBuffer: 5000 * 1024},\n  onSuccess: processProxy => {\n    console.log(`Started ${processProxy.options.command}`);\n  }\n};\n\nexport default class ChildProcessProxy {\n  constructor({id = 'browser-driver'} = {}) {\n    this.id = id;\n    this.childProcess = null;\n    this.port = null;\n  }\n\n  async start(options = {}) {\n    options = {...DEFAULT_PROCESS_OPTIONS, ...options};\n    assert(options.command && typeof options.command === 'string');\n    this.options = options;\n\n    const args = [...options.arguments];\n\n    // If portArg is set, we can look up an available port\n    this.port = options.port;\n    if (options.portArg) {\n      if (this.port === 'auto') {\n        this.port = await getAvailablePort(options.basePort);\n      }\n      args.push(options.portArg, this.port);\n    }\n\n    return await new Promise((resolve, reject) => {\n      try {\n        const successTimer = setTimeout(() => {\n          if (options.onSuccess) {\n            options.onSuccess(this);\n          }\n          resolve({});\n        }, options.wait);\n\n        console.log(`Spawning ${options.command} ${options.arguments.join(' ')}`);\n        this.childProcess = ChildProcess.spawn(options.command, args, options.spawn);\n\n        // TODO - add option regarding whether stderr should be treated as data\n        this.childProcess.stderr.on('data', data => {\n          console.log(`Child process wrote to stderr: \"${data}\".`);\n          clearTimeout(successTimer);\n          reject(new Error(data));\n        });\n        this.childProcess.on('error', error => {\n          console.log(`Child process errored with ${error}`);\n          clearTimeout(successTimer);\n          reject(error);\n        });\n        this.childProcess.on('close', code => {\n          console.log(`Child process exited with ${code}`);\n          this.childProcess = null;\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  async stop() {\n    if (this.childProcess) {\n      this.childProcess.kill();\n      this.childProcess = null;\n    }\n  }\n\n  async exit(statusCode = 0) {\n    try {\n      await this.stop();\n      // eslint-disable-next-line no-process-exit\n      process.exit(statusCode);\n    } catch (error) {\n      console.error(error.message || error);\n      // eslint-disable-next-line no-process-exit\n      process.exit(1);\n    }\n  }\n}\n", "export function getMeshSize(attributes) {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes) {\n  if (!attributes || !attributes.POSITION) {\n    return null;\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION.value;\n  const len = positions && positions.length;\n\n  if (!len) {\n    return null;\n  }\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [[minX, minY, minZ], [maxX, maxY, maxZ]];\n}\n", "// GENERAL UTILS\nexport {default as assert} from './lib/env-utils/assert';\nexport {\n  isBrowser,\n  isWorker,\n  nodeVersion,\n  self,\n  window,\n  global,\n  document\n} from './lib/env-utils/globals';\n\n// WORKER LOADER UTILS\nexport {default as createWorker} from './lib/worker-loader-utils/create-worker';\nexport {validateLoaderVersion} from './lib/worker-loader-utils/validate-loader-version';\nexport {makeTransformIterator} from './lib/iterator-utils/make-transform-iterator';\n\n// WORKER UTILS\nexport {getTransferList} from './lib/worker-utils/get-transfer-list';\nexport {default as _WorkerFarm} from './lib/worker-utils/worker-farm';\nexport {default as _WorkerPool} from './lib/worker-utils/worker-pool';\nexport {default as _WorkerThread} from './lib/worker-utils/worker-thread';\n\n// LIBRARY UTILS\nexport {getLibraryUrl, loadLibrary} from './lib/library-utils/library-utils';\n\n// PARSER UTILS\nexport {parseJSON} from './lib/parser-utils/parse-json';\n\n// MEMORY COPY UTILS\nexport {isBuffer, toBuffer, bufferToArrayBuffer} from './lib/binary-utils/buffer-utils';\nexport {\n  toArrayBuffer,\n  sliceArrayBuffer,\n  concatenateArrayBuffers,\n  compareArrayBuffers\n} from './lib/binary-utils/array-buffer-utils';\nexport {padTo4Bytes, copyToArray, copyArrayBuffer} from './lib/binary-utils/memory-copy-utils';\nexport {\n  copyPaddedArrayBufferToDataView,\n  copyPaddedStringToDataView\n} from './lib/binary-utils/binary-copy-utils';\nexport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from './lib/binary-utils/encode-utils';\nexport {getFirstCharacters, getMagicString} from './lib/binary-utils/get-first-characters';\n\n// PATH UTILS\n\nimport * as path from './lib/path-utils/path';\nexport {path};\nexport {setPathPrefix, getPathPrefix, resolvePath} from './lib/path-utils/file-aliases';\nexport {addAliases as _addAliases} from './lib/path-utils/file-aliases.js';\n\n// ITERATOR UTILS\n\nexport {\n  makeTextEncoderIterator,\n  makeTextDecoderIterator,\n  makeLineIterator,\n  makeNumberedLineIterator\n} from './lib/iterator-utils/text-iterators';\nexport {forEach, concatenateChunksAsync} from './lib/iterator-utils/async-iteration';\n\n// REQUEST UTILS\nexport {default as RequestScheduler} from './lib/request-utils/request-scheduler';\n\n// PROCESS UTILS\nexport {default as ChildProcessProxy} from './lib/process-utils/child-process-proxy';\n\n// MESH CATEGORY UTILS\n// Note: Should move to category specific module if code size increases\nexport {getMeshSize as _getMeshSize, getMeshBoundingBox} from './categories/mesh/mesh-utils';\n\n// DEPRECATED IN 2.3\nexport {getZeroOffsetArrayBuffer} from './lib/binary-utils/memory-copy-utils';\n", "import {resolvePath} from '@loaders.gl/loader-utils';\nimport assert from '../utils/assert';\n\n// Generate a url by calling getUrl with mix of options, applying options.baseUrl\nexport function generateUrl(getUrl, options, urlOptions) {\n  // Get url\n  let url = getUrl;\n  if (typeof getUrl === 'function') {\n    url = getUrl({...options, ...urlOptions});\n  }\n  assert(typeof url === 'string');\n\n  // Apply options.baseUrl\n  const {baseUrl} = options;\n  if (baseUrl) {\n    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;\n  }\n\n  return resolvePath(url);\n}\n", "/* global fetch */\nimport {asyncDeepMap} from './async-deep-map';\n\nexport async function deepLoad(urlTree, load, options) {\n  return await asyncDeepMap(urlTree, url => shallowLoad(url, load, options));\n}\n\nexport async function shallowLoad(url, load, options) {\n  // console.error('loading', url);\n  const response = await fetch(url, options.fetch);\n  const arrayBuffer = await response.arrayBuffer();\n  return await load(arrayBuffer, options);\n}\n", "import assert from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n", "import parseImage from '../parsers/parse-image';\nimport {getImageUrls} from './load-image';\nimport {deepLoad} from './deep-load';\n\nexport async function loadImageArray(count, getUrl, options = {}) {\n  const imageUrls = await getImageArrayUrls(count, getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageArrayUrls(count, getUrl, options = {}) {\n  const promises = [];\n  for (let index = 0; index < count; index++) {\n    const promise = getImageUrls(getUrl, options, {index});\n    promises.push(promise);\n  }\n  return await Promise.all(promises);\n}\n", "import parseImage from '../parsers/parse-image';\nimport {getImageUrls} from './load-image';\nimport {deepLoad} from './deep-load';\n\n// Returned map will be have keys corresponding to GL cubemap constants\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\nconst GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\nconst GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;\n\nconst CUBE_FACES = [\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},\n  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},\n  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}\n];\n\n// Returns an object with six key-value pairs containing the urls (or url mip arrays)\n// for each cube face\nexport async function getImageCubeUrls(getUrl, options) {\n  // Calculate URLs\n  const urls = {};\n  const promises = [];\n\n  let index = 0;\n  for (const face in CUBE_FACES) {\n    const faceValues = CUBE_FACES[index];\n    const promise = getImageUrls(getUrl, options, {...faceValues, index: index++}).then(url => {\n      urls[face] = url;\n    });\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n\n  return urls;\n}\n\n// Returns an object with six key-value pairs containing the images (or image mip arrays)\n// for each cube face\nexport async function loadImageCube(getUrl, options = {}) {\n  const urls = await getImageCubeUrls(getUrl, options);\n  return await deepLoad(urls, parseImage, options);\n}\n", "import {getBinaryImageMetadata} from '../category-api/binary-image-api';\n\n// Supported image types are PNG, JPEG, GIF and BMP.\nexport function isBinaryImage(arrayBuffer, mimeType) {\n  const metadata = getBinaryImageMetadata(arrayBuffer);\n  if (mimeType) {\n    return Boolean(metadata && metadata.mimeType === mimeType);\n  }\n  // return true if any known type\n  return Boolean(metadata);\n}\n\n// Sniffs the contents of a file to attempt to deduce the image type\nexport function getBinaryImageMIMEType(arrayBuffer) {\n  const metadata = getBinaryImageMetadata(arrayBuffer);\n  return metadata ? metadata.mimeType : null;\n}\n\nexport function getBinaryImageSize(arrayBuffer, mimeType = null) {\n  const metadata = getBinaryImageMetadata(arrayBuffer);\n\n  if (metadata) {\n    return {\n      width: metadata.width,\n      height: metadata.height\n    };\n  }\n\n  mimeType = mimeType || 'unknown';\n  throw new Error(`invalid image data for type: ${mimeType}`);\n}\n", "export {default as ImageLoader} from './image-loader';\nexport {default as ImageWriter} from './image-writer';\n\n// IMAGE CATEGORY API\n\n// Binary Image API\nexport {getBinaryImageMetadata} from './lib/category-api/binary-image-api';\n\n// Parsed Image API\nexport {isImageTypeSupported, getDefaultImageType} from './lib/category-api/image-type';\n\nexport {\n  isImage,\n  getImageType,\n  getImageSize,\n  getImageData\n} from './lib/category-api/parsed-image-api';\n\n// Texture Loading API\nexport {loadImage} from './lib/texture-api/load-image';\nexport {loadImageArray} from './lib/texture-api/load-image-array';\nexport {loadImageCube} from './lib/texture-api/load-image-cube';\n\n// DEPRECATED\n// TODO - Remove in V3\n\nexport {default as HTMLImageLoader} from './image-loader';\n\nimport {getDefaultImageType} from './lib/category-api/image-type';\n\nexport function getSupportedImageType(imageType = null) {\n  return getDefaultImageType();\n}\n\nexport {\n  isBinaryImage,\n  getBinaryImageMIMEType,\n  getBinaryImageSize\n} from './lib/deprecated/binary-image-api-deprecated';\n", "/* global document */\nimport GL from '@luma.gl/constants';\nimport {Texture2D, copyToTexture, cloneTextureFrom} from '@luma.gl/core';\nimport {ImageLoader} from '@loaders.gl/images';\nimport {load} from '@loaders.gl/core';\nimport {createIterable, log} from '@deck.gl/core';\n\nconst DEFAULT_CANVAS_WIDTH = 1024;\nconst DEFAULT_BUFFER = 4;\n\nconst noop = () => {};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nfunction nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n// update comment to create a new texture and copy original data.\nfunction resizeImage(ctx, imageData, width, height) {\n  if (width === imageData.width && height === imageData.height) {\n    return imageData;\n  }\n\n  ctx.canvas.height = height;\n  ctx.canvas.width = width;\n\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);\n\n  return ctx.canvas;\n}\n\nfunction getIconId(icon) {\n  return icon && (icon.id || icon.url);\n}\n\n// resize texture without losing original data\nfunction resizeTexture(gl, texture, width, height) {\n  const oldWidth = texture.width;\n  const oldHeight = texture.height;\n\n  const newTexture = cloneTextureFrom(texture, {width, height});\n  copyToTexture(texture, newTexture, {\n    targetY: 0,\n    width: oldWidth,\n    height: oldHeight\n  });\n\n  texture.delete();\n  return newTexture;\n}\n\n// traverse icons in a row of icon atlas\n// extend each icon with left-top coordinates\nfunction buildRowMapping(mapping, columns, yOffset) {\n  for (let i = 0; i < columns.length; i++) {\n    const {icon, xOffset} = columns[i];\n    const id = getIconId(icon);\n    mapping[id] = Object.assign({}, icon, {\n      x: xOffset,\n      y: yOffset\n    });\n  }\n}\n\n/**\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\n * @param buffer {Number} add buffer to the right and bottom side of the image\n * @param xOffset {Number} right position of last icon in old mapping\n * @param yOffset {Number} top position in last icon in old mapping\n * @param rowHeight {Number} rowHeight of the last icon's row\n * @param canvasWidth {Number} max width of canvas\n * @param mapping {object} old mapping\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\n */\nexport function buildMapping({\n  icons,\n  buffer,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n  rowHeight = 0,\n  canvasWidth\n}) {\n  let columns = [];\n  // Strategy to layout all the icons into a texture:\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\n  // when the sum of the icons width is equal or larger than canvasWidth,\n  // move to next row starting from total height so far plus max height of the icons in previous row\n  // row width is equal to canvasWidth\n  // row height is decided by the max height of the icons in that row\n  // mapping coordinates of each icon is its left-top position in the texture\n  for (let i = 0; i < icons.length; i++) {\n    const icon = icons[i];\n    const id = getIconId(icon);\n\n    if (!mapping[id]) {\n      const {height, width} = icon;\n\n      // fill one row\n      if (xOffset + width + buffer > canvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset\n      });\n\n      xOffset = xOffset + width + buffer;\n      rowHeight = Math.max(rowHeight, height);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  return {\n    mapping,\n    rowHeight,\n    xOffset,\n    yOffset,\n    canvasWidth,\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)\n  };\n}\n\n// extract icons from data\n// return icons should be unique, and not cached or cached but url changed\nexport function getDiffIcons(data, getIcon, cachedIcons) {\n  if (!data || !getIcon) {\n    return null;\n  }\n\n  cachedIcons = cachedIcons || {};\n  const icons = {};\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const icon = getIcon(object, objectInfo);\n    const id = getIconId(icon);\n\n    if (!icon) {\n      throw new Error('Icon is missing.');\n    }\n\n    if (!icon.url) {\n      throw new Error('Icon url is missing.');\n    }\n\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\n      icons[id] = icon;\n    }\n  }\n  return icons;\n}\n\nexport default class IconManager {\n  constructor(\n    gl,\n    {\n      onUpdate = noop // notify IconLayer when icon texture update\n    }\n  ) {\n    this.gl = gl;\n    this.onUpdate = onUpdate;\n\n    // load options used for loading images\n    this._loadOptions = null;\n    this._getIcon = null;\n\n    this._texture = null;\n    this._externalTexture = null;\n    this._mapping = {};\n    // count of pending requests to fetch icons\n    this._pendingCount = 0;\n\n    this._autoPacking = false;\n\n    // internal props used when autoPacking applied\n    // right position of last icon\n    this._xOffset = 0;\n    // top position of last icon\n    this._yOffset = 0;\n    this._rowHeight = 0;\n    this._buffer = DEFAULT_BUFFER;\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH;\n    this._canvasHeight = 0;\n    this._canvas = null;\n  }\n\n  finalize() {\n    if (this._texture) {\n      this._texture.delete();\n    }\n  }\n\n  getTexture() {\n    return this._texture || this._externalTexture;\n  }\n\n  getIconMapping(icon) {\n    const id = this._autoPacking ? getIconId(icon) : icon;\n    return this._mapping[id] || {};\n  }\n\n  setProps({loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon}) {\n    if (loadOptions) {\n      this._loadOptions = loadOptions;\n    }\n\n    if (autoPacking !== undefined) {\n      this._autoPacking = autoPacking;\n    }\n\n    if (getIcon) {\n      this._getIcon = getIcon;\n    }\n\n    if (iconMapping) {\n      this._mapping = iconMapping;\n    }\n\n    if (iconAtlas) {\n      this._updateIconAtlas(iconAtlas);\n    }\n\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\n      this._canvas = this._canvas || document.createElement('canvas');\n\n      this._updateAutoPacking(data);\n    }\n  }\n\n  get isLoaded() {\n    return this._pendingCount === 0;\n  }\n\n  _updateIconAtlas(iconAtlas) {\n    if (this._texture) {\n      this._texture.delete();\n      this._texture = null;\n    }\n    if (iconAtlas instanceof Texture2D) {\n      iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);\n\n      this._externalTexture = iconAtlas;\n      this.onUpdate();\n    } else if (iconAtlas) {\n      // Browser object: Image, ImageData, HTMLCanvasElement, ImageBitmap\n      this._texture = new Texture2D(this.gl, {\n        data: iconAtlas,\n        parameters: DEFAULT_TEXTURE_PARAMETERS\n      });\n      this.onUpdate();\n    }\n  }\n\n  _updateAutoPacking(data) {\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});\n\n    if (icons.length > 0) {\n      // generate icon mapping\n      const {mapping, xOffset, yOffset, rowHeight, canvasHeight} = buildMapping({\n        icons,\n        buffer: this._buffer,\n        canvasWidth: this._canvasWidth,\n        mapping: this._mapping,\n        rowHeight: this._rowHeight,\n        xOffset: this._xOffset,\n        yOffset: this._yOffset\n      });\n\n      this._rowHeight = rowHeight;\n      this._mapping = mapping;\n      this._xOffset = xOffset;\n      this._yOffset = yOffset;\n      this._canvasHeight = canvasHeight;\n\n      // create new texture\n      if (!this._texture) {\n        this._texture = new Texture2D(this.gl, {\n          width: this._canvasWidth,\n          height: this._canvasHeight,\n          parameters: DEFAULT_TEXTURE_PARAMETERS\n        });\n      }\n\n      if (this._texture.height !== this._canvasHeight) {\n        this._texture = resizeTexture(\n          this.gl,\n          this._texture,\n          this._canvasWidth,\n          this._canvasHeight\n        );\n      }\n\n      this.onUpdate();\n\n      // load images\n      this._loadIcons(icons);\n    }\n  }\n\n  _loadIcons(icons) {\n    const ctx = this._canvas.getContext('2d');\n\n    for (const icon of icons) {\n      this._pendingCount++;\n      load(icon.url, ImageLoader, this._loadOptions)\n        .then(imageData => {\n          const id = getIconId(icon);\n          const {x, y, width, height} = this._mapping[id];\n\n          const data = resizeImage(ctx, imageData, width, height);\n\n          this._texture.setSubImageData({\n            data,\n            x,\n            y,\n            width,\n            height\n          });\n\n          // Call to regenerate mipmaps after modifying texture(s)\n          this._texture.generateMipmap();\n\n          this.onUpdate();\n        })\n        .catch(error => {\n          log.error(error)();\n        })\n        .finally(() => {\n          this._pendingCount--;\n        });\n    }\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './icon-layer-vertex.glsl';\nimport fs from './icon-layer-fragment.glsl';\nimport IconManager from './icon-manager';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n/*\n * @param {object} props\n * @param {Texture2D | string} props.iconAtlas - atlas image url or texture\n * @param {object} props.iconMapping - icon names mapped to icon definitions\n * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image\n * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,\n *   default to width / 2\n * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,\n *   default to height / 2\n * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency\n *   mask. If true, user defined color is applied. If false, original color from the image is\n *   applied. Default to false.\n * @param {number} props.size - icon size in pixels\n * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]\n * @param {func} props.getIcon - returns icon name as a string\n * @param {func} props.getSize - returns icon size multiplier as a number\n * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons\n *   with mask: true.\n * @param {func} props.getAngle - returns rotating angle (in degree) of the icon.\n */\nconst defaultProps = {\n  iconAtlas: {type: 'object', value: null, async: true},\n  iconMapping: {type: 'object', value: {}, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n  billboard: true,\n  sizeUnits: 'pixels',\n  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n  alphaCutoff: {type: 'number', value: 0.05, min: 0, max: 1},\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getIcon: {type: 'accessor', value: x => x.icon},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 1},\n  getAngle: {type: 'accessor', value: 0},\n  getPixelOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class IconLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.state = {\n      iconManager: new IconManager(this.context.gl, {onUpdate: () => this._onUpdate()})\n    };\n\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceSizes: {\n        size: 1,\n        transition: true,\n        accessor: 'getSize',\n        defaultValue: 1\n      },\n      instanceOffsets: {size: 2, accessor: 'getIcon', transform: this.getInstanceOffset},\n      instanceIconFrames: {size: 4, accessor: 'getIcon', transform: this.getInstanceIconFrame},\n      instanceColorModes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getIcon',\n        transform: this.getInstanceColorMode\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceAngles: {\n        size: 1,\n        transition: true,\n        accessor: 'getAngle'\n      },\n      instancePixelOffset: {\n        size: 2,\n        transition: true,\n        accessor: 'getPixelOffset'\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  /* eslint-disable max-statements, complexity */\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n    const {iconAtlas, iconMapping, data, getIcon} = props;\n    const {iconManager} = this.state;\n\n    iconManager.setProps({loadOptions: props.loadOptions});\n\n    let iconMappingChanged = false;\n    const prePacked = iconAtlas || this.internalState.isAsyncPropLoading('iconAtlas');\n\n    // prepacked iconAtlas from user\n    if (prePacked) {\n      if (oldProps.iconAtlas !== props.iconAtlas) {\n        iconManager.setProps({iconAtlas, autoPacking: false});\n      }\n\n      if (oldProps.iconMapping !== props.iconMapping) {\n        iconManager.setProps({iconMapping});\n        iconMappingChanged = true;\n      }\n    } else {\n      // otherwise, use autoPacking\n      iconManager.setProps({autoPacking: true});\n    }\n\n    if (\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))\n    ) {\n      iconManager.setProps({data, getIcon});\n      iconMappingChanged = true;\n    }\n\n    if (iconMappingChanged) {\n      attributeManager.invalidate('instanceOffsets');\n      attributeManager.invalidate('instanceIconFrames');\n      attributeManager.invalidate('instanceColorModes');\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      attributeManager.invalidateAll();\n    }\n  }\n  /* eslint-enable max-statements, complexity */\n\n  get isLoaded() {\n    return super.isLoaded && this.state.iconManager.isLoaded;\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    // Release resources held by the icon manager\n    this.state.iconManager.finalize();\n  }\n\n  draw({uniforms}) {\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard, alphaCutoff} = this.props;\n    const {iconManager} = this.state;\n    const {viewport} = this.context;\n\n    const iconsTexture = iconManager.getTexture();\n    if (iconsTexture && iconsTexture.loaded) {\n      this.state.model\n        .setUniforms(\n          Object.assign({}, uniforms, {\n            iconsTexture,\n            iconsTextureDim: [iconsTexture.width, iconsTexture.height],\n            sizeScale: sizeScale * (sizeUnits === 'pixels' ? viewport.metersPerPixel : 1),\n            sizeMinPixels,\n            sizeMaxPixels,\n            billboard,\n            alphaCutoff\n          })\n        )\n        .draw();\n    }\n  }\n\n  _getModel(gl) {\n    // The icon-layer vertex shader uses 2d positions\n    // specifed via: attribute vec2 positions;\n    const positions = [-1, -1, -1, 1, 1, 1, 1, -1];\n\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_FAN,\n          attributes: {\n            // The size must be explicitly passed here otherwise luma.gl\n            // will default to assuming that positions are 3D (x,y,z)\n            positions: {\n              size: 2,\n              value: new Float32Array(positions)\n            }\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n\n  _onUpdate() {\n    this.setNeedsRedraw();\n  }\n\n  getInstanceOffset(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];\n  }\n\n  getInstanceColorMode(icon) {\n    const mapping = this.state.iconManager.getIconMapping(icon);\n    return mapping.mask ? 1 : 0;\n  }\n\n  getInstanceIconFrame(icon) {\n    const rect = this.state.iconManager.getIconMapping(icon);\n    return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];\n  }\n}\n\nIconLayer.layerName = 'IconLayer';\nIconLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\n// offset vector by strokeWidth pixels\n// offset_direction is -1 (left) or 1 (right)\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  // Position\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(instanceSourcePositions, instanceSourcePositions64Low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(instanceTargetPositions, instanceTargetPositions64Low, vec3(0.), target_commonspace);\n\n  // Multiply out width and clamp to limits\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  \n  // linear interpolation of source & target to pick right coord\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  // extrude\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Color\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './line-layer-vertex.glsl';\nimport fs from './line-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  getSourcePosition: {type: 'accessor', value: x => x.sourcePosition},\n  getTargetPosition: {type: 'accessor', value: x => x.targetPosition},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1},\n\n  widthUnits: 'pixels',\n  widthScale: {type: 'number', value: 1, min: 0},\n  widthMinPixels: {type: 'number', value: 0, min: 0},\n  widthMaxPixels: {type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0}\n};\n\nexport default class LineLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceSourcePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getSourcePosition'\n      },\n      instanceTargetPositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getTargetPosition'\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getWidth',\n        defaultValue: 1\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({uniforms}) {\n    const {viewport} = this.context;\n    const {widthUnits, widthScale, widthMinPixels, widthMaxPixels} = this.props;\n\n    const widthMultiplier = widthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n\n    this.state.model\n      .setUniforms(\n        Object.assign({}, uniforms, {\n          widthScale: widthScale * widthMultiplier,\n          widthMinPixels,\n          widthMaxPixels\n        })\n      )\n      .draw();\n  }\n\n  _getModel(gl) {\n    /*\n     *  (0, -1)-------------_(1, -1)\n     *       |          _,-\"  |\n     *       o      _,-\"      o\n     *       |  _,-\"          |\n     *   (0, 1)\"-------------(1, 1)\n     */\n    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];\n\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_STRIP,\n          attributes: {\n            positions: new Float32Array(positions)\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n}\n\nLineLayer.layerName = 'LineLayer';\nLineLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  // Find the center of the point and add the current vertex\n  vec3 offset = vec3(positions.xy * radiusPixels, 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply lighting\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n\n  // Apply opacity to instance color, or return instance picking color\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, gouraudLighting, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './point-cloud-layer-vertex.glsl';\nimport fs from './point-cloud-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst DEFAULT_NORMAL = [0, 0, 1];\n\nconst defaultProps = {\n  sizeUnits: 'pixels',\n  pointSize: {type: 'number', min: 0, value: 10}, //  point radius in pixels\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getNormal: {type: 'accessor', value: DEFAULT_NORMAL},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  material: true,\n\n  // Depreated\n  radiusPixels: {deprecatedFor: 'pointSize'}\n};\n\n// support loaders.gl point cloud format\nfunction normalizeData(data) {\n  const {header, attributes} = data;\n  if (!header || !attributes) {\n    return;\n  }\n\n  data.length = header.vertexCount;\n\n  if (attributes.POSITION) {\n    attributes.instancePositions = attributes.POSITION;\n  }\n  if (attributes.NORMAL) {\n    attributes.instanceNormals = attributes.NORMAL;\n  }\n  if (attributes.COLOR_0) {\n    attributes.instanceColors = attributes.COLOR_0;\n  }\n}\n\nexport default class PointCloudLayer extends Layer {\n  getShaders(id) {\n    return super.getShaders({vs, fs, modules: [project32, gouraudLighting, picking]});\n  }\n\n  initializeState() {\n    /* eslint-disable max-len */\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceNormals: {\n        size: 3,\n        transition: true,\n        accessor: 'getNormal',\n        defaultValue: DEFAULT_NORMAL\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n    if (changeFlags.dataChanged) {\n      normalizeData(props.data);\n    }\n  }\n\n  draw({uniforms}) {\n    const {viewport} = this.context;\n    const {pointSize, sizeUnits} = this.props;\n\n    const sizeMultiplier = sizeUnits === 'meters' ? 1 / viewport.metersPerPixel : 1;\n\n    this.state.model\n      .setUniforms(\n        Object.assign({}, uniforms, {\n          radiusPixels: pointSize * sizeMultiplier\n        })\n      )\n      .draw();\n  }\n\n  _getModel(gl) {\n    // a triangle that minimally cover the unit circle\n    const positions = [];\n    for (let i = 0; i < 3; i++) {\n      const angle = (i / 3) * Math.PI * 2;\n      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);\n    }\n\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          attributes: {\n            positions: new Float32Array(positions)\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n}\n\nPointCloudLayer.layerName = 'PointCloudLayer';\nPointCloudLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  \n  // Multiply out line width and clamp to limits\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n\n  // position on the containing square in [-1, 1] space\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Apply opacity to instance color, or return instance picking color\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = smoothedge(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport vs from './scatterplot-layer-vertex.glsl';\nimport fs from './scatterplot-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  radiusUnits: 'meters',\n  radiusScale: {type: 'number', min: 0, value: 1},\n  radiusMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels\n  radiusMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: {type: 'number', min: 0, value: 1},\n  lineWidthMinPixels: {type: 'number', min: 0, value: 0},\n  lineWidthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  stroked: false,\n  filled: true,\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getRadius: {type: 'accessor', value: 1},\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineWidth: {type: 'accessor', value: 1},\n\n  // deprecated\n  strokeWidth: {deprecatedFor: 'getLineWidth'},\n  outline: {deprecatedFor: 'stroked'},\n  getColor: {deprecatedFor: ['getFillColor', 'getLineColor']}\n};\n\nexport default class ScatterplotLayer extends Layer {\n  getShaders(id) {\n    return super.getShaders({vs, fs, modules: [project32, picking]});\n  }\n\n  initializeState() {\n    this.getAttributeManager().addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceRadius: {\n        size: 1,\n        transition: true,\n        accessor: 'getRadius',\n        defaultValue: 1\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        transition: true,\n        normalized: true,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        transition: true,\n        normalized: true,\n        type: GL.UNSIGNED_BYTE,\n        accessor: 'getLineColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineWidths: {\n        size: 1,\n        transition: true,\n        accessor: 'getLineWidth',\n        defaultValue: 1\n      }\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n  }\n\n  draw({uniforms}) {\n    const {viewport} = this.context;\n    const {\n      radiusUnits,\n      radiusScale,\n      radiusMinPixels,\n      radiusMaxPixels,\n      stroked,\n      filled,\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels\n    } = this.props;\n\n    const pointRadiusMultiplier = radiusUnits === 'pixels' ? viewport.metersPerPixel : 1;\n    const lineWidthMultiplier = lineWidthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n\n    this.state.model\n      .setUniforms(uniforms)\n      .setUniforms({\n        stroked: stroked ? 1 : 0,\n        filled,\n        radiusScale: radiusScale * pointRadiusMultiplier,\n        radiusMinPixels,\n        radiusMaxPixels,\n        lineWidthScale: lineWidthScale * lineWidthMultiplier,\n        lineWidthMinPixels,\n        lineWidthMaxPixels\n      })\n      .draw();\n  }\n\n  _getModel(gl) {\n    // a square that minimally cover the unit circle\n    const positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];\n\n    return new Model(\n      gl,\n      Object.assign(this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLE_FAN,\n          vertexCount: 4,\n          attributes: {\n            positions: {size: 3, value: new Float32Array(positions)}\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n}\n\nScatterplotLayer.layerName = 'ScatterplotLayer';\nScatterplotLayer.defaultProps = defaultProps;\n", "import {log} from '@deck.gl/core';\nimport {Geometry, uid} from '@luma.gl/core';\n\nexport default class ColumnGeometry extends Geometry {\n  constructor(props = {}) {\n    const {id = uid('column-geometry')} = props;\n    const {indices, attributes} = tesselateColumn(props);\n    super({\n      ...props,\n      id,\n      indices,\n      attributes\n    });\n  }\n}\n\n/* eslint-disable max-statements, complexity */\nfunction tesselateColumn(props) {\n  const {radius, height = 1, nradial = 10, vertices} = props;\n  log.assert(!vertices || vertices.length >= nradial);\n\n  const vertsAroundEdge = nradial + 1; // loop\n  const numVertices = vertsAroundEdge * 3; // top, side top edge, side bottom edge\n\n  const stepAngle = (Math.PI * 2) / nradial;\n\n  // Used for wireframe\n  const indices = new Uint16Array(nradial * 3 * 2); // top loop, side vertical, bottom loop\n\n  const positions = new Float32Array(numVertices * 3);\n  const normals = new Float32Array(numVertices * 3);\n\n  let i = 0;\n\n  // side tesselation: 0, 1, 2, 3, 4, 5, ...\n  //\n  // 0 - 2 - 4  ... top\n  // | / | / |\n  // 1 - 3 - 5  ... bottom\n  //\n  for (let j = 0; j < vertsAroundEdge; j++) {\n    const a = j * stepAngle;\n    const vertex = vertices && vertices[j % nradial];\n    const nextVertex = vertices && vertices[(j + 1) % nradial];\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    for (let k = 0; k < 2; k++) {\n      positions[i + 0] = vertex ? vertex[0] : cos * radius;\n      positions[i + 1] = vertex ? vertex[1] : sin * radius;\n      positions[i + 2] = (1 / 2 - k) * height;\n\n      normals[i + 0] = vertex ? nextVertex[0] - vertex[0] : cos;\n      normals[i + 1] = vertex ? nextVertex[1] - vertex[1] : sin;\n\n      i += 3;\n    }\n  }\n\n  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...\n  //\n  //    0 -- 1\n  //   /      \\\n  // -1        2\n  //  |        |\n  // -2        3\n  //   \\      /\n  //   -3 -- 4\n  //\n  for (let j = 0; j < vertsAroundEdge; j++) {\n    const v = Math.floor(j / 2) * Math.sign((j % 2) - 0.5);\n    const a = v * stepAngle;\n    const vertex = vertices && vertices[(v + nradial) % nradial];\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    positions[i + 0] = vertex ? vertex[0] : cos * radius;\n    positions[i + 1] = vertex ? vertex[1] : sin * radius;\n    positions[i + 2] = height / 2;\n\n    normals[i + 2] = 1;\n\n    i += 3;\n  }\n\n  let index = 0;\n  for (let j = 0; j < nradial; j++) {\n    // top loop\n    indices[index++] = j * 2 + 0;\n    indices[index++] = j * 2 + 2;\n    // side vertical\n    indices[index++] = j * 2 + 0;\n    indices[index++] = j * 2 + 1;\n    // bottom loop\n    indices[index++] = j * 2 + 1;\n    indices[index++] = j * 2 + 3;\n  }\n\n  return {\n    indices,\n    attributes: {\n      POSITION: {size: 3, value: positions},\n      NORMAL: {size: 3, value: normals}\n    }\n  };\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\n#define SHADER_NAME column-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute float instanceElevations;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute float instanceStrokeWidths;\n\nattribute vec3 instancePickingColors;\n\n// Custom uniforms\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\n// Result\nvarying vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  // rotate primitive position and normal\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\n  float elevation = 0.0;\n  // calculate stroke offset\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (isStroke) {\n    float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    strokeOffsetRatio += sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n  }\n\n  // if alpha == 0.0 or z < 0.0, do not render element\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  geometry.pickingColor = instancePickingColors;\n\n  // project center of column\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec3 pos = vec3(project_size(rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Light calculations\n  if (extruded && !isStroke) {\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, gouraudLighting, picking} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model} from '@luma.gl/core';\nimport ColumnGeometry from './column-geometry';\n\nimport vs from './column-layer-vertex.glsl';\nimport fs from './column-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  diskResolution: {type: 'number', min: 4, value: 20},\n  vertices: null,\n  radius: {type: 'number', min: 0, value: 1000},\n  angle: {type: 'number', value: 0},\n  offset: {type: 'array', value: [0, 0]},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n\n  extruded: true,\n  wireframe: false,\n  filled: true,\n  stroked: false,\n\n  getPosition: {type: 'accessor', value: x => x.position},\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineWidth: {type: 'accessor', value: 1},\n  getElevation: {type: 'accessor', value: 1000},\n  material: true,\n  getColor: {deprecatedFor: ['getFillColor', 'getLineColor']}\n};\n\nexport default class ColumnLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, gouraudLighting, picking]});\n  }\n\n  /**\n   * DeckGL calls initializeState when GL context is available\n   * Essentially a deferred constructor\n   */\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: true,\n        accessor: 'getPosition'\n      },\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getLineWidth',\n        transition: true\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const regenerateModels = changeFlags.extensionsChanged;\n\n    if (regenerateModels) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      this.getAttributeManager().invalidateAll();\n    }\n\n    if (\n      regenerateModels ||\n      props.diskResolution !== oldProps.diskResolution ||\n      props.vertices !== oldProps.vertices\n    ) {\n      this._updateGeometry(props);\n    }\n  }\n\n  getGeometry(diskResolution, vertices) {\n    const geometry = new ColumnGeometry({\n      radius: 1,\n      height: 2,\n      vertices,\n      nradial: diskResolution\n    });\n\n    let meanVertexDistance = 0;\n    if (vertices) {\n      for (let i = 0; i < diskResolution; i++) {\n        const p = vertices[i];\n        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n        meanVertexDistance += d / diskResolution;\n      }\n    } else {\n      meanVertexDistance = 1;\n    }\n    this.setState({\n      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance\n    });\n\n    return geometry;\n  }\n\n  _getModel(gl) {\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        isInstanced: true\n      })\n    );\n  }\n\n  _updateGeometry({diskResolution, vertices}) {\n    const geometry = this.getGeometry(diskResolution, vertices);\n\n    this.setState({\n      fillVertexCount: geometry.attributes.POSITION.value.length / 3,\n      wireframeVertexCount: geometry.indices.value.length\n    });\n\n    this.state.model.setProps({geometry});\n  }\n\n  draw({uniforms}) {\n    const {viewport} = this.context;\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n\n      elevationScale,\n      extruded,\n      filled,\n      stroked,\n      wireframe,\n      offset,\n      coverage,\n      radius,\n      angle\n    } = this.props;\n    const {model, fillVertexCount, wireframeVertexCount, edgeDistance} = this.state;\n\n    const widthMultiplier = lineWidthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n\n    model.setUniforms(\n      Object.assign({}, uniforms, {\n        radius,\n        angle: (angle / 180) * Math.PI,\n        offset,\n        extruded,\n        coverage,\n        elevationScale,\n        edgeDistance,\n        widthScale: lineWidthScale * widthMultiplier,\n        widthMinPixels: lineWidthMinPixels,\n        widthMaxPixels: lineWidthMaxPixels\n      })\n    );\n\n    // When drawing 3d: draw wireframe first so it doesn't get occluded by depth test\n    if (extruded && wireframe) {\n      model.setProps({isIndexed: true});\n      model\n        .setVertexCount(wireframeVertexCount)\n        .setDrawMode(GL.LINES)\n        .setUniforms({isStroke: true})\n        .draw();\n    }\n    if (filled) {\n      model.setProps({isIndexed: false});\n      model\n        .setVertexCount(fillVertexCount)\n        .setDrawMode(GL.TRIANGLE_STRIP)\n        .setUniforms({isStroke: false})\n        .draw();\n    }\n    // When drawing 2d: draw fill before stroke so that the outline is always on top\n    if (!extruded && stroked) {\n      model.setProps({isIndexed: false});\n      // The width of the stroke is achieved by flattening the side of the cylinder.\n      // Skip the last 1/3 of the vertices which is the top.\n      model\n        .setVertexCount((fillVertexCount * 2) / 3)\n        .setDrawMode(GL.TRIANGLE_STRIP)\n        .setUniforms({isStroke: true})\n        .draw();\n    }\n  }\n}\n\nColumnLayer.layerName = 'ColumnLayer';\nColumnLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CubeGeometry} from '@luma.gl/core';\nimport ColumnLayer from './column-layer';\n\nconst defaultProps = {\n  cellSize: {type: 'number', min: 0, value: 1000},\n  offset: {type: 'array', min: 0, value: [1, 1]}\n};\n\nexport default class GridCellLayer extends ColumnLayer {\n  getGeometry(diskResolution) {\n    return new CubeGeometry();\n  }\n\n  draw({uniforms}) {\n    const {elevationScale, extruded, offset, coverage, cellSize, angle} = this.props;\n    this.state.model\n      .setUniforms(\n        Object.assign({}, uniforms, {\n          radius: cellSize / 2,\n          angle,\n          offset,\n          extruded,\n          coverage,\n          elevationScale,\n          edgeDistance: 1,\n          isWireframe: false\n        })\n      )\n      .draw();\n  }\n}\n\nGridCellLayer.layerName = 'GridCellLayer';\nGridCellLayer.defaultProps = defaultProps;\n", "/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\n\nimport {equals} from '@math.gl/core';\nimport type {NumericArray} from '@math.gl/core';\n\nexport const WINDING = {\n  CLOCKWISE: 1,\n  COUNTER_CLOCKWISE: -1\n} as const;\n\n/** Polygon representation where each point is represented as a separate array of positions. */\ntype PointsArray = NumericArray[];\n\n/** Segment visitor callback type for polygons defined with flat arrays, */\ntype SegmentVisitorFlat = (\n  p1x: number,\n  p1y: number,\n  p2x: number,\n  p2y: number,\n  i1: number,\n  i2: number\n) => void;\n\n/** Segment visitor callback type for polygons defined with array of points. */\nexport type SegmentVisitorPoints = (\n  p1: NumericArray,\n  p2: NumericArray,\n  i1: number,\n  i2: number\n) => void;\n\n/** Parameters of a polygon. */\ntype PolygonParams = {\n  start?: number; // Start index of the polygon in the array of positions. Defaults to 0.\n  end?: number; // End index of the polygon in the array of positions. Defaults to number of positions.\n  size?: number; // Size of a point, 2 (XZ) or 3 (XYZ). Defaults to 2. Affects only polygons stored in flat arrays.\n  isClosed?: boolean; // Indicates that the first point of the polygon is equal to the last point, and additional checks should be ommited.\n};\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points An array that represents points of the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirection(\n  points: NumericArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const windingDirection = getPolygonWindingDirection(points, options);\n  if (windingDirection !== direction) {\n    reversePolygon(points, options);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirection(\n  points: NumericArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedArea(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points An array that represents points of the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n * https://en.wikipedia.org/wiki/Shoelace_formula\n */\nexport function getPolygonSignedArea(points: NumericArray, options: PolygonParams = {}): number {\n  const {start = 0, end = points.length} = options;\n  const dim = options.size || 2;\n  let area = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    area += (points[i] - points[j]) * (points[i + 1] + points[j + 1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls the visitor callback for each segment in the polygon.\n * @param points An array that represents points of the polygon\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygon(\n  points: NumericArray,\n  visitor: SegmentVisitorFlat,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, size = 2, isClosed} = options;\n\n  const numPoints = (end - start) / size;\n  for (let i = 0; i < numPoints - 1; ++i) {\n    visitor(\n      points[start + i * size],\n      points[start + i * size + 1],\n      points[start + (i + 1) * size],\n      points[start + (i + 1) * size + 1],\n      i,\n      i + 1\n    );\n  }\n\n  const endPointIndex = start + (numPoints - 1) * size;\n  const isClosedEx =\n    isClosed ||\n    (equals(points[start], points[endPointIndex]) &&\n      equals(points[start + 1], points[endPointIndex + 1]));\n\n  if (!isClosedEx) {\n    visitor(\n      points[endPointIndex],\n      points[endPointIndex + 1],\n      points[start],\n      points[start + 1],\n      numPoints - 1,\n      0\n    );\n  }\n}\n\nfunction reversePolygon(\n  points: NumericArray,\n  options: {start?: number; end?: number; size?: number}\n): void {\n  const {start = 0, end = points.length, size = 2} = options;\n\n  const numPoints = (end - start) / size;\n  const numSwaps = Math.floor(numPoints / 2);\n  for (let i = 0; i < numSwaps; ++i) {\n    const b1 = start + i * size;\n    const b2 = start + (numPoints - 1 - i) * size;\n    for (let j = 0; j < size; ++j) {\n      const tmp = points[b1 + j];\n      points[b1 + j] = points[b2 + j];\n      points[b2 + j] = tmp;\n    }\n  }\n}\n\n/**\n * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n * Note: points are modified in-place.\n * @param points Array of points that represent the polygon.\n * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n * @param options Parameters of the polygon.\n * @return Returns true if the winding direction was changed.\n */\nexport function modifyPolygonWindingDirectionPoints(\n  points: PointsArray,\n  direction: number,\n  options: PolygonParams = {}\n): boolean {\n  const currentDirection = getPolygonWindingDirectionPoints(points, options);\n  if (currentDirection !== direction) {\n    points.reverse();\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns winding direction of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Winding direction of the polygon.\n */\nexport function getPolygonWindingDirectionPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  return Math.sign(getPolygonSignedAreaPoints(points, options));\n}\n\n/**\n * Returns signed area of the polygon.\n * @param points Array of points that represent the polygon.\n * @param options Parameters of the polygon.\n * @returns Signed area of the polygon.\n */\nexport function getPolygonSignedAreaPoints(\n  points: PointsArray,\n  options: PolygonParams = {}\n): number {\n  // https://en.wikipedia.org/wiki/Shoelace_formula\n  const {start = 0, end = points.length} = options;\n  let area = 0;\n  for (let i = start, j = end - 1; i < end; ++i) {\n    area += (points[i][0] - points[j][0]) * (points[i][1] + points[j][1]);\n    j = i;\n  }\n  return area / 2;\n}\n\n/**\n * Calls visitor callback for each segment in the polygon.\n * @param points Array of points that represent the polygon.\n * @param visitor A callback to call for each segment.\n * @param options Parameters of the polygon.\n */\nexport function forEachSegmentInPolygonPoints(\n  points: PointsArray,\n  visitor: SegmentVisitorPoints,\n  options: PolygonParams = {}\n): void {\n  const {start = 0, end = points.length, isClosed} = options;\n  for (let i = start; i < end - 1; ++i) {\n    visitor(points[i], points[i + 1], i, i + 1);\n  }\n\n  const isClosedEx = isClosed || equals(points[end - 1], points[0]);\n  if (!isClosedEx) {\n    visitor(points[end - 1], points[0], end - 1, 0);\n  }\n}\n", "/* eslint-disable no-undef, no-console */\nimport {isArray} from '@math.gl/core';\nimport type {SegmentVisitorPoints} from './polygon-utils';\nimport type {NumericArray} from '@math.gl/core';\n\nimport {\n  getPolygonSignedArea,\n  forEachSegmentInPolygon,\n  modifyPolygonWindingDirection,\n  getPolygonSignedAreaPoints,\n  forEachSegmentInPolygonPoints,\n  modifyPolygonWindingDirectionPoints\n} from './polygon-utils';\n\nexport type PolygonOptions = {\n  start?: number;\n  end?: number;\n  size?: number;\n  isClosed?: boolean;\n};\n\nexport default class Polygon {\n  points: NumericArray | number[][];\n  isFlatArray: boolean;\n  options: PolygonOptions;\n\n  constructor(points: NumericArray | number[][], options: PolygonOptions = {}) {\n    this.points = points;\n    this.isFlatArray = !isArray(points[0]);\n\n    this.options = {\n      start: options.start || 0,\n      end: options.end || points.length,\n      size: options.size || 2,\n      isClosed: options.isClosed\n    };\n\n    Object.freeze(this);\n  }\n\n  /**\n   * Returns signed area of the polygon.\n   * @returns Signed area of the polygon.\n   */\n  getSignedArea(): number {\n    if (this.isFlatArray) return getPolygonSignedArea(this.points as NumericArray, this.options);\n\n    return getPolygonSignedAreaPoints(this.points as number[][], this.options);\n  }\n\n  /**\n   * Returns absolute area of the polygon.\n   * @returns Absolute area of the polygon.\n   */\n  getArea(): number {\n    return Math.abs(this.getSignedArea());\n  }\n\n  /**\n   * Returns winding direction of the polygon.\n   * @returns Winding direction of the polygon. 1 is for clockwise, -1 for counterclockwise winding direction.\n   */\n  getWindingDirection(): number {\n    return Math.sign(this.getSignedArea());\n  }\n\n  /**\n   * Calls the visitor callback for each segment in the polygon.\n   * @param visitor A callback to call for each segment.\n   */\n  forEachSegment(visitor: SegmentVisitorPoints): void {\n    if (this.isFlatArray) {\n      forEachSegmentInPolygon(\n        this.points as NumericArray,\n        // eslint-disable-next-line max-params\n        (x1, y1, x2, y2, i1, i2) => {\n          // TODO @igorDykhta original visitor uses arrays for each point, but with flat arrays performance degrades if we allocate points for each segment\n          visitor([x1, y1], [x2, y2], i1, i2);\n        },\n        this.options\n      );\n    } else {\n      forEachSegmentInPolygonPoints(this.points as number[][], visitor, this.options);\n    }\n  }\n\n  /**\n   * Checks winding direction of the polygon and reverses the polygon in case of opposite winding direction.\n   * @param direction Requested winding direction. 1 is for clockwise, -1 for counterclockwise winding direction.\n   * @return Returns true if the winding direction was changed.\n   */\n  modifyWindingDirection(direction: number): boolean {\n    if (this.isFlatArray) {\n      return modifyPolygonWindingDirection(this.points as NumericArray, direction, this.options);\n    }\n    return modifyPolygonWindingDirectionPoints(this.points as number[][], direction, this.options);\n  }\n}\n", "/*\n  Adapted from https://github.com/mapbox/earcut to allow passing in\n  of outline and hole areas using the `areas` parameter. As the\n  areas are calcuted as part of classifying the polygon rings\n  we can pass them in again to avoid recomputation\n\n  ISC License\n\n  Copyright (c) 2016, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n/* eslint-disable */\n\nimport {getPolygonSignedArea} from './polygon-utils';\n\n/**\n * Computes a triangulation of a polygon\n * @param positions a flat array of the vertex positions that define the polygon.\n * @param holeIndices an array of hole indices if any (e.g. [5, 8] for a 12-vertex input would mean one hole with vertices 5–7 and another with 8–11).\n * @param dim the number of elements in each vertex. Size `2` will interpret `positions` as `[x0, y0, x1, y1, ...]` and size `3` will interpret `positions` as `[x0, y0, z0, x1, y1, z1, ...]`. Default `2`.\n * @param areas areas of outer polygon and holes as computed by `getPolygonSignedArea()`. Can be optionally supplied to speed up triangulation\n * @returns array of indices into the `positions` array that describes the triangulation of the polygon\n * Adapted from https://github.com/mapbox/earcut\n */\nexport function earcut(\n  positions: number[],\n  holeIndices?: number[],\n  dim: number = 2,\n  areas?: number[]\n): number[] {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : positions.length;\n  let outerNode = linkedList(positions, 0, outerLen, dim, true, areas && areas[0]);\n  const triangles = [];\n\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n  let invSize;\n  let maxX;\n  let maxY;\n  let minX;\n  let minY;\n  let x;\n  let y;\n\n  if (hasHoles) outerNode = eliminateHoles(positions, holeIndices, outerNode, dim, areas);\n\n  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n  if (positions.length > 80 * dim) {\n    minX = maxX = positions[0];\n    minY = maxY = positions[1];\n\n    for (let i = dim; i < outerLen; i += dim) {\n      x = positions[i];\n      y = positions[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 1 / invSize : 0;\n  }\n\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n  return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise, area) {\n  let i;\n  let last;\n  if (area === undefined) {\n    area = getPolygonSignedArea(data, {start, end, size: dim});\n  }\n\n  // Note that the signed area calculation in math.gl\n  // has the opposite sign to that which was originally\n  // present in earcut, thus the `< 0` is reversed\n  if (clockwise === area < 0) {\n    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n  }\n\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end?) {\n  if (!start) return start;\n  if (!end) end = start;\n\n  let p = start;\n  let again;\n  do {\n    again = false;\n\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass?) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n  let stop = ear;\n  let prev;\n  let next;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      // cut off the triangle\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n\n      continue;\n    }\n\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  let p = ear.next.next;\n\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)\n      return false;\n    p = p.next;\n  }\n\n  return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev;\n  const b = ear;\n  const c = ear.next;\n\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // triangle bbox; min & max are calculated like this for speed\n  const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : b.x < c.x ? b.x : c.x;\n  const minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : b.y < c.y ? b.y : c.y;\n  const maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : b.x > c.x ? b.x : c.x;\n  const maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : b.y > c.y ? b.y : c.y;\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize);\n  const maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n  let p = ear.prevZ;\n  let n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (\n      p !== ear.prev &&\n      p !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n\n    if (\n      n !== ear.prev &&\n      n !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (\n      p !== ear.prev &&\n      p !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n      area(p.prev, p, p.next) >= 0\n    )\n      return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (\n      n !== ear.prev &&\n      n !== ear.next &&\n      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n      area(n.prev, n, n.next) >= 0\n    )\n      return false;\n    n = n.nextZ;\n  }\n\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev;\n    const b = p.next.next;\n\n    if (\n      !equals(a, b) &&\n      intersects(a, p, p.next, b) &&\n      locallyInside(a, b) &&\n      locallyInside(b, a)\n    ) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim, areas) {\n  const queue = [];\n  let i;\n  let len;\n  let start;\n  let end;\n  let list;\n\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false, areas && areas[i + 1]);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n\n  queue.sort(compareX);\n\n  // process holes from left to right\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n\n  return outerNode;\n}\n\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        if (x === hx) {\n          if (hy === p.y) return p;\n          if (hy === p.next.y) return p.next;\n        }\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n\n  if (!m) return null;\n\n  if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  let tan;\n\n  p = m;\n\n  do {\n    if (\n      hx >= p.x &&\n      p.x >= mx &&\n      hx !== p.x &&\n      pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)\n    ) {\n      tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (\n        locallyInside(p, hole) &&\n        (tan < tanMin ||\n          (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))\n      ) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n\n    p = p.next;\n  } while (p !== stop);\n\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let e;\n  let i;\n  let inSize = 1;\n  let numMerges;\n  let p;\n  let pSize;\n  let q;\n  let qSize;\n  let tail;\n\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      qSize = inSize;\n\n      while (pSize > 0 || (qSize > 0 && q)) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n\n        if (tail) tail.nextZ = e;\n        else list = e;\n\n        e.prevZ = tail;\n        tail = e;\n      }\n\n      p = q;\n    }\n\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n\n  x = (x | (x << 8)) & 0x00ff00ff;\n  x = (x | (x << 4)) & 0x0f0f0f0f;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y = (y | (y << 8)) & 0x00ff00ff;\n  y = (y | (y << 4)) & 0x0f0f0f0f;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start;\n  let leftmost = start;\n  do {\n    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (\n    (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n    (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n    (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0\n  );\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return (\n    a.next.i !== b.i &&\n    a.prev.i !== b.i &&\n    !intersectsPolygon(a, b) && // dones't intersect other edges\n    ((locallyInside(a, b) &&\n      locallyInside(b, a) &&\n      middleInside(a, b) && // locally visible\n      (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors\n      (equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0))\n  ); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return (\n    q.x <= Math.max(p.x, r.x) &&\n    q.x >= Math.min(p.x, r.x) &&\n    q.y <= Math.max(p.y, r.y) &&\n    q.y >= Math.min(p.y, r.y)\n  );\n}\n\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (\n      p.i !== a.i &&\n      p.next.i !== a.i &&\n      p.i !== b.i &&\n      p.next.i !== b.i &&\n      intersects(p, p.next, a, b)\n    )\n      return true;\n    p = p.next;\n  } while (p !== a);\n\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0\n    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0\n    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n  do {\n    if (\n      p.y > py !== p.next.y > py &&\n      p.next.y !== p.y &&\n      px < ((p.next.x - p.x) * (py - p.y)) / (p.next.y - p.y) + p.x\n    )\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y);\n  const b2 = new Node(b.i, b.x, b.y);\n  const an = a.next;\n  const bp = b.prev;\n\n  a.next = b;\n  b.prev = a;\n\n  a2.next = an;\n  an.prev = a2;\n\n  b2.next = a2;\n  a2.prev = b2;\n\n  bp.next = b2;\n  b2.prev = bp;\n\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\n\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n  // vertex index in coordinates array\n  this.i = i;\n\n  // vertex coordinates\n  this.x = x;\n  this.y = y;\n\n  // previous and next vertex nodes in a polygon ring\n  this.prev = null;\n  this.next = null;\n\n  // z-order curve value\n  this.z = null;\n\n  // previous and next nodes in z-order\n  this.prevZ = null;\n  this.nextZ = null;\n\n  // indicates whether this is a steiner point\n  this.steiner = false;\n}\n", "import type {NumericArray} from '@math.gl/core';\n\nexport function push(target: number[], source: number[]): boolean {\n  const size = source.length;\n  const startIndex = target.length;\n\n  // dedupe, if source is the same point as the last vertex\n  if (startIndex > 0) {\n    let isDuplicate = true;\n    for (let i = 0; i < size; i++) {\n      if (target[startIndex - size + i] !== source[i]) {\n        isDuplicate = false;\n        break;\n      }\n    }\n    if (isDuplicate) {\n      return false;\n    }\n  }\n\n  for (let i = 0; i < size; i++) {\n    target[startIndex + i] = source[i];\n  }\n  return true;\n}\n\nexport function copy(target: number[], source: Readonly<NumericArray>): void {\n  const size = source.length;\n  for (let i = 0; i < size; i++) {\n    target[i] = source[i];\n  }\n}\n\nexport function getPointAtIndex(\n  positions: Readonly<NumericArray>,\n  index: number,\n  size: number,\n  offset: number,\n  out: number[] = []\n): number[] {\n  const startI = offset + index * size;\n  for (let i = 0; i < size; i++) {\n    out[i] = positions[startI + i];\n  }\n  return out;\n}\n", "/*\n  Adapted from https://github.com/mapbox/lineclip to work with flat arrays\n  and 3d positions\n\n  ISC License\n\n  Copyright (c) 2015, Mapbox\n\n  Permission to use, copy, modify, and/or distribute this software for any purpose\n  with or without fee is hereby granted, provided that the above copyright notice\n  and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n  FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\n  OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n  THIS SOFTWARE.\n\n */\n\n/* eslint-disable max-statements, max-depth, complexity */\n\nimport {push, copy, getPointAtIndex} from './utils';\nimport type {NumericArray} from '@math.gl/core';\n\nexport type BoundingBox = [number, number, number, number];\n\n/**\n * Cohen-Sutherland line clipping algorithm, adapted to efficiently\n * handle polylines rather than just segments\n */\nexport function clipPolyline(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length} = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  const result: number[][] = [];\n  let part: number[] = [];\n  let a: number[];\n  let b: number[];\n  let codeA: number = -1;\n  let codeB: number;\n  let lastCode: number;\n\n  for (let i = 1; i < numPoints; i++) {\n    a = getPointAtIndex(positions, i - 1, size, startIndex, a);\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    if (codeA < 0) {\n      codeA = bitCode(a, bbox);\n    }\n    codeB = lastCode = bitCode(b, bbox);\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (!(codeA | codeB)) {\n        // accept\n        push(part, a);\n\n        if (codeB !== lastCode) {\n          // segment went outside\n          push(part, b);\n\n          if (i < numPoints - 1) {\n            // start a new line\n            result.push(part);\n            part = [];\n          }\n        } else if (i === numPoints - 1) {\n          push(part, b);\n        }\n        break;\n      } else if (codeA & codeB) {\n        // trivial reject\n        break;\n      } else if (codeA) {\n        // a outside, intersect with clip edge\n        intersect(a, b, codeA, bbox, a);\n        codeA = bitCode(a, bbox);\n      } else {\n        // b outside\n        intersect(a, b, codeB, bbox, b);\n        codeB = bitCode(b, bbox);\n      }\n    }\n\n    codeA = lastCode;\n  }\n\n  if (part.length) result.push(part);\n\n  return result;\n}\n\n/**\n * Sutherland-Hodgeman polygon clipping algorithm\n * polygon must be closed (first vertex == last vertex)\n */\nexport function clipPolygon(\n  positions: Readonly<NumericArray>,\n  bbox: BoundingBox,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] {\n  const {size = 2, endIndex = positions.length} = options || {};\n  let {startIndex = 0} = options || {};\n  let numPoints = (endIndex - startIndex) / size;\n  let result: number[];\n  let p: number[];\n  let prev: number[];\n  let inside: boolean;\n  let prevInside: boolean;\n\n  // clip against each side of the clip rectangle\n  for (let edge = 1; edge <= 8; edge *= 2) {\n    result = [];\n    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);\n    prevInside = !(bitCode(prev, bbox) & edge);\n\n    for (let i = 0; i < numPoints; i++) {\n      p = getPointAtIndex(positions, i, size, startIndex, p);\n      inside = !(bitCode(p, bbox) & edge);\n\n      // if segment goes through the clip window, add an intersection\n      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));\n\n      if (inside) push(result, p); // add a point if it's inside\n\n      copy(prev, p);\n      prevInside = inside;\n    }\n\n    // close loop\n    positions = result;\n    startIndex = 0;\n    numPoints = result.length / size;\n\n    if (!numPoints) break;\n  }\n\n  return result;\n}\n\n/** intersect a segment against one of the 4 lines that make up the bbox */\n\nexport function intersect(\n  a: number[],\n  b: number[],\n  edge: number,\n  bbox: BoundingBox,\n  out: number[] = []\n): number[] {\n  let t;\n  // Forces out[snapI] to be on the bbox edge\n  // Interpolation introduces precision issue which may cause lineclip to be\n  // stuck in an infinite loop\n  let snap: number;\n  if (edge & 8) {\n    // top\n    t = (bbox[3] - a[1]) / (b[1] - a[1]);\n    snap = 3;\n  } else if (edge & 4) {\n    // bottom\n    t = (bbox[1] - a[1]) / (b[1] - a[1]);\n    snap = 1;\n  } else if (edge & 2) {\n    // right\n    t = (bbox[2] - a[0]) / (b[0] - a[0]);\n    snap = 2;\n  } else if (edge & 1) {\n    // left\n    t = (bbox[0] - a[0]) / (b[0] - a[0]);\n    snap = 0;\n  } else {\n    return null;\n  }\n  for (let i = 0; i < a.length; i++) {\n    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];\n  }\n  return out;\n}\n\n/**\n * bit code reflects the point position relative to the bbox:\n *         left  mid  right\n *    top  1001  1000  1010\n *    mid  0001  0000  0010\n * bottom  0101  0100  0110\n */\nexport function bitCode(p: number[], bbox: BoundingBox): number {\n  let code = 0;\n\n  if (p[0] < bbox[0]) code |= 1;\n  // left\n  else if (p[0] > bbox[2]) code |= 2; // right\n\n  if (p[1] < bbox[1]) code |= 4;\n  // bottom\n  else if (p[1] > bbox[3]) code |= 8; // top\n\n  return code;\n}\n", "/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect, BoundingBox} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nimport type {NumericArray} from '@math.gl/core';\n\nexport type Polygon = {\n  positions: Readonly<NumericArray>;\n  holeIndices?: Readonly<NumericArray>;\n  edgeTypes?: Readonly<NumericArray>;\n};\n\nexport function cutPolylineByGrid(\n  positions: NumericArray,\n  options?: {\n    size?: number;\n    broken?: boolean;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    startIndex?: number;\n    endIndex?: number;\n  }\n): number[] | number[][] {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options || {};\n  const numPoints = (endIndex - startIndex) / size;\n  let part: number[] = [];\n  const result: number[][] = [part];\n  const a: number[] = getPointAtIndex(positions, 0, size, startIndex);\n  let b: number[];\n  let codeB: number;\n  const cell: BoundingBox = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint: number[] = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nfunction concatInPlace(arr1: number[], arr2: number[]): number[] {\n  for (let i = 0; i < arr2.length; i++) {\n    arr1.push(arr2[i]);\n  }\n  return arr1;\n}\n\nexport function cutPolygonByGrid(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    gridResolution?: number;\n    gridOffset?: [number, number];\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options || {};\n  const result: Polygon[] = [];\n  const queue: {pos: Readonly<NumericArray>; types: number[]; holes: Readonly<NumericArray>}[] = [\n    {\n      pos: positions,\n      types: edgeTypes ? (new Array(positions.length / size).fill(TYPE_BORDER) as number[]) : null,\n      holes: holeIndices || []\n    }\n  ];\n  const bbox: number[][] = [[], []];\n  // @ts-ignore\n  let cell: BoundingBox = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon: Polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(\n  positions: Readonly<NumericArray>,\n  edgeTypes: number[] | undefined,\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  bbox: BoundingBox,\n  edge: number\n): {\n  pos: number[];\n  types?: number[];\n}[] {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow: number[] = [];\n  const resultHigh: number[] = [];\n  const typesLow: number[] = [];\n  const typesHigh: number[] = [];\n  const scratchPoint: number[] = [];\n\n  let p: number[];\n  let side: number;\n  let type: number;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(\n  p: number[],\n  gridResolution: number,\n  gridOffset: [number, number],\n  out: number[]\n): BoundingBox {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out as BoundingBox;\n}\n\nfunction moveToNeighborCell(cell: number[], gridResolution: number, edge: number): void {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(\n  positions: Readonly<NumericArray>,\n  size: number,\n  endIndex: number,\n  out: number[][]\n): number[][] {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n", "import {cutPolylineByGrid, cutPolygonByGrid} from './cut-by-grid';\nimport {getPointAtIndex, push} from './utils';\nimport type {Polygon} from './cut-by-grid';\nimport type {NumericArray} from '@math.gl/core';\n\n// https://en.wikipedia.org/wiki/Web_Mercator_projection\nconst DEFAULT_MAX_LATITUDE = 85.051129;\n\n/** https://user-images.githubusercontent.com/2059298/78465769-938b7a00-76ae-11ea-9b95-1f4c26425ab9.png */\nexport function cutPolylineByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  options?: {\n    size?: number;\n    startIndex?: number;\n    endIndex?: number;\n    normalize?: boolean;\n  }\n): number[][] {\n  const {size = 2, startIndex = 0, endIndex = positions.length, normalize = true} = options || {};\n\n  // Remap longitudes so that each segment takes the shorter path\n  const newPositions = positions.slice(startIndex, endIndex);\n  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);\n\n  const parts = cutPolylineByGrid(newPositions, {\n    size,\n    broken: true,\n    gridResolution: 360,\n    gridOffset: [-180, -180]\n  }) as number[][];\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      shiftLongitudesIntoRange(part, size);\n    }\n  }\n  return parts;\n}\n\n/** https://user-images.githubusercontent.com/2059298/78465770-94241080-76ae-11ea-809a-6a8534dac1d9.png */\nexport function cutPolygonByMercatorBounds(\n  positions: Readonly<NumericArray>,\n  holeIndices: Readonly<NumericArray> | null = null,\n  options?: {\n    size?: number;\n    normalize?: boolean;\n    maxLatitude?: number;\n    edgeTypes?: boolean;\n  }\n): Polygon[] {\n  const {size = 2, normalize = true, edgeTypes = false} = options || {};\n  holeIndices = holeIndices || [];\n  const newPositions: number[] = [];\n  const newHoleIndices: number[] = [];\n  let srcStartIndex = 0;\n  let targetIndex = 0;\n\n  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {\n    // srcStartIndex/srcEndIndex define the ring in the original positions\n    const srcEndIndex = holeIndices[ringIndex] || positions.length;\n    // targetStartIndex/targetIndex define the ring in newPositions\n    const targetStartIndex = targetIndex;\n\n    // In case the ring contains a pole (e.g. Antarctica), we'll have to insert vertices\n    // The insertion point is defined by the vertex closest to the pole\n    // Split the the ring by the insertion point when copying to newPositions\n    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);\n    for (let i = splitIndex; i < srcEndIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n    for (let i = srcStartIndex; i < splitIndex; i++) {\n      newPositions[targetIndex++] = positions[i];\n    }\n\n    // Remap longitudes so that each segment takes the shorter path\n    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);\n\n    // Handle the case when the ring contains a pole\n    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options?.maxLatitude);\n\n    srcStartIndex = srcEndIndex;\n    newHoleIndices[ringIndex] = targetIndex;\n  }\n  newHoleIndices.pop();\n\n  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {\n    size,\n    gridResolution: 360,\n    gridOffset: [-180, -180],\n    edgeTypes\n  });\n\n  if (normalize) {\n    // Each part is guaranteed to be in a single copy of the world\n    // Map longitudes back to [-180, 180]\n    for (const part of parts) {\n      // @ts-expect-error (mutates readonly array) May mutate newPositions, which is created by us\n      shiftLongitudesIntoRange(part.positions, size);\n    }\n  }\n  return parts;\n}\n\n/* Helpers */\n\n// See comments for insertPoleVertices\nfunction findSplitIndex(\n  positions: Readonly<NumericArray>,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): number {\n  let maxLat = -1;\n  let pointIndex = -1;\n  for (let i = startIndex + 1; i < endIndex; i += size) {\n    const lat = Math.abs(positions[i]);\n    if (lat > maxLat) {\n      maxLat = lat;\n      pointIndex = i - 1;\n    }\n  }\n  return pointIndex;\n}\n\n// https://user-images.githubusercontent.com/2059298/78857483-5987e400-79de-11ea-98fc-0631287a8431.png\n//\n// If the polygon contains a pole, to tesselate it correctly, we need to insert the edge\n// of map into the polygon. This requires adding two vertices that represent the pole, by\n// drawing a perpendicular line to the Mercator map edge from a selected vertex on the ring.\n//\n// We select the insertion position carefully so that the inserted line segments do not\n// intersect with the ring itself. This is ensured by findSplitIndex, which returns the\n// vertex closest to the pole.\nfunction insertPoleVertices(\n  positions: number[],\n  size: number,\n  startIndex: number,\n  endIndex: number,\n  maxLatitude: number = DEFAULT_MAX_LATITUDE\n): void {\n  // Check if the ring contains a pole\n  const firstLng = positions[startIndex];\n  const lastLng = positions[endIndex - size];\n  if (Math.abs(firstLng - lastLng) > 180) {\n    // The ring does not make a round trip\n    // Add the nearest pole to the vertices so that the polygon tesselates correctly\n    const p = getPointAtIndex(positions, 0, size, startIndex);\n    // Copy the first vertex to the world of the last vertex\n    p[0] += Math.round((lastLng - firstLng) / 360) * 360;\n    push(positions, p);\n    // Project the copied vertex to the edge of the map\n    p[1] = Math.sign(p[1]) * maxLatitude;\n    push(positions, p);\n    // Project the first vertex to the edge of the map\n    p[0] = firstLng;\n    push(positions, p);\n  }\n}\n\nfunction wrapLongitudesForShortestPath(\n  positions: NumericArray,\n  size: number,\n  startIndex: number,\n  endIndex: number\n): void {\n  let prevLng: number = positions[0];\n  let lng: number;\n  for (let i = startIndex; i < endIndex; i += size) {\n    lng = positions[i];\n    const delta = lng - prevLng;\n    if (delta > 180 || delta < -180) {\n      lng -= Math.round(delta / 360) * 360;\n    }\n    positions[i] = prevLng = lng;\n  }\n}\n\nfunction shiftLongitudesIntoRange(positions: NumericArray, size: number): void {\n  let refLng: number;\n  const pointCount = positions.length / size;\n\n  // Find a longitude that is not on the edge of a world\n  // Which we will use to determine which world copy it is\n  for (let i = 0; i < pointCount; i++) {\n    refLng = positions[i * size];\n    if ((refLng + 180) % 360 !== 0) {\n      break;\n    }\n  }\n\n  const delta = -Math.round(refLng / 360) * 360;\n  if (delta === 0) {\n    return;\n  }\n  for (let i = 0; i < pointCount; i++) {\n    positions[i * size] += delta;\n  }\n}\n", "export {default as Polygon} from './polygon';\n\nexport {\n  getPolygonSignedArea,\n  getPolygonWindingDirection,\n  forEachSegmentInPolygon,\n  modifyPolygonWindingDirection,\n  WINDING\n} from './polygon-utils';\n\nexport {earcut} from './earcut';\n\nexport {clipPolygon, clipPolyline} from './lineclip';\n\nexport {cutPolygonByGrid, cutPolylineByGrid} from './cut-by-grid';\n\nexport {cutPolylineByMercatorBounds, cutPolygonByMercatorBounds} from './cut-by-mercator-bounds';\n\n// DEPRECATED\nexport {default as _Polygon} from './polygon';\n", "import {cutPolylineByGrid, cutPolylineByMercatorBounds} from '@math.gl/polygon';\n\n/** Returns a flat array of path positions\n * Flattens a nested path object\n * Cut the feature if needed (globe projection, wrap longitude, etc.)\n */\nexport function normalizePath(path, size, gridResolution, wrapLongitude) {\n  let flatPath = path;\n  if (Array.isArray(path[0])) {\n    const length = path.length * size;\n    flatPath = new Array(length);\n    for (let i = 0; i < path.length; i++) {\n      for (let j = 0; j < size; j++) {\n        flatPath[i * size + j] = path[i][j] || 0;\n      }\n    }\n  }\n  if (gridResolution) {\n    return cutPolylineByGrid(flatPath, {size, gridResolution});\n  }\n  if (wrapLongitude) {\n    return cutPolylineByMercatorBounds(flatPath, {size});\n  }\n  return flatPath;\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {Tesselator} from '@deck.gl/core';\nimport {normalizePath} from './path';\n\nconst START_CAP = 1;\nconst END_CAP = 2;\nconst INVALID = 4;\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PathTesselator extends Tesselator {\n  constructor(opts) {\n    super({\n      ...opts,\n      attributes: {\n        // Padding covers shaderAttributes for last segment in largest case fp64\n        // additional vertex + hi & low parts, 3 * 6\n        positions: {\n          size: 3,\n          padding: 18,\n          initialize: true,\n          type: opts.fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {size: 1, type: Uint8ClampedArray}\n      }\n    });\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization\n    return () => null;\n  }\n\n  normalizeGeometry(path) {\n    if (this.normalize) {\n      return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);\n    }\n    return path;\n  }\n\n  /* Getters */\n  get(attributeName) {\n    return this.attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  getGeometrySize(path) {\n    if (Array.isArray(path[0])) {\n      let size = 0;\n      for (const subPath of path) {\n        size += this.getGeometrySize(subPath);\n      }\n      return size;\n    }\n    const numPoints = this.getPathLength(path);\n    if (numPoints < 2) {\n      // invalid path\n      return 0;\n    }\n    if (this.isClosed(path)) {\n      // minimum 3 vertices\n      return numPoints < 3 ? 0 : numPoints + 2;\n    }\n    return numPoints;\n  }\n\n  updateGeometryAttributes(path, context) {\n    if (context.geometrySize === 0) {\n      return;\n    }\n    if (path && Array.isArray(path[0])) {\n      for (const subPath of path) {\n        const geometrySize = this.getGeometrySize(subPath);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPath, context);\n        context.vertexStart += geometrySize;\n      }\n    } else {\n      this._updateSegmentTypes(path, context);\n      this._updatePositions(path, context);\n    }\n  }\n\n  _updateSegmentTypes(path, context) {\n    const {segmentTypes} = this.attributes;\n    const isPathClosed = this.isClosed(path);\n    const {vertexStart, geometrySize} = context;\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);\n    if (isPathClosed) {\n      segmentTypes[vertexStart] = INVALID;\n      segmentTypes[vertexStart + geometrySize - 2] = INVALID;\n    } else {\n      segmentTypes[vertexStart] += START_CAP;\n      segmentTypes[vertexStart + geometrySize - 2] += END_CAP;\n    }\n    segmentTypes[vertexStart + geometrySize - 1] = INVALID;\n  }\n\n  _updatePositions(path, context) {\n    const {positions} = this.attributes;\n    if (!positions) {\n      return;\n    }\n    const {vertexStart, geometrySize} = context;\n    const p = new Array(3);\n\n    // positions   --  A0 A1 B0 B1 B2 B3 B0 B1 B2 --\n    // segmentTypes     3  4  4  0  0  0  0  4  4\n    for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n      this.getPointOnPath(path, ptIndex, p);\n      positions[i * 3] = p[0];\n      positions[i * 3 + 1] = p[1];\n      positions[i * 3 + 2] = p[2];\n    }\n  }\n\n  /* Utilities */\n  // Returns the number of points in the path\n  getPathLength(path) {\n    return path.length / this.positionSize;\n  }\n\n  // Returns a point on the path at the specified index\n  getPointOnPath(path, index, target = []) {\n    const {positionSize} = this;\n    if (index * positionSize >= path.length) {\n      // loop\n      index += 1 - path.length / positionSize;\n    }\n    const i = index * positionSize;\n    target[0] = path[i];\n    target[1] = path[i + 1];\n    target[2] = (positionSize === 3 && path[i + 2]) || 0;\n    return target;\n  }\n\n  // Returns true if the first and last points are identical\n  isClosed(path) {\n    if (!this.normalize) {\n      return this.opts.loop;\n    }\n    const {positionSize} = this;\n    const lastPointIndex = path.length - positionSize;\n    return (\n      path[0] === path[lastPointIndex] &&\n      path[1] === path[lastPointIndex + 1] &&\n      (positionSize === 2 || path[2] === path[lastPointIndex + 2])\n    );\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\n\n// calculate line join positions\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  // side of the segment - -1: left, 0: center, 1: right\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n\n  // tangent of the corner\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  // direction of the corner\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  // direction of the segment\n  vec2 dir = isEnd ? dirA : dirB;\n  // direction of the extrusion\n  vec2 perp = isEnd ? perpA : perpB;\n  // length of the segment\n  float L = isEnd ? lenA : lenB;\n\n  // A = angle of the corner\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  // -1: right, 1: left\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n\n  // relative position to the corner:\n  // -1: inside (smaller side of the angle)\n  // 0: center\n  // 1: outside (bigger side of the angle)\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  // trim if inside corner extends further than the line segment\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n\n  // special treatment for start cap and end cap\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n\n  // extend out a triangle to envelope the round cap\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * jointType * 4.0 * flipIfTrue(isStartCap), isJoint);\n  }\n\n  // Generate variables for fragment shader\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\n\n// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition = instanceStartPositions;\n  geometry.worldPositionAlt = instanceEndPositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  if (billboard) {\n    // Extrude in clipspace\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec2 width = project_pixel_size_to_clipspace(widthPixels);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      width\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    // Extrude in commonspace\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    vec2 width = project_pixel_size(widthPixels);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\n/*\n * vPathPosition represents the relative coordinates of the current fragment on the path segment.\n * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.\n * vPathPosition.y - position along the length of the path, between [0, L / width].\n */\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    // if joint is rounded, test distance from the corner\n    if (jointType > 0.0 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    // trim miter\n    if (jointType == 0.0 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry} from '@luma.gl/core';\n\nimport PathTesselator from './path-tesselator';\n\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {type: 'number', min: 0, value: 1}, // stroke width in meters\n  widthMinPixels: {type: 'number', min: 0, value: 0}, //  min stroke width in pixels\n  widthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max stroke width in pixels\n  rounded: false,\n  miterLimit: {type: 'number', min: 0, value: 4},\n  billboard: false,\n  // `loop` or `open`\n  _pathType: null,\n\n  getPath: {type: 'accessor', value: object => object.path},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getWidth: {type: 'accessor', value: 1}\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class PathLayer extends Layer {\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, picking]}); // 'project' module added by default.\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const noAlloc = true;\n    const attributeManager = this.getAttributeManager();\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      positions: {\n        size: 3,\n        // Start filling buffer from 1 vertex in\n        vertexOffset: 1,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPath',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          instanceLeftPositions: {\n            vertexOffset: 0\n          },\n          instanceStartPositions: {\n            vertexOffset: 1\n          },\n          instanceEndPositions: {\n            vertexOffset: 2\n          },\n          instanceRightPositions: {\n            vertexOffset: 3\n          }\n        }\n      },\n      instanceTypes: {\n        size: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateSegmentTypes,\n        noAlloc\n      },\n      instanceStrokeWidths: {\n        size: 1,\n        accessor: 'getWidth',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: 1\n      },\n      instanceColors: {\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        accessor: 'getColor',\n        transition: ATTRIBUTE_TRANSITION,\n        defaultValue: DEFAULT_COLOR\n      },\n      instancePickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value)\n      }\n    });\n    /* eslint-enable max-len */\n\n    this.setState({\n      pathTesselator: new PathTesselator({\n        fp64: this.use64bitPositions()\n      })\n    });\n\n    if (this.props.getDashArray && !this.props.extensions.length) {\n      log.removed('getDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    super.updateState({props, oldProps, changeFlags});\n\n    const attributeManager = this.getAttributeManager();\n\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath));\n\n    if (geometryChanged) {\n      const {pathTesselator} = this.state;\n      const buffers = props.data.attributes || {};\n\n      pathTesselator.updateGeometry({\n        data: props.data,\n        geometryBuffer: buffers.getPath,\n        buffers,\n        normalize: !props._pathType,\n        loop: props._pathType === 'loop',\n        getGeometry: props.getPath,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        dataChanged: changeFlags.dataChanged\n      });\n      this.setState({\n        numInstances: pathTesselator.instanceCount,\n        startIndices: pathTesselator.vertexStarts\n      });\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        attributeManager.invalidateAll();\n      }\n    }\n\n    if (changeFlags.extensionsChanged) {\n      const {gl} = this.context;\n      if (this.state.model) {\n        this.state.model.delete();\n      }\n      this.setState({model: this._getModel(gl)});\n      attributeManager.invalidateAll();\n    }\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    if (data[0] && data[0].__source) {\n      // data is wrapped\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  draw({uniforms}) {\n    const {viewport} = this.context;\n    const {\n      rounded,\n      billboard,\n      miterLimit,\n      widthUnits,\n      widthScale,\n      widthMinPixels,\n      widthMaxPixels\n    } = this.props;\n\n    const widthMultiplier = widthUnits === 'pixels' ? viewport.metersPerPixel : 1;\n\n    this.state.model\n      .setUniforms(\n        Object.assign({}, uniforms, {\n          jointType: Number(rounded),\n          billboard,\n          widthScale: widthScale * widthMultiplier,\n          miterLimit,\n          widthMinPixels,\n          widthMaxPixels\n        })\n      )\n      .draw();\n  }\n\n  _getModel(gl) {\n    /*\n     *       _\n     *        \"-_ 1                   3                       5\n     *     _     \"o---------------------o-------------------_-o\n     *       -   / \"\"--..__              '.             _.-' /\n     *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n     *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n     *       \"o----------------------------\"\"-o'    :     /\n     *      0,2                            4 / '.  :     /\n     *                                      /   '.:     /\n     *                                     /     :'.   /\n     *                                    /     :  ', /\n     *                                   /     :     o\n     */\n\n    // prettier-ignore\n    const SEGMENT_INDICES = [\n      // start corner\n      0, 1, 2,\n      // body\n      1, 4, 2,\n      1, 3, 4,\n      // end corner\n      3, 5, 4\n    ];\n\n    // [0] position on segment - 0: start, 1: end\n    // [1] side of path - -1: left, 0: center (joint), 1: right\n    // prettier-ignore\n    const SEGMENT_POSITIONS = [\n      // bevel start corner\n      0, 0,\n      // start inner corner\n      0, -1,\n      // start outer corner\n      0, 1,\n      // end inner corner\n      1, -1,\n      // end outer corner\n      1, 1,\n      // bevel end corner\n      1, 0\n    ];\n\n    return new Model(\n      gl,\n      Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: {value: new Float32Array(SEGMENT_POSITIONS), size: 2}\n          }\n        }),\n        isInstanced: true\n      })\n    );\n  }\n\n  calculatePositions(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('positions');\n  }\n\n  calculateSegmentTypes(attribute) {\n    const {pathTesselator} = this.state;\n\n    attribute.startIndices = pathTesselator.vertexStarts;\n    attribute.value = pathTesselator.get('segmentTypes');\n  }\n}\n\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;\n", "'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim | 0);\n            triangles.push(ear.i / dim | 0);\n            triangles.push(next.i / dim | 0);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    var p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox; min & max are calculated like this for speed\n    var x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),\n        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),\n        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),\n        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim | 0);\n            triangles.push(p.i / dim | 0);\n            triangles.push(b.i / dim | 0);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    var bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    var bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = 0;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n\n  const positions = [];\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i]\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const simplePolygon of polygon) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    const p = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n    }\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return (polygon.positions || polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n  isValid = vertexValid;\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n  isValid = 1.0;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n    \n#ifdef IS_SIDE_VERTEX\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport main from './solid-polygon-layer-vertex-main.glsl';\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n${main}\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = instancePositions;\n  props.positions64Low = instancePositions64Low;\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n  props.nextPositions = nextPositions;\n  props.nextPositions64Low = nextPositions64Low;\n\n  calculatePosition(props);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid < 0.5) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {Layer, project32, gouraudLighting, picking, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport GL from '@luma.gl/constants';\nimport {Model, Geometry, hasFeatures, FEATURES} from '@luma.gl/core';\n\n// Polygon geometry generation is managed by the polygon tesselator\nimport PolygonTesselator from './polygon-tesselator';\n\nimport vsTop from './solid-polygon-layer-vertex-top.glsl';\nimport vsSide from './solid-polygon-layer-vertex-side.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst defaultProps = {\n  filled: true,\n  // Whether to extrude\n  extruded: false,\n  // Whether to draw a GL.LINES wireframe of the polygon\n  wireframe: false,\n  _normalize: true,\n\n  // elevation multiplier\n  elevationScale: {type: 'number', min: 0, value: 1},\n\n  // Accessor for polygon geometry\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  // Accessor for extrusion height\n  getElevation: {type: 'accessor', value: 1000},\n  // Accessor for colors\n  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // Optional settings for 'lighting' shader module\n  material: true\n};\n\nconst ATTRIBUTE_TRANSITION = {\n  enter: (value, chunk) => {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nexport default class SolidPolygonLayer extends Layer {\n  getShaders(vs) {\n    return super.getShaders({\n      vs,\n      fs,\n      defines: {},\n      modules: [project32, gouraudLighting, picking]\n    });\n  }\n\n  get wrapLongitude() {\n    return false;\n  }\n\n  initializeState() {\n    const {gl, viewport} = this.context;\n    let {coordinateSystem} = this.props;\n    if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {\n      coordinateSystem = COORDINATE_SYSTEM.LNGLAT;\n    }\n\n    this.setState({\n      numInstances: 0,\n      polygonTesselator: new PolygonTesselator({\n        // Lnglat coordinates are usually projected non-linearly, which affects tesselation results\n        // Provide a preproject function if the coordinates are in lnglat\n        preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat,\n        fp64: this.use64bitPositions(),\n        IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      })\n    });\n\n    const attributeManager = this.getAttributeManager();\n    const noAlloc = true;\n\n    attributeManager.remove(['instancePickingColors']);\n\n    /* eslint-disable max-len */\n    attributeManager.add({\n      indices: {size: 1, isIndexed: true, update: this.calculateIndices, noAlloc},\n      positions: {\n        size: 3,\n        type: GL.DOUBLE,\n        fp64: this.use64bitPositions(),\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getPolygon',\n        update: this.calculatePositions,\n        noAlloc,\n        shaderAttributes: {\n          positions: {\n            vertexOffset: 0,\n            divisor: 0\n          },\n          instancePositions: {\n            vertexOffset: 0,\n            divisor: 1\n          },\n          nextPositions: {\n            vertexOffset: 1,\n            divisor: 1\n          }\n        }\n      },\n      vertexValid: {\n        size: 1,\n        divisor: 1,\n        type: GL.UNSIGNED_BYTE,\n        update: this.calculateVertexValid,\n        noAlloc\n      },\n      elevations: {\n        size: 1,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getElevation',\n        shaderAttributes: {\n          elevations: {\n            divisor: 0\n          },\n          instanceElevations: {\n            divisor: 1\n          }\n        }\n      },\n      fillColors: {\n        alias: 'colors',\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getFillColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          fillColors: {\n            divisor: 0\n          },\n          instanceFillColors: {\n            divisor: 1\n          }\n        }\n      },\n      lineColors: {\n        alias: 'colors',\n        size: this.props.colorFormat.length,\n        type: GL.UNSIGNED_BYTE,\n        normalized: true,\n        transition: ATTRIBUTE_TRANSITION,\n        accessor: 'getLineColor',\n        defaultValue: DEFAULT_COLOR,\n        shaderAttributes: {\n          lineColors: {\n            divisor: 0\n          },\n          instanceLineColors: {\n            divisor: 1\n          }\n        }\n      },\n      pickingColors: {\n        size: 3,\n        type: GL.UNSIGNED_BYTE,\n        accessor: (object, {index, target: value}) =>\n          this.encodePickingColor(object && object.__source ? object.__source.index : index, value),\n        shaderAttributes: {\n          pickingColors: {\n            divisor: 0\n          },\n          instancePickingColors: {\n            divisor: 1\n          }\n        }\n      }\n    });\n    /* eslint-enable max-len */\n  }\n\n  getPickingInfo(params) {\n    const info = super.getPickingInfo(params);\n    const {index} = info;\n    const {data} = this.props;\n\n    if (data[0] && data[0].__source) {\n      // data is wrapped\n      info.object = data.find(d => d.__source.index === index);\n    }\n    return info;\n  }\n\n  draw({uniforms}) {\n    const {extruded, filled, wireframe, elevationScale} = this.props;\n    const {topModel, sideModel, polygonTesselator} = this.state;\n\n    const renderUniforms = Object.assign({}, uniforms, {\n      extruded: Boolean(extruded),\n      elevationScale\n    });\n\n    // Note: the order is important\n    if (sideModel) {\n      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n      sideModel.setUniforms(renderUniforms);\n      if (wireframe) {\n        sideModel.setDrawMode(GL.LINE_STRIP);\n        sideModel.setUniforms({isWireframe: true}).draw();\n      }\n      if (filled) {\n        sideModel.setDrawMode(GL.TRIANGLE_FAN);\n        sideModel.setUniforms({isWireframe: false}).draw();\n      }\n    }\n\n    if (topModel) {\n      topModel.setVertexCount(polygonTesselator.vertexCount);\n      topModel.setUniforms(renderUniforms).draw();\n    }\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n\n    this.updateGeometry(updateParams);\n\n    const {props, oldProps, changeFlags} = updateParams;\n    const attributeManager = this.getAttributeManager();\n\n    const regenerateModels =\n      changeFlags.extensionsChanged ||\n      props.filled !== oldProps.filled ||\n      props.extruded !== oldProps.extruded;\n\n    if (regenerateModels) {\n      if (this.state.models) {\n        this.state.models.forEach(model => model.delete());\n      }\n\n      this.setState(this._getModels(this.context.gl));\n      attributeManager.invalidateAll();\n    }\n  }\n\n  updateGeometry({props, oldProps, changeFlags}) {\n    const geometryConfigChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    // When the geometry config  or the data is changed,\n    // tessellator needs to be invoked\n    if (geometryConfigChanged) {\n      const {polygonTesselator} = this.state;\n      const buffers = props.data.attributes || {};\n      polygonTesselator.updateGeometry({\n        data: props.data,\n        normalize: props._normalize,\n        geometryBuffer: buffers.getPolygon,\n        buffers,\n        getGeometry: props.getPolygon,\n        positionFormat: props.positionFormat,\n        wrapLongitude: props.wrapLongitude,\n        // TODO - move the flag out of the viewport\n        resolution: this.context.viewport.resolution,\n        fp64: this.use64bitPositions(),\n        dataChanged: changeFlags.dataChanged\n      });\n\n      this.setState({\n        numInstances: polygonTesselator.instanceCount,\n        startIndices: polygonTesselator.vertexStarts\n      });\n\n      if (!changeFlags.dataChanged) {\n        // Base `layer.updateState` only invalidates all attributes on data change\n        // Cover the rest of the scenarios here\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }\n\n  _getModels(gl) {\n    const {id, filled, extruded} = this.props;\n\n    let topModel;\n    let sideModel;\n\n    if (filled) {\n      const shaders = this.getShaders(vsTop);\n      shaders.defines.NON_INSTANCED_MODEL = 1;\n\n      topModel = new Model(\n        gl,\n        Object.assign({}, shaders, {\n          id: `${id}-top`,\n          drawMode: GL.TRIANGLES,\n          attributes: {\n            vertexPositions: new Float32Array([0, 1])\n          },\n          uniforms: {\n            isWireframe: false,\n            isSideVertex: false\n          },\n          vertexCount: 0,\n          isIndexed: true\n        })\n      );\n    }\n    if (extruded) {\n      sideModel = new Model(\n        gl,\n        Object.assign({}, this.getShaders(vsSide), {\n          id: `${id}-side`,\n          geometry: new Geometry({\n            drawMode: GL.LINES,\n            vertexCount: 4,\n            attributes: {\n              // top right - top left - bootom left - bottom right\n              vertexPositions: {\n                size: 2,\n                value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])\n              }\n            }\n          }),\n          instanceCount: 0,\n          isInstanced: 1\n        })\n      );\n\n      sideModel.userData.excludeAttributes = {indices: true};\n    }\n\n    return {\n      models: [sideModel, topModel].filter(Boolean),\n      topModel,\n      sideModel\n    };\n  }\n\n  calculateIndices(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.indexStarts;\n    attribute.value = polygonTesselator.get('indices');\n  }\n\n  calculatePositions(attribute) {\n    const {polygonTesselator} = this.state;\n    attribute.startIndices = polygonTesselator.vertexStarts;\n    attribute.value = polygonTesselator.get('positions');\n  }\n\n  calculateVertexValid(attribute) {\n    attribute.value = this.state.polygonTesselator.get('vertexValid');\n  }\n}\n\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;\n", "// Assume data array is sorted by <accessor>\n// Replaces the specified range with a new subarray\n// Mutates the data array\n// Returns {startRow, endRow} of the inserted items\nexport function replaceInRange({data, getIndex, dataRange, replace}) {\n  const {startRow = 0, endRow = Infinity} = dataRange;\n  const count = data.length;\n  let replaceStart = count;\n  let replaceEnd = count;\n  for (let i = 0; i < count; i++) {\n    const row = getIndex(data[i]);\n    if (replaceStart > i && row >= startRow) {\n      replaceStart = i;\n    }\n    if (row >= endRow) {\n      replaceEnd = i;\n      break;\n    }\n  }\n  let index = replaceStart;\n  const dataLengthChanged = replaceEnd - replaceStart !== replace.length;\n  // Save the items after replaceEnd before we overwrite data\n  const endChunk = dataLengthChanged && data.slice(replaceEnd);\n  // Insert new items\n  for (let i = 0; i < replace.length; i++) {\n    data[index++] = replace[i];\n  }\n  if (dataLengthChanged) {\n    // Append items after replaceEnd\n    for (let i = 0; i < endChunk.length; i++) {\n      data[index++] = endChunk[i];\n    }\n    // Trim additional items\n    data.length = index;\n  }\n\n  return {\n    startRow: replaceStart,\n    endRow: replaceStart + replace.length\n  };\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable, log} from '@deck.gl/core';\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport PathLayer from '../path-layer/path-layer';\nimport * as Polygon from '../solid-polygon-layer/polygon';\nimport {replaceInRange} from '../utils';\n\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\n\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  elevationScale: 1,\n  wireframe: false,\n  _normalize: true,\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n\n  getPolygon: {type: 'accessor', value: f => f.polygon},\n  // Polygon fill color\n  getFillColor: {type: 'accessor', value: defaultFillColor},\n  // Point, line and polygon outline color\n  getLineColor: {type: 'accessor', value: defaultLineColor},\n  // Line and polygon outline accessors\n  getLineWidth: {type: 'accessor', value: 1},\n  // Polygon extrusion accessor\n  getElevation: {type: 'accessor', value: 1000},\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\nexport default class PolygonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      paths: []\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({oldProps, props, changeFlags}) {\n    const geometryChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));\n\n    if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {\n      const paths = this.state.paths.slice();\n      const pathsDiff = changeFlags.dataChanged.map(dataRange =>\n        replaceInRange({\n          data: paths,\n          getIndex: p => p.__source.index,\n          dataRange,\n          replace: this._getPaths(dataRange)\n        })\n      );\n      this.setState({paths, pathsDiff});\n    } else if (geometryChanged) {\n      this.setState({\n        paths: this._getPaths(),\n        pathsDiff: null\n      });\n    }\n  }\n\n  _getPaths(dataRange = {}) {\n    const {data, getPolygon, positionFormat, _normalize} = this.props;\n    const paths = [];\n    const positionSize = positionFormat === 'XY' ? 2 : 3;\n    const {startRow, endRow} = dataRange;\n\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      let polygon = getPolygon(object, objectInfo);\n      if (_normalize) {\n        polygon = Polygon.normalize(polygon, positionSize);\n      }\n      const {holeIndices} = polygon;\n      const positions = polygon.positions || polygon;\n\n      if (holeIndices) {\n        // split the positions array into `holeIndices.length + 1` rings\n        // holeIndices[-1] falls back to 0\n        // holeIndices[holeIndices.length] falls back to positions.length\n        for (let i = 0; i <= holeIndices.length; i++) {\n          const path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);\n          paths.push(this.getSubLayerRow({path}, object, objectInfo.index));\n        }\n      } else {\n        paths.push(this.getSubLayerRow({path: positions}, object, objectInfo.index));\n      }\n    }\n    return paths;\n  }\n\n  /* eslint-disable complexity */\n  renderLayers() {\n    // Layer composition props\n    const {\n      data,\n      _dataDiff,\n      stroked,\n      filled,\n      extruded,\n      wireframe,\n      _normalize,\n      elevationScale,\n      transitions,\n      positionFormat\n    } = this.props;\n\n    // Rendering props underlying layer\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      lineDashJustified\n    } = this.props;\n\n    // Accessor props for underlying layers\n    const {\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      getPolygon,\n      updateTriggers,\n      material\n    } = this.props;\n\n    const {paths, pathsDiff} = this.state;\n\n    const FillLayer = this.getSubLayerClass('fill', SolidPolygonLayer);\n    const StrokeLayer = this.getSubLayerClass('stroke', PathLayer);\n\n    // Filled Polygon Layer\n    const polygonLayer =\n      this.shouldRenderSubLayer('fill', paths) &&\n      new FillLayer(\n        {\n          _dataDiff,\n          extruded,\n          elevationScale,\n\n          filled,\n          wireframe,\n          _normalize,\n\n          getElevation,\n          getFillColor,\n          getLineColor,\n\n          material,\n          transitions\n        },\n        this.getSubLayerProps({\n          id: 'fill',\n          updateTriggers: {\n            getPolygon: updateTriggers.getPolygon,\n            getElevation: updateTriggers.getElevation,\n            getFillColor: updateTriggers.getFillColor,\n            getLineColor: updateTriggers.getLineColor\n          }\n        }),\n        {\n          data,\n          positionFormat,\n          getPolygon\n        }\n      );\n\n    // Polygon line layer\n    const polygonLineLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer('stroke', paths) &&\n      new StrokeLayer(\n        {\n          _dataDiff: pathsDiff && (() => pathsDiff),\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          rounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          // Already normalized\n          _pathType: 'loop',\n\n          transitions: transitions && {\n            getWidth: transitions.getLineWidth,\n            getColor: transitions.getLineColor,\n            getPath: transitions.getPolygon\n          },\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray)\n        },\n        this.getSubLayerProps({\n          id: 'stroke',\n          updateTriggers: {\n            getWidth: updateTriggers.getLineWidth,\n            getColor: updateTriggers.getLineColor,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        {\n          data: paths,\n          positionFormat,\n          getPath: x => x.path\n        }\n      );\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonLayer,\n      polygonLineLayer,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonLayer\n    ];\n  }\n  /* eslint-enable complexity */\n}\n\nPolygonLayer.layerName = 'PolygonLayer';\nPolygonLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {log} from '@deck.gl/core';\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {startRow = 0, endRow = features.length} = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n\n    log.assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n\n    const {geometry} = feature;\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {geometries} = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {type, coordinates} = geometry;\n  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    // Avoid hard failure if some features are malformed\n    log.warn(`${type} coordinates are malformed`)();\n    return;\n  }\n\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Point', coordinates: point}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Polygon', coordinates: polygon}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(\n            wrapFeature(\n              {\n                geometry: {type: 'LineString', coordinates: path}\n              },\n              sourceFeature,\n              sourceFeatureIndex\n            )\n          );\n        });\n      });\n      break;\n    default:\n  }\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nexport function validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n\n  log.assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, log} from '@deck.gl/core';\nimport ScatterplotLayer from '../scatterplot-layer/scatterplot-layer';\nimport PathLayer from '../path-layer/path-layer';\n// Use primitive layer to avoid \"Composite Composite\" layers for now\nimport SolidPolygonLayer from '../solid-polygon-layer/solid-polygon-layer';\nimport {replaceInRange} from '../utils';\n\nimport {getGeojsonFeatures, separateGeojsonFeatures} from './geojson';\n\nconst defaultLineColor = [0, 0, 0, 255];\nconst defaultFillColor = [0, 0, 0, 255];\n\nconst defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n\n  elevationScale: 1,\n\n  pointRadiusUnits: 'meters',\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 0, //  min point radius in pixels\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels\n\n  // Line and polygon outline color\n  getLineColor: {type: 'accessor', value: defaultLineColor},\n  // Point and polygon fill color\n  getFillColor: {type: 'accessor', value: defaultFillColor},\n  // Point radius\n  getRadius: {type: 'accessor', value: 1},\n  // Line and polygon outline accessors\n  getLineWidth: {type: 'accessor', value: 1},\n  // Polygon extrusion accessor\n  getElevation: {type: 'accessor', value: 1000},\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\nfunction getCoordinates(f) {\n  return f.geometry.coordinates;\n}\n\nexport default class GeoJsonLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      features: {}\n    };\n\n    if (this.props.getLineDashArray) {\n      log.removed('getLineDashArray', 'PathStyleExtension')();\n    }\n  }\n\n  updateState({props, changeFlags}) {\n    if (!changeFlags.dataChanged) {\n      return;\n    }\n    const features = getGeojsonFeatures(props.data);\n    const wrapFeature = this.getSubLayerRow.bind(this);\n\n    if (Array.isArray(changeFlags.dataChanged)) {\n      const oldFeatures = this.state.features;\n      const newFeatures = {};\n      const featuresDiff = {};\n      for (const key in oldFeatures) {\n        newFeatures[key] = oldFeatures[key].slice();\n        featuresDiff[key] = [];\n      }\n\n      for (const dataRange of changeFlags.dataChanged) {\n        const partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);\n        for (const key in oldFeatures) {\n          featuresDiff[key].push(\n            replaceInRange({\n              data: newFeatures[key],\n              getIndex: f => f.__source.index,\n              dataRange,\n              replace: partialFeatures[key]\n            })\n          );\n        }\n      }\n      this.setState({features: newFeatures, featuresDiff});\n    } else {\n      this.setState({\n        features: separateGeojsonFeatures(features, wrapFeature),\n        featuresDiff: {}\n      });\n    }\n  }\n\n  /* eslint-disable complexity */\n  renderLayers() {\n    const {features, featuresDiff} = this.state;\n    const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = features;\n\n    // Layer composition props\n    const {stroked, filled, extruded, wireframe, material, transitions} = this.props;\n\n    // Rendering props underlying layer\n    const {\n      lineWidthUnits,\n      lineWidthScale,\n      lineWidthMinPixels,\n      lineWidthMaxPixels,\n      lineJointRounded,\n      lineMiterLimit,\n      pointRadiusUnits,\n      pointRadiusScale,\n      pointRadiusMinPixels,\n      pointRadiusMaxPixels,\n      elevationScale,\n      lineDashJustified\n    } = this.props;\n\n    // Accessor props for underlying layers\n    const {\n      getLineColor,\n      getFillColor,\n      getRadius,\n      getLineWidth,\n      getLineDashArray,\n      getElevation,\n      updateTriggers\n    } = this.props;\n\n    const PolygonFillLayer = this.getSubLayerClass('polygons-fill', SolidPolygonLayer);\n    const PolygonStrokeLayer = this.getSubLayerClass('polygons-stroke', PathLayer);\n    const LineStringsLayer = this.getSubLayerClass('line-strings', PathLayer);\n    const PointsLayer = this.getSubLayerClass('points', ScatterplotLayer);\n\n    // Filled Polygon Layer\n    const polygonFillLayer =\n      this.shouldRenderSubLayer('polygons-fill', polygonFeatures) &&\n      new PolygonFillLayer(\n        {\n          _dataDiff: featuresDiff.polygonFeatures && (() => featuresDiff.polygonFeatures),\n\n          extruded,\n          elevationScale,\n          filled,\n          wireframe,\n          material,\n          getElevation: this.getSubLayerAccessor(getElevation),\n          getFillColor: this.getSubLayerAccessor(getFillColor),\n          getLineColor: this.getSubLayerAccessor(getLineColor),\n\n          transitions: transitions && {\n            getPolygon: transitions.geometry,\n            getElevation: transitions.getElevation,\n            getFillColor: transitions.getFillColor,\n            getLineColor: transitions.getLineColor\n          }\n        },\n        this.getSubLayerProps({\n          id: 'polygons-fill',\n          updateTriggers: {\n            getElevation: updateTriggers.getElevation,\n            getFillColor: updateTriggers.getFillColor,\n            getLineColor: updateTriggers.getLineColor\n          }\n        }),\n        {\n          data: polygonFeatures,\n          getPolygon: getCoordinates\n        }\n      );\n\n    const polygonLineLayer =\n      !extruded &&\n      stroked &&\n      this.shouldRenderSubLayer('polygons-stroke', polygonOutlineFeatures) &&\n      new PolygonStrokeLayer(\n        {\n          _dataDiff:\n            featuresDiff.polygonOutlineFeatures && (() => featuresDiff.polygonOutlineFeatures),\n\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          rounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray),\n\n          transitions: transitions && {\n            getPath: transitions.geometry,\n            getColor: transitions.getLineColor,\n            getWidth: transitions.getLineWidth\n          }\n        },\n        this.getSubLayerProps({\n          id: 'polygons-stroke',\n          updateTriggers: {\n            getColor: updateTriggers.getLineColor,\n            getWidth: updateTriggers.getLineWidth,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        {\n          data: polygonOutlineFeatures,\n          getPath: getCoordinates\n        }\n      );\n\n    const pathLayer =\n      this.shouldRenderSubLayer('linestrings', lineFeatures) &&\n      new LineStringsLayer(\n        {\n          _dataDiff: featuresDiff.lineFeatures && (() => featuresDiff.lineFeatures),\n\n          widthUnits: lineWidthUnits,\n          widthScale: lineWidthScale,\n          widthMinPixels: lineWidthMinPixels,\n          widthMaxPixels: lineWidthMaxPixels,\n          rounded: lineJointRounded,\n          miterLimit: lineMiterLimit,\n          dashJustified: lineDashJustified,\n\n          getColor: this.getSubLayerAccessor(getLineColor),\n          getWidth: this.getSubLayerAccessor(getLineWidth),\n          getDashArray: this.getSubLayerAccessor(getLineDashArray),\n\n          transitions: transitions && {\n            getPath: transitions.geometry,\n            getColor: transitions.getLineColor,\n            getWidth: transitions.getLineWidth\n          }\n        },\n        this.getSubLayerProps({\n          id: 'line-strings',\n          updateTriggers: {\n            getColor: updateTriggers.getLineColor,\n            getWidth: updateTriggers.getLineWidth,\n            getDashArray: updateTriggers.getLineDashArray\n          }\n        }),\n        {\n          data: lineFeatures,\n          getPath: getCoordinates\n        }\n      );\n\n    const pointLayer =\n      this.shouldRenderSubLayer('points', pointFeatures) &&\n      new PointsLayer(\n        {\n          _dataDiff: featuresDiff.pointFeatures && (() => featuresDiff.pointFeatures),\n\n          stroked,\n          filled,\n          radiusUnits: pointRadiusUnits,\n          radiusScale: pointRadiusScale,\n          radiusMinPixels: pointRadiusMinPixels,\n          radiusMaxPixels: pointRadiusMaxPixels,\n          lineWidthUnits,\n          lineWidthScale,\n          lineWidthMinPixels,\n          lineWidthMaxPixels,\n\n          getFillColor: this.getSubLayerAccessor(getFillColor),\n          getLineColor: this.getSubLayerAccessor(getLineColor),\n          getRadius: this.getSubLayerAccessor(getRadius),\n          getLineWidth: this.getSubLayerAccessor(getLineWidth),\n\n          transitions: transitions && {\n            getPosition: transitions.geometry,\n            getFillColor: transitions.getFillColor,\n            getLineColor: transitions.getLineColor,\n            getRadius: transitions.getRadius,\n            getLineWidth: transitions.getLineWidth\n          }\n        },\n        this.getSubLayerProps({\n          id: 'points',\n          updateTriggers: {\n            getFillColor: updateTriggers.getFillColor,\n            getLineColor: updateTriggers.getLineColor,\n            getRadius: updateTriggers.getRadius,\n            getLineWidth: updateTriggers.getLineWidth\n          }\n        }),\n        {\n          data: pointFeatures,\n          getPosition: getCoordinates,\n          highlightedObjectIndex: this._getHighlightedIndex(pointFeatures)\n        }\n      );\n\n    return [\n      // If not extruded: flat fill layer is drawn below outlines\n      !extruded && polygonFillLayer,\n      polygonLineLayer,\n      pathLayer,\n      pointLayer,\n      // If extruded: draw fill layer last for correct blending behavior\n      extruded && polygonFillLayer\n    ];\n  }\n  /* eslint-enable complexity */\n\n  _getHighlightedIndex(data) {\n    const {highlightedObjectIndex} = this.props;\n    return Number.isFinite(highlightedObjectIndex)\n      ? data.findIndex(d => d.__source.index === highlightedObjectIndex)\n      : null;\n  }\n}\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float buffer;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform bool shouldDrawBackground;\nuniform vec3 backgroundColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n\n    // if enable sdf (signed distance fields)\n    if (sdf) {\n      alpha = smoothstep(buffer - vGamma, buffer + vGamma, alpha);\n    }\n\n    // Take the global opacity and the alpha from vColor into account for the alpha component\n    float a = alpha * vColor.a;\n    \n    if (a < alphaCutoff) {\n      // We are now in the background, let's decide what to draw\n      if (shouldDrawBackground) {\n        // draw background color and return if not picking\n        gl_FragColor = vec4(backgroundColor, vColor.a);\n        return;\n      } else {\n        // no background and no picking\n        discard;\n      }\n    }\n\n    if (shouldDrawBackground) {\n      gl_FragColor = vec4(mix(backgroundColor, vColor.rgb, alpha), vColor.a * opacity);\n    } else {\n      gl_FragColor = vec4(vColor.rgb, a * opacity);\n    }\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport fs from './multi-icon-layer-fragment.glsl';\n\n// TODO expose as layer properties\nconst DEFAULT_GAMMA = 0.2;\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\nconst defaultProps = {\n  backgroundColor: {type: 'color', value: null, optional: true},\n  getIconOffsets: {type: 'accessor', value: x => x.offsets}\n};\n\nexport default class MultiIconLayer extends IconLayer {\n  getShaders() {\n    return Object.assign({}, super.getShaders(), {\n      inject: {\n        'vs:#decl': `\n  uniform float gamma;\n  varying float vGamma;\n`,\n        'vs:#main-end': `\n  vGamma = gamma / (sizeScale * iconSize.y);\n`\n      },\n      fs\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    const {oldProps, props} = updateParams;\n\n    if (props.backgroundColor !== oldProps.backgroundColor) {\n      const backgroundColor = Array.isArray(props.backgroundColor)\n        ? props.backgroundColor.map(c => c / 255.0).slice(0, 3)\n        : null;\n      this.setState({backgroundColor});\n    }\n  }\n\n  draw({uniforms}) {\n    const {sdf} = this.props;\n    const {backgroundColor} = this.state;\n    const shouldDrawBackground = Array.isArray(backgroundColor);\n\n    super.draw({\n      uniforms: Object.assign({}, uniforms, {\n        // Refer the following doc about gamma and buffer\n        // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n        buffer: DEFAULT_BUFFER,\n        gamma: DEFAULT_GAMMA,\n        sdf: Boolean(sdf),\n        backgroundColor: backgroundColor || [0, 0, 0],\n        shouldDrawBackground\n      })\n    });\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\n\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;\n", "'use strict';\n\nmodule.exports = TinySDF;\nmodule.exports.default = TinySDF;\n\nvar INF = 1e20;\n\nfunction TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {\n    this.fontSize = fontSize || 24;\n    this.buffer = buffer === undefined ? 3 : buffer;\n    this.cutoff = cutoff || 0.25;\n    this.fontFamily = fontFamily || 'sans-serif';\n    this.fontWeight = fontWeight || 'normal';\n    this.radius = radius || 8;\n\n    // For backwards compatibility, we honor the implicit contract that the\n    // size of the returned bitmap will be fontSize + buffer * 2\n    var size = this.size = this.fontSize + this.buffer * 2;\n    // Glyphs may be slightly larger than their fontSize. The canvas already\n    // has buffer space, but create extra buffer space in the output grid for the\n    // \"halo\" to extend into (if metric extraction is enabled)\n    var gridSize = size + this.buffer * 2;\n\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = this.canvas.height = size;\n\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;\n\n    this.ctx.textAlign = 'left'; // Necessary so that RTL text doesn't have different alignment\n    this.ctx.fillStyle = 'black';\n\n    // temporary arrays for the distance transform\n    this.gridOuter = new Float64Array(gridSize * gridSize);\n    this.gridInner = new Float64Array(gridSize * gridSize);\n    this.f = new Float64Array(gridSize);\n    this.z = new Float64Array(gridSize + 1);\n    this.v = new Uint16Array(gridSize);\n\n    this.useMetrics = this.ctx.measureText('A').actualBoundingBoxLeft !== undefined;\n\n    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852\n    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));\n}\n\nfunction prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {\n    // Initialize grids outside the glyph range to alpha 0\n    gridOuter.fill(INF, 0, width * height);\n    gridInner.fill(0, 0, width * height);\n\n    var offset = (width - glyphWidth) / 2; // This is zero if we're not extracting metrics\n\n    for (var y = 0; y < glyphHeight; y++) {\n        for (var x = 0; x < glyphWidth; x++) {\n            var j = (y + offset) * width + x + offset;\n            var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255; // alpha value\n            if (a === 1) {\n                gridOuter[j] = 0;\n                gridInner[j] = INF;\n            } else if (a === 0) {\n                gridOuter[j] = INF;\n                gridInner[j] = 0;\n            } else {\n                var b = Math.max(0, 0.5 - a);\n                var c = Math.max(0, a - 0.5);\n                gridOuter[j] = b * b;\n                gridInner[j] = c * c;\n            }\n        }\n    }\n}\n\nfunction extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {\n    for (var i = 0; i < width * height; i++) {\n        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);\n        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));\n    }\n}\n\nTinySDF.prototype._draw = function (char, getMetrics) {\n    var textMetrics = this.ctx.measureText(char);\n    // Older browsers only expose the glyph width\n    // This is enough for basic layout with all glyphs using the same fixed size\n    var advance = textMetrics.width;\n\n    var doubleBuffer = 2 * this.buffer;\n    var width, glyphWidth, height, glyphHeight, top;\n\n    var imgTop, imgLeft, baselinePosition;\n    // If the browser supports bounding box metrics, we can generate a smaller\n    // SDF. This is a significant performance win.\n    if (getMetrics && this.useMetrics) {\n        // The integer/pixel part of the top alignment is encoded in metrics.top\n        // The remainder is implicitly encoded in the rasterization\n        top = Math.floor(textMetrics.actualBoundingBoxAscent);\n        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);\n        imgTop = this.buffer;\n        imgLeft = this.buffer;\n\n        // If the glyph overflows the canvas size, it will be clipped at the\n        // bottom/right\n        glyphWidth = Math.min(this.size,\n            Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft));\n        glyphHeight = Math.min(this.size - imgTop,\n            Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent));\n\n        width = glyphWidth + doubleBuffer;\n        height = glyphHeight + doubleBuffer;\n        this.ctx.textBaseline = 'alphabetic';\n    } else {\n        width = glyphWidth = this.size;\n        height = glyphHeight = this.size;\n        // 19 points is an approximation of the \"cap height\" ascent from alphabetic\n        // baseline (even though actual drawing is from middle baseline, we can\n        // use the approximation because every glyph fills the em box)\n        top = 19 * this.fontSize / 24;\n        imgTop = imgLeft = 0;\n        baselinePosition = this.middle;\n        this.ctx.textBaseline = 'middle';\n    }\n\n    var imgData;\n    if (glyphWidth && glyphHeight) {\n        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);\n        this.ctx.fillText(char, this.buffer, baselinePosition);\n        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);\n    }\n\n    var alphaChannel = new Uint8ClampedArray(width * height);\n\n    prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);\n\n    edt(this.gridOuter, width, height, this.f, this.v, this.z);\n    edt(this.gridInner, width, height, this.f, this.v, this.z);\n\n    extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);\n\n    return {\n        data: alphaChannel,\n        metrics: {\n            width: glyphWidth,\n            height: glyphHeight,\n            sdfWidth: width,\n            sdfHeight: height,\n            top: top,\n            left: 0,\n            advance: advance\n        }\n    };\n};\n\nTinySDF.prototype.draw = function (char) {\n    return this._draw(char, false).data;\n};\n\nTinySDF.prototype.drawWithMetrics = function (char) {\n    return this._draw(char, true);\n};\n\n// 2D Euclidean squared distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/papers/dt-final.pdf\nfunction edt(data, width, height, f, v, z) {\n    for (var x = 0; x < width; x++) edt1d(data, x, width, height, f, v, z);\n    for (var y = 0; y < height; y++) edt1d(data, y * width, 1, width, f, v, z);\n}\n\n// 1D squared distance transform\nfunction edt1d(grid, offset, stride, length, f, v, z) {\n    var q, k, s, r;\n    v[0] = 0;\n    z[0] = -INF;\n    z[1] = INF;\n\n    for (q = 0; q < length; q++) f[q] = grid[offset + q * stride];\n\n    for (q = 1, k = 0, s = 0; q < length; q++) {\n        do {\n            r = v[k];\n            s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;\n        } while (s <= z[k] && --k > -1);\n\n        k++;\n        v[k] = q;\n        z[k] = s;\n        z[k + 1] = INF;\n    }\n\n    for (q = 0, k = 0; q < length; q++) {\n        while (z[k + 1] < q) k++;\n        r = v[k];\n        grid[offset + q * stride] = f[r] + (q - r) * (q - r);\n    }\n}\n", "// TODO merge with icon-layer/icon-manager\nimport {log} from '@deck.gl/core';\n\nconst MISSING_CHAR_WIDTH = 32;\n\nexport function nextPowOfTwo(number) {\n  return Math.pow(2, Math.ceil(Math.log2(number)));\n}\n\n/**\n * Generate character mapping table or update from an existing mapping table\n * @param characterSet {Array|Set} new characters\n * @param getFontWidth {Function} function to get width of each character\n * @param fontHeight {Number} height of font\n * @param buffer {Number} buffer surround each character\n * @param maxCanvasWidth {Number} max width of font atlas\n * @param mapping {Object} old mapping table\n * @param xOffset {Number} x position of last character in old mapping table\n * @param yOffset {Number} y position of last character in old mapping table\n * @returns {{\n *   mapping: Object,\n *   xOffset: Number, x position of last character\n *   yOffset: Number, y position of last character in old mapping table\n *   canvasHeight: Number, height of the font atlas canvas, power of 2\n *  }}\n */\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0\n}) {\n  let row = 0;\n  // continue from x position of last character in the old mapping\n  let x = xOffset;\n\n  let i = 0;\n  for (const char of characterSet) {\n    if (!mapping[char]) {\n      // measure texts\n      // TODO - use Advanced text metrics when they are adopted:\n      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics\n      const width = getFontWidth(char, i++);\n\n      if (x + width + buffer * 2 > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x: x + buffer,\n        y: yOffset + row * (fontHeight + buffer * 2) + buffer,\n        width,\n        height: fontHeight\n      };\n      x += width + buffer * 2;\n    }\n  }\n\n  const rowHeight = fontHeight + buffer * 2;\n\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\n\nfunction getTextWidth(text, mapping) {\n  let width = 0;\n  for (let i = 0; i < text.length; i++) {\n    const character = text[i];\n    let frameWidth = null;\n    const frame = mapping && mapping[character];\n    if (frame) {\n      frameWidth = frame.width;\n    }\n\n    width += frameWidth;\n  }\n\n  return width;\n}\n\nfunction breakAll(text, maxWidth, iconMapping) {\n  const rows = [];\n  let rowStartCharIndex = 0;\n  let rowOffsetLeft = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    // 2. figure out where to break lines\n    const textWidth = getTextWidth(text[i], iconMapping);\n    if (rowOffsetLeft + textWidth > maxWidth) {\n      if (rowStartCharIndex < i) {\n        rows.push(text.substring(rowStartCharIndex, i));\n      }\n      rowStartCharIndex = i;\n      rowOffsetLeft = 0;\n    }\n    rowOffsetLeft += textWidth;\n  }\n\n  // last row\n  if (rowStartCharIndex < text.length) {\n    rows.push(text.substring(rowStartCharIndex));\n  }\n\n  return {\n    rows,\n    lastRowStartCharIndex: rowStartCharIndex,\n    lastRowOffsetLeft: rowOffsetLeft\n  };\n}\n\n/* eslint-disable max-statements, complexity, max-depth */\nfunction breakWord(text, maxWidth, iconMapping) {\n  let rows = [];\n  let rowStartCharIndex = 0;\n  let groupStartCharIndex = 0;\n  let rowOffsetLeft = 0;\n  let group = null;\n\n  for (let i = 0; i < text.length; i++) {\n    // 1. break text into word groups\n    //  - if current char is white space\n    //  - else if next char is white space\n    //  - else if reach last char\n    if (text[i] === ' ') {\n      group = text[i];\n      groupStartCharIndex = i + 1;\n    } else if ((i + 1 < text.length && text[i + 1] === ' ') || i + 1 === text.length) {\n      group = text.substring(groupStartCharIndex, i + 1);\n      groupStartCharIndex = i + 1;\n    } else {\n      group = null;\n    }\n\n    if (group) {\n      // 2. break text into next row at maxWidth\n      let groupWidth = getTextWidth(group, iconMapping);\n      if (rowOffsetLeft + groupWidth > maxWidth) {\n        const lastGroupStartIndex = groupStartCharIndex - group.length;\n        if (rowStartCharIndex < lastGroupStartIndex) {\n          rows.push(text.substring(rowStartCharIndex, lastGroupStartIndex));\n          rowStartCharIndex = lastGroupStartIndex;\n          rowOffsetLeft = 0;\n        }\n\n        // if a single text group is bigger than maxWidth, then `break-all`\n        if (groupWidth > maxWidth) {\n          const subGroups = breakAll(group, maxWidth, iconMapping);\n          if (subGroups.rows.length > 1) {\n            // add all the sub rows to results except last row\n            rows = rows.concat(subGroups.rows.slice(0, subGroups.rows.length - 1));\n          }\n          // move reference to last row\n          rowStartCharIndex = rowStartCharIndex + subGroups.lastRowStartCharIndex;\n          groupWidth = subGroups.lastRowOffsetLeft;\n        }\n      }\n      rowOffsetLeft += groupWidth;\n    }\n  }\n\n  // last row\n  if (rowStartCharIndex < text.length) {\n    rows.push(text.substring(rowStartCharIndex));\n  }\n\n  return {\n    rows,\n    lastRowStartCharIndex: rowStartCharIndex,\n    lastRowOffsetLeft: rowOffsetLeft\n  };\n}\n/* eslint-enable max-statements, complexity, max-depth */\n\nexport function autoWrapping(text, wordBreak, maxWidth, iconMapping) {\n  if (wordBreak === 'break-all') {\n    return breakAll(text, maxWidth, iconMapping);\n  }\n  return breakWord(text, maxWidth, iconMapping);\n}\n\nfunction transformRow(row, iconMapping) {\n  let x = 0;\n  let rowHeight = 0;\n\n  const leftOffsets = new Array(row.length);\n  for (let i = 0; i < row.length; i++) {\n    const character = row[i];\n    const frame = iconMapping[character];\n    if (frame) {\n      if (!rowHeight) {\n        // frame.height should be a constant\n        rowHeight = frame.height;\n      }\n      leftOffsets[i] = x + frame.width / 2;\n      x += frame.width;\n    } else {\n      log.warn(`Missing character: ${character}`)();\n      leftOffsets[i] = x;\n      x += MISSING_CHAR_WIDTH;\n    }\n  }\n\n  return {\n    leftOffsets,\n    rowWidth: x,\n    rowHeight\n  };\n}\n\n/**\n * Transform a text paragraph to an array of characters, each character contains\n * @param paragraph: {String}\n * @param iconMapping {Object} character mapping table for retrieving a character from font atlas\n * @param lineHeight {Number} css line-height\n * @param wordBreak {String} css word-break option\n * @param maxWidth {number} css max-width\n * @param transformedData {Array} output transformed data array, each datum contains\n *   - text: character\n *   - index: character index in the paragraph\n *   - x: x offset in the row,\n *   - y: y offset in the paragraph\n *   - size: [width, height] size of the paragraph\n *   - rowSize: [rowWidth, rowHeight] size of the row\n *   - len: length of the paragraph\n */\n/* eslint-disable max-params, max-depth, complexity */\nexport function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {\n  const result = new Array(paragraph.length);\n  const autoWrappingEnabled =\n    (wordBreak === 'break-word' || wordBreak === 'break-all') && isFinite(maxWidth) && maxWidth > 0;\n\n  // maxWidth and height of the paragraph\n  const size = [0, 0];\n  let rowOffsetTop = 0;\n  let lineStartIndex = 0;\n\n  for (let i = 0; i <= paragraph.length; i++) {\n    const char = paragraph[i];\n    let line;\n    if (char === '\\n' || char === undefined) {\n      line = paragraph.slice(lineStartIndex, i);\n    }\n\n    if (line) {\n      const rows = autoWrappingEnabled\n        ? autoWrapping(line, wordBreak, maxWidth, iconMapping).rows\n        : [line];\n\n      for (const row of rows) {\n        const {rowWidth, rowHeight, leftOffsets} = transformRow(row, iconMapping, lineHeight);\n\n        for (const x of leftOffsets) {\n          result[lineStartIndex++] = {\n            x,\n            y: rowOffsetTop + rowHeight / 2,\n            rowWidth\n          };\n        }\n\n        rowOffsetTop = rowOffsetTop + rowHeight * lineHeight;\n        size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowWidth);\n      }\n    }\n\n    if (char === '\\n') {\n      // Make sure result.length matches paragraph.length\n      result[lineStartIndex++] = {x: 0, y: 0, rowWidth: 0};\n    }\n  }\n\n  // last row\n  size[1] = rowOffsetTop;\n  return {characters: result, size};\n}\n/* eslint-enable max-depth, complexity */\n\nexport function getTextFromBuffer({value, length, stride, offset, startIndices}) {\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementStride = stride ? stride / bytesPerElement : 1;\n  const elementOffset = offset ? offset / bytesPerElement : 0;\n  const characterCount =\n    startIndices[length] ||\n    Math.floor((value.length - elementOffset - bytesPerElement) / elementStride) + 1;\n\n  const texts = new Array(length);\n\n  let codes = value;\n  if (elementStride > 1 || elementOffset > 0) {\n    codes = new value.constructor(characterCount);\n    for (let i = 0; i < characterCount; i++) {\n      codes[i] = value[i * elementStride + elementOffset];\n    }\n  }\n\n  for (let index = 0; index < length; index++) {\n    const startIndex = startIndices[index];\n    const endIndex = startIndices[index + 1] || characterCount;\n    texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));\n  }\n\n  return {texts, characterCount};\n}\n", "/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  constructor(limit = 5) {\n    this.limit = limit;\n\n    this.clear();\n  }\n\n  clear() {\n    this._cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this._order = [];\n  }\n\n  get(key) {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n    if (value) {\n      this._deleteCache(key);\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteCache(key) {\n    delete this._cache[key];\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.findIndex(o => o === key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n}\n", "/* global document */\n\nimport {Texture2D} from '@luma.gl/core';\nimport TinySDF from '@mapbox/tiny-sdf';\n\nimport {buildMapping} from './utils';\nimport LRUCache from './lru-cache';\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nexport const DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport const DEFAULT_FONT_FAMILY = 'Monaco, monospace';\nexport const DEFAULT_FONT_WEIGHT = 'normal';\nexport const DEFAULT_FONT_SIZE = 64;\nexport const DEFAULT_BUFFER = 2;\nexport const DEFAULT_CUTOFF = 0.25;\nexport const DEFAULT_RADIUS = 3;\n\nconst GL_TEXTURE_WRAP_S = 0x2802;\nconst GL_TEXTURE_WRAP_T = 0x2803;\nconst GL_CLAMP_TO_EDGE = 0x812f;\nconst MAX_CANVAS_WIDTH = 1024;\n\nconst BASELINE_SCALE = 0.9;\nconst HEIGHT_SCALE = 1.2;\n\n// only preserve latest three fontAtlas\nconst CACHE_LIMIT = 3;\n\n/**\n * [key]: {\n *   xOffset, // x position of last character in mapping\n *   yOffset, // y position of last character in mapping\n *   mapping, // x, y coordinate of each character in shared `fontAtlas`\n *   data, // canvas\n *   width. // canvas.width,\n *   height, // canvas.height\n * }\n *\n */\nconst cache = new LRUCache(CACHE_LIMIT);\n\nconst VALID_PROPS = [\n  'fontFamily',\n  'fontWeight',\n  'characterSet',\n  'fontSize',\n  'sdf',\n  'buffer',\n  'cutoff',\n  'radius'\n];\n\n/**\n * get all the chars not in cache\n * @param key cache key\n * @param characterSet (Array|Set)\n * @returns {Array} chars not in cache\n */\nfunction getNewChars(key, characterSet) {\n  const cachedFontAtlas = cache.get(key);\n  if (!cachedFontAtlas) {\n    return characterSet;\n  }\n\n  const newChars = [];\n  const cachedMapping = cachedFontAtlas.mapping;\n  let cachedCharSet = Object.keys(cachedMapping);\n  cachedCharSet = new Set(cachedCharSet);\n\n  let charSet = characterSet;\n  if (charSet instanceof Array) {\n    charSet = new Set(charSet);\n  }\n\n  charSet.forEach(char => {\n    if (!cachedCharSet.has(char)) {\n      newChars.push(char);\n    }\n  });\n\n  return newChars;\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = '#000';\n  ctx.textBaseline = 'baseline';\n  ctx.textAlign = 'left';\n}\n\nexport default class FontAtlasManager {\n  constructor(gl) {\n    this.gl = gl;\n\n    // font settings\n    this.props = {\n      fontFamily: DEFAULT_FONT_FAMILY,\n      fontWeight: DEFAULT_FONT_WEIGHT,\n      characterSet: DEFAULT_CHAR_SET,\n      fontSize: DEFAULT_FONT_SIZE,\n      buffer: DEFAULT_BUFFER,\n      // sdf only props\n      // https://github.com/mapbox/tiny-sdf\n      sdf: false,\n      cutoff: DEFAULT_CUTOFF,\n      radius: DEFAULT_RADIUS\n    };\n\n    // key is used for caching generated fontAtlas\n    this._key = null;\n    this._texture = new Texture2D(this.gl);\n  }\n\n  finalize() {\n    this._texture.delete();\n  }\n\n  get texture() {\n    return this._texture;\n  }\n\n  get mapping() {\n    const data = cache.get(this._key);\n    return data && data.mapping;\n  }\n\n  get scale() {\n    return HEIGHT_SCALE;\n  }\n\n  setProps(props = {}) {\n    VALID_PROPS.forEach(prop => {\n      if (prop in props) {\n        this.props[prop] = props[prop];\n      }\n    });\n\n    // update cache key\n    const oldKey = this._key;\n    this._key = this._getKey();\n\n    const charSet = getNewChars(this._key, this.props.characterSet);\n    const cachedFontAtlas = cache.get(this._key);\n\n    // if a fontAtlas associated with the new settings is cached and\n    // there are no new chars\n    if (cachedFontAtlas && charSet.length === 0) {\n      // update texture with cached fontAtlas\n      if (this._key !== oldKey) {\n        this._updateTexture(cachedFontAtlas);\n      }\n      return;\n    }\n\n    // update fontAtlas with new settings\n    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);\n    this._updateTexture(fontAtlas);\n\n    // update cache\n    cache.set(this._key, fontAtlas);\n  }\n\n  _updateTexture({data: canvas, width, height}) {\n    // resize texture\n    if (this._texture.width !== width || this._texture.height !== height) {\n      this._texture.resize({width, height});\n    }\n\n    // update image data\n    this._texture.setImageData({\n      data: canvas,\n      width,\n      height,\n      parameters: {\n        [GL_TEXTURE_WRAP_S]: GL_CLAMP_TO_EDGE,\n        [GL_TEXTURE_WRAP_T]: GL_CLAMP_TO_EDGE\n      }\n    });\n\n    // this is required step after texture data changed\n    this._texture.generateMipmap();\n  }\n\n  _generateFontAtlas(key, characterSet, cachedFontAtlas) {\n    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d');\n\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const {mapping, canvasHeight, xOffset, yOffset} = buildMapping(\n      Object.assign(\n        {\n          getFontWidth: char => ctx.measureText(char).width,\n          fontHeight: fontSize * HEIGHT_SCALE,\n          buffer,\n          characterSet,\n          maxCanvasWidth: MAX_CANVAS_WIDTH\n        },\n        cachedFontAtlas && {\n          mapping: cachedFontAtlas.mapping,\n          xOffset: cachedFontAtlas.xOffset,\n          yOffset: cachedFontAtlas.yOffset\n        }\n      )\n    );\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    if (canvas.height !== canvasHeight) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(imageData, 0, 0);\n    }\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n      // used to store distance values from tinySDF\n      // tinySDF.size equals `fontSize + buffer * 2`\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n      for (const char of characterSet) {\n        populateAlphaChannel(tinySDF.draw(char), imageData);\n        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y - buffer);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);\n      }\n    }\n\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height\n    };\n  }\n\n  _getKey() {\n    const {gl, fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;\n    if (sdf) {\n      return `${gl} ${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;\n    }\n    return `${gl} ${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {CompositeLayer, createIterable} from '@deck.gl/core';\nimport MultiIconLayer from './multi-icon-layer/multi-icon-layer';\nimport FontAtlasManager, {\n  DEFAULT_CHAR_SET,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_FONT_WEIGHT,\n  DEFAULT_FONT_SIZE,\n  DEFAULT_BUFFER,\n  DEFAULT_RADIUS,\n  DEFAULT_CUTOFF\n} from './font-atlas-manager';\nimport {transformParagraph, getTextFromBuffer} from './utils';\n\nconst DEFAULT_FONT_SETTINGS = {\n  fontSize: DEFAULT_FONT_SIZE,\n  buffer: DEFAULT_BUFFER,\n  sdf: false,\n  radius: DEFAULT_RADIUS,\n  cutoff: DEFAULT_CUTOFF\n};\n\nconst TEXT_ANCHOR = {\n  start: 1,\n  middle: 0,\n  end: -1\n};\n\nconst ALIGNMENT_BASELINE = {\n  top: 1,\n  center: 0,\n  bottom: -1\n};\n\nconst DEFAULT_COLOR = [0, 0, 0, 255];\n\nconst DEFAULT_LINE_HEIGHT = 1.0;\n\nconst FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];\n\nconst defaultProps = {\n  billboard: true,\n  sizeScale: 1,\n  sizeUnits: 'pixels',\n  sizeMinPixels: 0,\n  sizeMaxPixels: Number.MAX_SAFE_INTEGER,\n  backgroundColor: {type: 'color', value: null, optional: true},\n\n  characterSet: DEFAULT_CHAR_SET,\n  fontFamily: DEFAULT_FONT_FAMILY,\n  fontWeight: DEFAULT_FONT_WEIGHT,\n  lineHeight: DEFAULT_LINE_HEIGHT,\n  fontSettings: {},\n\n  // auto wrapping options\n  wordBreak: 'word-break',\n  maxWidth: {type: 'number', value: -1},\n\n  getText: {type: 'accessor', value: x => x.text},\n  getPosition: {type: 'accessor', value: x => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n  getSize: {type: 'accessor', value: 32},\n  getAngle: {type: 'accessor', value: 0},\n  getTextAnchor: {type: 'accessor', value: 'middle'},\n  getAlignmentBaseline: {type: 'accessor', value: 'center'},\n  getPixelOffset: {type: 'accessor', value: [0, 0]}\n};\n\nexport default class TextLayer extends CompositeLayer {\n  initializeState() {\n    this.state = {\n      styleVersion: 0,\n      fontAtlasManager: new FontAtlasManager(this.context.gl)\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  updateState({props, oldProps, changeFlags}) {\n    const fontChanged = this._fontChanged(oldProps, props);\n\n    if (fontChanged) {\n      this._updateFontAtlas(oldProps, props);\n    }\n\n    const styleChanged =\n      fontChanged ||\n      props.lineHeight !== oldProps.lineHeight ||\n      props.wordBreak !== oldProps.wordBreak ||\n      props.maxWidth !== oldProps.maxWidth;\n\n    const textChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText));\n\n    if (textChanged) {\n      this._updateText();\n    }\n    if (styleChanged) {\n      this.setState({\n        styleVersion: this.state.styleVersion + 1\n      });\n    }\n  }\n\n  finalizeState() {\n    super.finalizeState();\n    // Release resources held by the font atlas manager\n    this.state.fontAtlasManager.finalize();\n  }\n\n  getPickingInfo({info}) {\n    // because `TextLayer` assign the same pickingInfoIndex for one text label,\n    // here info.index refers the index of text label in props.data\n    return Object.assign(info, {\n      // override object with original data\n      object: info.index >= 0 ? this.props.data[info.index] : null\n    });\n  }\n\n  _updateFontAtlas(oldProps, props) {\n    const {characterSet, fontSettings, fontFamily, fontWeight} = props;\n\n    // generate test characterSet\n    const {fontAtlasManager} = this.state;\n    fontAtlasManager.setProps(\n      Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {\n        characterSet,\n        fontFamily,\n        fontWeight\n      })\n    );\n\n    this.setNeedsRedraw(true);\n  }\n\n  _fontChanged(oldProps, props) {\n    if (\n      oldProps.fontFamily !== props.fontFamily ||\n      oldProps.characterSet !== props.characterSet ||\n      oldProps.fontWeight !== props.fontWeight\n    ) {\n      return true;\n    }\n\n    if (oldProps.fontSettings === props.fontSettings) {\n      return false;\n    }\n\n    const oldFontSettings = oldProps.fontSettings || {};\n    const fontSettings = props.fontSettings || {};\n\n    return FONT_SETTINGS_PROPS.some(prop => oldFontSettings[prop] !== fontSettings[prop]);\n  }\n\n  // Text strings are variable width objects\n  // Returns the index at the start of each string (every character is rendered by one instance)\n  _updateText() {\n    const {data} = this.props;\n    const textBuffer = data.attributes && data.attributes.getText;\n    let {getText} = this.props;\n    let {startIndices} = data;\n    let numInstances;\n\n    if (textBuffer && startIndices) {\n      const {texts, characterCount} = getTextFromBuffer({\n        ...(ArrayBuffer.isView(textBuffer) ? {value: textBuffer} : textBuffer),\n        length: data.length,\n        startIndices\n      });\n      numInstances = characterCount;\n      getText = (_, {index}) => texts[index];\n    } else {\n      const {iterable, objectInfo} = createIterable(data);\n      startIndices = [0];\n      numInstances = 0;\n\n      for (const object of iterable) {\n        objectInfo.index++;\n        const text = getText(object, objectInfo) || '';\n        numInstances += text.length;\n        startIndices.push(numInstances);\n      }\n    }\n\n    this.setState({getText, startIndices, numInstances});\n  }\n\n  // Returns the x, y offsets of each character in a text string\n  getIconOffsets(object, objectInfo) {\n    const iconMapping = this.state.fontAtlasManager.mapping;\n    const {getText} = this.state;\n    const {wordBreak, maxWidth, lineHeight, getTextAnchor, getAlignmentBaseline} = this.props;\n\n    const paragraph = getText(object, objectInfo) || '';\n    const {\n      characters,\n      size: [width, height]\n    } = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping);\n    const anchorX =\n      TEXT_ANCHOR[\n        typeof getTextAnchor === 'function' ? getTextAnchor(object, objectInfo) : getTextAnchor\n      ];\n    const anchorY =\n      ALIGNMENT_BASELINE[\n        typeof getAlignmentBaseline === 'function'\n          ? getAlignmentBaseline(object, objectInfo)\n          : getAlignmentBaseline\n      ];\n\n    const offsets = new Array(paragraph.length * 2);\n    let index = 0;\n\n    for (const {rowWidth, x, y} of characters) {\n      // For a multi-line object, offset in x-direction needs consider\n      // the row offset in the paragraph and the object offset in the row\n      const rowOffset = ((1 - anchorX) * (width - rowWidth)) / 2;\n      offsets[index++] = ((anchorX - 1) * width) / 2 + rowOffset + x;\n      offsets[index++] = ((anchorY - 1) * height) / 2 + y;\n    }\n    return offsets;\n  }\n\n  renderLayers() {\n    const {\n      startIndices,\n      numInstances,\n      getText,\n      fontAtlasManager: {scale, texture, mapping},\n      styleVersion\n    } = this.state;\n\n    const {\n      data,\n      _dataDiff,\n      backgroundColor,\n      getPosition,\n      getColor,\n      getSize,\n      getAngle,\n      getPixelOffset,\n      billboard,\n      sdf,\n      sizeScale,\n      sizeUnits,\n      sizeMinPixels,\n      sizeMaxPixels,\n      transitions,\n      updateTriggers\n    } = this.props;\n\n    const getIconOffsets = this.getIconOffsets.bind(this);\n\n    const SubLayerClass = this.getSubLayerClass('characters', MultiIconLayer);\n\n    return new SubLayerClass(\n      {\n        sdf,\n        iconAtlas: texture,\n        iconMapping: mapping,\n        backgroundColor,\n\n        getPosition,\n        getColor,\n        getSize,\n        getAngle,\n        getPixelOffset,\n\n        billboard,\n        sizeScale: sizeScale * scale,\n        sizeUnits,\n        sizeMinPixels: sizeMinPixels * scale,\n        sizeMaxPixels: sizeMaxPixels * scale,\n\n        transitions: transitions && {\n          getPosition: transitions.getPosition,\n          getAngle: transitions.getAngle,\n          getColor: transitions.getColor,\n          getSize: transitions.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset\n        }\n      },\n      this.getSubLayerProps({\n        id: 'characters',\n        updateTriggers: {\n          getPosition: updateTriggers.getPosition,\n          getAngle: updateTriggers.getAngle,\n          getColor: updateTriggers.getColor,\n          getSize: updateTriggers.getSize,\n          getPixelOffset: updateTriggers.getPixelOffset,\n          getIconOffsets: {\n            getText: updateTriggers.getText,\n            getTextAnchor: updateTriggers.getTextAnchor,\n            getAlignmentBaseline: updateTriggers.getAlignmentBaseline,\n            styleVersion\n          }\n        }\n      }),\n      {\n        data,\n        _dataDiff,\n        startIndices,\n        numInstances,\n        getIconOffsets,\n        getIcon: getText\n      }\n    );\n  }\n}\n\nTextLayer.layerName = 'TextLayer';\nTextLayer.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n/* eslint-disable max-len */\n\n// Core Layers\nexport {default as ArcLayer} from './arc-layer/arc-layer';\nexport {default as BitmapLayer} from './bitmap-layer/bitmap-layer';\nexport {default as IconLayer} from './icon-layer/icon-layer';\nexport {default as LineLayer} from './line-layer/line-layer';\nexport {default as PointCloudLayer} from './point-cloud-layer/point-cloud-layer';\nexport {default as ScatterplotLayer} from './scatterplot-layer/scatterplot-layer';\nexport {default as ColumnLayer} from './column-layer/column-layer';\nexport {default as GridCellLayer} from './column-layer/grid-cell-layer';\nexport {default as PathLayer} from './path-layer/path-layer';\nexport {default as PolygonLayer} from './polygon-layer/polygon-layer';\nexport {default as GeoJsonLayer} from './geojson-layer/geojson-layer';\nexport {default as TextLayer} from './text-layer/text-layer';\nexport {default as SolidPolygonLayer} from './solid-polygon-layer/solid-polygon-layer';\n\n// Experimental layer exports\nexport {default as _MultiIconLayer} from './text-layer/multi-icon-layer/multi-icon-layer';\n"],
  "mappings": "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",
  "names": ["DEFAULT_COLOR", "defaultProps", "ArcLayer", "init_esm", "getSourcePosition", "type", "value", "x", "sourcePosition", "getTargetPosition", "targetPosition", "getSourceColor", "getTargetColor", "getWidth", "getHeight", "getTilt", "greatCircle", "widthUnits", "widthScale", "min", "widthMinPixels", "widthMaxPixels", "Number", "MAX_SAFE_INTEGER", "vs", "fs", "modules", "project32", "picking", "attributeManager", "getAttributeManager", "addInstanced", "instanceSourcePositions", "size", "fp64", "use64bitPositions", "transition", "accessor", "instanceTargetPositions", "instanceSourceColors", "props", "colorFormat", "length", "normalized", "defaultValue", "instanceTargetColors", "instanceWidths", "instanceHeights", "instanceTilts", "oldProps", "changeFlags", "extensionsChanged", "gl", "context", "state", "model", "setState", "_getModel", "invalidateAll", "uniforms", "viewport", "widthMultiplier", "metersPerPixel", "setUniforms", "draw", "positions", "NUM_SEGMENTS", "i", "concat", "Model", "Object", "assign", "getShaders", "id", "geometry", "Geometry", "drawMode", "attributes", "Float32Array", "isInstanced", "numSegments", "Layer", "layerName", "bounds", "resolution", "createQuad", "maxXSpan", "Math", "max", "abs", "maxYSpan", "uCount", "ceil", "vCount", "vertexCount", "indices", "Uint32Array", "texCoords", "Float32Array", "positions", "Float64Array", "vertex", "index", "u", "ut", "v", "vt", "p", "interpolateQuad", "i", "length", "DEFAULT_INDICES", "DEFAULT_TEX_COORDS", "quad", "lerp", "init_esm", "Uint16Array", "DEFAULT_TEXTURE_PARAMETERS", "defaultProps", "BitmapLayer", "init_esm", "image", "type", "value", "async", "bounds", "compare", "desaturate", "min", "max", "transparentColor", "tintColor", "vs", "fs", "modules", "project32", "picking", "attributeManager", "getAttributeManager", "remove", "noAlloc", "add", "indices", "size", "isIndexed", "update", "attribute", "state", "mesh", "positions", "fp64", "use64bitPositions", "texCoords", "props", "oldProps", "changeFlags", "extensionsChanged", "gl", "context", "model", "setState", "_getModel", "invalidateAll", "loadTexture", "oldMesh", "_createMesh", "setVertexCount", "vertexCount", "key", "invalidate", "bitmapTexture", "normalizedBounds", "Number", "isFinite", "createMesh", "viewport", "resolution", "Model", "Object", "assign", "getShaders", "id", "geometry", "Geometry", "drawMode", "isInstanced", "opts", "uniforms", "HTMLVideoElement", "readyState", "HAVE_METADATA", "sizeChanged", "width", "videoWidth", "height", "videoHeight", "resize", "mipmaps", "setSubImageData", "data", "paramters", "generateMipmap", "setUniforms", "map", "x", "slice", "draw", "Texture2D", "parameters", "Layer", "layerName", "condition", "message", "Error", "globals", "self_", "window_", "global_", "document_", "isBrowser", "matches", "nodeVersion", "self", "window", "global", "document", "process", "String", "browser", "version", "match", "parseFloat", "isImageTypeSupported", "type", "IMAGE_BITMAP_SUPPORTED", "IMAGE_SUPPORTED", "DATA_SUPPORTED", "Error", "getDefaultImageType", "_parseImageNode", "NODE_IMAGE_SUPPORTED", "global", "Image", "ImageBitmap", "Boolean", "isBrowser", "getImageType", "image", "format", "getImageTypeOrNull", "Error", "getImageData", "canvas", "document", "createElement", "context", "getContext", "width", "height", "drawImage", "assert", "ImageBitmap", "Image", "data", "isSVG", "url", "SVG_DATA_URL_PATTERN", "test", "SVG_URL_PATTERN", "getBlobOrSVGDataUrl", "arrayBuffer", "textDecoder", "TextDecoder", "xmlText", "decode", "src", "btoa", "getBlob", "Error", "Blob", "Uint8Array", "arrayBuffer", "options", "url", "URL", "_regeneratorRuntime", "blobOrDataUrl", "getBlobOrSVGDataUrl", "self", "webkitURL", "objectUrl", "createObjectURL", "loadToImage", "revokeObjectURL", "image", "Image", "src", "decode", "Promise", "resolve", "reject", "onload", "onerror", "err", "Error", "error", "arrayBuffer", "options", "url", "_regeneratorRuntime", "isSVG", "parseToImage", "image", "blob", "getBlob", "imagebitmapOptions", "imagebitmap", "safeCreateImageBitmap", "isEmptyObject", "imagebitmapOptionsSupported", "createImageBitmap", "console", "warn", "object", "key", "EMPTY_OBJECT", "getBinaryImageMetadata", "binaryData", "dataView", "toDataView", "getPngMetadata", "getJpegMetadata", "getGifMetadata", "getBmpMetadata", "isPng", "byteLength", "getUint32", "BIG_ENDIAN", "mimeType", "width", "height", "isGif", "getUint16", "LITTLE_ENDIAN", "isBmp", "isJpeg", "getUint8", "getJpegMarkers", "tableMarkers", "sofMarkers", "i", "marker", "has", "Set", "add", "data", "DataView", "ArrayBuffer", "isView", "buffer", "Error", "arrayBuffer", "options", "getBinaryImageMetadata", "mimeType", "_parseImageNode", "global", "assert", "arrayBuffer", "options", "context", "_regeneratorRuntime", "imageOptions", "image", "imageType", "type", "url", "loadType", "getLoadableImageType", "parseToImageBitmap", "parseToImage", "parseToNodeImage", "assert", "getImageData", "getDefaultImageType", "isImageTypeSupported", "VERSION", "EXTENSIONS", "MIME_TYPES", "ImageLoader", "id", "name", "version", "mimeTypes", "extensions", "parse", "parseImage", "tests", "arrayBuffer", "Boolean", "getBinaryImageMetadata", "DataView", "options", "image", "type", "decode", "_encodeImageNode", "global", "assert", "condition", "message", "Error", "init_assert", "globals", "self_", "window_", "global_", "document_", "isBrowser", "matches", "nodeVersion", "self", "window", "global", "document", "process", "String", "browser", "version", "match", "parseFloat", "getTransferList", "object", "recursive", "transfers", "transfersSet", "Set", "isTransferable", "add", "buffer", "ArrayBuffer", "isView", "key", "undefined", "Array", "from", "MessagePort", "ImageBitmap", "OffscreenCanvas", "init_assert", "getWorkerURL", "workerSource", "workerName", "assert", "startsWith", "endsWith", "workerUrl", "match", "buildScript", "workerURL", "workerURLCache", "get", "blob", "Blob", "type", "URL", "createObjectURL", "set", "init_assert", "Map", "defaultOnMessage", "data", "resolve", "count", "WorkerThread", "source", "name", "onMessage", "url", "getWorkerURL", "worker", "Worker", "Promise", "reject", "onmessage", "event", "onerror", "error", "message", "filename", "lineno", "colno", "betterError", "Error", "console", "transferList", "getTransferList", "postMessage", "terminate", "WorkerPool", "source", "name", "maxConcurrency", "onMessage", "onDebug", "reuseWorkers", "jobQueue", "idleQueue", "count", "isDestroyed", "forEach", "worker", "destroy", "data", "jobName", "Promise", "resolve", "reject", "push", "_startQueuedJob", "length", "_getAvailableWorker", "job", "shift", "message", "backlog", "process", "_onWorkerDone", "toLowerCase", "WorkerThread", "onWorkerMessage", "onMessage", "worker", "data", "resolve", "reject", "type", "result", "message", "DEFAULT_MAX_CONCURRENCY", "WorkerFarm", "Worker", "maxConcurrency", "onDebug", "reuseWorkers", "workerPools", "Map", "props", "forEach", "workerPool", "destroy", "workerSource", "workerName", "_getWorkerPool", "process", "get", "WorkerPool", "source", "name", "bind", "set", "init_globals", "init_assert", "node", "node", "init_assert", "init_assert", "STAT_QUEUED_REQUESTS", "STAT_ACTIVE_REQUESTS", "STAT_CANCELLED_REQUESTS", "STAT_QUEUED_REQUESTS_EVER", "STAT_ACTIVE_REQUESTS_EVER", "DEFAULT_PROPS", "RequestScheduler", "id", "throttleRequests", "maxRequests", "props", "requestQueue", "activeRequestCount", "requestMap", "Map", "stats", "Stats", "get", "_deferredUpdate", "handle", "getPriority", "Promise", "resolve", "done", "has", "request", "promise", "push", "set", "_issueNewRequests", "isDone", "setTimeout", "_issueNewRequestsAsync", "freeSlots", "Math", "max", "_updateAllRequests", "i", "length", "shift", "_issueRequest", "_updateRequest", "splice", "sort", "a", "b", "priority", "getAvailablePort", "defaultPort", "Promise", "resolve", "reject", "ChildProcess", "exec", "error", "stdout", "stderr", "portsInUse", "regex", "split", "forEach", "line", "match", "push", "Number", "port", "includes", "import_child_process", "DEFAULT_PROCESS_OPTIONS", "ChildProcessProxy", "init_assert", "command", "arguments", "portArg", "port", "basePort", "wait", "nodeSpawnOptions", "maxBuffer", "onSuccess", "processProxy", "console", "log", "options", "id", "childProcess", "_objectSpread", "assert", "args", "getAvailablePort", "push", "Promise", "resolve", "reject", "successTimer", "setTimeout", "join", "ChildProcess", "spawn", "stderr", "on", "data", "clearTimeout", "Error", "error", "code", "kill", "statusCode", "stop", "process", "exit", "message", "init_esm", "init_assert", "init_globals", "init_esm", "init_esm", "nextPowOfTwo", "number", "Math", "pow", "ceil", "log2", "resizeImage", "ctx", "imageData", "width", "height", "canvas", "clearRect", "drawImage", "getIconId", "icon", "id", "url", "resizeTexture", "gl", "texture", "oldWidth", "oldHeight", "newTexture", "cloneTextureFrom", "copyToTexture", "targetY", "buildRowMapping", "mapping", "columns", "yOffset", "i", "length", "xOffset", "Object", "assign", "x", "y", "buildMapping", "icons", "buffer", "rowHeight", "canvasWidth", "push", "max", "canvasHeight", "getDiffIcons", "data", "getIcon", "cachedIcons", "createIterable", "iterable", "objectInfo", "object", "index", "Error", "DEFAULT_CANVAS_WIDTH", "DEFAULT_BUFFER", "noop", "DEFAULT_TEXTURE_PARAMETERS", "IconManager", "init_esm", "_DEFAULT_TEXTURE_PARA", "onUpdate", "_loadOptions", "_getIcon", "_texture", "_externalTexture", "_mapping", "_pendingCount", "_autoPacking", "_xOffset", "_yOffset", "_rowHeight", "_buffer", "_canvasWidth", "_canvasHeight", "_canvas", "loadOptions", "autoPacking", "iconAtlas", "iconMapping", "undefined", "_updateIconAtlas", "document", "createElement", "_updateAutoPacking", "Texture2D", "setParameters", "parameters", "values", "_loadIcons", "getContext", "_loop", "load", "ImageLoader", "then", "setSubImageData", "generateMipmap", "error", "log", "DEFAULT_COLOR", "defaultProps", "IconLayer", "init_esm", "iconAtlas", "type", "value", "async", "iconMapping", "sizeScale", "min", "billboard", "sizeUnits", "sizeMinPixels", "sizeMaxPixels", "Number", "MAX_SAFE_INTEGER", "alphaCutoff", "max", "getPosition", "x", "position", "getIcon", "icon", "getColor", "getSize", "getAngle", "getPixelOffset", "vs", "fs", "modules", "project32", "picking", "state", "iconManager", "IconManager", "context", "gl", "onUpdate", "_onUpdate", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "size", "fp64", "use64bitPositions", "transition", "accessor", "instanceSizes", "defaultValue", "instanceOffsets", "transform", "getInstanceOffset", "instanceIconFrames", "getInstanceIconFrame", "instanceColorModes", "getInstanceColorMode", "instanceColors", "props", "colorFormat", "length", "normalized", "instanceAngles", "instancePixelOffset", "oldProps", "changeFlags", "data", "setProps", "loadOptions", "iconMappingChanged", "prePacked", "internalState", "isAsyncPropLoading", "autoPacking", "dataChanged", "updateTriggersChanged", "all", "invalidate", "extensionsChanged", "model", "setState", "_getModel", "invalidateAll", "finalize", "uniforms", "viewport", "iconsTexture", "getTexture", "loaded", "setUniforms", "Object", "assign", "iconsTextureDim", "width", "height", "metersPerPixel", "draw", "positions", "Model", "getShaders", "id", "geometry", "Geometry", "drawMode", "attributes", "Float32Array", "isInstanced", "setNeedsRedraw", "rect", "getIconMapping", "anchorX", "anchorY", "mapping", "mask", "y", "isLoaded", "Layer", "layerName", "DEFAULT_COLOR", "defaultProps", "LineLayer", "init_esm", "getSourcePosition", "type", "value", "x", "sourcePosition", "getTargetPosition", "targetPosition", "getColor", "getWidth", "widthUnits", "widthScale", "min", "widthMinPixels", "widthMaxPixels", "Number", "MAX_SAFE_INTEGER", "vs", "fs", "modules", "project32", "picking", "attributeManager", "getAttributeManager", "addInstanced", "instanceSourcePositions", "size", "fp64", "use64bitPositions", "transition", "accessor", "instanceTargetPositions", "instanceColors", "props", "colorFormat", "length", "normalized", "defaultValue", "instanceWidths", "oldProps", "changeFlags", "extensionsChanged", "gl", "context", "state", "model", "setState", "_getModel", "invalidateAll", "uniforms", "viewport", "widthMultiplier", "metersPerPixel", "setUniforms", "Object", "assign", "draw", "positions", "Model", "getShaders", "id", "geometry", "Geometry", "drawMode", "attributes", "Float32Array", "isInstanced", "Layer", "layerName", "normalizeData", "data", "header", "attributes", "length", "vertexCount", "POSITION", "instancePositions", "NORMAL", "instanceNormals", "COLOR_0", "instanceColors", "DEFAULT_COLOR", "DEFAULT_NORMAL", "defaultProps", "PointCloudLayer", "init_esm", "sizeUnits", "pointSize", "type", "min", "value", "getPosition", "x", "position", "getNormal", "getColor", "material", "radiusPixels", "deprecatedFor", "id", "vs", "fs", "modules", "project32", "gouraudLighting", "picking", "getAttributeManager", "addInstanced", "size", "fp64", "use64bitPositions", "transition", "accessor", "defaultValue", "props", "colorFormat", "normalized", "oldProps", "changeFlags", "extensionsChanged", "gl", "context", "state", "model", "setState", "_getModel", "invalidateAll", "dataChanged", "uniforms", "viewport", "sizeMultiplier", "metersPerPixel", "setUniforms", "Object", "assign", "draw", "positions", "i", "angle", "Math", "PI", "push", "cos", "sin", "Model", "getShaders", "geometry", "Geometry", "drawMode", "Float32Array", "isInstanced", "Layer", "layerName", "DEFAULT_COLOR", "defaultProps", "ScatterplotLayer", "init_esm", "radiusUnits", "radiusScale", "type", "min", "value", "radiusMinPixels", "radiusMaxPixels", "Number", "MAX_SAFE_INTEGER", "lineWidthUnits", "lineWidthScale", "lineWidthMinPixels", "lineWidthMaxPixels", "stroked", "filled", "getPosition", "x", "position", "getRadius", "getFillColor", "getLineColor", "getLineWidth", "strokeWidth", "deprecatedFor", "outline", "getColor", "id", "vs", "fs", "modules", "project32", "picking", "getAttributeManager", "addInstanced", "instancePositions", "size", "fp64", "use64bitPositions", "transition", "accessor", "instanceRadius", "defaultValue", "instanceFillColors", "props", "colorFormat", "length", "normalized", "instanceLineColors", "instanceLineWidths", "oldProps", "changeFlags", "extensionsChanged", "gl", "context", "state", "model", "setState", "_getModel", "invalidateAll", "uniforms", "viewport", "pointRadiusMultiplier", "metersPerPixel", "lineWidthMultiplier", "setUniforms", "draw", "positions", "Model", "Object", "assign", "getShaders", "geometry", "Geometry", "drawMode", "vertexCount", "attributes", "Float32Array", "isInstanced", "Layer", "layerName", "tesselateColumn", "props", "radius", "height", "nradial", "vertices", "log", "assert", "length", "vertsAroundEdge", "numVertices", "stepAngle", "Math", "PI", "indices", "Uint16Array", "positions", "Float32Array", "normals", "i", "j", "a", "vertex", "nextVertex", "sin", "cos", "k", "v", "floor", "sign", "index", "attributes", "POSITION", "size", "value", "NORMAL", "ColumnGeometry", "init_esm", "id", "uid", "_objectSpread", "Geometry", "DEFAULT_COLOR", "defaultProps", "ColumnLayer", "init_esm", "diskResolution", "type", "min", "value", "vertices", "radius", "angle", "offset", "coverage", "max", "elevationScale", "lineWidthUnits", "lineWidthScale", "lineWidthMinPixels", "lineWidthMaxPixels", "Number", "MAX_SAFE_INTEGER", "extruded", "wireframe", "filled", "stroked", "getPosition", "x", "position", "getFillColor", "getLineColor", "getLineWidth", "getElevation", "material", "getColor", "deprecatedFor", "vs", "fs", "modules", "project32", "gouraudLighting", "picking", "attributeManager", "getAttributeManager", "addInstanced", "instancePositions", "size", "fp64", "use64bitPositions", "transition", "accessor", "instanceElevations", "instanceFillColors", "props", "colorFormat", "length", "normalized", "defaultValue", "instanceLineColors", "instanceStrokeWidths", "oldProps", "changeFlags", "regenerateModels", "extensionsChanged", "gl", "context", "state", "model", "setState", "_getModel", "invalidateAll", "_updateGeometry", "geometry", "ColumnGeometry", "height", "nradial", "meanVertexDistance", "i", "p", "d", "Math", "sqrt", "edgeDistance", "cos", "PI", "Model", "Object", "assign", "getShaders", "id", "isInstanced", "getGeometry", "fillVertexCount", "attributes", "POSITION", "wireframeVertexCount", "indices", "setProps", "uniforms", "viewport", "widthMultiplier", "metersPerPixel", "setUniforms", "widthScale", "widthMinPixels", "widthMaxPixels", "isIndexed", "setVertexCount", "setDrawMode", "isStroke", "draw", "Layer", "layerName", "defaultProps", "GridCellLayer", "init_esm", "cellSize", "type", "min", "value", "offset", "diskResolution", "CubeGeometry", "uniforms", "props", "elevationScale", "extruded", "coverage", "angle", "state", "model", "setUniforms", "Object", "assign", "radius", "edgeDistance", "isWireframe", "draw", "ColumnLayer", "layerName", "init_esm", "init_esm", "push", "target", "source", "size", "length", "startIndex", "isDuplicate", "i", "copy", "getPointAtIndex", "positions", "index", "offset", "out", "startI", "intersect", "a", "b", "edge", "bbox", "out", "t", "snap", "i", "length", "bitCode", "p", "code", "cutPolylineByGrid", "positions", "options", "size", "broken", "gridResolution", "gridOffset", "startIndex", "endIndex", "length", "numPoints", "part", "result", "a", "getPointAtIndex", "b", "codeB", "cell", "getGridCell", "scratchPoint", "push", "i", "bitCode", "intersect", "codeAlt", "copy", "moveToNeighborCell", "concatInPlace", "arr1", "arr2", "cutPolygonByGrid", "holeIndices", "edgeTypes", "queue", "pos", "types", "Array", "fill", "TYPE_BORDER", "holes", "bbox", "shift", "getBoundingBox", "code", "parts", "bisectPolygon", "polygonLow", "polygonHigh", "polygon", "edge", "resultLow", "resultHigh", "typesLow", "typesHigh", "p", "side", "type", "prev", "prevSide", "Math", "sign", "prevType", "lowPointCount", "highPointCount", "TYPE_INSIDE", "out", "left", "floor", "bottom", "minX", "Infinity", "maxX", "minY", "maxY", "x", "y", "cutPolylineByMercatorBounds", "positions", "options", "size", "startIndex", "endIndex", "length", "normalize", "newPositions", "slice", "wrapLongitudesForShortestPath", "parts", "cutPolylineByGrid", "broken", "gridResolution", "gridOffset", "part", "shiftLongitudesIntoRange", "cutPolygonByMercatorBounds", "holeIndices", "edgeTypes", "newHoleIndices", "srcStartIndex", "targetIndex", "ringIndex", "srcEndIndex", "targetStartIndex", "splitIndex", "findSplitIndex", "i", "insertPoleVertices", "maxLatitude", "pop", "cutPolygonByGrid", "maxLat", "pointIndex", "lat", "Math", "abs", "DEFAULT_MAX_LATITUDE", "firstLng", "lastLng", "p", "getPointAtIndex", "round", "push", "sign", "prevLng", "lng", "delta", "refLng", "pointCount", "init_esm", "normalizePath", "path", "size", "gridResolution", "wrapLongitude", "flatPath", "Array", "isArray", "length", "i", "j", "cutPolylineByGrid", "cutPolylineByMercatorBounds", "init_path", "init_esm", "START_CAP", "END_CAP", "INVALID", "PathTesselator", "init_esm", "init_path", "opts", "_objectSpread", "attributes", "positions", "size", "padding", "initialize", "type", "fp64", "Float64Array", "Float32Array", "segmentTypes", "Uint8ClampedArray", "buffer", "normalize", "path", "normalizePath", "positionSize", "resolution", "wrapLongitude", "attributeName", "Array", "isArray", "subPath", "getGeometrySize", "numPoints", "getPathLength", "isClosed", "context", "geometrySize", "updateGeometryAttributes", "vertexStart", "_updateSegmentTypes", "_updatePositions", "isPathClosed", "fill", "p", "i", "ptIndex", "getPointOnPath", "length", "index", "target", "loop", "lastPointIndex", "Tesselator", "DEFAULT_COLOR", "defaultProps", "ATTRIBUTE_TRANSITION", "PathLayer", "init_esm", "widthUnits", "widthScale", "type", "min", "value", "widthMinPixels", "widthMaxPixels", "Number", "MAX_SAFE_INTEGER", "rounded", "miterLimit", "billboard", "_pathType", "getPath", "object", "path", "getColor", "getWidth", "enter", "chunk", "length", "subarray", "vs", "fs", "modules", "project32", "picking", "noAlloc", "attributeManager", "getAttributeManager", "addInstanced", "positions", "size", "vertexOffset", "fp64", "use64bitPositions", "transition", "accessor", "update", "calculatePositions", "shaderAttributes", "instanceLeftPositions", "instanceStartPositions", "instanceEndPositions", "instanceRightPositions", "instanceTypes", "calculateSegmentTypes", "instanceStrokeWidths", "defaultValue", "instanceColors", "props", "colorFormat", "normalized", "instancePickingColors", "index", "target", "encodePickingColor", "__source", "setState", "pathTesselator", "PathTesselator", "getDashArray", "extensions", "log", "removed", "oldProps", "changeFlags", "geometryChanged", "dataChanged", "updateTriggersChanged", "all", "state", "buffers", "data", "attributes", "updateGeometry", "geometryBuffer", "normalize", "loop", "getGeometry", "positionFormat", "wrapLongitude", "resolution", "context", "viewport", "numInstances", "instanceCount", "startIndices", "vertexStarts", "invalidateAll", "extensionsChanged", "gl", "model", "_getModel", "params", "info", "find", "d", "uniforms", "widthMultiplier", "metersPerPixel", "setUniforms", "Object", "assign", "jointType", "draw", "SEGMENT_INDICES", "SEGMENT_POSITIONS", "Model", "getShaders", "id", "geometry", "Geometry", "drawMode", "indices", "Uint16Array", "Float32Array", "isInstanced", "attribute", "get", "Layer", "layerName", "earcut", "equals", "validate", "polygon", "positions", "Array", "isArray", "ArrayBuffer", "isView", "Error", "isSimple", "length", "Number", "isFinite", "isNestedRingClosed", "simplePolygon", "p0", "p1", "isFlatRingClosed", "size", "startIndex", "endIndex", "i", "copyNestedRing", "target", "targetStartIndex", "targetIndex", "len", "j", "copyFlatRing", "srcStartIndex", "srcEndIndex", "srcLength", "normalize", "positionSize", "holeIndices", "srcPositions", "srcHoleIndices", "push", "pop", "getSurfaceIndices", "normalizedPolygon", "preproject", "map", "positionIndex", "n", "slice", "p", "xy", "earcut", "import_earcut", "init_polygon", "PolygonTesselator", "init_polygon", "init_esm", "opts", "fp64", "IndexType", "Uint32Array", "_objectSpread", "attributes", "positions", "size", "type", "Float64Array", "Float32Array", "vertexValid", "Uint8ClampedArray", "indices", "attributeName", "subarray", "vertexCount", "externalIndices", "buffers", "value", "length", "polygon", "normalize", "positionSize", "resolution", "cutPolygonByGrid", "holeIndices", "gridResolution", "edgeTypes", "wrapLongitude", "cutPolygonByMercatorBounds", "maxLatitude", "Array", "isArray", "Number", "isFinite", "subPolygon", "getGeometrySize", "buffer", "context", "geometrySize", "updateGeometryAttributes", "vertexStart", "indexStart", "indexStarts", "geometryIndex", "_updateIndices", "_updatePositions", "_updateVertexValid", "offset", "typedArrayManager", "target", "i", "getSurfaceIndices", "preproject", "allocate", "copy", "j", "polygonPositions", "x", "y", "z", "set", "fill", "Tesselator", "main", "main", "DEFAULT_COLOR", "defaultProps", "ATTRIBUTE_TRANSITION", "SolidPolygonLayer", "init_esm", "filled", "extruded", "wireframe", "_normalize", "elevationScale", "type", "min", "value", "getPolygon", "f", "polygon", "getElevation", "getFillColor", "getLineColor", "material", "enter", "chunk", "length", "subarray", "vs", "fs", "defines", "modules", "project32", "gouraudLighting", "picking", "context", "gl", "viewport", "coordinateSystem", "props", "isGeospatial", "COORDINATE_SYSTEM", "DEFAULT", "LNGLAT", "setState", "numInstances", "polygonTesselator", "PolygonTesselator", "preproject", "projectFlat", "fp64", "use64bitPositions", "IndexType", "hasFeatures", "FEATURES", "ELEMENT_INDEX_UINT32", "Uint32Array", "Uint16Array", "attributeManager", "getAttributeManager", "noAlloc", "remove", "add", "indices", "size", "isIndexed", "update", "calculateIndices", "positions", "transition", "accessor", "calculatePositions", "shaderAttributes", "vertexOffset", "divisor", "instancePositions", "nextPositions", "vertexValid", "calculateVertexValid", "elevations", "instanceElevations", "fillColors", "alias", "colorFormat", "normalized", "defaultValue", "instanceFillColors", "lineColors", "instanceLineColors", "pickingColors", "object", "index", "target", "encodePickingColor", "__source", "instancePickingColors", "params", "info", "data", "find", "d", "uniforms", "state", "topModel", "sideModel", "renderUniforms", "Object", "assign", "Boolean", "setInstanceCount", "instanceCount", "setUniforms", "setDrawMode", "isWireframe", "draw", "setVertexCount", "vertexCount", "updateParams", "updateGeometry", "oldProps", "changeFlags", "regenerateModels", "extensionsChanged", "models", "forEach", "model", "_getModels", "invalidateAll", "geometryConfigChanged", "dataChanged", "updateTriggersChanged", "all", "buffers", "attributes", "normalize", "geometryBuffer", "getGeometry", "positionFormat", "wrapLongitude", "resolution", "startIndices", "vertexStarts", "id", "shaders", "getShaders", "vsTop", "NON_INSTANCED_MODEL", "Model", "drawMode", "vertexPositions", "Float32Array", "isSideVertex", "vsSide", "geometry", "Geometry", "isInstanced", "userData", "excludeAttributes", "filter", "attribute", "indexStarts", "get", "Layer", "layerName", "replaceInRange", "data", "getIndex", "dataRange", "replace", "startRow", "endRow", "Infinity", "count", "length", "replaceStart", "replaceEnd", "i", "row", "index", "dataLengthChanged", "endChunk", "slice", "init_utils", "defaultLineColor", "defaultFillColor", "defaultProps", "PolygonLayer", "init_esm", "init_polygon", "init_utils", "stroked", "filled", "extruded", "elevationScale", "wireframe", "_normalize", "lineWidthUnits", "lineWidthScale", "lineWidthMinPixels", "lineWidthMaxPixels", "Number", "MAX_SAFE_INTEGER", "lineJointRounded", "lineMiterLimit", "getPolygon", "type", "value", "f", "polygon", "getFillColor", "getLineColor", "getLineWidth", "getElevation", "material", "state", "paths", "props", "getLineDashArray", "log", "removed", "oldProps", "changeFlags", "geometryChanged", "dataChanged", "updateTriggersChanged", "all", "Array", "isArray", "slice", "pathsDiff", "map", "dataRange", "replaceInRange", "data", "getIndex", "p", "__source", "index", "replace", "_getPaths", "setState", "positionFormat", "positionSize", "startRow", "endRow", "createIterable", "iterable", "objectInfo", "object", "normalize", "holeIndices", "positions", "i", "length", "path", "push", "getSubLayerRow", "_dataDiff", "transitions", "lineDashJustified", "updateTriggers", "FillLayer", "getSubLayerClass", "SolidPolygonLayer", "StrokeLayer", "PathLayer", "polygonLayer", "shouldRenderSubLayer", "getSubLayerProps", "id", "polygonLineLayer", "widthUnits", "widthScale", "widthMinPixels", "widthMaxPixels", "rounded", "miterLimit", "dashJustified", "_pathType", "getWidth", "getColor", "getPath", "getSubLayerAccessor", "getDashArray", "x", "CompositeLayer", "layerName", "getGeojsonFeatures", "geojson", "Array", "isArray", "log", "assert", "type", "features", "geometry", "separateGeojsonFeatures", "wrapFeature", "dataRange", "separated", "pointFeatures", "lineFeatures", "polygonFeatures", "polygonOutlineFeatures", "startRow", "endRow", "length", "featureIndex", "feature", "geometries", "i", "subGeometry", "separateGeometry", "sourceFeature", "sourceFeatureIndex", "coordinates", "validateGeometry", "warn", "push", "forEach", "point", "path", "polygon", "nestLevel", "COORDINATE_NEST_LEVEL", "Number", "isFinite", "init_esm", "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "getCoordinates", "f", "geometry", "coordinates", "defaultLineColor", "defaultFillColor", "defaultProps", "GeoJsonLayer", "init_esm", "init_utils", "stroked", "filled", "extruded", "wireframe", "lineWidthUnits", "lineWidthScale", "lineWidthMinPixels", "lineWidthMaxPixels", "Number", "MAX_SAFE_INTEGER", "lineJointRounded", "lineMiterLimit", "elevationScale", "pointRadiusUnits", "pointRadiusScale", "pointRadiusMinPixels", "pointRadiusMaxPixels", "getLineColor", "type", "value", "getFillColor", "getRadius", "getLineWidth", "getElevation", "material", "state", "features", "props", "getLineDashArray", "log", "removed", "changeFlags", "dataChanged", "getGeojsonFeatures", "data", "wrapFeature", "getSubLayerRow", "bind", "Array", "isArray", "oldFeatures", "newFeatures", "featuresDiff", "key", "slice", "dataRange", "partialFeatures", "separateGeojsonFeatures", "push", "replaceInRange", "getIndex", "__source", "index", "replace", "setState", "pointFeatures", "lineFeatures", "polygonFeatures", "polygonOutlineFeatures", "transitions", "lineDashJustified", "updateTriggers", "PolygonFillLayer", "getSubLayerClass", "SolidPolygonLayer", "PolygonStrokeLayer", "PathLayer", "LineStringsLayer", "PointsLayer", "ScatterplotLayer", "polygonFillLayer", "shouldRenderSubLayer", "_dataDiff", "getSubLayerAccessor", "getPolygon", "getSubLayerProps", "id", "polygonLineLayer", "widthUnits", "widthScale", "widthMinPixels", "widthMaxPixels", "rounded", "miterLimit", "dashJustified", "getColor", "getWidth", "getDashArray", "getPath", "pathLayer", "pointLayer", "radiusUnits", "radiusScale", "radiusMinPixels", "radiusMaxPixels", "getPosition", "highlightedObjectIndex", "_getHighlightedIndex", "isFinite", "findIndex", "d", "CompositeLayer", "layerName", "DEFAULT_GAMMA", "DEFAULT_BUFFER", "EMPTY_ARRAY", "defaultProps", "MultiIconLayer", "backgroundColor", "type", "value", "optional", "getIconOffsets", "x", "offsets", "Object", "assign", "inject", "fs", "attributeManager", "getAttributeManager", "addInstanced", "instanceOffsets", "size", "accessor", "instancePickingColors", "object", "index", "target", "encodePickingColor", "updateParams", "oldProps", "props", "Array", "isArray", "map", "c", "slice", "setState", "uniforms", "sdf", "state", "shouldDrawBackground", "buffer", "gamma", "Boolean", "icons", "from", "icon", "IconLayer", "layerName", "TinySDF", "nextPowOfTwo", "number", "Math", "pow", "ceil", "log2", "buildMapping", "characterSet", "getFontWidth", "fontHeight", "buffer", "maxCanvasWidth", "mapping", "xOffset", "yOffset", "row", "x", "i", "char", "width", "y", "height", "rowHeight", "canvasHeight", "getTextWidth", "text", "length", "character", "frameWidth", "frame", "breakAll", "maxWidth", "iconMapping", "rows", "rowStartCharIndex", "rowOffsetLeft", "textWidth", "push", "substring", "lastRowStartCharIndex", "lastRowOffsetLeft", "breakWord", "groupStartCharIndex", "group", "groupWidth", "lastGroupStartIndex", "subGroups", "concat", "slice", "autoWrapping", "wordBreak", "transformRow", "leftOffsets", "Array", "log", "warn", "MISSING_CHAR_WIDTH", "rowWidth", "transformParagraph", "paragraph", "lineHeight", "result", "autoWrappingEnabled", "isFinite", "size", "rowOffsetTop", "lineStartIndex", "line", "undefined", "max", "characters", "getTextFromBuffer", "value", "stride", "offset", "startIndices", "bytesPerElement", "BYTES_PER_ELEMENT", "elementStride", "elementOffset", "characterCount", "floor", "texts", "codes", "constructor", "index", "startIndex", "endIndex", "String", "fromCodePoint", "apply", "subarray", "init_utils", "init_esm", "LRUCache", "limit", "clear", "_cache", "_order", "key", "value", "_deleteOrder", "_appendOrder", "Object", "keys", "length", "_deleteCache", "index", "findIndex", "o", "splice", "push", "getDefaultCharacterSet", "charSet", "i", "push", "String", "fromCharCode", "getNewChars", "key", "characterSet", "cachedFontAtlas", "cache", "get", "newChars", "cachedMapping", "mapping", "cachedCharSet", "Object", "keys", "Set", "Array", "forEach", "char", "has", "populateAlphaChannel", "alphaChannel", "imageData", "length", "data", "setTextStyle", "ctx", "fontFamily", "fontSize", "fontWeight", "font", "fillStyle", "textBaseline", "textAlign", "DEFAULT_CHAR_SET", "DEFAULT_FONT_FAMILY", "DEFAULT_FONT_WEIGHT", "DEFAULT_FONT_SIZE", "DEFAULT_BUFFER", "DEFAULT_CUTOFF", "DEFAULT_RADIUS", "GL_TEXTURE_WRAP_S", "GL_TEXTURE_WRAP_T", "GL_CLAMP_TO_EDGE", "MAX_CANVAS_WIDTH", "BASELINE_SCALE", "HEIGHT_SCALE", "CACHE_LIMIT", "VALID_PROPS", "FontAtlasManager", "init_esm", "init_utils", "LRUCache", "gl", "props", "buffer", "sdf", "cutoff", "radius", "_key", "_texture", "Texture2D", "prop", "oldKey", "_getKey", "_updateTexture", "fontAtlas", "_generateFontAtlas", "set", "canvas", "width", "height", "resize", "setImageData", "parameters", "generateMipmap", "document", "createElement", "getContext", "buildMapping", "assign", "getFontWidth", "measureText", "fontHeight", "maxCanvasWidth", "xOffset", "yOffset", "canvasHeight", "getImageData", "putImageData", "tinySDF", "TinySDF", "size", "draw", "x", "y", "fillText", "DEFAULT_FONT_SETTINGS", "TEXT_ANCHOR", "ALIGNMENT_BASELINE", "DEFAULT_COLOR", "DEFAULT_LINE_HEIGHT", "FONT_SETTINGS_PROPS", "defaultProps", "TextLayer", "init_esm", "init_utils", "fontSize", "DEFAULT_FONT_SIZE", "buffer", "DEFAULT_BUFFER", "sdf", "radius", "DEFAULT_RADIUS", "cutoff", "DEFAULT_CUTOFF", "start", "middle", "end", "top", "center", "bottom", "billboard", "sizeScale", "sizeUnits", "sizeMinPixels", "sizeMaxPixels", "Number", "MAX_SAFE_INTEGER", "backgroundColor", "type", "value", "optional", "characterSet", "DEFAULT_CHAR_SET", "fontFamily", "DEFAULT_FONT_FAMILY", "fontWeight", "DEFAULT_FONT_WEIGHT", "lineHeight", "fontSettings", "wordBreak", "maxWidth", "getText", "x", "text", "getPosition", "position", "getColor", "getSize", "getAngle", "getTextAnchor", "getAlignmentBaseline", "getPixelOffset", "state", "styleVersion", "fontAtlasManager", "FontAtlasManager", "context", "gl", "props", "oldProps", "changeFlags", "fontChanged", "_fontChanged", "_updateFontAtlas", "styleChanged", "textChanged", "dataChanged", "updateTriggersChanged", "all", "_updateText", "setState", "finalize", "info", "Object", "assign", "object", "index", "data", "setProps", "setNeedsRedraw", "oldFontSettings", "some", "prop", "textBuffer", "attributes", "startIndices", "numInstances", "getTextFromBuffer", "_objectSpread", "ArrayBuffer", "isView", "length", "texts", "characterCount", "_", "createIterable", "iterable", "objectInfo", "push", "iconMapping", "mapping", "paragraph", "transformParagraph", "characters", "size", "width", "height", "anchorX", "anchorY", "offsets", "Array", "rowWidth", "y", "rowOffset", "scale", "texture", "_dataDiff", "transitions", "updateTriggers", "getIconOffsets", "bind", "SubLayerClass", "getSubLayerClass", "MultiIconLayer", "iconAtlas", "getSubLayerProps", "id", "getIcon", "CompositeLayer", "layerName", "init_esm"]
}
