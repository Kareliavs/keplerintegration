import {
  COORDINATE_SYSTEM,
  LayerExtension,
  Texture2D,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  fp64,
  init_asyncToGenerator,
  init_classCallCheck,
  init_createClass,
  init_esm12 as init_esm3,
  init_esm6 as init_esm,
  init_esm8 as init_esm2,
  init_getPrototypeOf,
  init_inherits,
  init_possibleConstructorReturn,
  memoize,
  mergeShaders,
  project_default,
  require_regenerator
} from "./chunk-5T2OUC3W.js";
import {
  _defineProperty,
  init_defineProperty
} from "./chunk-K5YS6U7Z.js";
import {
  __esm,
  __export,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js
var vs, fs, TARGET, inject, shader_module_default;
var init_shader_module = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/shader-module.js"() {
    init_esm3();
    vs = "\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n";
    fs = "\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n";
    TARGET = {
      source: 0,
      target: 1,
      custom: 2,
      source_target: 3
    };
    inject = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  "
    };
    shader_module_default = {
      name: "brushing",
      dependencies: [project_default],
      vs,
      fs,
      inject,
      getUniforms: function getUniforms(opts) {
        if (!opts || !opts.viewport) {
          return {};
        }
        var _opts$brushingEnabled = opts.brushingEnabled, brushingEnabled = _opts$brushingEnabled === void 0 ? true : _opts$brushingEnabled, _opts$brushingRadius = opts.brushingRadius, brushingRadius = _opts$brushingRadius === void 0 ? 1e4 : _opts$brushingRadius, _opts$brushingTarget = opts.brushingTarget, brushingTarget = _opts$brushingTarget === void 0 ? "source" : _opts$brushingTarget, mousePosition = opts.mousePosition, viewport = opts.viewport;
        return {
          brushing_enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
          brushing_radius: brushingRadius,
          brushing_target: TARGET[brushingTarget] || 0,
          brushing_mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
        };
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/brushing/brushing.js
var defaultProps, BrushingExtension;
var init_brushing = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/brushing/brushing.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm3();
    init_shader_module();
    defaultProps = {
      getBrushingTarget: {
        type: "accessor",
        value: [0, 0]
      },
      brushingTarget: "source",
      brushingEnabled: true,
      brushingRadius: 1e4
    };
    BrushingExtension = function(_LayerExtension) {
      _inherits(BrushingExtension2, _LayerExtension);
      function BrushingExtension2() {
        _classCallCheck(this, BrushingExtension2);
        return _possibleConstructorReturn(this, _getPrototypeOf(BrushingExtension2).apply(this, arguments));
      }
      _createClass(BrushingExtension2, [{
        key: "getShaders",
        value: function getShaders(extension) {
          return {
            modules: [shader_module_default]
          };
        }
      }, {
        key: "initializeState",
        value: function initializeState(context, extension) {
          var _this = this;
          var attributeManager = this.getAttributeManager();
          if (attributeManager) {
            attributeManager.add({
              brushingTargets: {
                size: 2,
                accessor: "getBrushingTarget",
                update: !this.props.getBrushingTarget && extension.useConstantTargetPositions,
                shaderAttributes: {
                  brushingTargets: {
                    divisor: 0
                  },
                  instanceBrushingTargets: {
                    divisor: 1
                  }
                }
              }
            });
          }
          extension.onMouseMove = function() {
            _this.getCurrentLayer().setNeedsRedraw();
          };
          if (this.context.deck) {
            this.context.deck.eventManager.on({
              pointermove: extension.onMouseMove,
              pointerleave: extension.onMouseMove
            });
          }
        }
      }, {
        key: "finalizeState",
        value: function finalizeState(extension) {
          if (this.context.deck) {
            this.context.deck.eventManager.off({
              pointermove: extension.onMouseMove,
              pointerleave: extension.onMouseMove
            });
          }
        }
      }, {
        key: "useConstantTargetPositions",
        value: function useConstantTargetPositions(attribute) {
          attribute.constant = true;
          attribute.value = new Float32Array(2);
          return;
        }
      }]);
      return BrushingExtension2;
    }(LayerExtension);
    BrushingExtension.extensionName = "BrushingExtension";
    BrushingExtension.defaultProps = defaultProps;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js
var vs2, fs2, getUniforms2, getUniforms64, inject2, shaderModule, shaderModule64;
var init_shader_module2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/shader-module.js"() {
    vs2 = "\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n";
    fs2 = "\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n";
    getUniforms2 = function getUniforms3(opts) {
      if (!opts || !opts.extensions) {
        return {};
      }
      var _opts$filterRange = opts.filterRange, filterRange = _opts$filterRange === void 0 ? [-1, 1] : _opts$filterRange, _opts$filterEnabled = opts.filterEnabled, filterEnabled = _opts$filterEnabled === void 0 ? true : _opts$filterEnabled, _opts$filterTransform = opts.filterTransformSize, filterTransformSize = _opts$filterTransform === void 0 ? true : _opts$filterTransform, _opts$filterTransform2 = opts.filterTransformColor, filterTransformColor = _opts$filterTransform2 === void 0 ? true : _opts$filterTransform2;
      var filterSoftRange = opts.filterSoftRange || filterRange;
      var uniforms = Number.isFinite(filterRange[0]) ? {
        filter_min: filterRange[0],
        filter_softMin: filterSoftRange[0],
        filter_softMax: filterSoftRange[1],
        filter_max: filterRange[1]
      } : {
        filter_min: filterRange.map(function(r) {
          return r[0];
        }),
        filter_softMin: filterSoftRange.map(function(r) {
          return r[0];
        }),
        filter_softMax: filterSoftRange.map(function(r) {
          return r[1];
        }),
        filter_max: filterRange.map(function(r) {
          return r[1];
        })
      };
      uniforms.filter_enabled = filterEnabled;
      uniforms.filter_useSoftMargin = Boolean(opts.filterSoftRange);
      uniforms.filter_transformSize = filterEnabled && filterTransformSize;
      uniforms.filter_transformColor = filterEnabled && filterTransformColor;
      return uniforms;
    };
    getUniforms64 = function getUniforms642(opts) {
      if (!opts || !opts.extensions) {
        return {};
      }
      var uniforms = getUniforms2(opts);
      if (Number.isFinite(uniforms.filter_min)) {
        var min64High = Math.fround(uniforms.filter_min);
        uniforms.filter_min -= min64High;
        uniforms.filter_softMin -= min64High;
        uniforms.filter_min64High = min64High;
        var max64High = Math.fround(uniforms.filter_max);
        uniforms.filter_max -= max64High;
        uniforms.filter_softMax -= max64High;
        uniforms.filter_max64High = max64High;
      } else {
        var _min64High = uniforms.filter_min.map(Math.fround);
        uniforms.filter_min = uniforms.filter_min.map(function(x, i) {
          return x - _min64High[i];
        });
        uniforms.filter_softMin = uniforms.filter_softMin.map(function(x, i) {
          return x - _min64High[i];
        });
        uniforms.filter_min64High = _min64High;
        var _max64High = uniforms.filter_max.map(Math.fround);
        uniforms.filter_max = uniforms.filter_max.map(function(x, i) {
          return x - _max64High[i];
        });
        uniforms.filter_softMax = uniforms.filter_softMax.map(function(x, i) {
          return x - _max64High[i];
        });
        uniforms.filter_max64High = _max64High;
      }
      return uniforms;
    };
    inject2 = {
      "vs:#main-start": "\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  ",
      "vs:DECKGL_FILTER_SIZE": "\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  "
    };
    shaderModule = {
      name: "data-filter",
      vs: vs2,
      fs: fs2,
      inject: inject2,
      getUniforms: getUniforms2
    };
    shaderModule64 = {
      name: "data-filter-fp64",
      vs: vs2,
      fs: fs2,
      inject: inject2,
      getUniforms: getUniforms64
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter.js
var defaultProps2, DATA_TYPE_FROM_SIZE, DataFilterExtension;
var init_data_filter = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/data-filter/data-filter.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm3();
    init_shader_module2();
    defaultProps2 = {
      getFilterValue: {
        type: "accessor",
        value: 0
      },
      filterEnabled: true,
      filterRange: [-1, 1],
      filterSoftRange: null,
      filterTransformSize: true,
      filterTransformColor: true
    };
    DATA_TYPE_FROM_SIZE = {
      1: "float",
      2: "vec2",
      3: "vec3",
      4: "vec4"
    };
    DataFilterExtension = function(_LayerExtension) {
      _inherits(DataFilterExtension2, _LayerExtension);
      function DataFilterExtension2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$filterSize = _ref.filterSize, filterSize = _ref$filterSize === void 0 ? 1 : _ref$filterSize, _ref$fp = _ref.fp64, fp642 = _ref$fp === void 0 ? false : _ref$fp;
        _classCallCheck(this, DataFilterExtension2);
        if (!DATA_TYPE_FROM_SIZE[filterSize]) {
          throw new Error("filterSize out of range");
        }
        return _possibleConstructorReturn(this, _getPrototypeOf(DataFilterExtension2).call(this, {
          filterSize,
          fp64: fp642
        }));
      }
      _createClass(DataFilterExtension2, [{
        key: "getShaders",
        value: function getShaders(extension) {
          var _extension$opts = extension.opts, filterSize = _extension$opts.filterSize, fp642 = _extension$opts.fp64;
          return {
            modules: [fp642 ? shaderModule64 : shaderModule],
            defines: {
              DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],
              DATAFILTER_DOUBLE: Boolean(fp642)
            }
          };
        }
      }, {
        key: "initializeState",
        value: function initializeState(context, extension) {
          var attributeManager = this.getAttributeManager();
          if (attributeManager) {
            attributeManager.add({
              filterValues: {
                size: extension.opts.filterSize,
                type: extension.opts.fp64 ? 5130 : 5126,
                accessor: "getFilterValue",
                shaderAttributes: {
                  filterValues: {
                    divisor: 0
                  },
                  instanceFilterValues: {
                    divisor: 1
                  }
                }
              }
            });
          }
        }
      }]);
      return DataFilterExtension2;
    }(LayerExtension);
    DataFilterExtension.extensionName = "DataFilterExtension";
    DataFilterExtension.defaultProps = defaultProps2;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js
var project64_glsl_default;
var init_project64_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.glsl.js"() {
    project64_glsl_default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n";
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js
function getUniforms4() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  if (opts.viewport) {
    var _opts$viewport = opts.viewport, viewProjectionMatrix = _opts$viewport.viewProjectionMatrix, scale = _opts$viewport.scale;
    return getMemoizedUniforms({
      viewProjectionMatrix,
      scale
    });
  }
  return {};
}
function calculateUniforms(_ref) {
  var viewProjectionMatrix = _ref.viewProjectionMatrix, scale = _ref.scale;
  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  var scaleFP64 = fp64ify(scale);
  return {
    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
    project64_uScale: scaleFP64
  };
}
var fp64ify, fp64ifyMatrix4, project64_default, DEFAULT_MODULE_OPTIONS, getMemoizedUniforms;
var init_project64 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/project64.js"() {
    init_esm();
    init_esm3();
    init_project64_glsl();
    fp64ify = fp64.fp64ify;
    fp64ifyMatrix4 = fp64.fp64ifyMatrix4;
    project64_default = {
      name: "project64",
      dependencies: [project_default, fp64],
      vs: project64_glsl_default,
      getUniforms: getUniforms4
    };
    DEFAULT_MODULE_OPTIONS = {};
    getMemoizedUniforms = memoize(calculateUniforms);
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fp64/fp64.js
var Fp64Extension;
var init_fp64 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fp64/fp64.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm3();
    init_project64();
    Fp64Extension = function(_LayerExtension) {
      _inherits(Fp64Extension2, _LayerExtension);
      function Fp64Extension2() {
        _classCallCheck(this, Fp64Extension2);
        return _possibleConstructorReturn(this, _getPrototypeOf(Fp64Extension2).apply(this, arguments));
      }
      _createClass(Fp64Extension2, [{
        key: "getShaders",
        value: function getShaders(opts) {
          var coordinateSystem = this.props.coordinateSystem;
          if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
            throw new Error("fp64: coordinateSystem must be LNGLAT");
          }
          return {
            modules: [project64_default]
          };
        }
      }]);
      return Fp64Extension2;
    }(LayerExtension);
    Fp64Extension.extensionName = "Fp64Extension";
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js
var dashShaders, offsetShaders;
var init_shaders_glsl = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/shaders.glsl.js"() {
    dashShaders = {
      inject: {
        "vs:#decl": "\nattribute vec2 instanceDashArrays;\nvarying vec2 vDashArray;\n",
        "vs:#main-end": "\nvDashArray = instanceDashArrays;\n",
        "fs:#decl": "\nuniform float dashAlignMode;\nvarying vec2 vDashArray;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n",
        "fs:#main-start": "\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength > 0.0) {\n    unitLength = mix(\n      unitLength,\n      vPathLength / round(vPathLength / unitLength),\n      dashAlignMode\n    );\n\n    float offset = dashAlignMode * solidLength / 2.0;\n\n    if (\n      gapLength > 0.0 &&\n      vPathPosition.y >= 0.0 &&\n      vPathPosition.y <= vPathLength &&\n      mod2(vPathPosition.y + offset, unitLength) > solidLength\n    ) {\n      discard;\n    }\n  }  \n"
      }
    };
    offsetShaders = {
      inject: {
        "vs:#decl": "\nattribute float instanceOffsets;\n",
        "vs:DECKGL_FILTER_SIZE": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n",
        "vCornerOffset = offsetVec;": "\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  vec2 offsetCenter = -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;\n  vCornerOffset = vCornerOffset * offsetWidth - offsetCenter;\n",
        "fs:#main-start": "\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n"
      }
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/path-style/path-style.js
var defaultProps3, PathStyleExtension;
var init_path_style = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/path-style/path-style.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm3();
    init_shaders_glsl();
    defaultProps3 = {
      getDashArray: {
        type: "accessor",
        value: [0, 0]
      },
      getOffset: {
        type: "accessor",
        value: 0
      },
      dashJustified: false
    };
    PathStyleExtension = function(_LayerExtension) {
      _inherits(PathStyleExtension2, _LayerExtension);
      function PathStyleExtension2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$dash = _ref.dash, dash = _ref$dash === void 0 ? false : _ref$dash, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? false : _ref$offset;
        _classCallCheck(this, PathStyleExtension2);
        return _possibleConstructorReturn(this, _getPrototypeOf(PathStyleExtension2).call(this, {
          dash,
          offset
        }));
      }
      _createClass(PathStyleExtension2, [{
        key: "isEnabled",
        value: function isEnabled(layer) {
          return layer.state.pathTesselator;
        }
      }, {
        key: "getShaders",
        value: function getShaders(extension) {
          if (!extension.isEnabled(this)) {
            return null;
          }
          var result = {};
          if (extension.opts.dash) {
            result = mergeShaders(result, dashShaders);
          }
          if (extension.opts.offset) {
            result = mergeShaders(result, offsetShaders);
          }
          return result;
        }
      }, {
        key: "initializeState",
        value: function initializeState(context, extension) {
          var attributeManager = this.getAttributeManager();
          if (!attributeManager || !extension.isEnabled(this)) {
            return;
          }
          extension.enabled = true;
          if (extension.opts.dash) {
            attributeManager.addInstanced({
              instanceDashArrays: {
                size: 2,
                accessor: "getDashArray"
              }
            });
          }
          if (extension.opts.offset) {
            attributeManager.addInstanced({
              instanceOffsets: {
                size: 1,
                accessor: "getOffset"
              }
            });
          }
        }
      }, {
        key: "updateState",
        value: function updateState(params, extension) {
          if (!extension.isEnabled(this)) {
            return;
          }
          var uniforms = {};
          if (extension.opts.dash) {
            uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;
          }
          this.state.model.setUniforms(uniforms);
        }
      }]);
      return PathStyleExtension2;
    }(LayerExtension);
    PathStyleExtension.extensionName = "PathStyleExtension";
    PathStyleExtension.defaultProps = defaultProps3;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js
function getPatternUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var uniforms = arguments.length > 1 ? arguments[1] : void 0;
  if ("fillPatternTexture" in opts) {
    var fillPatternTexture = opts.fillPatternTexture;
    return {
      fill_patternTexture: fillPatternTexture,
      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]
    };
  }
  if (opts.viewport) {
    var viewport = opts.viewport, _opts$fillPatternMask = opts.fillPatternMask, fillPatternMask = _opts$fillPatternMask === void 0 ? true : _opts$fillPatternMask, _opts$fillPatternEnab = opts.fillPatternEnabled, fillPatternEnabled = _opts$fillPatternEnab === void 0 ? true : _opts$fillPatternEnab;
    var project_uCoordinateOrigin = uniforms.project_uCoordinateOrigin, project_uCoordinateSystem = uniforms.project_uCoordinateSystem;
    var coordinateOriginCommon = project_uCoordinateSystem === COORDINATE_SYSTEM.CARTESIAN ? project_uCoordinateOrigin : viewport.projectPosition(project_uCoordinateOrigin);
    return {
      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),
      fill_patternMask: fillPatternMask,
      fill_patternEnabled: fillPatternEnabled
    };
  }
  return {};
}
var patternVs, patternFs, inject3, patternShaders;
var init_shaders_glsl2 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/shaders.glsl.js"() {
    init_esm3();
    patternVs = "\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec3 fill_patternPlacement;\n";
    patternFs = "\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\n\nvarying vec4 fill_patternBounds;\nvarying vec3 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n";
    inject3 = {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    fill_uv = geometry.position.xy;\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.z = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.w;\n    }\n  ",
      "fs:DECKGL_FILTER_COLOR": "\n    if (fill_patternEnabled) {\n      float scale = FILL_UV_SCALE * fill_patternPlacement.z;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n      texCoords.y = 1.0 - texCoords.y;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      if (fill_patternMask) {\n        color.a *= patternColor.a;\n      } else {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  "
    };
    patternShaders = {
      name: "fill-pattern",
      vs: patternVs,
      fs: patternFs,
      inject: inject3,
      dependencies: [project_default],
      getUniforms: getPatternUniforms
    };
  }
});

// node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style.js
var import_regenerator, _DEFAULT_TEXTURE_PARA, defaultProps4, DEFAULT_TEXTURE_PARAMETERS, FillStyleExtension;
var init_fill_style = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/fill-style/fill-style.js"() {
    import_regenerator = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_defineProperty();
    init_esm3();
    init_esm2();
    init_shaders_glsl2();
    defaultProps4 = {
      fillPatternEnabled: true,
      fillPatternAtlas: null,
      fillPatternMapping: null,
      fillPatternMask: true,
      getFillPattern: {
        type: "accessor",
        value: function value(d) {
          return d.pattern;
        }
      },
      getFillPatternScale: {
        type: "accessor",
        value: 1
      },
      getFillPatternOffset: {
        type: "accessor",
        value: [0, 0]
      }
    };
    DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);
    FillStyleExtension = function(_LayerExtension) {
      _inherits(FillStyleExtension2, _LayerExtension);
      function FillStyleExtension2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$pattern = _ref.pattern, pattern = _ref$pattern === void 0 ? false : _ref$pattern;
        _classCallCheck(this, FillStyleExtension2);
        return _possibleConstructorReturn(this, _getPrototypeOf(FillStyleExtension2).call(this, {
          pattern
        }));
      }
      _createClass(FillStyleExtension2, [{
        key: "isEnabled",
        value: function isEnabled(layer) {
          return layer.getAttributeManager() && !layer.state.pathTesselator;
        }
      }, {
        key: "getShaders",
        value: function getShaders(extension) {
          if (!extension.isEnabled(this)) {
            return null;
          }
          return {
            modules: [extension.opts.pattern && patternShaders].filter(Boolean)
          };
        }
      }, {
        key: "initializeState",
        value: function initializeState(context, extension) {
          if (!extension.isEnabled(this)) {
            return;
          }
          var attributeManager = this.getAttributeManager();
          if (extension.opts.pattern) {
            attributeManager.add({
              fillPatternFrames: {
                size: 4,
                accessor: "getFillPattern",
                transform: extension.getPatternFrame.bind(this),
                shaderAttributes: {
                  fillPatternFrames: {
                    divisor: 0
                  },
                  instanceFillPatternFrames: {
                    divisor: 1
                  }
                }
              },
              fillPatternScales: {
                size: 1,
                accessor: "getFillPatternScale",
                defaultValue: 1,
                shaderAttributes: {
                  fillPatternScales: {
                    divisor: 0
                  },
                  instanceFillPatternScales: {
                    divisor: 1
                  }
                }
              },
              fillPatternOffsets: {
                size: 2,
                accessor: "getFillPatternOffset",
                shaderAttributes: {
                  fillPatternOffsets: {
                    divisor: 0
                  },
                  instanceFillPatternOffsets: {
                    divisor: 1
                  }
                }
              }
            });
          }
          this.setState({
            emptyTexture: new Texture2D(this.context.gl, {
              data: new Uint8Array(4),
              width: 1,
              height: 1
            })
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref2, extension) {
          var props = _ref2.props, oldProps = _ref2.oldProps;
          if (!extension.isEnabled(this)) {
            return;
          }
          if (props.fillPatternAtlas && props.fillPatternAtlas !== oldProps.fillPatternAtlas) {
            extension.loadPatternAtlas.call(this, props);
          }
          if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
            extension.loadPatternMapping.call(this, props);
          }
        }
      }, {
        key: "draw",
        value: function draw(params, extension) {
          if (!extension.isEnabled(this)) {
            return;
          }
          var patternTexture = this.state.patternTexture;
          this.setModuleParameters({
            fillPatternTexture: patternTexture || this.state.emptyTexture
          });
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          var _this$state = this.state, patternTexture = _this$state.patternTexture, emptyTexture = _this$state.emptyTexture;
          if (patternTexture) {
            patternTexture["delete"]();
          }
          if (emptyTexture) {
            emptyTexture["delete"]();
          }
        }
      }, {
        key: "loadPatternAtlas",
        value: function() {
          var _loadPatternAtlas = _asyncToGenerator(import_regenerator.default.mark(function _callee(_ref3) {
            var fillPatternAtlas, fetch, image, patternTexture;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    fillPatternAtlas = _ref3.fillPatternAtlas, fetch = _ref3.fetch;
                    if (this.state.patternTexture) {
                      this.state.patternTexture["delete"]();
                    }
                    this.setState({
                      patternTexture: null
                    });
                    image = fillPatternAtlas;
                    if (!(typeof image === "string")) {
                      _context.next = 8;
                      break;
                    }
                    _context.next = 7;
                    return fetch(image, {
                      propName: "fillPatternAtlas",
                      layer: this
                    });
                  case 7:
                    image = _context.sent;
                  case 8:
                    patternTexture = image instanceof Texture2D ? image : new Texture2D(this.context.gl, {
                      data: image,
                      parameters: DEFAULT_TEXTURE_PARAMETERS
                    });
                    this.setState({
                      patternTexture
                    });
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function loadPatternAtlas(_x) {
            return _loadPatternAtlas.apply(this, arguments);
          }
          return loadPatternAtlas;
        }()
      }, {
        key: "loadPatternMapping",
        value: function() {
          var _loadPatternMapping = _asyncToGenerator(import_regenerator.default.mark(function _callee2(_ref4) {
            var fillPatternMapping, fetch, patternMapping;
            return import_regenerator.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    fillPatternMapping = _ref4.fillPatternMapping, fetch = _ref4.fetch;
                    this.setState({
                      patternMapping: null
                    });
                    patternMapping = fillPatternMapping;
                    if (!(typeof patternMapping === "string")) {
                      _context2.next = 7;
                      break;
                    }
                    _context2.next = 6;
                    return fetch(patternMapping, {
                      propName: "fillPatternMapping",
                      layer: this
                    });
                  case 6:
                    patternMapping = _context2.sent;
                  case 7:
                    this.setState({
                      patternMapping
                    });
                    this.getAttributeManager().invalidate("getFillPattern");
                    this.setNeedsUpdate();
                  case 10:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function loadPatternMapping(_x2) {
            return _loadPatternMapping.apply(this, arguments);
          }
          return loadPatternMapping;
        }()
      }, {
        key: "getPatternFrame",
        value: function getPatternFrame(name) {
          var patternMapping = this.state.patternMapping;
          var def = patternMapping && patternMapping[name];
          return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
        }
      }]);
      return FillStyleExtension2;
    }(LayerExtension);
    FillStyleExtension.extensionName = "FillStyleExtension";
    FillStyleExtension.defaultProps = defaultProps4;
  }
});

// node_modules/@deck.gl/extensions/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  BrushingExtension: () => BrushingExtension,
  DataFilterExtension: () => DataFilterExtension,
  FillStyleExtension: () => FillStyleExtension,
  Fp64Extension: () => Fp64Extension,
  PathStyleExtension: () => PathStyleExtension,
  project64: () => project64_default
});
var init_esm4 = __esm({
  "node_modules/@deck.gl/extensions/dist/esm/index.js"() {
    init_brushing();
    init_data_filter();
    init_fp64();
    init_path_style();
    init_fill_style();
    init_project64();
  }
});

export {
  BrushingExtension,
  DataFilterExtension,
  project64_default,
  Fp64Extension,
  PathStyleExtension,
  FillStyleExtension,
  esm_exports,
  init_esm4 as init_esm
};
//# sourceMappingURL=chunk-HWJ4GZDG.js.map
