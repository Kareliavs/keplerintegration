import {
  __commonJS
} from "./chunk-AUZ3RYOM.js";

// node_modules/react-palm/tasks/core.js
var require_core = __commonJS({
  "node_modules/react-palm/tasks/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports._run = _run;
    exports.fromPromise = fromPromise;
    exports.fromPromiseWithProgress = fromPromiseWithProgress;
    exports.fromCallback = fromCallback;
    exports.taskCreator_ = taskCreator_;
    exports.reportTasksForTesting = reportTasksForTesting;
    exports.all = all;
    exports.allSettled = allSettled;
    function _run(task, fnApplication, success, error, context) {
      if (typeof task.run !== "function") {
        throw new Error("Attempted to run something that is not a task.");
      }
      return task.run(fnApplication, success, error, context);
    }
    function fromPromise(fn, label) {
      var creator = function creator2(outbound) {
        return taskCreator_(function(success, error) {
          return fn(outbound).then(success, error);
        }, outbound, label);
      };
      creator.type = label;
      return creator;
    }
    var noop = function noop2() {
    };
    function fromPromiseWithProgress(fn, label) {
      var creator = function creator2(_ref) {
        var arg = _ref.arg, onProgress = _ref.onProgress;
        var task = taskCreator_(function(success, error, context) {
          return fn({
            arg,
            onProgress: (context ? function(v) {
              return context.onProgress(onProgress(v));
            } : noop) || noop
          }).then(success, error);
        }, {
          arg,
          onProgress
        }, label);
        return task;
      };
      creator.type = label;
      return creator;
    }
    function fromCallback(fn, label) {
      var creator = function creator2(outbound) {
        return taskCreator_(function(success, error) {
          return fn(outbound, function(err, result) {
            return err ? error(err) : success(result);
          });
        }, outbound, label);
      };
      creator.type = label;
      return creator;
    }
    function taskCreator_(effector, payload, label) {
      var effectorPrime = function effectorPrime2(success, error, context) {
        reportEffects("start", newTask, payload);
        return effector(function(result) {
          reportEffects("success", newTask, result);
          return success(result);
        }, function(reason) {
          reportEffects("error", newTask, reason);
          return error(reason);
        }, context);
      };
      effectorPrime.payload = payload;
      effectorPrime.type = label;
      var newTask = _task(payload, function(runEffect, success, error, context) {
        return runEffect(effectorPrime, success, error, context);
      }, label);
      return newTask;
    }
    function _task(payload, next, label) {
      return {
        label,
        type: label,
        payload,
        /*
         * Given the effector (or a mock), kicks off the task.
         * You (the end user) probably don't need to call this
         * directly. The middleware should handle it.
         */
        run: next,
        /*
         * Public Task Methods
         */
        chain,
        map,
        bimap
      };
      function map(successTransform) {
        return _task(payload, function(runEffect, success, error, context) {
          return next(runEffect, function(result) {
            return success(successTransform(result));
          }, error, context);
        }, label);
      }
      function bimap(successTransform, errorTransform) {
        return _task(payload, function(runEffect, success, error, context) {
          return next(runEffect, function(result) {
            return success(successTransform(result));
          }, function(reason) {
            return error(errorTransform(reason));
          }, context);
        }, label);
      }
      function chain(chainTransform) {
        return _task(payload, function(runEffect, success, error, context) {
          return next(runEffect, function(result) {
            var chainTask = chainTransform(result);
            return chainTask.run(runEffect, success, error, context);
          }, error, context);
        }, "Chain(".concat(label, ")"));
      }
    }
    var reportEffects = function reportEffects2(event, task, payload) {
    };
    function reportTasksForTesting(fn) {
      reportEffects = fn;
    }
    function all(tasks) {
      return _task(tasks.map(function(task) {
        return task.payload;
      }), function(runEffect, success, error, context) {
        if (tasks.length === 0) {
          return success([]);
        }
        var accumulated = Array(tasks.length);
        var complete = 0;
        var errorValue = null;
        function allSuccess(index) {
          return function(value) {
            if (errorValue) {
              return;
            }
            accumulated[index] = value;
            complete += 1;
            if (complete === tasks.length) {
              return success(accumulated);
            }
          };
        }
        function anyError(err) {
          if (!err) {
            return;
          }
          errorValue = err;
          return error(errorValue);
        }
        return Promise.all(tasks.map(function(task, index) {
          return task.run(runEffect, allSuccess(index), anyError, context);
        }));
      }, "Task.all(" + tasks.map(function(_ref2) {
        var type = _ref2.type;
        return type;
      }).join(", ") + ")");
    }
    function allSettled(tasks) {
      return _task(tasks.map(function(task) {
        return task.payload;
      }), function(runEffect, success, error, context) {
        if (tasks.length === 0) {
          return success([]);
        }
        var accumulated = Array(tasks.length);
        var complete = 0;
        function onOneTaskFinish(index, status) {
          return function(value) {
            accumulated[index] = {
              status,
              value
            };
            complete += 1;
            if (complete === tasks.length) {
              return success(accumulated);
            }
          };
        }
        return Promise.allSettled(tasks.map(function(task, index) {
          return task.run(runEffect, onOneTaskFinish(index, "fulfilled"), onOneTaskFinish(index, "rejected"), context);
        }));
      }, "Task.allSettled(" + tasks.map(function(_ref3) {
        var type = _ref3.type;
        return type;
      }).join(", ") + ")");
    }
  }
});

// node_modules/react-palm/tasks/legacy.js
var require_legacy = __commonJS({
  "node_modules/react-palm/tasks/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.taskCreator = taskCreator;
    var _core = require_core();
    function taskCreator(fn, label) {
      var creator = function creator2(outbound) {
        return (0, _core.taskCreator_)(function(success, error) {
          return fn(outbound, success, error);
        }, outbound, label);
      };
      creator.type = label;
      return creator;
    }
  }
});

// node_modules/react-palm/tasks/global.js
var require_global = __commonJS({
  "node_modules/react-palm/tasks/global.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getGlobalTaskQueue = getGlobalTaskQueue;
    exports.updateGlobalTaskQueue = updateGlobalTaskQueue;
    exports.getLastWithTaskCall = getLastWithTaskCall;
    exports.setLastWithTaskCall = setLastWithTaskCall;
    exports.clearLastWithTaskCall = clearLastWithTaskCall;
    var GLOBAL_TASK_STATE = "___GLOBAL_TASK_STATE_e3b0c442";
    var GLOBAL = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
    if (typeof GLOBAL[GLOBAL_TASK_STATE] !== "undefined") {
      console.warn("More than one copy of react-palm was loaded. This may cause problems.");
    } else {
      Object.defineProperty(GLOBAL, GLOBAL_TASK_STATE, {
        ennumerable: false,
        value: {
          tasks: [],
          lastWithTaskCall: null
        }
      });
    }
    function getGlobalTaskQueue() {
      return GLOBAL[GLOBAL_TASK_STATE].tasks;
    }
    function updateGlobalTaskQueue(newQueue) {
      GLOBAL[GLOBAL_TASK_STATE].tasks = newQueue;
    }
    function getLastWithTaskCall() {
      return GLOBAL[GLOBAL_TASK_STATE].lastWithTaskCall;
    }
    function setLastWithTaskCall(last) {
      GLOBAL[GLOBAL_TASK_STATE].lastWithTaskCall = last;
    }
    function clearLastWithTaskCall() {
      GLOBAL[GLOBAL_TASK_STATE].lastWithTaskCall = null;
    }
  }
});

// node_modules/react-palm/tasks/redux.js
var require_redux = __commonJS({
  "node_modules/react-palm/tasks/redux.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.withTasks = withTasks;
    exports.disableStackCapturing = disableStackCapturing;
    exports.withTask = exports.taskMiddleware = void 0;
    var _core = require_core();
    var _global = require_global();
    var CACHED_PROMISE = Promise.resolve();
    var makeDispatchAsync = function makeDispatchAsync2(dispatch) {
      return function(action) {
        return CACHED_PROMISE.then(function() {
          return dispatch(action);
        });
      };
    };
    var WEBPACK_HOT_RELOAD_ENABLED = Boolean(module.hot);
    var enableStackCapture = !WEBPACK_HOT_RELOAD_ENABLED;
    var IMPROPER_TASK_USAGE = "Tasks should not be added outside of reducers.";
    var taskMiddleware = function taskMiddleware2(store) {
      return function(next) {
        return function(action) {
          if (enableStackCapture && (0, _global.getGlobalTaskQueue)().length > 0) {
            var err = (0, _global.getLastWithTaskCall)();
            (0, _global.clearLastWithTaskCall)();
            throw err;
          }
          next(action);
          var dispatch = makeDispatchAsync(store.dispatch);
          if ((0, _global.getGlobalTaskQueue)().length > 0) {
            var taskResolutions = (0, _global.getGlobalTaskQueue)().map(runTaskActual(dispatch));
            (0, _global.updateGlobalTaskQueue)([]);
            (0, _global.clearLastWithTaskCall)();
            return Promise.all(taskResolutions);
          }
          return CACHED_PROMISE;
        };
      };
    };
    exports.taskMiddleware = taskMiddleware;
    var biApply = function biApply2(f, s, e, c) {
      return f(s, e, c);
    };
    function runTaskActual(dispatch) {
      return function(task) {
        return (0, _core._run)(task, biApply, dispatch, dispatch, {
          onProgress: dispatch
        });
      };
    }
    function withTasks(state, tasks) {
      if (enableStackCapture && !(0, _global.getLastWithTaskCall)()) {
        (0, _global.setLastWithTaskCall)(trace(IMPROPER_TASK_USAGE));
      }
      (0, _global.updateGlobalTaskQueue)((0, _global.getGlobalTaskQueue)().concat(tasks instanceof Array ? tasks : [tasks]));
      return state;
    }
    var withTask = withTasks;
    exports.withTask = withTask;
    function disableStackCapturing() {
      enableStackCapture = false;
    }
    function trace(message) {
      try {
        throw new Error(message);
      } catch (e) {
        return e;
      }
    }
  }
});

// node_modules/react-palm/tasks/test-utils.js
var require_test_utils = __commonJS({
  "node_modules/react-palm/tasks/test-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.succeedTaskInTest = succeedTaskInTest;
    exports.errorTaskInTest = errorTaskInTest;
    exports.simulateTask = simulateTask;
    exports.succeedTaskWithValues = succeedTaskWithValues;
    exports.drainTasksForTesting = drainTasksForTesting;
    var _core = require_core();
    var _global = require_global();
    function succeedTaskInTest(someTask, value) {
      return _runAndCaptureResult(someTask, function(_, s, _e) {
        return s(value);
      });
    }
    function errorTaskInTest(someTask, value) {
      return _runAndCaptureResult(someTask, function(_, _s, e) {
        return e(value);
      });
    }
    function simulateTask(someTask, simulator) {
      return _runAndCaptureResult(someTask, simulator);
    }
    function succeedTaskWithValues(someTask, values) {
      var index = 0;
      return _runAndCaptureResult(someTask, function(_, s) {
        if (index >= values.length) {
          throw new Error("Not enough values were provided!");
        }
        var returned = s(values[index]);
        index += 1;
        return returned;
      });
    }
    function drainTasksForTesting() {
      var drained = (0, _global.getGlobalTaskQueue)();
      (0, _global.updateGlobalTaskQueue)([]);
      (0, _global.clearLastWithTaskCall)();
      return drained;
    }
    function _runAndCaptureResult(someTask, simulator) {
      var returned;
      var setReturned = function setReturned2(val) {
        returned = val;
      };
      (0, _core._run)(someTask, simulator, setReturned, setReturned);
      if (typeof returned === "undefined") {
        throw new Error("A success or error handler was never called!");
      }
      return returned;
    }
  }
});

// node_modules/react-palm/tasks/index.js
var require_tasks = __commonJS({
  "node_modules/react-palm/tasks/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      reportTasksForTesting: true,
      taskCreator: true,
      taskMiddleware: true,
      withTask: true,
      withTasks: true,
      disableStackCapturing: true,
      getGlobalTaskQueue: true
    };
    Object.defineProperty(exports, "reportTasksForTesting", {
      enumerable: true,
      get: function get() {
        return _core.reportTasksForTesting;
      }
    });
    Object.defineProperty(exports, "taskCreator", {
      enumerable: true,
      get: function get() {
        return _legacy.taskCreator;
      }
    });
    Object.defineProperty(exports, "taskMiddleware", {
      enumerable: true,
      get: function get() {
        return _redux.taskMiddleware;
      }
    });
    Object.defineProperty(exports, "withTask", {
      enumerable: true,
      get: function get() {
        return _redux.withTask;
      }
    });
    Object.defineProperty(exports, "withTasks", {
      enumerable: true,
      get: function get() {
        return _redux.withTasks;
      }
    });
    Object.defineProperty(exports, "disableStackCapturing", {
      enumerable: true,
      get: function get() {
        return _redux.disableStackCapturing;
      }
    });
    Object.defineProperty(exports, "getGlobalTaskQueue", {
      enumerable: true,
      get: function get() {
        return _global.getGlobalTaskQueue;
      }
    });
    exports.default = void 0;
    var _core = require_core();
    var _legacy = require_legacy();
    var _redux = require_redux();
    var _global = require_global();
    var _testUtils = require_test_utils();
    Object.keys(_testUtils).forEach(function(key) {
      if (key === "default" || key === "__esModule")
        return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key))
        return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _testUtils[key];
        }
      });
    });
    var _default = {
      all: _core.all,
      allSettled: _core.allSettled,
      fromCallback: _core.fromCallback,
      fromPromise: _core.fromPromise,
      fromPromiseWithProgress: _core.fromPromiseWithProgress
    };
    exports.default = _default;
  }
});

export {
  require_tasks
};
//# sourceMappingURL=chunk-B3AKFFBR.js.map
