import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-36YJ42RY.js";
import {
  _defineProperty,
  _toPropertyKey,
  _typeof,
  init_defineProperty,
  init_toPropertyKey,
  init_typeof
} from "./chunk-K5YS6U7Z.js";
import {
  require_typeof
} from "./chunk-CE2QQUBF.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
var init_assert = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
var globals, self_, window_, global_, document_, isBrowser, isWorker, matches, nodeVersion;
var init_globals = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"() {
    init_typeof();
    globals = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_ = globals.self || globals.window || globals.global;
    window_ = globals.window || globals.self || globals.global;
    global_ = globals.global || globals.self || globals.window;
    document_ = globals.document || {};
    isBrowser = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
    isWorker = typeof importScripts === "function";
    matches = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
    nodeVersion = matches && parseFloat(matches[1]) || 0;
  }
});

// node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof2 = require_typeof()["default"];
    function _regeneratorRuntime47() {
      "use strict";
      module.exports = _regeneratorRuntime47 = function _regeneratorRuntime48() {
        return exports2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value4) {
        return Object.defineProperty(obj, key, {
          value: value4,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function define3(obj, key, value4) {
          return obj[key] = value4;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg, value4 = result.value;
            return value4 && "object" == _typeof2(value4) && hasOwn.call(value4, "__await") ? PromiseImpl.resolve(value4.__await).then(function(value5) {
              invoke("next", value5, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value4).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error2) {
              return invoke("throw", error2, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value4(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self2, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type)
          return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; )
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
        return this;
      }), define2(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type)
            throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    module.exports = _regeneratorRuntime47, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value4 = info.value;
  } catch (error2) {
    reject(error2);
    return;
  }
  if (info.done) {
    resolve(value4);
  } else {
    Promise.resolve(value4).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value4) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value4);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js
function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : void 0;
  var transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && _typeof(object) === "object") {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
var init_get_transfer_list = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js"() {
    init_typeof();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js
function validateLoaderVersion(loader) {
  var coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
  assert(loader, "no loader provided");
  var loaderVersion = loader.version;
  if (!coreVersion || !loaderVersion) {
    return;
  }
  coreVersion = parseVersion(coreVersion);
  loaderVersion = parseVersion(loaderVersion);
}
function parseVersion(version3) {
  var parts = version3.split(".").map(Number);
  return {
    major: parts[0],
    minor: parts[1]
  };
}
var VERSION;
var init_validate_loader_version = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js"() {
    init_assert();
    VERSION = true ? "2.3.13" : "";
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-worker.js
var import_regenerator;
var init_create_worker = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-worker.js"() {
    init_defineProperty();
    import_regenerator = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_get_transfer_list();
    init_validate_loader_version();
  }
});

// node_modules/@babel/runtime/helpers/esm/OverloadYield.js
function _OverloadYield(value4, kind) {
  this.v = value4, this.k = kind;
}
var init_OverloadYield = __esm({
  "node_modules/@babel/runtime/helpers/esm/OverloadYield.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js
function _awaitAsyncGenerator(value4) {
  return new _OverloadYield(value4, 0);
}
var init_awaitAsyncGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js"() {
    init_OverloadYield();
  }
});

// node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js
function AsyncGenerator(gen) {
  var front, back;
  function resume(key, arg) {
    try {
      var result = gen[key](arg), value4 = result.value, overloaded = value4 instanceof _OverloadYield;
      Promise.resolve(overloaded ? value4.v : value4).then(function(arg2) {
        if (overloaded) {
          var nextKey = "return" === key ? "return" : "next";
          if (!value4.k || arg2.done)
            return resume(nextKey, arg2);
          arg2 = gen[nextKey](arg2).value;
        }
        settle(result.done ? "return" : "normal", arg2);
      }, function(err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }
  function settle(type, value4) {
    switch (type) {
      case "return":
        front.resolve({
          value: value4,
          done: true
        });
        break;
      case "throw":
        front.reject(value4);
        break;
      default:
        front.resolve({
          value: value4,
          done: false
        });
    }
    (front = front.next) ? resume(front.key, front.arg) : back = null;
  }
  this._invoke = function(key, arg) {
    return new Promise(function(resolve, reject) {
      var request = {
        key,
        arg,
        resolve,
        reject,
        next: null
      };
      back ? back = back.next = request : (front = back = request, resume(key, arg));
    });
  }, "function" != typeof gen["return"] && (this["return"] = void 0);
}
var init_AsyncGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js"() {
    init_OverloadYield();
    AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function() {
      return this;
    }, AsyncGenerator.prototype.next = function(arg) {
      return this._invoke("next", arg);
    }, AsyncGenerator.prototype["throw"] = function(arg) {
      return this._invoke("throw", arg);
    }, AsyncGenerator.prototype["return"] = function(arg) {
      return this._invoke("return", arg);
    };
  }
});

// node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js
function _wrapAsyncGenerator(fn) {
  return function() {
    return new AsyncGenerator(fn.apply(this, arguments));
  };
}
var init_wrapAsyncGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js"() {
    init_AsyncGenerator();
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncIterator.js
function _asyncIterator(iterable) {
  var method, async, sync, retry = 2;
  for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--; ) {
    if (async && null != (method = iterable[async]))
      return method.call(iterable);
    if (sync && null != (method = iterable[sync]))
      return new AsyncFromSyncIterator(method.call(iterable));
    async = "@@asyncIterator", sync = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r)
      return Promise.reject(new TypeError(r + " is not an object."));
    var done = r.done;
    return Promise.resolve(r.value).then(function(value4) {
      return {
        value: value4,
        done
      };
    });
  }
  return AsyncFromSyncIterator = function AsyncFromSyncIterator2(s2) {
    this.s = s2, this.n = s2.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function next() {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    "return": function _return(value4) {
      var ret = this.s["return"];
      return void 0 === ret ? Promise.resolve({
        value: value4,
        done: true
      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
    },
    "throw": function _throw(value4) {
      var thr = this.s["return"];
      return void 0 === thr ? Promise.reject(value4) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(s);
}
var init_asyncIterator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncIterator.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/make-transform-iterator.js
function makeTransformIterator(_x, _x2, _x3) {
  return _makeTransformIterator.apply(this, arguments);
}
function _makeTransformIterator() {
  _makeTransformIterator = _wrapAsyncGenerator(import_regenerator2.default.mark(function _callee(asyncIterator, IncrementalTransform, options) {
    var transform2, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, _output, output;
    return import_regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            transform2 = new IncrementalTransform(options);
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 3;
            _iterator = _asyncIterator(asyncIterator);
          case 5:
            _context.next = 7;
            return _awaitAsyncGenerator(_iterator.next());
          case 7:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 11;
            return _awaitAsyncGenerator(_step.value);
          case 11:
            _value = _context.sent;
            if (_iteratorNormalCompletion) {
              _context.next = 23;
              break;
            }
            chunk = _value;
            _context.next = 16;
            return _awaitAsyncGenerator(transform2.write(chunk));
          case 16:
            _output = _context.sent;
            if (!_output) {
              _context.next = 20;
              break;
            }
            _context.next = 20;
            return _output;
          case 20:
            _iteratorNormalCompletion = true;
            _context.next = 5;
            break;
          case 23:
            _context.next = 29;
            break;
          case 25:
            _context.prev = 25;
            _context.t0 = _context["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context.t0;
          case 29:
            _context.prev = 29;
            _context.prev = 30;
            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 34;
              break;
            }
            _context.next = 34;
            return _awaitAsyncGenerator(_iterator["return"]());
          case 34:
            _context.prev = 34;
            if (!_didIteratorError) {
              _context.next = 37;
              break;
            }
            throw _iteratorError;
          case 37:
            return _context.finish(34);
          case 38:
            return _context.finish(29);
          case 39:
            _context.next = 41;
            return _awaitAsyncGenerator(transform2.end());
          case 41:
            output = _context.sent;
            if (!output) {
              _context.next = 45;
              break;
            }
            _context.next = 45;
            return output;
          case 45:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 25, 29, 39], [30, , 34, 38]]);
  }));
  return _makeTransformIterator.apply(this, arguments);
}
var import_regenerator2;
var init_make_transform_iterator = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/make-transform-iterator.js"() {
    import_regenerator2 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
  }
});

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@babel/runtime/helpers/esm/createClass.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js
function getWorkerURL(workerSource) {
  var workerName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Worker";
  assert(typeof workerSource === "string", "worker source");
  if (workerSource.startsWith("url(") && workerSource.endsWith(")")) {
    var workerUrl = workerSource.match(/^url\((.*)\)$/)[1];
    if (workerUrl && !workerUrl.startsWith("http")) {
      return workerUrl;
    }
    workerSource = buildScript(workerUrl);
  }
  var workerURL = workerURLCache.get(workerSource);
  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    workerURL = URL.createObjectURL(blob);
    workerURLCache.set(workerSource, workerURL);
  }
  return workerURL;
}
function buildScript(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n}");
}
var workerURLCache;
var init_get_worker_url = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js"() {
    init_assert();
    workerURLCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js
function defaultOnMessage(_ref) {
  var data = _ref.data, resolve = _ref.resolve;
  resolve(data);
}
var import_regenerator3, count, WorkerThread;
var init_worker_thread = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js"() {
    import_regenerator3 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_get_worker_url();
    init_get_transfer_list();
    count = 0;
    WorkerThread = function() {
      function WorkerThread3(_ref2) {
        var source = _ref2.source, _ref2$name = _ref2.name, name = _ref2$name === void 0 ? "web-worker-".concat(count++) : _ref2$name, onMessage = _ref2.onMessage;
        _classCallCheck(this, WorkerThread3);
        var url = getWorkerURL(source, name);
        this.worker = new Worker(url, {
          name
        });
        this.name = name;
        this.onMessage = onMessage || defaultOnMessage;
      }
      _createClass(WorkerThread3, [{
        key: "process",
        value: function() {
          var _process = _asyncToGenerator(import_regenerator3.default.mark(function _callee(data) {
            var _this = this;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", new Promise(function(resolve, reject) {
                      _this.worker.onmessage = function(event) {
                        _this.onMessage({
                          worker: _this.worker,
                          data: event.data,
                          resolve,
                          reject
                        });
                      };
                      _this.worker.onerror = function(error2) {
                        var message = "".concat(_this.name, ": WorkerThread.process() failed");
                        if (error2.message) {
                          message += " ".concat(error2.message, " ").concat(error2.filename, ":").concat(error2.lineno, ":").concat(error2.colno);
                        }
                        var betterError = new Error(message);
                        console.error(error2);
                        reject(betterError);
                      };
                      var transferList = getTransferList(data);
                      _this.worker.postMessage(data, transferList);
                    }));
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          function process2(_x) {
            return _process.apply(this, arguments);
          }
          return process2;
        }()
      }, {
        key: "destroy",
        value: function destroy() {
          this.worker.terminate();
          this.worker = null;
        }
      }]);
      return WorkerThread3;
    }();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js
var import_regenerator4, WorkerPool;
var init_worker_pool = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js"() {
    import_regenerator4 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_worker_thread();
    WorkerPool = function() {
      function WorkerPool3(_ref) {
        var source = _ref.source, _ref$name = _ref.name, name = _ref$name === void 0 ? "unnamed" : _ref$name, _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency, onMessage = _ref.onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
        } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
        _classCallCheck(this, WorkerPool3);
        this.source = source;
        this.name = name;
        this.maxConcurrency = maxConcurrency;
        this.onMessage = onMessage;
        this.onDebug = onDebug;
        this.jobQueue = [];
        this.idleQueue = [];
        this.count = 0;
        this.isDestroyed = false;
        this.reuseWorkers = reuseWorkers;
      }
      _createClass(WorkerPool3, [{
        key: "destroy",
        value: function destroy() {
          this.idleQueue.forEach(function(worker) {
            return worker.destroy();
          });
          this.isDestroyed = true;
        }
      }, {
        key: "process",
        value: function process2(data, jobName) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.jobQueue.push({
              data,
              jobName,
              resolve,
              reject
            });
            _this._startQueuedJob();
          });
        }
      }, {
        key: "_startQueuedJob",
        value: function() {
          var _startQueuedJob2 = _asyncToGenerator(import_regenerator4.default.mark(function _callee() {
            var worker, job;
            return import_regenerator4.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.jobQueue.length) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    worker = this._getAvailableWorker();
                    if (worker) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return");
                  case 5:
                    job = this.jobQueue.shift();
                    this.onDebug({
                      message: "processing",
                      worker: worker.name,
                      job: job.jobName,
                      backlog: this.jobQueue.length
                    });
                    _context.prev = 7;
                    _context.t0 = job;
                    _context.next = 11;
                    return worker.process(job.data);
                  case 11:
                    _context.t1 = _context.sent;
                    _context.t0.resolve.call(_context.t0, _context.t1);
                    _context.next = 18;
                    break;
                  case 15:
                    _context.prev = 15;
                    _context.t2 = _context["catch"](7);
                    job.reject(_context.t2);
                  case 18:
                    _context.prev = 18;
                    this._onWorkerDone(worker);
                    return _context.finish(18);
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[7, 15, 18, 21]]);
          }));
          function _startQueuedJob() {
            return _startQueuedJob2.apply(this, arguments);
          }
          return _startQueuedJob;
        }()
      }, {
        key: "_onWorkerDone",
        value: function _onWorkerDone(worker) {
          if (this.isDestroyed) {
            worker.destroy();
            return;
          }
          if (this.reuseWorkers) {
            this.idleQueue.push(worker);
          } else {
            worker.destroy();
            this.count--;
          }
          this._startQueuedJob();
        }
      }, {
        key: "_getAvailableWorker",
        value: function _getAvailableWorker() {
          if (this.idleQueue.length > 0) {
            return this.idleQueue.shift();
          }
          if (this.count < this.maxConcurrency) {
            this.count++;
            var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
            return new WorkerThread({
              source: this.source,
              onMessage: this.onMessage,
              name
            });
          }
          return null;
        }
      }]);
      return WorkerPool3;
    }();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js
function onWorkerMessage(onMessage, _ref2) {
  var worker = _ref2.worker, data = _ref2.data, resolve = _ref2.resolve, reject = _ref2.reject;
  if (onMessage) {
    onMessage({
      worker,
      data,
      resolve,
      reject
    });
    return;
  }
  switch (data.type) {
    case "done":
      resolve(data.result);
      break;
    case "error":
      reject(data.message);
      break;
    default:
  }
}
var import_regenerator5, DEFAULT_MAX_CONCURRENCY, WorkerFarm;
var init_worker_farm = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js"() {
    import_regenerator5 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_worker_pool();
    DEFAULT_MAX_CONCURRENCY = 5;
    WorkerFarm = function() {
      _createClass(WorkerFarm3, null, [{
        key: "isSupported",
        value: function isSupported() {
          return typeof Worker !== "undefined";
        }
      }]);
      function WorkerFarm3(_ref) {
        var _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY : _ref$maxConcurrency, _ref$onMessage = _ref.onMessage, onMessage = _ref$onMessage === void 0 ? null : _ref$onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
        } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
        _classCallCheck(this, WorkerFarm3);
        this.maxConcurrency = maxConcurrency;
        this.onMessage = onMessage;
        this.onDebug = onDebug;
        this.workerPools = /* @__PURE__ */ new Map();
        this.reuseWorkers = reuseWorkers;
      }
      _createClass(WorkerFarm3, [{
        key: "setProps",
        value: function setProps(props) {
          if ("maxConcurrency" in props) {
            this.maxConcurrency = props.maxConcurrency;
          }
          if ("onDebug" in props) {
            this.onDebug = props.onDebug;
          }
          if ("reuseWorkers" in props) {
            this.reuseWorkers = props.reuseWorkers;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.workerPools.forEach(function(workerPool) {
            return workerPool.destroy();
          });
        }
      }, {
        key: "process",
        value: function() {
          var _process = _asyncToGenerator(import_regenerator5.default.mark(function _callee(workerSource, workerName, data) {
            var workerPool;
            return import_regenerator5.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    workerPool = this._getWorkerPool(workerSource, workerName);
                    return _context.abrupt("return", workerPool.process(data));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function process2(_x, _x2, _x3) {
            return _process.apply(this, arguments);
          }
          return process2;
        }()
      }, {
        key: "_getWorkerPool",
        value: function _getWorkerPool(workerSource, workerName) {
          var workerPool = this.workerPools.get(workerName);
          if (!workerPool) {
            workerPool = new WorkerPool({
              source: workerSource,
              name: workerName,
              onMessage: onWorkerMessage.bind(null, this.onMessage),
              maxConcurrency: this.maxConcurrency,
              onDebug: this.onDebug,
              reuseWorkers: this.reuseWorkers
            });
            this.workerPools.set(workerName, workerPool);
          }
          return workerPool;
        }
      }]);
      return WorkerFarm3;
    }();
  }
});

// (disabled):node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/require-utils.node
var require_require_utils = __commonJS({
  "(disabled):node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/require-utils.node"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/library-utils/library-utils.js
var import_regenerator6, node;
var init_library_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/library-utils/library-utils.js"() {
    import_regenerator6 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_globals();
    node = __toESM(require_require_utils());
    init_assert();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
var init_get_first_characters = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
var init_parse_json = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js"() {
    init_get_first_characters();
  }
});

// (disabled):node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer-utils.node
var require_buffer_utils = __commonJS({
  "(disabled):node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer-utils.node"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js
var node2;
var init_buffer_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js"() {
    init_typeof();
    node2 = __toESM(require_buffer_utils());
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function toArrayBuffer3(data) {
  if (void 0) {
    data = (void 0)(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }
  if (typeof data === "string") {
    var text = data;
    var uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && _typeof(data) === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  return assert(false);
}
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  var array12 = new Uint8Array(arrayBuffer1);
  var array2 = new Uint8Array(arrayBuffer2);
  for (var i = 0; i < array12.length; ++i) {
    if (array12[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers() {
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  var sourceArrays = sources.map(function(source2) {
    return source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  });
  var byteLength = sourceArrays.reduce(function(length5, typedArray) {
    return length5 + typedArray.byteLength;
  }, 0);
  var result = new Uint8Array(byteLength);
  var offset = 0;
  var _iterator = _createForOfIteratorHelper(sourceArrays), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var sourceArray = _step.value;
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result.buffer;
}
var node3;
var init_array_buffer_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"() {
    init_typeof();
    init_assert();
    node3 = __toESM(require_buffer_utils());
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
var init_memory_copy_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"() {
    init_array_buffer_utils();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js
var init_binary_copy_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js"() {
    init_memory_copy_utils();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js
var init_encode_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
var init_path = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function resolvePath(filename) {
  for (var alias in fileAliases) {
    if (filename.startsWith(alias)) {
      var replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith("http://") && !filename.startsWith("https://")) {
    filename = "".concat(pathPrefix).concat(filename);
  }
  return filename;
}
var pathPrefix, fileAliases;
var init_file_aliases = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js"() {
    pathPrefix = "";
    fileAliases = {};
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/text-iterators.js
function makeTextDecoderIterator(_x, _x2) {
  return _makeTextDecoderIterator.apply(this, arguments);
}
function _makeTextDecoderIterator() {
  _makeTextDecoderIterator = _wrapAsyncGenerator(import_regenerator7.default.mark(function _callee(arrayBufferIterator, options) {
    var textDecoder, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, arrayBuffer2;
    return import_regenerator7.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            textDecoder = new TextDecoder(options);
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 3;
            _iterator = _asyncIterator(arrayBufferIterator);
          case 5:
            _context.next = 7;
            return _awaitAsyncGenerator(_iterator.next());
          case 7:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 11;
            return _awaitAsyncGenerator(_step.value);
          case 11:
            _value = _context.sent;
            if (_iteratorNormalCompletion) {
              _context.next = 19;
              break;
            }
            arrayBuffer2 = _value;
            _context.next = 16;
            return typeof arrayBuffer2 === "string" ? arrayBuffer2 : textDecoder.decode(arrayBuffer2, {
              stream: true
            });
          case 16:
            _iteratorNormalCompletion = true;
            _context.next = 5;
            break;
          case 19:
            _context.next = 25;
            break;
          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](3);
            _didIteratorError = true;
            _iteratorError = _context.t0;
          case 25:
            _context.prev = 25;
            _context.prev = 26;
            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 30;
              break;
            }
            _context.next = 30;
            return _awaitAsyncGenerator(_iterator["return"]());
          case 30:
            _context.prev = 30;
            if (!_didIteratorError) {
              _context.next = 33;
              break;
            }
            throw _iteratorError;
          case 33:
            return _context.finish(30);
          case 34:
            return _context.finish(25);
          case 35:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 21, 25, 35], [26, , 30, 34]]);
  }));
  return _makeTextDecoderIterator.apply(this, arguments);
}
function makeTextEncoderIterator(_x3, _x4) {
  return _makeTextEncoderIterator.apply(this, arguments);
}
function _makeTextEncoderIterator() {
  _makeTextEncoderIterator = _wrapAsyncGenerator(import_regenerator7.default.mark(function _callee2(textIterator, options) {
    var textEncoder, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, text;
    return import_regenerator7.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textEncoder = new TextEncoder();
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context2.prev = 3;
            _iterator2 = _asyncIterator(textIterator);
          case 5:
            _context2.next = 7;
            return _awaitAsyncGenerator(_iterator2.next());
          case 7:
            _step2 = _context2.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context2.next = 11;
            return _awaitAsyncGenerator(_step2.value);
          case 11:
            _value2 = _context2.sent;
            if (_iteratorNormalCompletion2) {
              _context2.next = 19;
              break;
            }
            text = _value2;
            _context2.next = 16;
            return typeof text === "string" ? textEncoder.encode(text) : text;
          case 16:
            _iteratorNormalCompletion2 = true;
            _context2.next = 5;
            break;
          case 19:
            _context2.next = 25;
            break;
          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context2.t0;
          case 25:
            _context2.prev = 25;
            _context2.prev = 26;
            if (!(!_iteratorNormalCompletion2 && _iterator2["return"] != null)) {
              _context2.next = 30;
              break;
            }
            _context2.next = 30;
            return _awaitAsyncGenerator(_iterator2["return"]());
          case 30:
            _context2.prev = 30;
            if (!_didIteratorError2) {
              _context2.next = 33;
              break;
            }
            throw _iteratorError2;
          case 33:
            return _context2.finish(30);
          case 34:
            return _context2.finish(25);
          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26, , 30, 34]]);
  }));
  return _makeTextEncoderIterator.apply(this, arguments);
}
function makeLineIterator(_x5) {
  return _makeLineIterator.apply(this, arguments);
}
function _makeLineIterator() {
  _makeLineIterator = _wrapAsyncGenerator(import_regenerator7.default.mark(function _callee3(textIterator) {
    var previous, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, textChunk, eolIndex, line;
    return import_regenerator7.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            previous = "";
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _context3.prev = 3;
            _iterator3 = _asyncIterator(textIterator);
          case 5:
            _context3.next = 7;
            return _awaitAsyncGenerator(_iterator3.next());
          case 7:
            _step3 = _context3.sent;
            _iteratorNormalCompletion3 = _step3.done;
            _context3.next = 11;
            return _awaitAsyncGenerator(_step3.value);
          case 11:
            _value3 = _context3.sent;
            if (_iteratorNormalCompletion3) {
              _context3.next = 26;
              break;
            }
            textChunk = _value3;
            previous += textChunk;
            eolIndex = void 0;
          case 16:
            if (!((eolIndex = previous.indexOf("\n")) >= 0)) {
              _context3.next = 23;
              break;
            }
            line = previous.slice(0, eolIndex + 1);
            previous = previous.slice(eolIndex + 1);
            _context3.next = 21;
            return line;
          case 21:
            _context3.next = 16;
            break;
          case 23:
            _iteratorNormalCompletion3 = true;
            _context3.next = 5;
            break;
          case 26:
            _context3.next = 32;
            break;
          case 28:
            _context3.prev = 28;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError3 = true;
            _iteratorError3 = _context3.t0;
          case 32:
            _context3.prev = 32;
            _context3.prev = 33;
            if (!(!_iteratorNormalCompletion3 && _iterator3["return"] != null)) {
              _context3.next = 37;
              break;
            }
            _context3.next = 37;
            return _awaitAsyncGenerator(_iterator3["return"]());
          case 37:
            _context3.prev = 37;
            if (!_didIteratorError3) {
              _context3.next = 40;
              break;
            }
            throw _iteratorError3;
          case 40:
            return _context3.finish(37);
          case 41:
            return _context3.finish(32);
          case 42:
            if (!(previous.length > 0)) {
              _context3.next = 45;
              break;
            }
            _context3.next = 45;
            return previous;
          case 45:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 28, 32, 42], [33, , 37, 41]]);
  }));
  return _makeLineIterator.apply(this, arguments);
}
function makeNumberedLineIterator(_x6) {
  return _makeNumberedLineIterator.apply(this, arguments);
}
function _makeNumberedLineIterator() {
  _makeNumberedLineIterator = _wrapAsyncGenerator(import_regenerator7.default.mark(function _callee4(lineIterator) {
    var counter2, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, line;
    return import_regenerator7.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            counter2 = 1;
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _context4.prev = 3;
            _iterator4 = _asyncIterator(lineIterator);
          case 5:
            _context4.next = 7;
            return _awaitAsyncGenerator(_iterator4.next());
          case 7:
            _step4 = _context4.sent;
            _iteratorNormalCompletion4 = _step4.done;
            _context4.next = 11;
            return _awaitAsyncGenerator(_step4.value);
          case 11:
            _value4 = _context4.sent;
            if (_iteratorNormalCompletion4) {
              _context4.next = 20;
              break;
            }
            line = _value4;
            _context4.next = 16;
            return {
              counter: counter2,
              line
            };
          case 16:
            counter2++;
          case 17:
            _iteratorNormalCompletion4 = true;
            _context4.next = 5;
            break;
          case 20:
            _context4.next = 26;
            break;
          case 22:
            _context4.prev = 22;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError4 = true;
            _iteratorError4 = _context4.t0;
          case 26:
            _context4.prev = 26;
            _context4.prev = 27;
            if (!(!_iteratorNormalCompletion4 && _iterator4["return"] != null)) {
              _context4.next = 31;
              break;
            }
            _context4.next = 31;
            return _awaitAsyncGenerator(_iterator4["return"]());
          case 31:
            _context4.prev = 31;
            if (!_didIteratorError4) {
              _context4.next = 34;
              break;
            }
            throw _iteratorError4;
          case 34:
            return _context4.finish(31);
          case 35:
            return _context4.finish(26);
          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 22, 26, 36], [27, , 31, 35]]);
  }));
  return _makeNumberedLineIterator.apply(this, arguments);
}
var import_regenerator7;
var init_text_iterators = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/text-iterators.js"() {
    import_regenerator7 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js
function forEach(_x, _x2) {
  return _forEach.apply(this, arguments);
}
function _forEach() {
  _forEach = _asyncToGenerator(import_regenerator8.default.mark(function _callee(iterator, visitor) {
    var _yield$iterator$next, done, value4, cancel;
    return import_regenerator8.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {
              _context.next = 14;
              break;
            }
            _context.next = 3;
            return iterator.next();
          case 3:
            _yield$iterator$next = _context.sent;
            done = _yield$iterator$next.done;
            value4 = _yield$iterator$next.value;
            if (!done) {
              _context.next = 9;
              break;
            }
            iterator["return"]();
            return _context.abrupt("return");
          case 9:
            cancel = visitor(value4);
            if (!cancel) {
              _context.next = 12;
              break;
            }
            return _context.abrupt("return");
          case 12:
            _context.next = 0;
            break;
          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _forEach.apply(this, arguments);
}
function concatenateChunksAsync(_x3) {
  return _concatenateChunksAsync.apply(this, arguments);
}
function _concatenateChunksAsync() {
  _concatenateChunksAsync = _asyncToGenerator(import_regenerator8.default.mark(function _callee2(asyncIterator) {
    var arrayBuffers, strings, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;
    return import_regenerator8.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            arrayBuffers = [];
            strings = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context2.prev = 4;
            _iterator = _asyncIterator(asyncIterator);
          case 6:
            _context2.next = 8;
            return _iterator.next();
          case 8:
            _step = _context2.sent;
            _iteratorNormalCompletion = _step.done;
            _context2.next = 12;
            return _step.value;
          case 12:
            _value = _context2.sent;
            if (_iteratorNormalCompletion) {
              _context2.next = 19;
              break;
            }
            chunk = _value;
            if (typeof chunk === "string") {
              strings.push(chunk);
            } else {
              arrayBuffers.push(chunk);
            }
          case 16:
            _iteratorNormalCompletion = true;
            _context2.next = 6;
            break;
          case 19:
            _context2.next = 25;
            break;
          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context2.t0;
          case 25:
            _context2.prev = 25;
            _context2.prev = 26;
            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context2.next = 30;
              break;
            }
            _context2.next = 30;
            return _iterator["return"]();
          case 30:
            _context2.prev = 30;
            if (!_didIteratorError) {
              _context2.next = 33;
              break;
            }
            throw _iteratorError;
          case 33:
            return _context2.finish(30);
          case 34:
            return _context2.finish(25);
          case 35:
            if (!(strings.length > 0)) {
              _context2.next = 38;
              break;
            }
            assert(arrayBuffers.length === 0);
            return _context2.abrupt("return", strings.join(""));
          case 38:
            return _context2.abrupt("return", concatenateArrayBuffers.apply(void 0, arrayBuffers));
          case 39:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 21, 25, 35], [26, , 30, 34]]);
  }));
  return _concatenateChunksAsync.apply(this, arguments);
}
var import_regenerator8;
var init_async_iteration = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js"() {
    import_regenerator8 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_asyncIterator();
    init_array_buffer_utils();
    init_assert();
  }
});

// node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (typeof window !== "undefined" && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== "undefined" && process.hrtime) {
    const timeParts = process.hrtime();
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
var init_hi_res_timestamp = __esm({
  "node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js"() {
  }
});

// node_modules/@probe.gl/stats/dist/esm/lib/stat.js
var Stat;
var init_stat = __esm({
  "node_modules/@probe.gl/stats/dist/esm/lib/stat.js"() {
    init_defineProperty();
    init_hi_res_timestamp();
    Stat = class {
      constructor(name, type) {
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "type", void 0);
        _defineProperty(this, "sampleSize", 1);
        _defineProperty(this, "time", void 0);
        _defineProperty(this, "count", void 0);
        _defineProperty(this, "samples", void 0);
        _defineProperty(this, "lastTiming", void 0);
        _defineProperty(this, "lastSampleTime", void 0);
        _defineProperty(this, "lastSampleCount", void 0);
        _defineProperty(this, "_count", 0);
        _defineProperty(this, "_time", 0);
        _defineProperty(this, "_samples", 0);
        _defineProperty(this, "_startTime", 0);
        _defineProperty(this, "_timerPending", false);
        this.name = name;
        this.type = type;
        this.reset();
      }
      setSampleSize(samples) {
        this.sampleSize = samples;
        return this;
      }
      incrementCount() {
        this.addCount(1);
        return this;
      }
      decrementCount() {
        this.subtractCount(1);
        return this;
      }
      addCount(value4) {
        this._count += value4;
        this._samples++;
        this._checkSampling();
        return this;
      }
      subtractCount(value4) {
        this._count -= value4;
        this._samples++;
        this._checkSampling();
        return this;
      }
      addTime(time) {
        this._time += time;
        this.lastTiming = time;
        this._samples++;
        this._checkSampling();
        return this;
      }
      timeStart() {
        this._startTime = getHiResTimestamp();
        this._timerPending = true;
        return this;
      }
      timeEnd() {
        if (!this._timerPending) {
          return this;
        }
        this.addTime(getHiResTimestamp() - this._startTime);
        this._timerPending = false;
        this._checkSampling();
        return this;
      }
      getSampleAverageCount() {
        return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
      }
      getSampleAverageTime() {
        return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
      }
      getSampleHz() {
        return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
      }
      getAverageCount() {
        return this.samples > 0 ? this.count / this.samples : 0;
      }
      getAverageTime() {
        return this.samples > 0 ? this.time / this.samples : 0;
      }
      getHz() {
        return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
      }
      reset() {
        this.time = 0;
        this.count = 0;
        this.samples = 0;
        this.lastTiming = 0;
        this.lastSampleTime = 0;
        this.lastSampleCount = 0;
        this._count = 0;
        this._time = 0;
        this._samples = 0;
        this._startTime = 0;
        this._timerPending = false;
        return this;
      }
      _checkSampling() {
        if (this._samples === this.sampleSize) {
          this.lastSampleTime = this._time;
          this.lastSampleCount = this._count;
          this.count += this._count;
          this.time += this._time;
          this.samples += this._samples;
          this._time = 0;
          this._count = 0;
          this._samples = 0;
        }
      }
    };
  }
});

// node_modules/@probe.gl/stats/dist/esm/lib/stats.js
var Stats;
var init_stats = __esm({
  "node_modules/@probe.gl/stats/dist/esm/lib/stats.js"() {
    init_defineProperty();
    init_stat();
    Stats = class {
      constructor(options) {
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "stats", {});
        this.id = options.id;
        this.stats = {};
        this._initializeStats(options.stats);
        Object.seal(this);
      }
      get(name) {
        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
        return this._getOrCreate({
          name,
          type
        });
      }
      get size() {
        return Object.keys(this.stats).length;
      }
      reset() {
        for (const key in this.stats) {
          this.stats[key].reset();
        }
        return this;
      }
      forEach(fn) {
        for (const key in this.stats) {
          fn(this.stats[key]);
        }
      }
      getTable() {
        const table = {};
        this.forEach((stat) => {
          table[stat.name] = {
            time: stat.time || 0,
            count: stat.count || 0,
            average: stat.getAverageTime() || 0,
            hz: stat.getHz() || 0
          };
        });
        return table;
      }
      _initializeStats() {
        let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        stats.forEach((stat) => this._getOrCreate(stat));
      }
      _getOrCreate(stat) {
        if (!stat || !stat.name) {
          return null;
        }
        const {
          name,
          type
        } = stat;
        if (!this.stats[name]) {
          if (stat instanceof Stat) {
            this.stats[name] = stat;
          } else {
            this.stats[name] = new Stat(name, type);
          }
        }
        return this.stats[name];
      }
    };
  }
});

// node_modules/@probe.gl/stats/dist/esm/index.js
var init_esm = __esm({
  "node_modules/@probe.gl/stats/dist/esm/index.js"() {
    init_stats();
    init_stat();
    init_hi_res_timestamp();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var STAT_QUEUED_REQUESTS, STAT_ACTIVE_REQUESTS, STAT_CANCELLED_REQUESTS, STAT_QUEUED_REQUESTS_EVER, STAT_ACTIVE_REQUESTS_EVER, DEFAULT_PROPS, RequestScheduler;
var init_request_scheduler = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm();
    STAT_QUEUED_REQUESTS = "Queued Requests";
    STAT_ACTIVE_REQUESTS = "Active Requests";
    STAT_CANCELLED_REQUESTS = "Cancelled Requests";
    STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
    STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
    DEFAULT_PROPS = {
      id: "request-scheduler",
      throttleRequests: true,
      maxRequests: 6
    };
    RequestScheduler = function() {
      function RequestScheduler3() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, RequestScheduler3);
        this.props = _objectSpread(_objectSpread({}, DEFAULT_PROPS), props);
        this.requestQueue = [];
        this.activeRequestCount = 0;
        this.requestMap = /* @__PURE__ */ new Map();
        this.stats = new Stats({
          id: props.id
        });
        this.stats.get(STAT_QUEUED_REQUESTS);
        this.stats.get(STAT_ACTIVE_REQUESTS);
        this.stats.get(STAT_CANCELLED_REQUESTS);
        this.stats.get(STAT_QUEUED_REQUESTS_EVER);
        this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
        this._deferredUpdate = null;
      }
      _createClass(RequestScheduler3, [{
        key: "scheduleRequest",
        value: function scheduleRequest(handle) {
          var getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
            return 0;
          };
          if (!this.props.throttleRequests) {
            return Promise.resolve({
              done: function done() {
              }
            });
          }
          if (this.requestMap.has(handle)) {
            return this.requestMap.get(handle);
          }
          var request = {
            handle,
            getPriority
          };
          var promise = new Promise(function(resolve) {
            request.resolve = resolve;
            return request;
          });
          this.requestQueue.push(request);
          this.requestMap.set(handle, promise);
          this._issueNewRequests();
          return promise;
        }
      }, {
        key: "_issueRequest",
        value: function _issueRequest(request) {
          var _this = this;
          var handle = request.handle, resolve = request.resolve;
          var isDone = false;
          var done = function done2() {
            if (!isDone) {
              isDone = true;
              _this.requestMap["delete"](handle);
              _this.activeRequestCount--;
              _this._issueNewRequests();
            }
          };
          this.activeRequestCount++;
          return resolve ? resolve({
            done
          }) : Promise.resolve({
            done
          });
        }
      }, {
        key: "_issueNewRequests",
        value: function _issueNewRequests() {
          var _this2 = this;
          if (!this._deferredUpdate) {
            this._deferredUpdate = setTimeout(function() {
              return _this2._issueNewRequestsAsync();
            }, 0);
          }
        }
      }, {
        key: "_issueNewRequestsAsync",
        value: function _issueNewRequestsAsync() {
          this._deferredUpdate = null;
          var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
          if (freeSlots === 0) {
            return;
          }
          this._updateAllRequests();
          for (var i = 0; i < freeSlots; ++i) {
            if (this.requestQueue.length > 0) {
              var request = this.requestQueue.shift();
              this._issueRequest(request);
            }
          }
        }
      }, {
        key: "_updateAllRequests",
        value: function _updateAllRequests() {
          var requestQueue = this.requestQueue;
          for (var i = 0; i < requestQueue.length; ++i) {
            var request = requestQueue[i];
            if (!this._updateRequest(request)) {
              requestQueue.splice(i, 1);
              this.requestMap["delete"](request.handle);
              i--;
            }
          }
          requestQueue.sort(function(a2, b) {
            return a2.priority - b.priority;
          });
        }
      }, {
        key: "_updateRequest",
        value: function _updateRequest(request) {
          request.priority = request.getPriority(request.handle);
          if (request.priority < 0) {
            request.resolve(null);
            return false;
          }
          return true;
        }
      }]);
      return RequestScheduler3;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray2(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++)
    arr2[i] = arr[i];
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
var init_arrayWithoutHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
var init_iterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArray.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableSpread = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread();
}
var init_toConsumableArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"() {
    init_arrayWithoutHoles();
    init_iterableToArray();
    init_unsupportedIterableToArray();
    init_nonIterableSpread();
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/process-utils.js
function getAvailablePort() {
  var defaultPort = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3e3;
  return new Promise(function(resolve, reject) {
    import_child_process.default.exec("lsof -i -P -n | grep LISTEN", function(error2, stdout, stderr) {
      if (error2) {
        resolve(defaultPort);
        return;
      }
      var portsInUse = [];
      var regex = /:(\d+) \(LISTEN\)/;
      stdout.split("\n").forEach(function(line) {
        var match = line.match(regex);
        if (match) {
          portsInUse.push(Number(match[1]));
        }
      });
      var port = defaultPort;
      while (portsInUse.includes(port)) {
        port++;
      }
      resolve(port);
    });
  });
}
var import_child_process;
var init_process_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/process-utils.js"() {
    import_child_process = __toESM(require_child_process());
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/child-process-proxy.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator9, import_child_process2, DEFAULT_PROCESS_OPTIONS, ChildProcessProxy;
var init_child_process_proxy = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/child-process-proxy.js"() {
    import_regenerator9 = __toESM(require_regenerator());
    init_toConsumableArray();
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_child_process2 = __toESM(require_child_process());
    init_assert();
    init_process_utils();
    DEFAULT_PROCESS_OPTIONS = {
      command: null,
      arguments: [],
      portArg: null,
      port: "auto",
      basePort: 5e3,
      wait: 2e3,
      nodeSpawnOptions: {
        maxBuffer: 5e3 * 1024
      },
      onSuccess: function onSuccess(processProxy) {
        console.log("Started ".concat(processProxy.options.command));
      }
    };
    ChildProcessProxy = function() {
      function ChildProcessProxy3() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$id = _ref.id, id = _ref$id === void 0 ? "browser-driver" : _ref$id;
        _classCallCheck(this, ChildProcessProxy3);
        this.id = id;
        this.childProcess = null;
        this.port = null;
      }
      _createClass(ChildProcessProxy3, [{
        key: "start",
        value: function() {
          var _start = _asyncToGenerator(import_regenerator9.default.mark(function _callee() {
            var _this = this;
            var options, args, _args = arguments;
            return import_regenerator9.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    options = _objectSpread2(_objectSpread2({}, DEFAULT_PROCESS_OPTIONS), options);
                    assert(options.command && typeof options.command === "string");
                    this.options = options;
                    args = _toConsumableArray(options.arguments);
                    this.port = options.port;
                    if (!options.portArg) {
                      _context.next = 12;
                      break;
                    }
                    if (!(this.port === "auto")) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 10;
                    return getAvailablePort(options.basePort);
                  case 10:
                    this.port = _context.sent;
                  case 11:
                    args.push(options.portArg, this.port);
                  case 12:
                    _context.next = 14;
                    return new Promise(function(resolve, reject) {
                      try {
                        var successTimer = setTimeout(function() {
                          if (options.onSuccess) {
                            options.onSuccess(_this);
                          }
                          resolve({});
                        }, options.wait);
                        console.log("Spawning ".concat(options.command, " ").concat(options.arguments.join(" ")));
                        _this.childProcess = import_child_process2.default.spawn(options.command, args, options.spawn);
                        _this.childProcess.stderr.on("data", function(data) {
                          console.log('Child process wrote to stderr: "'.concat(data, '".'));
                          clearTimeout(successTimer);
                          reject(new Error(data));
                        });
                        _this.childProcess.on("error", function(error2) {
                          console.log("Child process errored with ".concat(error2));
                          clearTimeout(successTimer);
                          reject(error2);
                        });
                        _this.childProcess.on("close", function(code) {
                          console.log("Child process exited with ".concat(code));
                          _this.childProcess = null;
                        });
                      } catch (error2) {
                        reject(error2);
                      }
                    });
                  case 14:
                    return _context.abrupt("return", _context.sent);
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function start() {
            return _start.apply(this, arguments);
          }
          return start;
        }()
      }, {
        key: "stop",
        value: function() {
          var _stop = _asyncToGenerator(import_regenerator9.default.mark(function _callee2() {
            return import_regenerator9.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.childProcess) {
                      this.childProcess.kill();
                      this.childProcess = null;
                    }
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function stop() {
            return _stop.apply(this, arguments);
          }
          return stop;
        }()
      }, {
        key: "exit",
        value: function() {
          var _exit = _asyncToGenerator(import_regenerator9.default.mark(function _callee3() {
            var statusCode, _args3 = arguments;
            return import_regenerator9.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    statusCode = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : 0;
                    _context3.prev = 1;
                    _context3.next = 4;
                    return this.stop();
                  case 4:
                    process.exit(statusCode);
                    _context3.next = 11;
                    break;
                  case 7:
                    _context3.prev = 7;
                    _context3.t0 = _context3["catch"](1);
                    console.error(_context3.t0.message || _context3.t0);
                    process.exit(1);
                  case 11:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[1, 7]]);
          }));
          function exit() {
            return _exit.apply(this, arguments);
          }
          return exit;
        }()
      }]);
      return ChildProcessProxy3;
    }();
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/categories/mesh/mesh-utils.js
var init_mesh_utils = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/categories/mesh/mesh-utils.js"() {
  }
});

// node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/@loaders.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/index.js"() {
    init_assert();
    init_globals();
    init_create_worker();
    init_validate_loader_version();
    init_make_transform_iterator();
    init_get_transfer_list();
    init_worker_farm();
    init_worker_pool();
    init_worker_thread();
    init_library_utils();
    init_parse_json();
    init_buffer_utils();
    init_array_buffer_utils();
    init_memory_copy_utils();
    init_binary_copy_utils();
    init_encode_utils();
    init_get_first_characters();
    init_path();
    init_file_aliases();
    init_file_aliases();
    init_text_iterators();
    init_async_iteration();
    init_request_scheduler();
    init_child_process_proxy();
    init_mesh_utils();
    init_memory_copy_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/init.js
var version, init_default;
var init_init = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/init.js"() {
    init_esm2();
    version = true ? "2.3.13" : "";
    global_.loaders = Object.assign(global_.loaders || {}, {
      VERSION: version
    });
    init_default = global_.loaders;
  }
});

// node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
var isBoolean, isFunction, isObject, isPureObject, isPromise, isIterable, isAsyncIterable, isIterator, isResponse, isBlob, isWritableDOMStream, isReadableDOMStream, isBuffer2, isWritableNodeStream, isReadableNodeStream, isReadableStream, isWritableStream;
var init_is_type = __esm({
  "node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js"() {
    init_typeof();
    isBoolean = function isBoolean2(x) {
      return typeof x === "boolean";
    };
    isFunction = function isFunction2(x) {
      return typeof x === "function";
    };
    isObject = function isObject2(x) {
      return x !== null && _typeof(x) === "object";
    };
    isPureObject = function isPureObject2(x) {
      return isObject(x) && x.constructor === {}.constructor;
    };
    isPromise = function isPromise2(x) {
      return isObject(x) && isFunction(x.then);
    };
    isIterable = function isIterable2(x) {
      return x && typeof x[Symbol.iterator] === "function";
    };
    isAsyncIterable = function isAsyncIterable2(x) {
      return x && typeof x[Symbol.asyncIterator] === "function";
    };
    isIterator = function isIterator2(x) {
      return x && isFunction(x.next);
    };
    isResponse = function isResponse2(x) {
      return typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
    };
    isBlob = function isBlob2(x) {
      return typeof Blob !== "undefined" && x instanceof Blob;
    };
    isWritableDOMStream = function isWritableDOMStream2(x) {
      return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
    };
    isReadableDOMStream = function isReadableDOMStream2(x) {
      return typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
    };
    isBuffer2 = function isBuffer3(x) {
      return x && _typeof(x) === "object" && x.isBuffer;
    };
    isWritableNodeStream = function isWritableNodeStream2(x) {
      return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
    };
    isReadableNodeStream = function isReadableNodeStream2(x) {
      return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
    };
    isReadableStream = function isReadableStream2(x) {
      return isReadableDOMStream(x) || isReadableNodeStream(x);
    };
    isWritableStream = function isWritableStream2(x) {
      return isWritableDOMStream(x) || isWritableNodeStream(x);
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
function parseMIMEType(mimeString) {
  if (typeof mimeString !== "string") {
    return "";
  }
  var matches4 = mimeString.match(MIME_TYPE_PATTERN);
  if (matches4) {
    return matches4[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(dataUrl) {
  if (typeof dataUrl !== "string") {
    return "";
  }
  var matches4 = dataUrl.match(DATA_URL_PATTERN);
  if (matches4) {
    return matches4[1];
  }
  return "";
}
var DATA_URL_PATTERN, MIME_TYPE_PATTERN;
var init_mime_type_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js"() {
    DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
    MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
function getResourceUrlAndType(resource) {
  if (isResponse(resource)) {
    var contentType = parseMIMEType(resource.headers.get("content-type"));
    var urlType = parseMIMETypeFromURL(resource.url);
    return {
      url: stripQueryString(resource.url || ""),
      type: contentType || urlType || null
    };
  }
  if (isBlob(resource)) {
    return {
      url: stripQueryString(resource.name || ""),
      type: resource.type || ""
    };
  }
  if (typeof resource === "string") {
    return {
      url: stripQueryString(resource),
      type: parseMIMETypeFromURL(resource)
    };
  }
  return {
    url: "",
    type: ""
  };
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    return resource.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    return resource.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
var QUERY_STRING_PATTERN;
var init_resource_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js"() {
    init_is_type();
    init_mime_type_utils();
    QUERY_STRING_PATTERN = /\?.*/;
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
function makeResponse(_x) {
  return _makeResponse.apply(this, arguments);
}
function _makeResponse() {
  _makeResponse = _asyncToGenerator(import_regenerator10.default.mark(function _callee(resource) {
    var headers, contentLength, _getResourceUrlAndTyp, url, type, initialDataUrl, response;
    return import_regenerator10.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isResponse(resource)) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return", resource);
          case 2:
            headers = {};
            contentLength = getResourceContentLength(resource);
            if (contentLength >= 0) {
              headers["content-length"] = String(contentLength);
            }
            _getResourceUrlAndTyp = getResourceUrlAndType(resource), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;
            if (type) {
              headers["content-type"] = type;
            }
            _context.next = 9;
            return getInitialDataUrl(resource);
          case 9:
            initialDataUrl = _context.sent;
            if (initialDataUrl) {
              headers["x-first-bytes"] = initialDataUrl;
            }
            if (typeof resource === "string") {
              resource = new TextEncoder().encode(resource);
            }
            response = new Response(resource, {
              headers
            });
            Object.defineProperty(response, "url", {
              value: url
            });
            return _context.abrupt("return", response);
          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeResponse.apply(this, arguments);
}
function checkResponse(_x2) {
  return _checkResponse.apply(this, arguments);
}
function _checkResponse() {
  _checkResponse = _asyncToGenerator(import_regenerator10.default.mark(function _callee2(response) {
    var message;
    return import_regenerator10.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (response.ok) {
              _context2.next = 5;
              break;
            }
            _context2.next = 3;
            return getResponseError(response);
          case 3:
            message = _context2.sent;
            throw new Error(message);
          case 5:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _checkResponse.apply(this, arguments);
}
function getResponseError(_x3) {
  return _getResponseError.apply(this, arguments);
}
function _getResponseError() {
  _getResponseError = _asyncToGenerator(import_regenerator10.default.mark(function _callee3(response) {
    var message, contentType, text;
    return import_regenerator10.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
            _context3.prev = 1;
            contentType = response.headers.get("Content-Type");
            text = response.statusText;
            if (!contentType.includes("application/json")) {
              _context3.next = 11;
              break;
            }
            _context3.t0 = text;
            _context3.t1 = " ";
            _context3.next = 9;
            return response.text();
          case 9:
            _context3.t2 = _context3.sent;
            text = _context3.t0 += _context3.t1.concat.call(_context3.t1, _context3.t2);
          case 11:
            message += text;
            message = message.length > 60 ? "".concat(message.slice(60), "...") : message;
            _context3.next = 17;
            break;
          case 15:
            _context3.prev = 15;
            _context3.t3 = _context3["catch"](1);
          case 17:
            return _context3.abrupt("return", message);
          case 18:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[1, 15]]);
  }));
  return _getResponseError.apply(this, arguments);
}
function getInitialDataUrl(_x4) {
  return _getInitialDataUrl.apply(this, arguments);
}
function _getInitialDataUrl() {
  _getInitialDataUrl = _asyncToGenerator(import_regenerator10.default.mark(function _callee4(resource) {
    var INITIAL_DATA_LENGTH, blobSlice, slice, base64;
    return import_regenerator10.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            INITIAL_DATA_LENGTH = 5;
            if (!(typeof resource === "string")) {
              _context4.next = 3;
              break;
            }
            return _context4.abrupt("return", "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH)));
          case 3:
            if (!(resource instanceof Blob)) {
              _context4.next = 8;
              break;
            }
            blobSlice = resource.slice(0, 5);
            _context4.next = 7;
            return new Promise(function(resolve) {
              var reader = new FileReader();
              reader.onload = function(event) {
                return resolve(event.target && event.target.result);
              };
              reader.readAsDataURL(blobSlice);
            });
          case 7:
            return _context4.abrupt("return", _context4.sent);
          case 8:
            if (!(resource instanceof ArrayBuffer)) {
              _context4.next = 12;
              break;
            }
            slice = resource.slice(0, INITIAL_DATA_LENGTH);
            base64 = arrayBufferToBase64(slice);
            return _context4.abrupt("return", "data:base64,".concat(base64));
          case 12:
            return _context4.abrupt("return", null);
          case 13:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _getInitialDataUrl.apply(this, arguments);
}
function arrayBufferToBase64(buffer) {
  var binary = "";
  var bytes = new Uint8Array(buffer);
  for (var i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}
var import_regenerator10;
var init_response_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js"() {
    import_regenerator10 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_is_type();
    init_resource_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-error-message.js
function getErrorMessageFromResponse(_x) {
  return _getErrorMessageFromResponse.apply(this, arguments);
}
function _getErrorMessageFromResponse() {
  _getErrorMessageFromResponse = _asyncToGenerator(import_regenerator11.default.mark(function _callee(response) {
    var message, contentType;
    return import_regenerator11.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            message = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
            _context.prev = 1;
            contentType = response.headers.get("Content-Type");
            if (!contentType.includes("application/json")) {
              _context.next = 10;
              break;
            }
            _context.t0 = message;
            _context.next = 7;
            return response.text();
          case 7:
            message = _context.t0 += _context.sent;
            _context.next = 11;
            break;
          case 10:
            message += response.statusText;
          case 11:
            _context.next = 16;
            break;
          case 13:
            _context.prev = 13;
            _context.t1 = _context["catch"](1);
            return _context.abrupt("return", message);
          case 16:
            return _context.abrupt("return", message);
          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 13]]);
  }));
  return _getErrorMessageFromResponse.apply(this, arguments);
}
var import_regenerator11;
var init_fetch_error_message = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-error-message.js"() {
    import_regenerator11 = __toESM(require_regenerator());
    init_asyncToGenerator();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
function fetchFile(_x) {
  return _fetchFile.apply(this, arguments);
}
function _fetchFile() {
  _fetchFile = _asyncToGenerator(import_regenerator12.default.mark(function _callee(url) {
    var options, response, _args = arguments;
    return import_regenerator12.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
            if (!(typeof url !== "string")) {
              _context.next = 5;
              break;
            }
            _context.next = 4;
            return makeResponse(url);
          case 4:
            return _context.abrupt("return", _context.sent);
          case 5:
            url = resolvePath(url);
            _context.next = 8;
            return fetch(url, options);
          case 8:
            response = _context.sent;
            if (!(!response.ok && options["throws"])) {
              _context.next = 15;
              break;
            }
            _context.t0 = Error;
            _context.next = 13;
            return getErrorMessageFromResponse(response);
          case 13:
            _context.t1 = _context.sent;
            throw new _context.t0(_context.t1);
          case 15:
            return _context.abrupt("return", response);
          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}
var import_regenerator12;
var init_fetch_file = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js"() {
    import_regenerator12 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_esm2();
    init_response_utils();
    init_fetch_error_message();
  }
});

// (disabled):node_modules/@loaders.gl/core/dist/esm/node/read-file-sync.node
var require_read_file_sync = __commonJS({
  "(disabled):node_modules/@loaders.gl/core/dist/esm/node/read-file-sync.node"() {
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.browser.js
function readFileSyncBrowser(uri, options) {
  options = getReadFileOptions(options);
  if (isDataURL(uri)) {
  }
  if (!options.nothrow) {
    assert(false);
  }
  return null;
}
function getReadFileOptions() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;
  return options;
}
var DEFAULT_OPTIONS, isDataURL;
var init_read_file_browser = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.browser.js"() {
    init_esm2();
    DEFAULT_OPTIONS = {
      dataType: "arraybuffer",
      nothrow: true
    };
    isDataURL = function isDataURL2(url) {
      return url.startsWith("data:");
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js
function readFileSync2(url) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  url = resolvePath(url);
  if (!isBrowser && void 0) {
    return (void 0)(url, options);
  }
  return readFileSyncBrowser(url, options);
}
var node4;
var init_read_file = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/read-file.js"() {
    init_esm2();
    node4 = __toESM(require_read_file_sync());
    init_read_file_browser();
  }
});

// (disabled):node_modules/@loaders.gl/core/dist/esm/node/write-file.node
var require_write_file = __commonJS({
  "(disabled):node_modules/@loaders.gl/core/dist/esm/node/write-file.node"() {
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js
function writeFile2(filePath, arrayBufferOrString, options) {
  filePath = resolvePath(filePath);
  if (!isBrowser && void 0) {
    return (void 0)(filePath, arrayBufferOrString, options);
  }
  return assert(false);
}
function writeFileSync2(filePath, arrayBufferOrString, options) {
  filePath = resolvePath(filePath);
  if (!isBrowser && void 0) {
    return (void 0)(filePath, arrayBufferOrString, options);
  }
  return assert(false);
}
var node5;
var init_write_file = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js"() {
    init_esm2();
    node5 = __toESM(require_write_file());
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
var NullLog, ConsoleLog;
var init_loggers = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js"() {
    init_classCallCheck();
    init_createClass();
    NullLog = function() {
      function NullLog2() {
        _classCallCheck(this, NullLog2);
      }
      _createClass(NullLog2, [{
        key: "log",
        value: function log3() {
          return function(_) {
          };
        }
      }, {
        key: "info",
        value: function info() {
          return function(_) {
          };
        }
      }, {
        key: "warn",
        value: function warn() {
          return function(_) {
          };
        }
      }, {
        key: "error",
        value: function error2() {
          return function(_) {
          };
        }
      }]);
      return NullLog2;
    }();
    ConsoleLog = function() {
      function ConsoleLog2() {
        _classCallCheck(this, ConsoleLog2);
        this.console = console;
      }
      _createClass(ConsoleLog2, [{
        key: "log",
        value: function log3() {
          var _this$console$log;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return (_this$console$log = this.console.log).bind.apply(_this$console$log, [this.console].concat(args));
        }
      }, {
        key: "info",
        value: function info() {
          var _this$console$info;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return (_this$console$info = this.console.info).bind.apply(_this$console$info, [this.console].concat(args));
        }
      }, {
        key: "warn",
        value: function warn() {
          var _this$console$warn;
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }
          return (_this$console$warn = this.console.warn).bind.apply(_this$console$warn, [this.console].concat(args));
        }
      }, {
        key: "error",
        value: function error2() {
          var _this$console$error;
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return (_this$console$error = this.console.error).bind.apply(_this$console$error, [this.console].concat(args));
        }
      }]);
      return ConsoleLog2;
    }();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
function _createForOfIteratorHelper2(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray3(o, minLen);
}
function _arrayLikeToArray3(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function setGlobalOptions(options) {
  var state = getGlobalLoaderState();
  var globalOptions = getGlobalLoaderOptions();
  state.globalOptions = normalizeOptionsInternal(globalOptions, options);
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function getFetchFunction(options, context) {
  var globalOptions = getGlobalLoaderOptions();
  var fetch2 = options.fetch || globalOptions.fetch;
  if (typeof fetch2 === "function") {
    return fetch2;
  }
  if (isObject(fetch2)) {
    return function(url) {
      return fetchFile(url, fetch2);
    };
  }
  if (context && context.fetch) {
    return context.fetch;
  }
  return function(url) {
    return fetchFile(url, options);
  };
}
function validateOptions(options, loaders) {
  var log3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : console;
  validateOptionsObject(options, null, log3, DEFAULT_LOADER_OPTIONS, DEPRECATED_LOADER_OPTIONS, loaders);
  var _iterator = _createForOfIteratorHelper2(loaders), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var loader = _step.value;
      var idOptions = options && options[loader.id] || {};
      var loaderOptions = loader.options && loader.options[loader.id] || {};
      var deprecatedOptions = loader.defaultOptions && loader.defaultOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, log3, loaderOptions, deprecatedOptions, loaders);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function validateOptionsObject(options, id, log3, defaultOptions, deprecatedOptions, loaders) {
  var loaderName = id || "Top level";
  var prefix = id ? "".concat(id, ".") : "";
  for (var key in options) {
    var isSubOptions = !id && isObject(options[key]);
    if (!(key in defaultOptions)) {
      if (key in deprecatedOptions) {
        log3.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' deprecated, use '").concat(deprecatedOptions[key], "'"));
      } else if (!isSubOptions) {
        var suggestion = findSimilarOption(key, loaders);
        log3.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion));
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  var lowerCaseOptionKey = optionKey.toLowerCase();
  var bestSuggestion = "";
  var _iterator2 = _createForOfIteratorHelper2(loaders), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var loader = _step2.value;
      for (var key in loader.options) {
        if (optionKey === key) {
          return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
        var lowerCaseKey = key.toLowerCase();
        var isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  var loaderDefaultOptions = loader.options || {};
  var mergedOptions = _objectSpread3({}, loaderDefaultOptions);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog();
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  addUrlOptions(mergedOptions, url);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (var key in options) {
    if (key in options) {
      var value4 = options[key];
      if (isPureObject(value4) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = _objectSpread3(_objectSpread3({}, mergedOptions[key]), options[key]);
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !options.baseUri) {
    options.baseUri = url;
  }
}
var DEFAULT_LOADER_OPTIONS, DEPRECATED_LOADER_OPTIONS, getGlobalLoaderState, getGlobalLoaderOptions;
var init_option_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js"() {
    init_defineProperty();
    init_esm2();
    init_is_type();
    init_fetch_file();
    init_loggers();
    DEFAULT_LOADER_OPTIONS = {
      baseUri: "",
      fetch: null,
      CDN: "https://unpkg.com/@loaders.gl",
      worker: true,
      log: new ConsoleLog(),
      metadata: false,
      transforms: [],
      reuseWorkers: true
    };
    DEPRECATED_LOADER_OPTIONS = {
      dataType: "(no longer used)",
      method: "fetch.method",
      headers: "fetch.headers",
      body: "fetch.body",
      mode: "fetch.mode",
      credentials: "fetch.credentials",
      cache: "fetch.cache",
      redirect: "fetch.redirect",
      referrer: "fetch.referrer",
      referrerPolicy: "fetch.referrerPolicy",
      integrity: "fetch.integrity",
      keepalive: "fetch.keepalive",
      signal: "fetch.signal"
    };
    getGlobalLoaderState = function getGlobalLoaderState2() {
      global_.loaders = global_.loaders || {};
      var loaders = global_.loaders;
      loaders._state = loaders._state || {};
      return loaders._state;
    };
    getGlobalLoaderOptions = function getGlobalLoaderOptions2() {
      var state = getGlobalLoaderState();
      state.globalOptions = state.globalOptions || _objectSpread3({}, DEFAULT_LOADER_OPTIONS);
      return state.globalOptions;
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/set-loader-options.js
function setLoaderOptions(options) {
  setGlobalOptions(options);
}
var init_set_loader_options = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/set-loader-options.js"() {
    init_option_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  var hasParser = loader.parseTextSync || loader.parseSync || loader.parse || loader.parseStream || loader.parseInBatches;
  var loaderOptions = loader.options && loader.options[loader.id];
  hasParser = hasParser || loaderOptions && loaderOptions.workerUrl;
  return hasParser;
}
function normalizeLoader(loader) {
  assert(loader, "null loader");
  assert(isLoaderObject(loader), "invalid loader");
  var options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = _objectSpread4(_objectSpread4({}, loader), {}, {
      options: _objectSpread4(_objectSpread4({}, loader.options), options)
    });
  }
  if (loader.extension) {
    loader.extensions = loader.extensions || loader.extension;
    delete loader.extension;
  }
  if (!Array.isArray(loader.extensions)) {
    loader.extensions = [loader.extensions];
  }
  assert(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);
  if (loader.parseTextSync || loader.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}
var init_normalize_loader = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js"() {
    init_defineProperty();
    init_esm2();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
function _createForOfIteratorHelper3(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray4(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray4(o, minLen);
}
function _arrayLikeToArray4(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function registerLoaders(loaders) {
  var loaderRegistry = getGlobalLoaderRegistry();
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  var _iterator = _createForOfIteratorHelper3(loaders), _step;
  try {
    var _loop = function _loop2() {
      var loader = _step.value;
      var normalizedLoader = normalizeLoader(loader);
      if (!loaderRegistry.find(function(registeredLoader) {
        return normalizedLoader === registeredLoader;
      })) {
        loaderRegistry.unshift(normalizedLoader);
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}
function _unregisterLoaders() {
  var state = getGlobalLoaderState();
  state.loaderRegistry = [];
}
var getGlobalLoaderRegistry;
var init_register_loaders = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js"() {
    init_normalize_loader();
    init_option_utils();
    getGlobalLoaderRegistry = function getGlobalLoaderRegistry2() {
      var state = getGlobalLoaderState();
      state.loaderRegistry = state.loaderRegistry || [];
      return state.loaderRegistry;
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/string-iterator.js
function makeStringIterator(string) {
  var options, _options$chunkSize, chunkSize, offset, textEncoder, chunkLength, chunk, _args = arguments;
  return import_regenerator13.default.wrap(function makeStringIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;
          offset = 0;
          textEncoder = new TextEncoder();
        case 4:
          if (!(offset < string.length)) {
            _context.next = 12;
            break;
          }
          chunkLength = Math.min(string.length - offset, chunkSize);
          chunk = string.slice(offset, offset + chunkLength);
          offset += chunkLength;
          _context.next = 10;
          return textEncoder.encode(chunk);
        case 10:
          _context.next = 4;
          break;
        case 12:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
var import_regenerator13, _marked;
var init_string_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/string-iterator.js"() {
    import_regenerator13 = __toESM(require_regenerator());
    _marked = import_regenerator13.default.mark(makeStringIterator);
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/array-buffer-iterator.js
function makeArrayBufferIterator(arrayBuffer2) {
  var options, _options$chunkSize, chunkSize, byteOffset, chunkByteLength, chunk, sourceArray, chunkArray, _args = arguments;
  return import_regenerator14.default.wrap(function makeArrayBufferIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
          _options$chunkSize = options.chunkSize, chunkSize = _options$chunkSize === void 0 ? 256 * 1024 : _options$chunkSize;
          byteOffset = 0;
        case 3:
          if (!(byteOffset < arrayBuffer2.byteLength)) {
            _context.next = 14;
            break;
          }
          chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
          chunk = new ArrayBuffer(chunkByteLength);
          sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
          chunkArray = new Uint8Array(chunk);
          chunkArray.set(sourceArray);
          byteOffset += chunkByteLength;
          _context.next = 12;
          return chunk;
        case 12:
          _context.next = 3;
          break;
        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, _marked2);
}
var import_regenerator14, _marked2;
var init_array_buffer_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/array-buffer-iterator.js"() {
    import_regenerator14 = __toESM(require_regenerator());
    _marked2 = import_regenerator14.default.mark(makeArrayBufferIterator);
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/blob-iterator.js
function makeBlobIterator(_x) {
  return _makeBlobIterator.apply(this, arguments);
}
function _makeBlobIterator() {
  _makeBlobIterator = _wrapAsyncGenerator(import_regenerator15.default.mark(function _callee(file) {
    var options, chunkSize, offset, end, chunk, _args = arguments;
    return import_regenerator15.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
            chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;
            offset = 0;
          case 3:
            if (!(offset < file.size)) {
              _context.next = 13;
              break;
            }
            end = offset + chunkSize;
            _context.next = 7;
            return _awaitAsyncGenerator(readFileSlice(file, offset, end));
          case 7:
            chunk = _context.sent;
            offset = end;
            _context.next = 11;
            return chunk;
          case 11:
            _context.next = 3;
            break;
          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _makeBlobIterator.apply(this, arguments);
}
function readFileSlice(_x2, _x3, _x4) {
  return _readFileSlice.apply(this, arguments);
}
function _readFileSlice() {
  _readFileSlice = _asyncToGenerator(import_regenerator15.default.mark(function _callee2(file, offset, end) {
    return import_regenerator15.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return new Promise(function(resolve, reject) {
              var slice = file.slice(offset, end);
              var fileReader = new FileReader();
              fileReader.onload = function(event) {
                return resolve(event.target && event.target.result);
              };
              fileReader.onerror = function(error2) {
                return reject(error2);
              };
              fileReader.readAsArrayBuffer(slice);
            });
          case 2:
            return _context2.abrupt("return", _context2.sent);
          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _readFileSlice.apply(this, arguments);
}
var import_regenerator15, DEFAULT_CHUNK_SIZE;
var init_blob_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/blob-iterator.js"() {
    init_asyncToGenerator();
    import_regenerator15 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    DEFAULT_CHUNK_SIZE = 1024 * 1024;
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/stream-iterator.js
function makeStreamIterator(stream) {
  if (isBrowser || nodeVersion >= 10) {
    if (typeof stream[Symbol.asyncIterator] === "function") {
      return makeToArrayBufferIterator(stream);
    }
    if (typeof stream.getIterator === "function") {
      return stream.getIterator();
    }
  }
  return isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}
function makeToArrayBufferIterator(_x) {
  return _makeToArrayBufferIterator.apply(this, arguments);
}
function _makeToArrayBufferIterator() {
  _makeToArrayBufferIterator = _wrapAsyncGenerator(import_regenerator16.default.mark(function _callee(asyncIterator) {
    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;
    return import_regenerator16.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 2;
            _iterator = _asyncIterator(asyncIterator);
          case 4:
            _context.next = 6;
            return _awaitAsyncGenerator(_iterator.next());
          case 6:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 10;
            return _awaitAsyncGenerator(_step.value);
          case 10:
            _value = _context.sent;
            if (_iteratorNormalCompletion) {
              _context.next = 18;
              break;
            }
            chunk = _value;
            _context.next = 15;
            return toArrayBuffer3(chunk);
          case 15:
            _iteratorNormalCompletion = true;
            _context.next = 4;
            break;
          case 18:
            _context.next = 24;
            break;
          case 20:
            _context.prev = 20;
            _context.t0 = _context["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context.t0;
          case 24:
            _context.prev = 24;
            _context.prev = 25;
            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 29;
              break;
            }
            _context.next = 29;
            return _awaitAsyncGenerator(_iterator["return"]());
          case 29:
            _context.prev = 29;
            if (!_didIteratorError) {
              _context.next = 32;
              break;
            }
            throw _iteratorError;
          case 32:
            return _context.finish(29);
          case 33:
            return _context.finish(24);
          case 34:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 20, 24, 34], [25, , 29, 33]]);
  }));
  return _makeToArrayBufferIterator.apply(this, arguments);
}
function makeBrowserStreamIterator(_x2) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}
function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = _wrapAsyncGenerator(import_regenerator16.default.mark(function _callee2(stream) {
    var reader, _yield$_awaitAsyncGen, done, value4;
    return import_regenerator16.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            reader = stream.getReader();
            _context2.prev = 1;
          case 2:
            if (false) {
              _context2.next = 14;
              break;
            }
            _context2.next = 5;
            return _awaitAsyncGenerator(reader.read());
          case 5:
            _yield$_awaitAsyncGen = _context2.sent;
            done = _yield$_awaitAsyncGen.done;
            value4 = _yield$_awaitAsyncGen.value;
            if (!done) {
              _context2.next = 10;
              break;
            }
            return _context2.abrupt("return");
          case 10:
            _context2.next = 12;
            return toArrayBuffer3(value4);
          case 12:
            _context2.next = 2;
            break;
          case 14:
            _context2.next = 19;
            break;
          case 16:
            _context2.prev = 16;
            _context2.t0 = _context2["catch"](1);
            reader.releaseLock();
          case 19:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[1, 16]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}
function makeNodeStreamIterator(_x3) {
  return _makeNodeStreamIterator.apply(this, arguments);
}
function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = _wrapAsyncGenerator(import_regenerator16.default.mark(function _callee3(stream) {
    var data;
    return import_regenerator16.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return _awaitAsyncGenerator(stream);
          case 2:
            stream = _context3.sent;
          case 3:
            if (false) {
              _context3.next = 15;
              break;
            }
            data = stream.read();
            if (!(data !== null)) {
              _context3.next = 9;
              break;
            }
            _context3.next = 8;
            return toArrayBuffer3(data);
          case 8:
            return _context3.abrupt("continue", 3);
          case 9:
            if (!stream._readableState.ended) {
              _context3.next = 11;
              break;
            }
            return _context3.abrupt("return");
          case 11:
            _context3.next = 13;
            return _awaitAsyncGenerator(onceReadable(stream));
          case 13:
            _context3.next = 3;
            break;
          case 15:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}
function onceReadable(_x4) {
  return _onceReadable.apply(this, arguments);
}
function _onceReadable() {
  _onceReadable = _asyncToGenerator(import_regenerator16.default.mark(function _callee4(stream) {
    return import_regenerator16.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", new Promise(function(resolve) {
              stream.once("readable", resolve);
            }));
          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _onceReadable.apply(this, arguments);
}
var import_regenerator16;
var init_stream_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/stream-iterator.js"() {
    init_asyncToGenerator();
    import_regenerator16 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
    init_esm2();
  }
});

// node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/make-iterator.js
function makeIterator(data) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data);
  }
  if (isResponse(data)) {
    return makeStreamIterator(data.body);
  }
  return assert(false);
}
var init_make_iterator = __esm({
  "node_modules/@loaders.gl/core/dist/esm/iterator-utils/make-iterator/make-iterator.js"() {
    init_string_iterator();
    init_array_buffer_iterator();
    init_blob_iterator();
    init_esm2();
    init_stream_iterator();
    init_is_type();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
function getArrayBufferOrStringFromDataSync(data, loader) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    var arrayBuffer2 = data;
    if (loader.text && !loader.binary) {
      var textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer2);
    }
    return arrayBuffer2;
  }
  if (ArrayBuffer.isView(data) || isBuffer2(data)) {
    if (loader.text && !loader.binary) {
      var _textDecoder = new TextDecoder("utf8");
      return _textDecoder.decode(data);
    }
    var _arrayBuffer = data.buffer;
    var byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== _arrayBuffer.byteLength) {
      _arrayBuffer = _arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return _arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
function getArrayBufferOrStringFromData(_x, _x2) {
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}
function _getArrayBufferOrStringFromData() {
  _getArrayBufferOrStringFromData = _asyncToGenerator(import_regenerator17.default.mark(function _callee(data, loader) {
    var isArrayBuffer, response;
    return import_regenerator17.default.wrap(function _callee$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
            if (!(typeof data === "string" || isArrayBuffer)) {
              _context3.next = 3;
              break;
            }
            return _context3.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader));
          case 3:
            if (!isBlob(data)) {
              _context3.next = 7;
              break;
            }
            _context3.next = 6;
            return makeResponse(data);
          case 6:
            data = _context3.sent;
          case 7:
            if (!isResponse(data)) {
              _context3.next = 21;
              break;
            }
            response = data;
            _context3.next = 11;
            return checkResponse(response);
          case 11:
            if (!loader.binary) {
              _context3.next = 17;
              break;
            }
            _context3.next = 14;
            return response.arrayBuffer();
          case 14:
            _context3.t0 = _context3.sent;
            _context3.next = 20;
            break;
          case 17:
            _context3.next = 19;
            return response.text();
          case 19:
            _context3.t0 = _context3.sent;
          case 20:
            return _context3.abrupt("return", _context3.t0);
          case 21:
            if (isReadableStream(data)) {
              data = makeIterator(data);
            }
            if (!(isIterable(data) || isAsyncIterable(data))) {
              _context3.next = 24;
              break;
            }
            return _context3.abrupt("return", concatenateChunksAsync(data));
          case 24:
            throw new Error(ERR_DATA);
          case 25:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee);
  }));
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}
function getAsyncIteratorFromData(_x3) {
  return _getAsyncIteratorFromData.apply(this, arguments);
}
function _getAsyncIteratorFromData() {
  _getAsyncIteratorFromData = _asyncToGenerator(import_regenerator17.default.mark(function _callee2(data) {
    return import_regenerator17.default.wrap(function _callee2$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!isIterator(data)) {
              _context4.next = 2;
              break;
            }
            return _context4.abrupt("return", data);
          case 2:
            if (!isResponse(data)) {
              _context4.next = 6;
              break;
            }
            _context4.next = 5;
            return checkResponse(data);
          case 5:
            return _context4.abrupt("return", makeIterator(data.body));
          case 6:
            if (!(isBlob(data) || isReadableStream(data))) {
              _context4.next = 8;
              break;
            }
            return _context4.abrupt("return", makeIterator(data));
          case 8:
            if (!isAsyncIterable(data)) {
              _context4.next = 10;
              break;
            }
            return _context4.abrupt("return", data[Symbol.asyncIterator]());
          case 10:
            return _context4.abrupt("return", getIteratorFromData(data));
          case 11:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee2);
  }));
  return _getAsyncIteratorFromData.apply(this, arguments);
}
function getIteratorFromData(data) {
  if (ArrayBuffer.isView(data)) {
    return import_regenerator17.default.mark(function oneChunk() {
      return import_regenerator17.default.wrap(function oneChunk$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return data.buffer;
            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, oneChunk);
    })();
  }
  if (data instanceof ArrayBuffer) {
    return import_regenerator17.default.mark(function oneChunk() {
      return import_regenerator17.default.wrap(function oneChunk$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return data;
            case 2:
            case "end":
              return _context2.stop();
          }
        }
      }, oneChunk);
    })();
  }
  if (isIterator(data)) {
    return data;
  }
  if (isIterable(data)) {
    return data[Symbol.iterator]();
  }
  throw new Error(ERR_DATA);
}
function getReadableStream(_x4) {
  return _getReadableStream.apply(this, arguments);
}
function _getReadableStream() {
  _getReadableStream = _asyncToGenerator(import_regenerator17.default.mark(function _callee3(data) {
    var response;
    return import_regenerator17.default.wrap(function _callee3$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!isReadableStream(data)) {
              _context5.next = 2;
              break;
            }
            return _context5.abrupt("return", data);
          case 2:
            if (!isResponse(data)) {
              _context5.next = 4;
              break;
            }
            return _context5.abrupt("return", data.body);
          case 4:
            _context5.next = 6;
            return makeResponse(data);
          case 6:
            response = _context5.sent;
            return _context5.abrupt("return", response.body);
          case 8:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee3);
  }));
  return _getReadableStream.apply(this, arguments);
}
var import_regenerator17, ERR_DATA;
var init_get_data = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js"() {
    import_regenerator17 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_esm2();
    init_is_type();
    init_make_iterator();
    init_response_utils();
    ERR_DATA = "Cannot convert supplied data type";
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/context-utils.js
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function getLoaderContext(context, options) {
  var previousContext = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  if (previousContext) {
    return previousContext;
  }
  context = _objectSpread5({
    fetch: getFetchFunction(options || {}, context)
  }, context);
  if (!Array.isArray(context.loaders)) {
    context.loaders = null;
  }
  return context;
}
function getLoaders(loaders, context) {
  if (!context && loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  var candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    var contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [].concat(_toConsumableArray(candidateLoaders), _toConsumableArray(contextLoaders)) : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
}
var init_context_utils = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/context-utils.js"() {
    init_toConsumableArray();
    init_defineProperty();
    init_option_utils();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/parse-with-worker.js
function canParseWithWorker(loader, data, options, context) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  var loaderOptions = options && options[loader.id];
  if (options.worker === "local" && loaderOptions && loaderOptions.localWorkerUrl || options.worker && loaderOptions && loaderOptions.workerUrl) {
    return loader.useWorker ? loader.useWorker(options) : true;
  }
  return false;
}
function parseWithWorker(loader, data, options, context) {
  var _ref = options || {}, worker = _ref.worker;
  var loaderOptions = options && options[loader.id] || {};
  var workerUrl = worker === "local" ? loaderOptions.localWorkerUrl : loaderOptions.workerUrl;
  var workerSource = "url(".concat(workerUrl, ")");
  var workerName = loader.name;
  var workerFarm = getWorkerFarm(options);
  options = JSON.parse(JSON.stringify(options));
  var warning = loader.version !== VERSION2 ? "(core version ".concat(VERSION2, ")") : "";
  return workerFarm.process(workerSource, "".concat(workerName, "-worker@").concat(loader.version).concat(warning), {
    arraybuffer: toArrayBuffer3(data),
    options,
    source: "loaders.gl@".concat(VERSION2),
    type: "parse"
  });
}
function getWorkerFarm() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var props = {};
  if (options.maxConcurrency) {
    props.maxConcurrency = options.maxConcurrency;
  }
  if (options.onDebug) {
    props.onDebug = options.onDebug;
  }
  if ("reuseWorkers" in options) {
    props.reuseWorkers = options.reuseWorkers;
  }
  if (!_workerFarm) {
    _workerFarm = new WorkerFarm({
      onMessage: onWorkerMessage2
    });
  }
  _workerFarm.setProps(props);
  return _workerFarm;
}
function onWorkerMessage2(_x) {
  return _onWorkerMessage.apply(this, arguments);
}
function _onWorkerMessage() {
  _onWorkerMessage = _asyncToGenerator(import_regenerator18.default.mark(function _callee(_ref2) {
    var worker, data, resolve, reject, result;
    return import_regenerator18.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            worker = _ref2.worker, data = _ref2.data, resolve = _ref2.resolve, reject = _ref2.reject;
            _context.t0 = data.type;
            _context.next = _context.t0 === "done" ? 4 : _context.t0 === "parse" ? 6 : _context.t0 === "error" ? 17 : 19;
            break;
          case 4:
            resolve(data.result);
            return _context.abrupt("break", 19);
          case 6:
            _context.prev = 6;
            _context.next = 9;
            return parse(data.arraybuffer, data.options, data.url);
          case 9:
            result = _context.sent;
            worker.postMessage({
              type: "parse-done",
              id: data.id,
              result
            }, getTransferList(result));
            _context.next = 16;
            break;
          case 13:
            _context.prev = 13;
            _context.t1 = _context["catch"](6);
            worker.postMessage({
              type: "parse-error",
              id: data.id,
              message: _context.t1.message
            });
          case 16:
            return _context.abrupt("break", 19);
          case 17:
            reject(data.message);
            return _context.abrupt("break", 19);
          case 19:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[6, 13]]);
  }));
  return _onWorkerMessage.apply(this, arguments);
}
var import_regenerator18, VERSION2, _workerFarm;
var init_parse_with_worker = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/parse-with-worker.js"() {
    import_regenerator18 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_esm2();
    init_parse();
    VERSION2 = true ? "2.3.13" : "latest";
    _workerFarm = null;
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createForOfIteratorHelper4(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray5(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray5(o, minLen);
}
function _arrayLikeToArray5(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function selectLoader(_x) {
  return _selectLoader.apply(this, arguments);
}
function _selectLoader() {
  _selectLoader = _asyncToGenerator(import_regenerator19.default.mark(function _callee(data) {
    var loaders, options, context, loader, _args = arguments;
    return import_regenerator19.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            loaders = _args.length > 1 && _args[1] !== void 0 ? _args[1] : [];
            options = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {};
            context = _args.length > 3 && _args[3] !== void 0 ? _args[3] : {};
            loader = selectLoaderSync(data, loaders, _objectSpread6(_objectSpread6({}, options), {}, {
              nothrow: true
            }), context);
            if (!loader) {
              _context.next = 6;
              break;
            }
            return _context.abrupt("return", loader);
          case 6:
            if (!isBlob(data)) {
              _context.next = 11;
              break;
            }
            _context.next = 9;
            return readFileSlice(data, 0, 10);
          case 9:
            data = _context.sent;
            loader = selectLoaderSync(data, loaders, options, context);
          case 11:
            if (!(!loader && !options.nothrow)) {
              _context.next = 13;
              break;
            }
            throw new Error(getNoValidLoaderMessage(data));
          case 13:
            return _context.abrupt("return", loader);
          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _selectLoader.apply(this, arguments);
}
function selectLoaderSync(data) {
  var loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var context = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  loaders = [].concat(_toConsumableArray(loaders || []), _toConsumableArray(getRegisteredLoaders()));
  normalizeLoaders(loaders);
  var _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url, type = _getResourceUrlAndTyp.type;
  var loader = findLoaderByUrl(loaders, url || context.url);
  loader = loader || findLoaderByContentType(loaders, type);
  loader = loader || findLoaderByExamingInitialData(loaders, data);
  if (!loader && !options.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function getNoValidLoaderMessage(data) {
  var _getResourceUrlAndTyp2 = getResourceUrlAndType(data), url = _getResourceUrlAndTyp2.url, type = _getResourceUrlAndTyp2.type;
  var message = "No valid loader found";
  if (data) {
    message += ' data: "'.concat(getFirstCharacters2(data), '", contentType: "').concat(type, '"');
  }
  if (url) {
    message += " url: ".concat(url);
  }
  return message;
}
function normalizeLoaders(loaders) {
  var _iterator = _createForOfIteratorHelper4(loaders), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var loader = _step.value;
      normalizeLoader(loader);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function findLoaderByUrl(loaders, url) {
  var match = url && url.match(EXT_PATTERN);
  var extension = match && match[1];
  return extension && findLoaderByExtension(loaders, extension);
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  var _iterator2 = _createForOfIteratorHelper4(loaders), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var loader = _step2.value;
      var _iterator3 = _createForOfIteratorHelper4(loader.extensions), _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
          var loaderExtension = _step3.value;
          if (loaderExtension.toLowerCase() === extension) {
            return loader;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return null;
}
function findLoaderByContentType(loaders, mimeType) {
  var _iterator4 = _createForOfIteratorHelper4(loaders), _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
      var loader = _step4.value;
      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }
      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return null;
}
function findLoaderByExamingInitialData(loaders, data) {
  if (!data) {
    return null;
  }
  var _iterator5 = _createForOfIteratorHelper4(loaders), _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
      var loader = _step5.value;
      if (typeof data === "string") {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        var byteOffset = 0;
        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  return null;
}
function testDataAgainstText(data, loader) {
  return loader.testText && loader.testText(data);
}
function testDataAgainstBinary(data, byteOffset, loader) {
  var tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some(function(test) {
    return testBinary(data, byteOffset, loader, test);
  });
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (_typeof(test)) {
    case "function":
      return test(data, loader);
    case "string":
      var magic = getMagicString2(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters2(data) {
  var length5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  if (typeof data === "string") {
    return data.slice(0, length5);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString2(data.buffer, data.byteOffset, length5);
  } else if (data instanceof ArrayBuffer) {
    var byteOffset = 0;
    return getMagicString2(data, byteOffset, length5);
  }
  return "";
}
function getMagicString2(arrayBuffer2, byteOffset, length5) {
  if (arrayBuffer2.byteLength < byteOffset + length5) {
    return "";
  }
  var dataView = new DataView(arrayBuffer2);
  var magic = "";
  for (var i = 0; i < length5; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}
var import_regenerator19, EXT_PATTERN;
var init_select_loader = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js"() {
    import_regenerator19 = __toESM(require_regenerator());
    init_defineProperty();
    init_typeof();
    init_toConsumableArray();
    init_asyncToGenerator();
    init_esm2();
    init_normalize_loader();
    init_resource_utils();
    init_register_loaders();
    init_blob_iterator();
    init_is_type();
    EXT_PATTERN = /\.([^.]+)$/;
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}
function _parse() {
  _parse = _asyncToGenerator(import_regenerator20.default.mark(function _callee(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, candidateLoaders, loader;
    return import_regenerator20.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assert(!context || typeof context !== "string", "parse no longer accepts final url");
            if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
              context = options;
              options = loaders;
              loaders = null;
            }
            _context.next = 4;
            return data;
          case 4:
            data = _context.sent;
            options = options || {};
            _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;
            candidateLoaders = getLoaders(loaders, context);
            _context.next = 10;
            return selectLoader(data, candidateLoaders, options);
          case 10:
            loader = _context.sent;
            if (loader) {
              _context.next = 13;
              break;
            }
            return _context.abrupt("return", null);
          case 13:
            options = normalizeOptions(options, loader, candidateLoaders, url);
            context = getLoaderContext({
              url,
              parse,
              loaders: candidateLoaders
            }, options, context);
            _context.next = 17;
            return parseWithLoader(loader, data, options, context);
          case 17:
            return _context.abrupt("return", _context.sent);
          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}
function parseWithLoader(_x5, _x6, _x7, _x8) {
  return _parseWithLoader.apply(this, arguments);
}
function _parseWithLoader() {
  _parseWithLoader = _asyncToGenerator(import_regenerator20.default.mark(function _callee2(loader, data, options, context) {
    return import_regenerator20.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            validateLoaderVersion(loader);
            _context2.next = 3;
            return getArrayBufferOrStringFromData(data, loader);
          case 3:
            data = _context2.sent;
            if (!(loader.parseTextSync && typeof data === "string")) {
              _context2.next = 7;
              break;
            }
            options.dataType = "text";
            return _context2.abrupt("return", loader.parseTextSync(data, options, context, loader));
          case 7:
            if (!canParseWithWorker(loader, data, options, context)) {
              _context2.next = 11;
              break;
            }
            _context2.next = 10;
            return parseWithWorker(loader, data, options, context);
          case 10:
            return _context2.abrupt("return", _context2.sent);
          case 11:
            if (!(loader.parseText && typeof data === "string")) {
              _context2.next = 15;
              break;
            }
            _context2.next = 14;
            return loader.parseText(data, options, context, loader);
          case 14:
            return _context2.abrupt("return", _context2.sent);
          case 15:
            if (!loader.parse) {
              _context2.next = 19;
              break;
            }
            _context2.next = 18;
            return loader.parse(data, options, context, loader);
          case 18:
            return _context2.abrupt("return", _context2.sent);
          case 19:
            assert(!loader.parseSync);
            return _context2.abrupt("return", assert(false));
          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseWithLoader.apply(this, arguments);
}
var import_regenerator20;
var init_parse = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js"() {
    import_regenerator20 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_esm2();
    init_normalize_loader();
    init_option_utils();
    init_get_data();
    init_context_utils();
    init_parse_with_worker();
    init_resource_utils();
    init_select_loader();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js
function parseSync(data, loaders, options, context) {
  assert(!context || typeof context !== "string", "parseSync no longer accepts final url");
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = options;
    options = loaders;
    loaders = null;
  }
  options = options || {};
  var candidateLoaders = getLoaders(loaders, context);
  var loader = selectLoaderSync(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders);
  var _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;
  context = getLoaderContext({
    url,
    parseSync,
    loaders
  }, options);
  return parseWithLoaderSync(loader, data, options, context);
}
function parseWithLoaderSync(loader, data, options, context) {
  data = getArrayBufferOrStringFromDataSync(data, loader);
  if (loader.parseTextSync && typeof data === "string") {
    return loader.parseTextSync(data, options, context, loader);
  }
  if (loader.parseSync) {
    return loader.parseSync(data, options, context, loader);
  }
  throw new Error("".concat(loader.name, " loader: 'parseSync' not supported by this loader, use 'parse' instead. ").concat(context.url || ""));
}
var init_parse_sync = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/parse-sync.js"() {
    init_esm2();
    init_select_loader();
    init_normalize_loader();
    init_option_utils();
    init_get_data();
    init_context_utils();
    init_resource_utils();
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js
function _asyncGeneratorDelegate(inner) {
  var iter = {}, waiting = false;
  function pump(key, value4) {
    return waiting = true, value4 = new Promise(function(resolve) {
      resolve(inner[key](value4));
    }), {
      done: false,
      value: new _OverloadYield(value4, 1)
    };
  }
  return iter["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function() {
    return this;
  }, iter.next = function(value4) {
    return waiting ? (waiting = false, value4) : pump("next", value4);
  }, "function" == typeof inner["throw"] && (iter["throw"] = function(value4) {
    if (waiting)
      throw waiting = false, value4;
    return pump("throw", value4);
  }), "function" == typeof inner["return"] && (iter["return"] = function(value4) {
    return waiting ? (waiting = false, value4) : pump("return", value4);
  }), iter;
}
var init_asyncGeneratorDelegate = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js"() {
    init_OverloadYield();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js
function _createForOfIteratorHelper5(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray6(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it["return"] != null)
        it["return"]();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray6(o, minLen);
}
function _arrayLikeToArray6(arr, len2) {
  if (len2 == null || len2 > arr.length)
    len2 = arr.length;
  for (var i = 0, arr2 = new Array(len2); i < len2; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function parseInBatches(_x2, _x3, _x4, _x5) {
  return _parseInBatches.apply(this, arguments);
}
function _parseInBatches() {
  _parseInBatches = _asyncToGenerator(import_regenerator21.default.mark(function _callee(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, loader;
    return import_regenerator21.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assert(!context || typeof context !== "string", "parseInBatches no longer accepts final url");
            if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
              context = options;
              options = loaders;
              loaders = null;
            }
            _context.next = 4;
            return data;
          case 4:
            data = _context.sent;
            options = options || {};
            _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;
            _context.next = 9;
            return selectLoader(data, loaders, options);
          case 9:
            loader = _context.sent;
            if (loader) {
              _context.next = 12;
              break;
            }
            return _context.abrupt("return", null);
          case 12:
            options = normalizeOptions(options, loader, loaders, url);
            context = getLoaderContext({
              url,
              parseInBatches,
              parse,
              loaders
            }, options, context);
            _context.next = 16;
            return parseWithLoaderInBatches(loader, data, options, context);
          case 16:
            return _context.abrupt("return", _context.sent);
          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseInBatches.apply(this, arguments);
}
function parseWithLoaderInBatches(_x6, _x7, _x8, _x9) {
  return _parseWithLoaderInBatches.apply(this, arguments);
}
function _parseWithLoaderInBatches() {
  _parseWithLoaderInBatches = _asyncToGenerator(import_regenerator21.default.mark(function _callee3(loader, data, options, context) {
    var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;
    return import_regenerator21.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {
              _makeMetadataBatchIterator = _wrapAsyncGenerator(import_regenerator21.default.mark(function _callee2(iterator) {
                return import_regenerator21.default.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return metadataBatch;
                      case 2:
                        return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(iterator), _awaitAsyncGenerator), "t0", 3);
                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));
              return _makeMetadataBatchIterator.apply(this, arguments);
            };
            makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {
              return _makeMetadataBatchIterator.apply(this, arguments);
            };
            _context3.next = 4;
            return parseToOutputIterator(loader, data, options, context);
          case 4:
            outputIterator = _context3.sent;
            if (options.metadata) {
              _context3.next = 7;
              break;
            }
            return _context3.abrupt("return", outputIterator);
          case 7:
            metadataBatch = {
              batchType: "metadata",
              metadata: {
                _loader: loader,
                _context: context
              },
              data: [],
              bytesUsed: 0
            };
            return _context3.abrupt("return", makeMetadataBatchIterator(outputIterator));
          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseWithLoaderInBatches.apply(this, arguments);
}
function parseToOutputIterator(_x10, _x11, _x12, _x13) {
  return _parseToOutputIterator.apply(this, arguments);
}
function _parseToOutputIterator() {
  _parseToOutputIterator = _asyncToGenerator(import_regenerator21.default.mark(function _callee5(loader, data, options, context) {
    var inputIterator, iteratorChain, stream, parseChunkInBatches, _parseChunkInBatches;
    return import_regenerator21.default.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _parseChunkInBatches = function _parseChunkInBatches3() {
              _parseChunkInBatches = _wrapAsyncGenerator(import_regenerator21.default.mark(function _callee4() {
                var inputIterator2, arrayBuffer2;
                return import_regenerator21.default.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _awaitAsyncGenerator(getAsyncIteratorFromData(data));
                      case 2:
                        inputIterator2 = _context4.sent;
                        _context4.next = 5;
                        return _awaitAsyncGenerator(concatenateChunksAsync(inputIterator2));
                      case 5:
                        arrayBuffer2 = _context4.sent;
                        _context4.next = 8;
                        return loader.parse(arrayBuffer2, options, context, loader);
                      case 8:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));
              return _parseChunkInBatches.apply(this, arguments);
            };
            parseChunkInBatches = function _parseChunkInBatches2() {
              return _parseChunkInBatches.apply(this, arguments);
            };
            if (!loader.parseInBatches) {
              _context5.next = 10;
              break;
            }
            _context5.next = 5;
            return getAsyncIteratorFromData(data);
          case 5:
            inputIterator = _context5.sent;
            iteratorChain = applyInputTransforms(inputIterator, options);
            _context5.next = 9;
            return loader.parseInBatches(iteratorChain, options, context, loader);
          case 9:
            return _context5.abrupt("return", _context5.sent);
          case 10:
            if (!loader.parseStreamInBatches) {
              _context5.next = 17;
              break;
            }
            _context5.next = 13;
            return getReadableStream(data);
          case 13:
            stream = _context5.sent;
            if (!stream) {
              _context5.next = 17;
              break;
            }
            if (options.transforms) {
              console.warn("options.transforms not implemented for loaders that use `parseStreamInBatches`");
            }
            return _context5.abrupt("return", loader.parseStreamInBatches(stream, options, context));
          case 17:
            _context5.next = 19;
            return parseChunkInBatches();
          case 19:
            return _context5.abrupt("return", _context5.sent);
          case 20:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _parseToOutputIterator.apply(this, arguments);
}
function applyInputTransforms(inputIterator, options) {
  var iteratorChain = inputIterator;
  var _iterator = _createForOfIteratorHelper5(options.transforms || []), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var Transform2 = _step.value;
      iteratorChain = makeTransformIterator(iteratorChain, Transform2, options);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return iteratorChain;
}
var import_regenerator21;
var init_parse_in_batches = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/parse-in-batches.js"() {
    import_regenerator21 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_wrapAsyncGenerator();
    init_awaitAsyncGenerator();
    init_asyncIterator();
    init_asyncGeneratorDelegate();
    init_esm2();
    init_esm2();
    init_normalize_loader();
    init_option_utils();
    init_context_utils();
    init_get_data();
    init_resource_utils();
    init_select_loader();
    init_parse();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
function load(_x, _x2, _x3) {
  return _load.apply(this, arguments);
}
function _load() {
  _load = _asyncToGenerator(import_regenerator22.default.mark(function _callee(url, loaders, options) {
    var fetch2, data;
    return import_regenerator22.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
              options = loaders;
              loaders = null;
            }
            fetch2 = getFetchFunction(options || {});
            data = url;
            if (!(typeof url === "string")) {
              _context.next = 9;
              break;
            }
            _context.next = 6;
            return fetch2(url);
          case 6:
            data = _context.sent;
            _context.next = 10;
            break;
          case 9:
            url = null;
          case 10:
            if (!isBlob(url)) {
              _context.next = 15;
              break;
            }
            _context.next = 13;
            return fetch2(url);
          case 13:
            data = _context.sent;
            url = null;
          case 15:
            _context.next = 17;
            return parse(data, loaders, options);
          case 17:
            return _context.abrupt("return", _context.sent);
          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _load.apply(this, arguments);
}
var import_regenerator22;
var init_load = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/load.js"() {
    import_regenerator22 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_is_type();
    init_normalize_loader();
    init_option_utils();
    init_parse();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js
function loadInBatches(files, loaders, options) {
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    options = loaders;
    loaders = null;
  }
  var fetch2 = getFetchFunction(options || {});
  if (!Array.isArray(files)) {
    return loadOneFileInBatches(files, loaders, options, fetch2);
  }
  var promises = files.map(function(file) {
    return loadOneFileInBatches(file, loaders, options, fetch2);
  });
  return promises;
}
function loadOneFileInBatches(_x, _x2, _x3, _x4) {
  return _loadOneFileInBatches.apply(this, arguments);
}
function _loadOneFileInBatches() {
  _loadOneFileInBatches = _asyncToGenerator(import_regenerator23.default.mark(function _callee(file, loaders, options, fetch2) {
    var url, response;
    return import_regenerator23.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof file === "string")) {
              _context.next = 8;
              break;
            }
            url = file;
            _context.next = 4;
            return fetch2(url);
          case 4:
            response = _context.sent;
            _context.next = 7;
            return parseInBatches(response, loaders, options);
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
            _context.next = 10;
            return parseInBatches(file, loaders, options);
          case 10:
            return _context.abrupt("return", _context.sent);
          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadOneFileInBatches.apply(this, arguments);
}
var import_regenerator23;
var init_load_in_batches = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/load-in-batches.js"() {
    import_regenerator23 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_normalize_loader();
    init_option_utils();
    init_parse_in_batches();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js
function getTemporaryFilename(filename) {
  return "/tmp/".concat(filename);
}
function encode(_x, _x2, _x3, _x4) {
  return _encode.apply(this, arguments);
}
function _encode() {
  _encode = _asyncToGenerator(import_regenerator24.default.mark(function _callee(data, writer, options, url) {
    var batches, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, batch, tmpInputFilename, tmpOutputFilename, outputFilename, response;
    return import_regenerator24.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!writer.encode) {
              _context.next = 4;
              break;
            }
            _context.next = 3;
            return writer.encode(data, options);
          case 3:
            return _context.abrupt("return", _context.sent);
          case 4:
            if (!writer.encodeSync) {
              _context.next = 6;
              break;
            }
            return _context.abrupt("return", writer.encodeSync(data, options));
          case 6:
            if (!writer.encodeText) {
              _context.next = 12;
              break;
            }
            _context.t0 = new TextEncoder();
            _context.next = 10;
            return writer.encodeText(data, options);
          case 10:
            _context.t1 = _context.sent;
            return _context.abrupt("return", _context.t0.encode.call(_context.t0, _context.t1));
          case 12:
            if (!writer.encodeInBatches) {
              _context.next = 51;
              break;
            }
            batches = encodeInBatches(data, writer, options);
            chunks = [];
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context.prev = 17;
            _iterator = _asyncIterator(batches);
          case 19:
            _context.next = 21;
            return _iterator.next();
          case 21:
            _step = _context.sent;
            _iteratorNormalCompletion = _step.done;
            _context.next = 25;
            return _step.value;
          case 25:
            _value = _context.sent;
            if (_iteratorNormalCompletion) {
              _context.next = 32;
              break;
            }
            batch = _value;
            chunks.push(batch);
          case 29:
            _iteratorNormalCompletion = true;
            _context.next = 19;
            break;
          case 32:
            _context.next = 38;
            break;
          case 34:
            _context.prev = 34;
            _context.t2 = _context["catch"](17);
            _didIteratorError = true;
            _iteratorError = _context.t2;
          case 38:
            _context.prev = 38;
            _context.prev = 39;
            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context.next = 43;
              break;
            }
            _context.next = 43;
            return _iterator["return"]();
          case 43:
            _context.prev = 43;
            if (!_didIteratorError) {
              _context.next = 46;
              break;
            }
            throw _iteratorError;
          case 46:
            return _context.finish(43);
          case 47:
            return _context.finish(38);
          case 48:
            _context.next = 50;
            return concatenateArrayBuffers.apply(void 0, chunks);
          case 50:
            return _context.abrupt("return", _context.sent);
          case 51:
            if (!(!isBrowser && writer.encodeURLtoURL)) {
              _context.next = 63;
              break;
            }
            tmpInputFilename = getTemporaryFilename("input");
            _context.next = 55;
            return writeFile2(tmpInputFilename, data);
          case 55:
            tmpOutputFilename = getTemporaryFilename("output");
            _context.next = 58;
            return encodeURLtoURL(tmpInputFilename, tmpOutputFilename, writer, options);
          case 58:
            outputFilename = _context.sent;
            _context.next = 61;
            return fetchFile(outputFilename);
          case 61:
            response = _context.sent;
            return _context.abrupt("return", response.arrayBuffer());
          case 63:
            throw new Error("Writer could not encode data");
          case 64:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[17, 34, 38, 48], [39, , 43, 47]]);
  }));
  return _encode.apply(this, arguments);
}
function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }
  throw new Error("Writer could not synchronously encode data");
}
function encodeText(_x5, _x6, _x7, _x8) {
  return _encodeText.apply(this, arguments);
}
function _encodeText() {
  _encodeText = _asyncToGenerator(import_regenerator24.default.mark(function _callee2(data, writer, options, url) {
    var arrayBuffer2;
    return import_regenerator24.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(writer.text && writer.encodeText)) {
              _context2.next = 4;
              break;
            }
            _context2.next = 3;
            return writer.encodeText(data, options);
          case 3:
            return _context2.abrupt("return", _context2.sent);
          case 4:
            if (!(writer.text && (writer.encode || writer.encodeInBatches))) {
              _context2.next = 9;
              break;
            }
            _context2.next = 7;
            return encode(data, writer, options);
          case 7:
            arrayBuffer2 = _context2.sent;
            return _context2.abrupt("return", new TextDecoder().decode(arrayBuffer2));
          case 9:
            throw new Error("Writer could not encode data as text");
          case 10:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _encodeText.apply(this, arguments);
}
function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    var dataIterator = getIterator(data);
    return writer.encodeInBatches(dataIterator, options);
  }
  throw new Error("Writer could not encode data in batches");
}
function getIterator(data) {
  var dataIterator = [{
    table: data,
    start: 0,
    end: data.length
  }];
  return dataIterator;
}
function encodeURLtoURL(_x9, _x10, _x11, _x12) {
  return _encodeURLtoURL.apply(this, arguments);
}
function _encodeURLtoURL() {
  _encodeURLtoURL = _asyncToGenerator(import_regenerator24.default.mark(function _callee3(inputUrl, outputUrl, writer, options) {
    var outputFilename;
    return import_regenerator24.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            inputUrl = resolvePath(inputUrl);
            outputUrl = resolvePath(outputUrl);
            if (!(isBrowser || !writer.encodeURLtoURL)) {
              _context3.next = 4;
              break;
            }
            throw new Error();
          case 4:
            _context3.next = 6;
            return writer.encodeURLtoURL(inputUrl, outputUrl, options);
          case 6:
            outputFilename = _context3.sent;
            return _context3.abrupt("return", outputFilename);
          case 8:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encodeURLtoURL.apply(this, arguments);
}
var import_regenerator24;
var init_encode = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/encode.js"() {
    import_regenerator24 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_asyncIterator();
    init_esm2();
    init_esm2();
    init_write_file();
    init_fetch_file();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/api/save.js
function save(data, url, writer, options) {
  var encodedData = encode(data, writer, options, url);
  return writeFile2(url, encodedData);
}
function saveSync(data, url, writer, options) {
  var encodedData = encodeSync(data, writer, options, url);
  return writeFileSync2(url, encodedData);
}
var init_save = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/api/save.js"() {
    init_encode();
    init_write_file();
  }
});

// node_modules/@loaders.gl/core/dist/esm/null-loader.js
var import_regenerator25, VERSION3, NullLoader;
var init_null_loader = __esm({
  "node_modules/@loaders.gl/core/dist/esm/null-loader.js"() {
    import_regenerator25 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_wrapAsyncGenerator();
    init_awaitAsyncGenerator();
    init_asyncIterator();
    init_asyncGeneratorDelegate();
    VERSION3 = true ? "2.3.13" : "latest";
    NullLoader = {
      id: "image",
      name: "Images",
      version: VERSION3,
      mimeTypes: ["application/x.empty"],
      extensions: ["null"],
      parse: function() {
        var _parse2 = _asyncToGenerator(import_regenerator25.default.mark(function _callee(arrayBuffer2, options) {
          return import_regenerator25.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", arrayBuffer2);
                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        function parse2(_x, _x2) {
          return _parse2.apply(this, arguments);
        }
        return parse2;
      }(),
      parseSync: function parseSync2(arrayBuffer2, options) {
        return arrayBuffer2;
      },
      parseInBatches: function() {
        var _parseInBatches2 = _asyncToGenerator(import_regenerator25.default.mark(function _callee3(asyncIterator, options) {
          return import_regenerator25.default.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", function() {
                    var _parseInBatches3 = _wrapAsyncGenerator(import_regenerator25.default.mark(function _callee2() {
                      return import_regenerator25.default.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(asyncIterator), _awaitAsyncGenerator), "t0", 1);
                            case 1:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }));
                    function parseInBatches3() {
                      return _parseInBatches3.apply(this, arguments);
                    }
                    return parseInBatches3;
                  }()());
                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));
        function parseInBatches2(_x3, _x4) {
          return _parseInBatches2.apply(this, arguments);
        }
        return parseInBatches2;
      }(),
      tests: [function() {
        return false;
      }],
      options: {}
    };
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js
function fetchProgress(_x, _x2) {
  return _fetchProgress.apply(this, arguments);
}
function _fetchProgress() {
  _fetchProgress = _asyncToGenerator(import_regenerator26.default.mark(function _callee(response, onProgress) {
    var onDone, onError, body, contentLength, totalBytes, progressStream, _args = arguments;
    return import_regenerator26.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            onDone = _args.length > 2 && _args[2] !== void 0 ? _args[2] : function() {
            };
            onError = _args.length > 3 && _args[3] !== void 0 ? _args[3] : function() {
            };
            _context.next = 4;
            return response;
          case 4:
            response = _context.sent;
            if (response.ok) {
              _context.next = 7;
              break;
            }
            return _context.abrupt("return", response);
          case 7:
            body = response.body;
            if (body) {
              _context.next = 10;
              break;
            }
            return _context.abrupt("return", response);
          case 10:
            contentLength = response.headers.get("content-length");
            totalBytes = contentLength && parseInt(contentLength, 10);
            if (contentLength > 0) {
              _context.next = 14;
              break;
            }
            return _context.abrupt("return", response);
          case 14:
            if (!(typeof ReadableStream === "undefined" || !body.getReader)) {
              _context.next = 16;
              break;
            }
            return _context.abrupt("return", response);
          case 16:
            progressStream = new ReadableStream({
              start: function start(controller) {
                var reader = body.getReader();
                read(controller, reader, 0, totalBytes, onProgress, onDone, onError);
              }
            });
            return _context.abrupt("return", new Response(progressStream));
          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchProgress.apply(this, arguments);
}
function read(_x3, _x4, _x5, _x6, _x7, _x8, _x9) {
  return _read.apply(this, arguments);
}
function _read() {
  _read = _asyncToGenerator(import_regenerator26.default.mark(function _callee2(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError) {
    var _yield$reader$read, done, value4, percent;
    return import_regenerator26.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return reader.read();
          case 3:
            _yield$reader$read = _context2.sent;
            done = _yield$reader$read.done;
            value4 = _yield$reader$read.value;
            if (!done) {
              _context2.next = 10;
              break;
            }
            onDone();
            controller.close();
            return _context2.abrupt("return");
          case 10:
            loadedBytes += value4.byteLength;
            percent = Math.round(loadedBytes / totalBytes * 100);
            onProgress(percent, {
              loadedBytes,
              totalBytes
            });
            controller.enqueue(value4);
            _context2.next = 16;
            return read(controller, reader, loadedBytes, totalBytes, onProgress, onDone, onError);
          case 16:
            _context2.next = 22;
            break;
          case 18:
            _context2.prev = 18;
            _context2.t0 = _context2["catch"](0);
            controller.error(_context2.t0);
            onError(_context2.t0);
          case 22:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 18]]);
  }));
  return _read.apply(this, arguments);
}
var import_regenerator26;
var init_fetch_progress = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/progress/fetch-progress.js"() {
    import_regenerator26 = __toESM(require_regenerator());
    init_asyncToGenerator();
  }
});

// node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js
function readFileSlice2(_x9, _x10, _x11) {
  return _readFileSlice2.apply(this, arguments);
}
function _readFileSlice2() {
  _readFileSlice2 = _asyncToGenerator(import_regenerator27.default.mark(function _callee8(file, start, end) {
    var slice;
    return import_regenerator27.default.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            slice = file.slice(start, end);
            _context8.next = 3;
            return new Promise(function(resolve, reject) {
              var fileReader = new FileReader();
              fileReader.onload = function(event) {
                return resolve(event.target && event.target.result);
              };
              fileReader.onerror = function(error2) {
                return reject(error2);
              };
              fileReader.readAsArrayBuffer(slice);
            });
          case 3:
            return _context8.abrupt("return", _context8.sent);
          case 4:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));
  return _readFileSlice2.apply(this, arguments);
}
var import_regenerator27, BrowserFileSystem;
var init_browser_filesystem = __esm({
  "node_modules/@loaders.gl/core/dist/esm/lib/filesystems/browser-filesystem.js"() {
    import_regenerator27 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    BrowserFileSystem = function() {
      function BrowserFileSystem2(files) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, BrowserFileSystem2);
        this._fetch = options.fetch || fetch;
        this.files = {};
        for (var i = 0; i < files.length; ++i) {
          var file = files[i];
          this.files[file.name] = file;
        }
        this.fetch = this.fetch.bind(this);
      }
      _createClass(BrowserFileSystem2, [{
        key: "fetch",
        value: function() {
          var _fetch = _asyncToGenerator(import_regenerator27.default.mark(function _callee(path) {
            var options, fallbackFetch, file, response, _args = arguments;
            return import_regenerator27.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 1 && _args[1] !== void 0 ? _args[1] : {};
                    if (!path.includes("://")) {
                      _context.next = 4;
                      break;
                    }
                    fallbackFetch = options.fetch || this._fetch;
                    return _context.abrupt("return", fallbackFetch(path, options));
                  case 4:
                    file = this.files[path];
                    if (!file) {
                      _context.next = 9;
                      break;
                    }
                    response = new Response(this.files[path]);
                    Object.defineProperty(response, "url", {
                      value: path
                    });
                    return _context.abrupt("return", response);
                  case 9:
                    return _context.abrupt("return", new Response(path, {
                      status: 400,
                      statusText: "NOT FOUND"
                    }));
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function fetch2(_x) {
            return _fetch.apply(this, arguments);
          }
          return fetch2;
        }()
      }, {
        key: "readdir",
        value: function() {
          var _readdir = _asyncToGenerator(import_regenerator27.default.mark(function _callee2() {
            var files, path;
            return import_regenerator27.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    files = [];
                    for (path in this.files) {
                      files.push(path);
                    }
                    return _context2.abrupt("return", files);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function readdir() {
            return _readdir.apply(this, arguments);
          }
          return readdir;
        }()
      }, {
        key: "stat",
        value: function() {
          var _stat = _asyncToGenerator(import_regenerator27.default.mark(function _callee3(path, options) {
            var file;
            return import_regenerator27.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    file = this.files[path];
                    if (file) {
                      _context3.next = 3;
                      break;
                    }
                    throw new Error("No such file: ".concat(path));
                  case 3:
                    return _context3.abrupt("return", {
                      size: file.size
                    });
                  case 4:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function stat(_x2, _x3) {
            return _stat.apply(this, arguments);
          }
          return stat;
        }()
      }, {
        key: "unlink",
        value: function() {
          var _unlink = _asyncToGenerator(import_regenerator27.default.mark(function _callee4(pathname) {
            return import_regenerator27.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    delete this.files[pathname];
                  case 1:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function unlink(_x4) {
            return _unlink.apply(this, arguments);
          }
          return unlink;
        }()
      }, {
        key: "open",
        value: function() {
          var _open = _asyncToGenerator(import_regenerator27.default.mark(function _callee5(pathname) {
            return import_regenerator27.default.wrap(function _callee5$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    return _context5.abrupt("return", this.files[pathname]);
                  case 1:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _callee5, this);
          }));
          function open(_x5) {
            return _open.apply(this, arguments);
          }
          return open;
        }()
      }, {
        key: "read",
        value: function() {
          var _read2 = _asyncToGenerator(import_regenerator27.default.mark(function _callee6(fd, _ref) {
            var _ref$buffer, buffer, _ref$offset, offset, _ref$length, length5, _ref$position, position, file, arrayBuffer2;
            return import_regenerator27.default.wrap(function _callee6$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    _ref$buffer = _ref.buffer, buffer = _ref$buffer === void 0 ? null : _ref$buffer, _ref$offset = _ref.offset, offset = _ref$offset === void 0 ? 0 : _ref$offset, _ref$length = _ref.length, length5 = _ref$length === void 0 ? buffer.byteLength : _ref$length, _ref$position = _ref.position, position = _ref$position === void 0 ? null : _ref$position;
                    file = fd;
                    _context6.next = 4;
                    return readFileSlice2(file, position, position + length5);
                  case 4:
                    arrayBuffer2 = _context6.sent;
                    return _context6.abrupt("return", arrayBuffer2);
                  case 6:
                  case "end":
                    return _context6.stop();
                }
              }
            }, _callee6);
          }));
          function read2(_x6, _x7) {
            return _read2.apply(this, arguments);
          }
          return read2;
        }()
      }, {
        key: "close",
        value: function() {
          var _close = _asyncToGenerator(import_regenerator27.default.mark(function _callee7(fd) {
            return import_regenerator27.default.wrap(function _callee7$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _callee7);
          }));
          function close(_x8) {
            return _close.apply(this, arguments);
          }
          return close;
        }()
      }]);
      return BrowserFileSystem2;
    }();
  }
});

// node_modules/@loaders.gl/core/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  NullLoader: () => NullLoader,
  RequestScheduler: () => RequestScheduler,
  _BrowserFileSystem: () => BrowserFileSystem,
  _fetchProgress: () => fetchProgress,
  _unregisterLoaders: () => _unregisterLoaders,
  assert: () => assert,
  concatenateChunksAsync: () => concatenateChunksAsync,
  document: () => document_,
  encode: () => encode,
  encodeInBatches: () => encodeInBatches,
  encodeSync: () => encodeSync,
  encodeText: () => encodeText,
  encodeURLtoURL: () => encodeURLtoURL,
  fetchFile: () => fetchFile,
  forEach: () => forEach,
  getPathPrefix: () => getPathPrefix,
  global: () => global_,
  isAsyncIterable: () => isAsyncIterable,
  isBrowser: () => isBrowser,
  isIterable: () => isIterable,
  isIterator: () => isIterator,
  isPromise: () => isPromise,
  isReadableStream: () => isReadableStream,
  isResponse: () => isResponse,
  isWorker: () => isWorker,
  isWritableStream: () => isWritableStream,
  load: () => load,
  loadInBatches: () => loadInBatches,
  makeIterator: () => makeIterator,
  makeLineIterator: () => makeLineIterator,
  makeNumberedLineIterator: () => makeNumberedLineIterator,
  makeTextDecoderIterator: () => makeTextDecoderIterator,
  makeTextEncoderIterator: () => makeTextEncoderIterator,
  parse: () => parse,
  parseInBatches: () => parseInBatches,
  parseSync: () => parseSync,
  readFileSync: () => readFileSync2,
  registerLoaders: () => registerLoaders,
  resolvePath: () => resolvePath,
  save: () => save,
  saveSync: () => saveSync,
  selectLoader: () => selectLoader,
  selectLoaderSync: () => selectLoaderSync,
  self: () => self_,
  setLoaderOptions: () => setLoaderOptions,
  setPathPrefix: () => setPathPrefix,
  window: () => window_,
  writeFile: () => writeFile2,
  writeFileSync: () => writeFileSync2
});
var init_esm3 = __esm({
  "node_modules/@loaders.gl/core/dist/esm/index.js"() {
    init_init();
    init_fetch_file();
    init_read_file();
    init_write_file();
    init_set_loader_options();
    init_register_loaders();
    init_parse();
    init_parse_sync();
    init_parse_in_batches();
    init_select_loader();
    init_load();
    init_load_in_batches();
    init_encode();
    init_save();
    init_make_iterator();
    init_null_loader();
    init_esm2();
    init_esm2();
    init_fetch_progress();
    init_browser_filesystem();
    init_register_loaders();
    init_esm2();
    init_esm2();
    init_esm2();
    init_esm2();
    init_is_type();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
var init_assert2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js
var globals2, self_2, window_2, global_2, document_2, isBrowser2, matches2, nodeVersion2;
var init_globals2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js"() {
    init_typeof();
    globals2 = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_2 = globals2.self || globals2.window || globals2.global;
    window_2 = globals2.window || globals2.self || globals2.global;
    global_2 = globals2.global || globals2.self || globals2.window;
    document_2 = globals2.document || {};
    isBrowser2 = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
    matches2 = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
    nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    case "html":
      return IMAGE_SUPPORTED;
    case "ndarray":
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
var _parseImageNode, IMAGE_SUPPORTED, IMAGE_BITMAP_SUPPORTED, NODE_IMAGE_SUPPORTED, DATA_SUPPORTED;
var init_image_type = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js"() {
    init_globals2();
    _parseImageNode = global_2._parseImageNode;
    IMAGE_SUPPORTED = typeof Image !== "undefined";
    IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
    NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
    DATA_SUPPORTED = isBrowser2 ? true : NODE_IMAGE_SUPPORTED;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
function getImageType(image) {
  var format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      var canvas = document.createElement("canvas");
      var context = canvas.getContext("2d");
      if (context) {
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      }
    default:
      return assert2(false);
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && _typeof(image) === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}
var init_parsed_image_api = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js"() {
    init_typeof();
    init_assert2();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer2, url) {
  if (isSVG(url)) {
    var textDecoder = new TextDecoder();
    var xmlText = textDecoder.decode(arrayBuffer2);
    var src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer2, url);
}
function getBlob(arrayBuffer2, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer2)]);
}
var SVG_DATA_URL_PATTERN, SVG_URL_PATTERN;
var init_svg_utils = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js"() {
    SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
    SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
function parseToImage(_x, _x2, _x3) {
  return _parseToImage.apply(this, arguments);
}
function _parseToImage() {
  _parseToImage = _asyncToGenerator(import_regenerator28.default.mark(function _callee(arrayBuffer2, options, url) {
    var blobOrDataUrl, URL2, objectUrl;
    return import_regenerator28.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
            URL2 = self.URL || self.webkitURL;
            objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
            _context.prev = 3;
            _context.next = 6;
            return loadToImage(objectUrl || blobOrDataUrl, options);
          case 6:
            return _context.abrupt("return", _context.sent);
          case 7:
            _context.prev = 7;
            if (objectUrl) {
              URL2.revokeObjectURL(objectUrl);
            }
            return _context.finish(7);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, , 7, 10]]);
  }));
  return _parseToImage.apply(this, arguments);
}
function loadToImage(_x4, _x5) {
  return _loadToImage.apply(this, arguments);
}
function _loadToImage() {
  _loadToImage = _asyncToGenerator(import_regenerator28.default.mark(function _callee2(url, options) {
    var image;
    return import_regenerator28.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            image = new Image();
            image.src = url;
            if (!(options.image && options.image.decode && image.decode)) {
              _context2.next = 6;
              break;
            }
            _context2.next = 5;
            return image.decode();
          case 5:
            return _context2.abrupt("return", image);
          case 6:
            _context2.next = 8;
            return new Promise(function(resolve, reject) {
              try {
                image.onload = function() {
                  return resolve(image);
                };
                image.onerror = function(err) {
                  return reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
                };
              } catch (error2) {
                reject(error2);
              }
            });
          case 8:
            return _context2.abrupt("return", _context2.sent);
          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadToImage.apply(this, arguments);
}
var import_regenerator28;
var init_parse_to_image = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js"() {
    import_regenerator28 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_svg_utils();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
function parseToImageBitmap(_x, _x2, _x3) {
  return _parseToImageBitmap.apply(this, arguments);
}
function _parseToImageBitmap() {
  _parseToImageBitmap = _asyncToGenerator(import_regenerator29.default.mark(function _callee(arrayBuffer2, options, url) {
    var blob, image, imagebitmapOptions;
    return import_regenerator29.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isSVG(url)) {
              _context.next = 7;
              break;
            }
            _context.next = 3;
            return parseToImage(arrayBuffer2, options, url);
          case 3:
            image = _context.sent;
            blob = image;
            _context.next = 8;
            break;
          case 7:
            blob = getBlob(arrayBuffer2, url);
          case 8:
            imagebitmapOptions = options && options.imagebitmap;
            _context.next = 11;
            return safeCreateImageBitmap(blob, imagebitmapOptions);
          case 11:
            return _context.abrupt("return", _context.sent);
          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseToImageBitmap.apply(this, arguments);
}
function safeCreateImageBitmap(_x4) {
  return _safeCreateImageBitmap.apply(this, arguments);
}
function _safeCreateImageBitmap() {
  _safeCreateImageBitmap = _asyncToGenerator(import_regenerator29.default.mark(function _callee2(blob) {
    var imagebitmapOptions, _args2 = arguments;
    return import_regenerator29.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            imagebitmapOptions = _args2.length > 1 && _args2[1] !== void 0 ? _args2[1] : null;
            if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
              imagebitmapOptions = null;
            }
            if (!imagebitmapOptions) {
              _context2.next = 13;
              break;
            }
            _context2.prev = 3;
            _context2.next = 6;
            return createImageBitmap(blob, imagebitmapOptions);
          case 6:
            return _context2.abrupt("return", _context2.sent);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](3);
            console.warn(_context2.t0);
            imagebitmapOptionsSupported = false;
          case 13:
            _context2.next = 15;
            return createImageBitmap(blob);
          case 15:
            return _context2.abrupt("return", _context2.sent);
          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 9]]);
  }));
  return _safeCreateImageBitmap.apply(this, arguments);
}
function isEmptyObject(object) {
  for (var key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
var import_regenerator29, EMPTY_OBJECT, imagebitmapOptionsSupported;
var init_parse_to_image_bitmap = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js"() {
    import_regenerator29 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_svg_utils();
    init_parse_to_image();
    EMPTY_OBJECT = {};
    imagebitmapOptionsSupported = true;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
function getBinaryImageMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
}
function getPngMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  var _getJpegMarkers = getJpegMarkers(), tableMarkers = _getJpegMarkers.tableMarkers, sofMarkers = _getJpegMarkers.sofMarkers;
  var i = 2;
  while (i + 9 < dataView.byteLength) {
    var marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  var tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (var i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  var sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}
var BIG_ENDIAN, LITTLE_ENDIAN;
var init_binary_image_api = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"() {
    BIG_ENDIAN = false;
    LITTLE_ENDIAN = true;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
function parseToNodeImage(arrayBuffer2, options) {
  var _ref = getBinaryImageMetadata(arrayBuffer2) || {}, mimeType = _ref.mimeType;
  var _parseImageNode2 = global_2._parseImageNode;
  assert2(_parseImageNode2);
  return _parseImageNode2(arrayBuffer2, mimeType, options);
}
var init_parse_to_node_image = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js"() {
    init_globals2();
    init_assert2();
    init_binary_image_api();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
function parseImage(_x, _x2, _x3) {
  return _parseImage.apply(this, arguments);
}
function _parseImage() {
  _parseImage = _asyncToGenerator(import_regenerator30.default.mark(function _callee(arrayBuffer2, options, context) {
    var imageOptions, imageType, _ref, url, loadType, image;
    return import_regenerator30.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = options || {};
            imageOptions = options.image || {};
            imageType = imageOptions.type || "auto";
            _ref = context || {}, url = _ref.url;
            loadType = getLoadableImageType(imageType);
            _context.t0 = loadType;
            _context.next = _context.t0 === "imagebitmap" ? 8 : _context.t0 === "image" ? 12 : _context.t0 === "data" ? 16 : 20;
            break;
          case 8:
            _context.next = 10;
            return parseToImageBitmap(arrayBuffer2, options, url);
          case 10:
            image = _context.sent;
            return _context.abrupt("break", 21);
          case 12:
            _context.next = 14;
            return parseToImage(arrayBuffer2, options, url);
          case 14:
            image = _context.sent;
            return _context.abrupt("break", 21);
          case 16:
            _context.next = 18;
            return parseToNodeImage(arrayBuffer2, options);
          case 18:
            image = _context.sent;
            return _context.abrupt("break", 21);
          case 20:
            assert2(false);
          case 21:
            if (imageType === "data") {
              image = getImageData(image);
            }
            return _context.abrupt("return", image);
          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseImage.apply(this, arguments);
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}
var import_regenerator30;
var init_parse_image = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js"() {
    import_regenerator30 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_assert2();
    init_image_type();
    init_parsed_image_api();
    init_parse_to_image();
    init_parse_to_image_bitmap();
    init_parse_to_node_image();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/image-loader.js
var VERSION4, EXTENSIONS, MIME_TYPES, ImageLoader, image_loader_default;
var init_image_loader = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/image-loader.js"() {
    init_parse_image();
    init_binary_image_api();
    VERSION4 = true ? "2.3.13" : "latest";
    EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
    MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
    ImageLoader = {
      id: "image",
      name: "Images",
      version: VERSION4,
      mimeTypes: MIME_TYPES,
      extensions: EXTENSIONS,
      parse: parseImage,
      tests: [function(arrayBuffer2) {
        return Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)));
      }],
      options: {
        image: {
          type: "auto",
          decode: true
        }
      }
    };
    image_loader_default = ImageLoader;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js
var import_regenerator31, _encodeImageNode;
var init_encode_image = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js"() {
    import_regenerator31 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_globals2();
    init_parsed_image_api();
    _encodeImageNode = global_2._encodeImageNode;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/image-writer.js
var init_image_writer = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/image-writer.js"() {
    init_encode_image();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
var init_assert3 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
var globals3, self_3, window_3, global_3, document_3, isBrowser3, matches3, nodeVersion3;
var init_globals3 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"() {
    init_typeof();
    globals3 = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_3 = globals3.self || globals3.window || globals3.global;
    window_3 = globals3.window || globals3.self || globals3.global;
    global_3 = globals3.global || globals3.self || globals3.window;
    document_3 = globals3.document || {};
    isBrowser3 = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
    matches3 = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
    nodeVersion3 = matches3 && parseFloat(matches3[1]) || 0;
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js
function getTransferList2(object) {
  var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : void 0;
  var transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable2(object)) {
    transfersSet.add(object);
  } else if (isTransferable2(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && _typeof(object) === "object") {
    for (var key in object) {
      getTransferList2(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable2(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
var init_get_transfer_list2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js"() {
    init_typeof();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js
var init_validate_loader_version2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js"() {
    init_assert3();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-worker.js
var import_regenerator32;
var init_create_worker2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-worker.js"() {
    init_defineProperty();
    import_regenerator32 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_get_transfer_list2();
    init_validate_loader_version2();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/make-transform-iterator.js
var import_regenerator33;
var init_make_transform_iterator2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/make-transform-iterator.js"() {
    import_regenerator33 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js
function getWorkerURL2(workerSource) {
  var workerName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Worker";
  assert3(typeof workerSource === "string", "worker source");
  if (workerSource.startsWith("url(") && workerSource.endsWith(")")) {
    var workerUrl = workerSource.match(/^url\((.*)\)$/)[1];
    if (workerUrl && !workerUrl.startsWith("http")) {
      return workerUrl;
    }
    workerSource = buildScript2(workerUrl);
  }
  var workerURL = workerURLCache2.get(workerSource);
  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    workerURL = URL.createObjectURL(blob);
    workerURLCache2.set(workerSource, workerURL);
  }
  return workerURL;
}
function buildScript2(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n}");
}
var workerURLCache2;
var init_get_worker_url2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js"() {
    init_assert3();
    workerURLCache2 = /* @__PURE__ */ new Map();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js
function defaultOnMessage2(_ref) {
  var data = _ref.data, resolve = _ref.resolve;
  resolve(data);
}
var import_regenerator34, count2, WorkerThread2;
var init_worker_thread2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js"() {
    import_regenerator34 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_get_worker_url2();
    init_get_transfer_list2();
    count2 = 0;
    WorkerThread2 = function() {
      function WorkerThread3(_ref2) {
        var source = _ref2.source, _ref2$name = _ref2.name, name = _ref2$name === void 0 ? "web-worker-".concat(count2++) : _ref2$name, onMessage = _ref2.onMessage;
        _classCallCheck(this, WorkerThread3);
        var url = getWorkerURL2(source, name);
        this.worker = new Worker(url, {
          name
        });
        this.name = name;
        this.onMessage = onMessage || defaultOnMessage2;
      }
      _createClass(WorkerThread3, [{
        key: "process",
        value: function() {
          var _process = _asyncToGenerator(import_regenerator34.default.mark(function _callee(data) {
            var _this = this;
            return import_regenerator34.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", new Promise(function(resolve, reject) {
                      _this.worker.onmessage = function(event) {
                        _this.onMessage({
                          worker: _this.worker,
                          data: event.data,
                          resolve,
                          reject
                        });
                      };
                      _this.worker.onerror = function(error2) {
                        var message = "".concat(_this.name, ": WorkerThread.process() failed");
                        if (error2.message) {
                          message += " ".concat(error2.message, " ").concat(error2.filename, ":").concat(error2.lineno, ":").concat(error2.colno);
                        }
                        var betterError = new Error(message);
                        console.error(error2);
                        reject(betterError);
                      };
                      var transferList = getTransferList2(data);
                      _this.worker.postMessage(data, transferList);
                    }));
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          function process2(_x) {
            return _process.apply(this, arguments);
          }
          return process2;
        }()
      }, {
        key: "destroy",
        value: function destroy() {
          this.worker.terminate();
          this.worker = null;
        }
      }]);
      return WorkerThread3;
    }();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js
var import_regenerator35, WorkerPool2;
var init_worker_pool2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js"() {
    import_regenerator35 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_worker_thread2();
    WorkerPool2 = function() {
      function WorkerPool3(_ref) {
        var source = _ref.source, _ref$name = _ref.name, name = _ref$name === void 0 ? "unnamed" : _ref$name, _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency, onMessage = _ref.onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
        } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
        _classCallCheck(this, WorkerPool3);
        this.source = source;
        this.name = name;
        this.maxConcurrency = maxConcurrency;
        this.onMessage = onMessage;
        this.onDebug = onDebug;
        this.jobQueue = [];
        this.idleQueue = [];
        this.count = 0;
        this.isDestroyed = false;
        this.reuseWorkers = reuseWorkers;
      }
      _createClass(WorkerPool3, [{
        key: "destroy",
        value: function destroy() {
          this.idleQueue.forEach(function(worker) {
            return worker.destroy();
          });
          this.isDestroyed = true;
        }
      }, {
        key: "process",
        value: function process2(data, jobName) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.jobQueue.push({
              data,
              jobName,
              resolve,
              reject
            });
            _this._startQueuedJob();
          });
        }
      }, {
        key: "_startQueuedJob",
        value: function() {
          var _startQueuedJob2 = _asyncToGenerator(import_regenerator35.default.mark(function _callee() {
            var worker, job;
            return import_regenerator35.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.jobQueue.length) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    worker = this._getAvailableWorker();
                    if (worker) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return");
                  case 5:
                    job = this.jobQueue.shift();
                    this.onDebug({
                      message: "processing",
                      worker: worker.name,
                      job: job.jobName,
                      backlog: this.jobQueue.length
                    });
                    _context.prev = 7;
                    _context.t0 = job;
                    _context.next = 11;
                    return worker.process(job.data);
                  case 11:
                    _context.t1 = _context.sent;
                    _context.t0.resolve.call(_context.t0, _context.t1);
                    _context.next = 18;
                    break;
                  case 15:
                    _context.prev = 15;
                    _context.t2 = _context["catch"](7);
                    job.reject(_context.t2);
                  case 18:
                    _context.prev = 18;
                    this._onWorkerDone(worker);
                    return _context.finish(18);
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[7, 15, 18, 21]]);
          }));
          function _startQueuedJob() {
            return _startQueuedJob2.apply(this, arguments);
          }
          return _startQueuedJob;
        }()
      }, {
        key: "_onWorkerDone",
        value: function _onWorkerDone(worker) {
          if (this.isDestroyed) {
            worker.destroy();
            return;
          }
          if (this.reuseWorkers) {
            this.idleQueue.push(worker);
          } else {
            worker.destroy();
            this.count--;
          }
          this._startQueuedJob();
        }
      }, {
        key: "_getAvailableWorker",
        value: function _getAvailableWorker() {
          if (this.idleQueue.length > 0) {
            return this.idleQueue.shift();
          }
          if (this.count < this.maxConcurrency) {
            this.count++;
            var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
            return new WorkerThread2({
              source: this.source,
              onMessage: this.onMessage,
              name
            });
          }
          return null;
        }
      }]);
      return WorkerPool3;
    }();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js
function onWorkerMessage3(onMessage, _ref2) {
  var worker = _ref2.worker, data = _ref2.data, resolve = _ref2.resolve, reject = _ref2.reject;
  if (onMessage) {
    onMessage({
      worker,
      data,
      resolve,
      reject
    });
    return;
  }
  switch (data.type) {
    case "done":
      resolve(data.result);
      break;
    case "error":
      reject(data.message);
      break;
    default:
  }
}
var import_regenerator36, DEFAULT_MAX_CONCURRENCY2, WorkerFarm2;
var init_worker_farm2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js"() {
    import_regenerator36 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_worker_pool2();
    DEFAULT_MAX_CONCURRENCY2 = 5;
    WorkerFarm2 = function() {
      _createClass(WorkerFarm3, null, [{
        key: "isSupported",
        value: function isSupported() {
          return typeof Worker !== "undefined";
        }
      }]);
      function WorkerFarm3(_ref) {
        var _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY2 : _ref$maxConcurrency, _ref$onMessage = _ref.onMessage, onMessage = _ref$onMessage === void 0 ? null : _ref$onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
        } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
        _classCallCheck(this, WorkerFarm3);
        this.maxConcurrency = maxConcurrency;
        this.onMessage = onMessage;
        this.onDebug = onDebug;
        this.workerPools = /* @__PURE__ */ new Map();
        this.reuseWorkers = reuseWorkers;
      }
      _createClass(WorkerFarm3, [{
        key: "setProps",
        value: function setProps(props) {
          if ("maxConcurrency" in props) {
            this.maxConcurrency = props.maxConcurrency;
          }
          if ("onDebug" in props) {
            this.onDebug = props.onDebug;
          }
          if ("reuseWorkers" in props) {
            this.reuseWorkers = props.reuseWorkers;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.workerPools.forEach(function(workerPool) {
            return workerPool.destroy();
          });
        }
      }, {
        key: "process",
        value: function() {
          var _process = _asyncToGenerator(import_regenerator36.default.mark(function _callee(workerSource, workerName, data) {
            var workerPool;
            return import_regenerator36.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    workerPool = this._getWorkerPool(workerSource, workerName);
                    return _context.abrupt("return", workerPool.process(data));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function process2(_x, _x2, _x3) {
            return _process.apply(this, arguments);
          }
          return process2;
        }()
      }, {
        key: "_getWorkerPool",
        value: function _getWorkerPool(workerSource, workerName) {
          var workerPool = this.workerPools.get(workerName);
          if (!workerPool) {
            workerPool = new WorkerPool2({
              source: workerSource,
              name: workerName,
              onMessage: onWorkerMessage3.bind(null, this.onMessage),
              maxConcurrency: this.maxConcurrency,
              onDebug: this.onDebug,
              reuseWorkers: this.reuseWorkers
            });
            this.workerPools.set(workerName, workerPool);
          }
          return workerPool;
        }
      }]);
      return WorkerFarm3;
    }();
  }
});

// (disabled):node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/require-utils.node
var require_require_utils2 = __commonJS({
  "(disabled):node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/require-utils.node"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/library-utils/library-utils.js
var import_regenerator37, node6;
var init_library_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/library-utils/library-utils.js"() {
    import_regenerator37 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_globals3();
    node6 = __toESM(require_require_utils2());
    init_assert3();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
var init_get_first_characters2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
var init_parse_json2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js"() {
    init_get_first_characters2();
  }
});

// (disabled):node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer-utils.node
var require_buffer_utils2 = __commonJS({
  "(disabled):node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer-utils.node"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js
var node7;
var init_buffer_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js"() {
    init_typeof();
    node7 = __toESM(require_buffer_utils2());
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
var node8;
var init_array_buffer_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"() {
    init_typeof();
    init_assert3();
    node8 = __toESM(require_buffer_utils2());
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
var init_memory_copy_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"() {
    init_array_buffer_utils2();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js
var init_binary_copy_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js"() {
    init_memory_copy_utils2();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js
var init_encode_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
var init_path2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
var init_file_aliases2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/text-iterators.js
var import_regenerator38;
var init_text_iterators2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/text-iterators.js"() {
    import_regenerator38 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js
var import_regenerator39;
var init_async_iteration2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js"() {
    import_regenerator39 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_asyncIterator();
    init_array_buffer_utils2();
    init_assert3();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
function ownKeys7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var STAT_QUEUED_REQUESTS2, STAT_ACTIVE_REQUESTS2, STAT_CANCELLED_REQUESTS2, STAT_QUEUED_REQUESTS_EVER2, STAT_ACTIVE_REQUESTS_EVER2, DEFAULT_PROPS2, RequestScheduler2;
var init_request_scheduler2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm();
    STAT_QUEUED_REQUESTS2 = "Queued Requests";
    STAT_ACTIVE_REQUESTS2 = "Active Requests";
    STAT_CANCELLED_REQUESTS2 = "Cancelled Requests";
    STAT_QUEUED_REQUESTS_EVER2 = "Queued Requests Ever";
    STAT_ACTIVE_REQUESTS_EVER2 = "Active Requests Ever";
    DEFAULT_PROPS2 = {
      id: "request-scheduler",
      throttleRequests: true,
      maxRequests: 6
    };
    RequestScheduler2 = function() {
      function RequestScheduler3() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, RequestScheduler3);
        this.props = _objectSpread7(_objectSpread7({}, DEFAULT_PROPS2), props);
        this.requestQueue = [];
        this.activeRequestCount = 0;
        this.requestMap = /* @__PURE__ */ new Map();
        this.stats = new Stats({
          id: props.id
        });
        this.stats.get(STAT_QUEUED_REQUESTS2);
        this.stats.get(STAT_ACTIVE_REQUESTS2);
        this.stats.get(STAT_CANCELLED_REQUESTS2);
        this.stats.get(STAT_QUEUED_REQUESTS_EVER2);
        this.stats.get(STAT_ACTIVE_REQUESTS_EVER2);
        this._deferredUpdate = null;
      }
      _createClass(RequestScheduler3, [{
        key: "scheduleRequest",
        value: function scheduleRequest(handle) {
          var getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
            return 0;
          };
          if (!this.props.throttleRequests) {
            return Promise.resolve({
              done: function done() {
              }
            });
          }
          if (this.requestMap.has(handle)) {
            return this.requestMap.get(handle);
          }
          var request = {
            handle,
            getPriority
          };
          var promise = new Promise(function(resolve) {
            request.resolve = resolve;
            return request;
          });
          this.requestQueue.push(request);
          this.requestMap.set(handle, promise);
          this._issueNewRequests();
          return promise;
        }
      }, {
        key: "_issueRequest",
        value: function _issueRequest(request) {
          var _this = this;
          var handle = request.handle, resolve = request.resolve;
          var isDone = false;
          var done = function done2() {
            if (!isDone) {
              isDone = true;
              _this.requestMap["delete"](handle);
              _this.activeRequestCount--;
              _this._issueNewRequests();
            }
          };
          this.activeRequestCount++;
          return resolve ? resolve({
            done
          }) : Promise.resolve({
            done
          });
        }
      }, {
        key: "_issueNewRequests",
        value: function _issueNewRequests() {
          var _this2 = this;
          if (!this._deferredUpdate) {
            this._deferredUpdate = setTimeout(function() {
              return _this2._issueNewRequestsAsync();
            }, 0);
          }
        }
      }, {
        key: "_issueNewRequestsAsync",
        value: function _issueNewRequestsAsync() {
          this._deferredUpdate = null;
          var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
          if (freeSlots === 0) {
            return;
          }
          this._updateAllRequests();
          for (var i = 0; i < freeSlots; ++i) {
            if (this.requestQueue.length > 0) {
              var request = this.requestQueue.shift();
              this._issueRequest(request);
            }
          }
        }
      }, {
        key: "_updateAllRequests",
        value: function _updateAllRequests() {
          var requestQueue = this.requestQueue;
          for (var i = 0; i < requestQueue.length; ++i) {
            var request = requestQueue[i];
            if (!this._updateRequest(request)) {
              requestQueue.splice(i, 1);
              this.requestMap["delete"](request.handle);
              i--;
            }
          }
          requestQueue.sort(function(a2, b) {
            return a2.priority - b.priority;
          });
        }
      }, {
        key: "_updateRequest",
        value: function _updateRequest(request) {
          request.priority = request.getPriority(request.handle);
          if (request.priority < 0) {
            request.resolve(null);
            return false;
          }
          return true;
        }
      }]);
      return RequestScheduler3;
    }();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/process-utils.js
function getAvailablePort2() {
  var defaultPort = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3e3;
  return new Promise(function(resolve, reject) {
    import_child_process3.default.exec("lsof -i -P -n | grep LISTEN", function(error2, stdout, stderr) {
      if (error2) {
        resolve(defaultPort);
        return;
      }
      var portsInUse = [];
      var regex = /:(\d+) \(LISTEN\)/;
      stdout.split("\n").forEach(function(line) {
        var match = line.match(regex);
        if (match) {
          portsInUse.push(Number(match[1]));
        }
      });
      var port = defaultPort;
      while (portsInUse.includes(port)) {
        port++;
      }
      resolve(port);
    });
  });
}
var import_child_process3;
var init_process_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/process-utils.js"() {
    import_child_process3 = __toESM(require_child_process());
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/child-process-proxy.js
function ownKeys8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator40, import_child_process4, DEFAULT_PROCESS_OPTIONS2, ChildProcessProxy2;
var init_child_process_proxy2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/child-process-proxy.js"() {
    import_regenerator40 = __toESM(require_regenerator());
    init_toConsumableArray();
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_child_process4 = __toESM(require_child_process());
    init_assert3();
    init_process_utils2();
    DEFAULT_PROCESS_OPTIONS2 = {
      command: null,
      arguments: [],
      portArg: null,
      port: "auto",
      basePort: 5e3,
      wait: 2e3,
      nodeSpawnOptions: {
        maxBuffer: 5e3 * 1024
      },
      onSuccess: function onSuccess2(processProxy) {
        console.log("Started ".concat(processProxy.options.command));
      }
    };
    ChildProcessProxy2 = function() {
      function ChildProcessProxy3() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$id = _ref.id, id = _ref$id === void 0 ? "browser-driver" : _ref$id;
        _classCallCheck(this, ChildProcessProxy3);
        this.id = id;
        this.childProcess = null;
        this.port = null;
      }
      _createClass(ChildProcessProxy3, [{
        key: "start",
        value: function() {
          var _start = _asyncToGenerator(import_regenerator40.default.mark(function _callee() {
            var _this = this;
            var options, args, _args = arguments;
            return import_regenerator40.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    options = _objectSpread8(_objectSpread8({}, DEFAULT_PROCESS_OPTIONS2), options);
                    assert3(options.command && typeof options.command === "string");
                    this.options = options;
                    args = _toConsumableArray(options.arguments);
                    this.port = options.port;
                    if (!options.portArg) {
                      _context.next = 12;
                      break;
                    }
                    if (!(this.port === "auto")) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 10;
                    return getAvailablePort2(options.basePort);
                  case 10:
                    this.port = _context.sent;
                  case 11:
                    args.push(options.portArg, this.port);
                  case 12:
                    _context.next = 14;
                    return new Promise(function(resolve, reject) {
                      try {
                        var successTimer = setTimeout(function() {
                          if (options.onSuccess) {
                            options.onSuccess(_this);
                          }
                          resolve({});
                        }, options.wait);
                        console.log("Spawning ".concat(options.command, " ").concat(options.arguments.join(" ")));
                        _this.childProcess = import_child_process4.default.spawn(options.command, args, options.spawn);
                        _this.childProcess.stderr.on("data", function(data) {
                          console.log('Child process wrote to stderr: "'.concat(data, '".'));
                          clearTimeout(successTimer);
                          reject(new Error(data));
                        });
                        _this.childProcess.on("error", function(error2) {
                          console.log("Child process errored with ".concat(error2));
                          clearTimeout(successTimer);
                          reject(error2);
                        });
                        _this.childProcess.on("close", function(code) {
                          console.log("Child process exited with ".concat(code));
                          _this.childProcess = null;
                        });
                      } catch (error2) {
                        reject(error2);
                      }
                    });
                  case 14:
                    return _context.abrupt("return", _context.sent);
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function start() {
            return _start.apply(this, arguments);
          }
          return start;
        }()
      }, {
        key: "stop",
        value: function() {
          var _stop = _asyncToGenerator(import_regenerator40.default.mark(function _callee2() {
            return import_regenerator40.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.childProcess) {
                      this.childProcess.kill();
                      this.childProcess = null;
                    }
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function stop() {
            return _stop.apply(this, arguments);
          }
          return stop;
        }()
      }, {
        key: "exit",
        value: function() {
          var _exit = _asyncToGenerator(import_regenerator40.default.mark(function _callee3() {
            var statusCode, _args3 = arguments;
            return import_regenerator40.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    statusCode = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : 0;
                    _context3.prev = 1;
                    _context3.next = 4;
                    return this.stop();
                  case 4:
                    process.exit(statusCode);
                    _context3.next = 11;
                    break;
                  case 7:
                    _context3.prev = 7;
                    _context3.t0 = _context3["catch"](1);
                    console.error(_context3.t0.message || _context3.t0);
                    process.exit(1);
                  case 11:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[1, 7]]);
          }));
          function exit() {
            return _exit.apply(this, arguments);
          }
          return exit;
        }()
      }]);
      return ChildProcessProxy3;
    }();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/categories/mesh/mesh-utils.js
var init_mesh_utils2 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/categories/mesh/mesh-utils.js"() {
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/index.js
var init_esm4 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/loader-utils/dist/esm/index.js"() {
    init_assert3();
    init_globals3();
    init_create_worker2();
    init_validate_loader_version2();
    init_make_transform_iterator2();
    init_get_transfer_list2();
    init_worker_farm2();
    init_worker_pool2();
    init_worker_thread2();
    init_library_utils2();
    init_parse_json2();
    init_buffer_utils2();
    init_array_buffer_utils2();
    init_memory_copy_utils2();
    init_binary_copy_utils2();
    init_encode_utils2();
    init_get_first_characters2();
    init_path2();
    init_file_aliases2();
    init_file_aliases2();
    init_text_iterators2();
    init_async_iteration2();
    init_request_scheduler2();
    init_child_process_proxy2();
    init_mesh_utils2();
    init_memory_copy_utils2();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js
var init_generate_url = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js"() {
    init_defineProperty();
    init_esm4();
    init_assert2();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js
var import_regenerator41;
var init_async_deep_map = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js"() {
    import_regenerator41 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_typeof();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js
var import_regenerator42;
var init_deep_load = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js"() {
    import_regenerator42 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_async_deep_map();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js
var import_regenerator43;
var init_load_image = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js"() {
    init_defineProperty();
    import_regenerator43 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_assert2();
    init_parse_image();
    init_parsed_image_api();
    init_generate_url();
    init_deep_load();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-array.js
var import_regenerator44;
var init_load_image_array = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-array.js"() {
    import_regenerator44 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_parse_image();
    init_load_image();
    init_deep_load();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-cube.js
var import_regenerator45;
var init_load_image_cube = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-cube.js"() {
    import_regenerator45 = __toESM(require_regenerator());
    init_defineProperty();
    init_asyncToGenerator();
    init_parse_image();
    init_load_image();
    init_deep_load();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/deprecated/binary-image-api-deprecated.js
var init_binary_image_api_deprecated = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/lib/deprecated/binary-image-api-deprecated.js"() {
    init_binary_image_api();
  }
});

// node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/index.js
var init_esm5 = __esm({
  "node_modules/@deck.gl/core/node_modules/@loaders.gl/images/dist/esm/index.js"() {
    init_image_loader();
    init_image_writer();
    init_binary_image_api();
    init_image_type();
    init_parsed_image_api();
    init_load_image();
    init_load_image_array();
    init_load_image_cube();
    init_image_loader();
    init_image_type();
    init_binary_image_api_deprecated();
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
  const userAgent2 = mockUserAgent || realUserAgent;
  if (userAgent2 && userAgent2.indexOf("Electron") >= 0) {
    return true;
  }
  return false;
}
var init_is_electron = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/is-electron.js"() {
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
function isBrowser4() {
  const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
  return !isNode || isElectron();
}
function isBrowserMainThread() {
  return isBrowser4() && typeof document !== "undefined";
}
var init_is_browser = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/is-browser.js"() {
    init_is_electron();
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/globals.js
var globals4, global_4, self_4, window_4, document_4, process_, console_;
var init_globals4 = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/globals.js"() {
    globals4 = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document,
      process: typeof process === "object" && process
    };
    global_4 = globalThis;
    self_4 = globals4.self || globals4.window || globals4.global;
    window_4 = globals4.window || globals4.self || globals4.global;
    document_4 = globals4.document || {};
    process_ = globals4.process || {};
    console_ = console;
  }
});

// node_modules/@probe.gl/env/dist/esm/utils/globals.js
var VERSION5, isBrowser5;
var init_globals5 = __esm({
  "node_modules/@probe.gl/env/dist/esm/utils/globals.js"() {
    init_is_browser();
    init_globals4();
    VERSION5 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
    isBrowser5 = isBrowser4();
  }
});

// node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
function isMobile() {
  return typeof window2.orientation !== "undefined";
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !isBrowser4()) {
    return "Node";
  }
  if (isElectron(mockUserAgent)) {
    return "Electron";
  }
  const navigator_ = typeof navigator !== "undefined" ? navigator : {};
  const userAgent2 = mockUserAgent || navigator_.userAgent || "";
  if (userAgent2.indexOf("Edge") > -1) {
    return "Edge";
  }
  const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
  const isTrident = userAgent2.indexOf("Trident/") !== -1;
  if (isMSIE || isTrident) {
    return "IE";
  }
  if (window2.chrome) {
    return "Chrome";
  }
  if (window2.safari) {
    return "Safari";
  }
  if (window2.mozInnerScreenX) {
    return "Firefox";
  }
  return "Unknown";
}
var window2;
var init_get_browser = __esm({
  "node_modules/@probe.gl/env/dist/esm/lib/get-browser.js"() {
    init_is_browser();
    init_is_electron();
    window2 = globalThis;
  }
});

// node_modules/@probe.gl/env/dist/esm/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var init_assert4 = __esm({
  "node_modules/@probe.gl/env/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@probe.gl/env/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  VERSION: () => VERSION5,
  assert: () => assert4,
  console: () => console_,
  document: () => document_4,
  getBrowser: () => getBrowser,
  global: () => global_4,
  isBrowser: () => isBrowser4,
  isBrowserMainThread: () => isBrowserMainThread,
  isElectron: () => isElectron,
  isMobile: () => isMobile,
  process: () => process_,
  self: () => self_4,
  window: () => window_4
});
var init_esm6 = __esm({
  "node_modules/@probe.gl/env/dist/esm/index.js"() {
    init_globals5();
    init_globals4();
    init_is_browser();
    init_get_browser();
    init_is_electron();
    init_assert4();
  }
});

// node_modules/probe.gl/env.js
var require_env = __commonJS({
  "node_modules/probe.gl/env.js"(exports, module) {
    module.exports = (init_esm6(), __toCommonJS(esm_exports2));
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e2) {
    return null;
  }
}
var LocalStorage;
var init_local_storage = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/local-storage.js"() {
    init_defineProperty();
    LocalStorage = class {
      constructor(id, defaultConfig) {
        let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
        _defineProperty(this, "storage", void 0);
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "config", void 0);
        this.storage = getStorage(type);
        this.id = id;
        this.config = defaultConfig;
        this._loadConfiguration();
      }
      getConfiguration() {
        return this.config;
      }
      setConfiguration(configuration) {
        Object.assign(this.config, configuration);
        if (this.storage) {
          const serialized = JSON.stringify(this.config);
          this.storage.setItem(this.id, serialized);
        }
      }
      _loadConfiguration() {
        let configuration = {};
        if (this.storage) {
          const serializedConfiguration = this.storage.getItem(this.id);
          configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
        }
        Object.assign(this.config, configuration);
        return this;
      }
    };
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1e3) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1e3).toFixed(2), "s");
  }
  return formatted;
}
function leftPad(string) {
  let length5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const padLength = Math.max(length5 - string.length, 0);
  return "".concat(" ".repeat(padLength)).concat(string);
}
function formatImage(image, message, scale6) {
  let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  if (image.width > maxWidth) {
    scale6 = Math.min(scale6, maxWidth / image.width);
  }
  const width = image.width * scale6;
  const height = image.height * scale6;
  const style = ["font-size:1px;", "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), "color:transparent;"].join("");
  return ["".concat(message, " %c+"), style];
}
var init_formatters = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/formatters.js"() {
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/color.js
function getColor(color) {
  return typeof color === "string" ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}
function addColor(string, color, background) {
  if (!isBrowser4 && typeof string === "string") {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }
    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }
  return string;
}
var COLOR;
var init_color = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/color.js"() {
    init_esm6();
    (function(COLOR2) {
      COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
      COLOR2[COLOR2["RED"] = 31] = "RED";
      COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
      COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
      COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
      COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
      COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
      COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
      COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
      COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
      COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
      COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
      COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
      COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
      COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
      COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
    })(COLOR || (COLOR = {}));
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/autobind.js
function autobind(obj) {
  let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  for (const key of propNames) {
    if (typeof obj[key] === "function") {
      if (!predefined.find((name) => key === name)) {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
}
var init_autobind = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/autobind.js"() {
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
var init_assert5 = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
function getHiResTimestamp2() {
  let timestamp;
  if (isBrowser4 && "performance" in window_4) {
    var _window$performance, _window$performance$n;
    timestamp = window_4 === null || window_4 === void 0 ? void 0 : (_window$performance = window_4.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
  } else if ("hrtime" in process_) {
    var _process$hrtime;
    const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
    timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}
var init_hi_res_timestamp2 = __esm({
  "node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js"() {
    init_esm6();
  }
});

// node_modules/@probe.gl/log/dist/esm/log.js
function noop() {
}
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert5(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const {
    logLevel,
    message
  } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {
  }
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== void 0) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert5(messageType === "string" || messageType === "object");
  return Object.assign(opts, {
    args
  }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message = opts.time ? "".concat(id, ": ").concat(time, "  ").concat(message) : "".concat(id, ": ").concat(message);
    message = addColor(message, opts.color, opts.background);
  }
  return message;
}
function logImageInNode(_ref2) {
  let {
    image,
    message = "",
    scale: scale6 = 1
  } = _ref2;
  console.warn("removed");
  return noop;
}
function logImageInBrowser(_ref3) {
  let {
    image,
    message = "",
    scale: scale6 = 1
  } = _ref3;
  if (typeof image === "string") {
    const img = new Image();
    img.onload = () => {
      const args = formatImage(img, message, scale6);
      console.log(...args);
    };
    img.src = image;
    return noop;
  }
  const element = image.nodeName || "";
  if (element.toLowerCase() === "img") {
    console.log(...formatImage(image, message, scale6));
    return noop;
  }
  if (element.toLowerCase() === "canvas") {
    const img = new Image();
    img.onload = () => console.log(...formatImage(img, message, scale6));
    img.src = image.toDataURL();
    return noop;
  }
  return noop;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}
var originalConsole, DEFAULT_SETTINGS, cache, ONCE, Log;
var init_log = __esm({
  "node_modules/@probe.gl/log/dist/esm/log.js"() {
    init_defineProperty();
    init_esm6();
    init_local_storage();
    init_formatters();
    init_color();
    init_autobind();
    init_assert5();
    init_hi_res_timestamp2();
    originalConsole = {
      debug: isBrowser4 ? console.debug || console.log : console.log,
      log: console.log,
      info: console.info,
      warn: console.warn,
      error: console.error
    };
    DEFAULT_SETTINGS = {
      enabled: true,
      level: 0
    };
    cache = {};
    ONCE = {
      once: true
    };
    Log = class {
      constructor() {
        let {
          id
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
          id: ""
        };
        _defineProperty(this, "id", void 0);
        _defineProperty(this, "VERSION", VERSION5);
        _defineProperty(this, "_startTs", getHiResTimestamp2());
        _defineProperty(this, "_deltaTs", getHiResTimestamp2());
        _defineProperty(this, "_storage", void 0);
        _defineProperty(this, "userData", {});
        _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
        this.id = id;
        this.userData = {};
        this._storage = new LocalStorage("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
        this.timeStamp("".concat(this.id, " started"));
        autobind(this);
        Object.seal(this);
      }
      set level(newLevel) {
        this.setLevel(newLevel);
      }
      get level() {
        return this.getLevel();
      }
      isEnabled() {
        return this._storage.config.enabled;
      }
      getLevel() {
        return this._storage.config.level;
      }
      getTotal() {
        return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
      }
      getDelta() {
        return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
      }
      set priority(newPriority) {
        this.level = newPriority;
      }
      get priority() {
        return this.level;
      }
      getPriority() {
        return this.level;
      }
      enable() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this._storage.setConfiguration({
          enabled
        });
        return this;
      }
      setLevel(level) {
        this._storage.setConfiguration({
          level
        });
        return this;
      }
      get(setting) {
        return this._storage.config[setting];
      }
      set(setting, value4) {
        this._storage.setConfiguration({
          [setting]: value4
        });
      }
      settings() {
        if (console.table) {
          console.table(this._storage.config);
        } else {
          console.log(this._storage.config);
        }
      }
      assert(condition, message) {
        assert5(condition, message);
      }
      warn(message) {
        return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
      }
      error(message) {
        return this._getLogFunction(0, message, originalConsole.error, arguments);
      }
      deprecated(oldUsage, newUsage) {
        return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
      }
      removed(oldUsage, newUsage) {
        return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
      }
      probe(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
          time: true,
          once: true
        });
      }
      log(logLevel, message) {
        return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
      }
      info(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.info, arguments);
      }
      once(logLevel, message) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }
        return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
      }
      table(logLevel, table, columns) {
        if (table) {
          return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
            tag: getTableHeader(table)
          });
        }
        return noop;
      }
      image(_ref) {
        let {
          logLevel,
          priority,
          image,
          message = "",
          scale: scale6 = 1
        } = _ref;
        if (!this._shouldLog(logLevel || priority)) {
          return noop;
        }
        return isBrowser4 ? logImageInBrowser({
          image,
          message,
          scale: scale6
        }) : logImageInNode({
          image,
          message,
          scale: scale6
        });
      }
      time(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
      }
      timeEnd(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
      }
      timeStamp(logLevel, message) {
        return this._getLogFunction(logLevel, message, console.timeStamp || noop);
      }
      group(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          collapsed: false
        };
        const options = normalizeArguments({
          logLevel,
          message,
          opts
        });
        const {
          collapsed
        } = opts;
        options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
        return this._getLogFunction(options);
      }
      groupCollapsed(logLevel, message) {
        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.group(logLevel, message, Object.assign({}, opts, {
          collapsed: true
        }));
      }
      groupEnd(logLevel) {
        return this._getLogFunction(logLevel, "", console.groupEnd || noop);
      }
      withGroup(logLevel, message, func) {
        this.group(logLevel, message)();
        try {
          func();
        } finally {
          this.groupEnd(logLevel)();
        }
      }
      trace() {
        if (console.trace) {
          console.trace();
        }
      }
      _shouldLog(logLevel) {
        return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
      }
      _getLogFunction(logLevel, message, method, args, opts) {
        if (this._shouldLog(logLevel)) {
          opts = normalizeArguments({
            logLevel,
            message,
            args,
            opts
          });
          method = method || opts.method;
          assert5(method);
          opts.total = this.getTotal();
          opts.delta = this.getDelta();
          this._deltaTs = getHiResTimestamp2();
          const tag = opts.tag || opts.message;
          if (opts.once) {
            if (!cache[tag]) {
              cache[tag] = getHiResTimestamp2();
            } else {
              return noop;
            }
          }
          message = decorateMessage(this.id, opts.message, opts);
          return method.bind(console, message, ...opts.args);
        }
        return noop;
      }
    };
    _defineProperty(Log, "VERSION", VERSION5);
  }
});

// node_modules/@probe.gl/log/dist/esm/init.js
var init_init2 = __esm({
  "node_modules/@probe.gl/log/dist/esm/init.js"() {
    globalThis.probe = {};
  }
});

// node_modules/@probe.gl/log/dist/esm/index.js
var esm_default;
var init_esm7 = __esm({
  "node_modules/@probe.gl/log/dist/esm/index.js"() {
    init_log();
    init_log();
    init_color();
    init_color();
    init_formatters();
    init_autobind();
    init_local_storage();
    init_hi_res_timestamp2();
    init_init2();
    esm_default = new Log({
      id: "@probe.gl/log"
    });
  }
});

// node_modules/probe.gl/dist/esm/index.js
var init_esm8 = __esm({
  "node_modules/probe.gl/dist/esm/index.js"() {
    init_esm6();
    init_esm6();
    init_esm6();
    init_esm6();
    init_esm6();
    init_esm6();
    init_esm7();
    init_esm7();
    init_esm7();
    init_esm7();
    init_esm7();
    init_esm7();
    init_esm7();
    init_esm7();
    init_esm();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/log.js
var log_default;
var init_log2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/log.js"() {
    init_esm8();
    log_default = new Log({
      id: "deck"
    });
  }
});

// node_modules/@deck.gl/core/dist/esm/debug/loggers.js
var logState, LOG_LEVEL_MAJOR_UPDATE, LOG_LEVEL_MINOR_UPDATE, LOG_LEVEL_UPDATE_DETAIL, LOG_LEVEL_INFO, LOG_LEVEL_DRAW, getLoggers;
var init_loggers2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/debug/loggers.js"() {
    logState = {
      attributeUpdateMessages: []
    };
    LOG_LEVEL_MAJOR_UPDATE = 1;
    LOG_LEVEL_MINOR_UPDATE = 2;
    LOG_LEVEL_UPDATE_DETAIL = 3;
    LOG_LEVEL_INFO = 4;
    LOG_LEVEL_DRAW = 2;
    getLoggers = function getLoggers2(log3) {
      return {
        "layer.changeFlag": function layerChangeFlag(layer, key, flags) {
          log3.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
        },
        "layer.initialize": function layerInitialize(layer) {
          log3.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
        },
        "layer.update": function layerUpdate(layer, needsUpdate) {
          if (needsUpdate) {
            var flags = layer.getChangeFlags();
            log3.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter(function(key) {
              return flags[key];
            }).join(", ")))();
          } else {
            log3.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
          }
        },
        "layer.matched": function layerMatched(layer, changed) {
          if (changed) {
            log3.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
          }
        },
        "layer.finalize": function layerFinalize(layer) {
          log3.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
        },
        "compositeLayer.renderLayers": function compositeLayerRenderLayers(layer, updated, subLayers) {
          if (updated) {
            log3.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
          } else {
            log3.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
          }
        },
        "layerManager.setLayers": function layerManagerSetLayers(layerManager, updated, layers) {
          if (updated) {
            log3.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
          }
        },
        "layerManager.activateViewport": function layerManagerActivateViewport(layerManager, viewport) {
          log3.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
        },
        "attributeManager.invalidate": function attributeManagerInvalidate(attributeManager, trigger, attributeNames) {
          log3.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
        },
        "attributeManager.updateStart": function attributeManagerUpdateStart(attributeManager) {
          logState.attributeUpdateMessages.length = 0;
          logState.attributeManagerUpdateStart = Date.now();
        },
        "attributeManager.updateEnd": function attributeManagerUpdateEnd(attributeManager, numInstances) {
          var timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
          log3.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = logState.attributeUpdateMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var updateMessage = _step.value;
              log3.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          log3.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
        },
        "attribute.updateStart": function attributeUpdateStart(attribute) {
          logState.attributeUpdateStart = Date.now();
        },
        "attribute.allocate": function attributeAllocate(attribute, numInstances) {
          var message = "".concat(attribute.id, " allocated ").concat(numInstances);
          logState.attributeUpdateMessages.push(message);
        },
        "attribute.updateEnd": function attributeUpdateEnd(attribute, numInstances) {
          var timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
          var message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
          logState.attributeUpdateMessages.push(message);
        },
        "deckRenderer.renderLayers": function deckRendererRenderLayers(deckRenderer, renderStats, opts) {
          var pass = opts.pass, redrawReason = opts.redrawReason, stats = opts.stats;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = renderStats[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var status = _step2.value;
              var totalCount = status.totalCount, visibleCount = status.visibleCount, compositeCount = status.compositeCount, pickableCount = status.pickableCount;
              var primitiveCount = totalCount - compositeCount;
              var hiddenCount = primitiveCount - visibleCount;
              log3.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
              if (stats) {
                stats.get("Redraw Layers").add(visibleCount);
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/debug/index.js
function register(handlers) {
  loggers = handlers;
}
function debug(eventType) {
  if (log_default.level > 0 && loggers[eventType]) {
    var _loggers$eventType;
    (_loggers$eventType = loggers[eventType]).call.apply(_loggers$eventType, arguments);
  }
}
var loggers;
var init_debug = __esm({
  "node_modules/@deck.gl/core/dist/esm/debug/index.js"() {
    init_log2();
    init_loggers2();
    loggers = {};
    if (true) {
      loggers = getLoggers(log_default);
    }
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/json-loader.js
function isJSON(text) {
  var firstChar = text[0];
  var lastChar = text[text.length - 1];
  return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
}
var json_loader_default;
var init_json_loader = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/json-loader.js"() {
    json_loader_default = {
      name: "JSON",
      extensions: ["json", "geojson"],
      testText: isJSON,
      parseTextSync: JSON.parse
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/init.js
var import_env10, version2, existingVersion, init_default2;
var init_init3 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/init.js"() {
    init_esm3();
    init_esm5();
    import_env10 = __toESM(require_env());
    init_log2();
    init_debug();
    init_json_loader();
    version2 = true ? "8.2.0" : import_env10.global.DECK_VERSION || "untranspiled source";
    existingVersion = import_env10.global.deck && import_env10.global.deck.VERSION;
    if (existingVersion && existingVersion !== version2) {
      throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version2));
    }
    if (!existingVersion) {
      if (true) {
        log_default.log(0, "deck.gl ".concat(version2, " - set deck.log.level=1 (or higher) to trace attribute updates"))();
      }
      import_env10.global.deck = Object.assign(import_env10.global.deck || {}, {
        VERSION: version2,
        version: version2,
        log: log_default,
        _registerLoggers: register
      });
      registerLoaders([json_loader_default, image_loader_default]);
    }
    init_default2 = import_env10.global.deck;
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/log.js
var log;
var init_log3 = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/log.js"() {
    init_esm7();
    log = new Log({
      id: "luma.gl"
    });
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
function assert6(condition, message) {
  if (!condition) {
    throw new Error(message || "luma.gl: assertion failed.");
  }
}
var init_assert6 = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
function isWebGL(gl) {
  if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
    return true;
  }
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && Number.isFinite(gl._version));
}
function isWebGL2(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getWebGL2Context(gl) {
  return isWebGL2(gl) ? gl : null;
}
function assertWebGLContext(gl) {
  assert6(isWebGL(gl), ERR_CONTEXT);
  return gl;
}
function assertWebGL2Context(gl) {
  assert6(isWebGL2(gl), ERR_WEBGL2);
  return gl;
}
var ERR_CONTEXT, ERR_WEBGL2;
var init_webgl_checks = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js"() {
    init_assert6();
    ERR_CONTEXT = "Invalid WebGLRenderingContext";
    ERR_WEBGL2 = "Requires WebGL2";
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
function error(msg) {
  if (globalThis.console && globalThis.console.error) {
    globalThis.console.error(msg);
  }
}
function log2(msg) {
  if (globalThis.console && globalThis.console.log) {
    globalThis.console.log(msg);
  }
}
function synthesizeGLError(err, opt_msg) {
  glErrorShadow[err] = true;
  if (opt_msg !== void 0) {
    error(opt_msg);
  }
}
function wrapGLError(gl) {
  const f = gl.getError;
  gl.getError = function getError() {
    let err;
    do {
      err = f.apply(gl);
      if (err !== 0) {
        glErrorShadow[err] = true;
      }
    } while (err !== 0);
    for (err in glErrorShadow) {
      if (glErrorShadow[err]) {
        delete glErrorShadow[err];
        return parseInt(err, 10);
      }
    }
    return 0;
  };
}
function polyfillVertexArrayObject(gl) {
  if (typeof gl.createVertexArray === "function") {
    return;
  }
  const original_getSupportedExtensions = gl.getSupportedExtensions;
  gl.getSupportedExtensions = function getSupportedExtensions() {
    const list = original_getSupportedExtensions.call(this) || [];
    if (list.indexOf("OES_vertex_array_object") < 0) {
      list.push("OES_vertex_array_object");
    }
    return list;
  };
  const original_getExtension = gl.getExtension;
  gl.getExtension = function getExtension(name) {
    const ext = original_getExtension.call(this, name);
    if (ext) {
      return ext;
    }
    if (name !== "OES_vertex_array_object") {
      return null;
    }
    if (!gl.__OESVertexArrayObject) {
      this.__OESVertexArrayObject = new OESVertexArrayObject(this);
    }
    return this.__OESVertexArrayObject;
  };
}
var glErrorShadow, WebGLVertexArrayObjectOES, OESVertexArrayObject;
var init_polyfill_vertex_array_object = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js"() {
    glErrorShadow = {};
    WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
      const gl = ext.gl;
      this.ext = ext;
      this.isAlive = true;
      this.hasBeenBound = false;
      this.elementArrayBuffer = null;
      this.attribs = new Array(ext.maxVertexAttribs);
      for (let n = 0; n < this.attribs.length; n++) {
        const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
        this.attribs[n] = attrib;
      }
      this.maxAttrib = 0;
    };
    WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
      this.enabled = false;
      this.buffer = null;
      this.size = 4;
      this.type = 5126;
      this.normalized = false;
      this.stride = 16;
      this.offset = 0;
      this.cached = "";
      this.recache();
    };
    WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
      this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
    };
    OESVertexArrayObject = function OESVertexArrayObject2(gl) {
      const self2 = this;
      this.gl = gl;
      wrapGLError(gl);
      const original = this.original = {
        getParameter: gl.getParameter,
        enableVertexAttribArray: gl.enableVertexAttribArray,
        disableVertexAttribArray: gl.disableVertexAttribArray,
        bindBuffer: gl.bindBuffer,
        getVertexAttrib: gl.getVertexAttrib,
        vertexAttribPointer: gl.vertexAttribPointer
      };
      gl.getParameter = function getParameter(pname) {
        if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
          if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
            return null;
          }
          return self2.currentVertexArrayObject;
        }
        return original.getParameter.apply(this, arguments);
      };
      gl.enableVertexAttribArray = function enableVertexAttribArray(index) {
        const vao = self2.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = true;
        return original.enableVertexAttribArray.apply(this, arguments);
      };
      gl.disableVertexAttribArray = function disableVertexAttribArray(index) {
        const vao = self2.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, index);
        const attrib = vao.attribs[index];
        attrib.enabled = false;
        return original.disableVertexAttribArray.apply(this, arguments);
      };
      gl.bindBuffer = function bindBuffer(target, buffer) {
        switch (target) {
          case 34962:
            self2.currentArrayBuffer = buffer;
            break;
          case 34963:
            self2.currentVertexArrayObject.elementArrayBuffer = buffer;
            break;
          default:
        }
        return original.bindBuffer.apply(this, arguments);
      };
      gl.getVertexAttrib = function getVertexAttrib(index, pname) {
        const vao = self2.currentVertexArrayObject;
        const attrib = vao.attribs[index];
        switch (pname) {
          case 34975:
            return attrib.buffer;
          case 34338:
            return attrib.enabled;
          case 34339:
            return attrib.size;
          case 34340:
            return attrib.stride;
          case 34341:
            return attrib.type;
          case 34922:
            return attrib.normalized;
          default:
            return original.getVertexAttrib.apply(this, arguments);
        }
      };
      gl.vertexAttribPointer = function vertexAttribPointer(indx, size, type, normalized, stride, offset) {
        const vao = self2.currentVertexArrayObject;
        vao.maxAttrib = Math.max(vao.maxAttrib, indx);
        const attrib = vao.attribs[indx];
        attrib.buffer = self2.currentArrayBuffer;
        attrib.size = size;
        attrib.type = type;
        attrib.normalized = normalized;
        attrib.stride = stride;
        attrib.offset = offset;
        attrib.recache();
        return original.vertexAttribPointer.apply(this, arguments);
      };
      if (gl.instrumentExtension) {
        gl.instrumentExtension(this, "OES_vertex_array_object");
      }
      if (gl.canvas) {
        gl.canvas.addEventListener("webglcontextrestored", () => {
          log2("OESVertexArrayObject emulation library context restored");
          self2.reset_();
        }, true);
      }
      this.reset_();
    };
    OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
    OESVertexArrayObject.prototype.reset_ = function reset_() {
      const contextWasLost = this.vertexArrayObjects !== void 0;
      if (contextWasLost) {
        for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
          this.vertexArrayObjects.isAlive = false;
        }
      }
      const gl = this.gl;
      this.maxVertexAttribs = gl.getParameter(34921);
      this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
      this.currentVertexArrayObject = null;
      this.currentArrayBuffer = null;
      this.vertexArrayObjects = [this.defaultVertexArrayObject];
      this.bindVertexArrayOES(null);
    };
    OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
      const arrayObject = new WebGLVertexArrayObjectOES(this);
      this.vertexArrayObjects.push(arrayObject);
      return arrayObject;
    };
    OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
      arrayObject.isAlive = false;
      this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
      if (this.currentVertexArrayObject === arrayObject) {
        this.bindVertexArrayOES(null);
      }
    };
    OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
      if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
        if (arrayObject.hasBeenBound && arrayObject.ext === this) {
          return true;
        }
      }
      return false;
    };
    OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
      const gl = this.gl;
      if (arrayObject && !arrayObject.isAlive) {
        synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
        return;
      }
      const original = this.original;
      const oldVAO = this.currentVertexArrayObject;
      this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
      this.currentVertexArrayObject.hasBeenBound = true;
      const newVAO = this.currentVertexArrayObject;
      if (oldVAO === newVAO) {
        return;
      }
      if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
        original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
      }
      let currentBinding = this.currentArrayBuffer;
      const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
      for (let n = 0; n <= maxAttrib; n++) {
        const attrib = newVAO.attribs[n];
        const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
        if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
          if (attrib.enabled) {
            original.enableVertexAttribArray.call(gl, n);
          } else {
            original.disableVertexAttribArray.call(gl, n);
          }
        }
        if (attrib.enabled) {
          let bufferChanged = false;
          if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
            if (currentBinding !== attrib.buffer) {
              original.bindBuffer.call(gl, 34962, attrib.buffer);
              currentBinding = attrib.buffer;
            }
            bufferChanged = true;
          }
          if (bufferChanged || attrib.cached !== oldAttrib.cached) {
            original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
          }
        }
      }
      if (this.currentArrayBuffer !== currentBinding) {
        original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
      }
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
function getParameterPolyfill(gl, originalGetParameter, pname) {
  const limit = WEBGL_PARAMETERS[pname];
  const value4 = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
  const result = value4 !== void 0 ? value4 : originalGetParameter(pname);
  return result;
}
var OES_element_index, WEBGL_draw_buffers, EXT_disjoint_timer_query, EXT_disjoint_timer_query_webgl2, EXT_texture_filter_anisotropic, WEBGL_debug_renderer_info, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, GL_DONT_CARE, GL_GPU_DISJOINT_EXT, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, GL_UNMASKED_VENDOR_WEBGL, GL_UNMASKED_RENDERER_WEBGL, getWebGL2ValueOrZero, WEBGL_PARAMETERS;
var init_get_parameter_polyfill = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js"() {
    init_webgl_checks();
    OES_element_index = "OES_element_index";
    WEBGL_draw_buffers = "WEBGL_draw_buffers";
    EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
    EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
    EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
    WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
    GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
    GL_DONT_CARE = 4352;
    GL_GPU_DISJOINT_EXT = 36795;
    GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
    GL_UNMASKED_VENDOR_WEBGL = 37445;
    GL_UNMASKED_RENDERER_WEBGL = 37446;
    getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
    WEBGL_PARAMETERS = {
      [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
      [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
      [35977]: getWebGL2ValueOrZero,
      [32937]: getWebGL2ValueOrZero,
      [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
        const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
        return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
      },
      [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
        const ext = gl.getExtension(WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
      },
      [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
        const ext = gl.getExtension(WEBGL_debug_renderer_info);
        return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
      },
      [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
        const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
        return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
      },
      [32883]: getWebGL2ValueOrZero,
      [35071]: getWebGL2ValueOrZero,
      [37447]: getWebGL2ValueOrZero,
      [36063]: (gl, getParameter) => {
        if (!isWebGL2(gl)) {
          const ext = gl.getExtension(WEBGL_draw_buffers);
          return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
        }
        return void 0;
      },
      [35379]: getWebGL2ValueOrZero,
      [35374]: getWebGL2ValueOrZero,
      [35377]: getWebGL2ValueOrZero,
      [34852]: (gl) => {
        if (!isWebGL2(gl)) {
          const ext = gl.getExtension(WEBGL_draw_buffers);
          return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
        }
        return void 0;
      },
      [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
      [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
      [33e3]: (gl) => 16777216,
      [37157]: getWebGL2ValueOrZero,
      [35373]: getWebGL2ValueOrZero,
      [35657]: getWebGL2ValueOrZero,
      [36183]: getWebGL2ValueOrZero,
      [37137]: getWebGL2ValueOrZero,
      [34045]: getWebGL2ValueOrZero,
      [35978]: getWebGL2ValueOrZero,
      [35979]: getWebGL2ValueOrZero,
      [35968]: getWebGL2ValueOrZero,
      [35376]: getWebGL2ValueOrZero,
      [35375]: getWebGL2ValueOrZero,
      [35659]: getWebGL2ValueOrZero,
      [37154]: getWebGL2ValueOrZero,
      [35371]: getWebGL2ValueOrZero,
      [35658]: getWebGL2ValueOrZero,
      [35076]: getWebGL2ValueOrZero,
      [35077]: getWebGL2ValueOrZero,
      [35380]: getWebGL2ValueOrZero
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}
var OES_vertex_array_object, ANGLE_instanced_arrays, WEBGL_draw_buffers2, EXT_disjoint_timer_query2, EXT_texture_filter_anisotropic2, ERR_VAO_NOT_SUPPORTED, WEBGL2_CONTEXT_POLYFILLS, WEBGL2_CONTEXT_OVERRIDES;
var init_polyfill_table = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js"() {
    init_assert6();
    init_webgl_checks();
    init_get_parameter_polyfill();
    OES_vertex_array_object = "OES_vertex_array_object";
    ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
    WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
    EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
    EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
    ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
    WEBGL2_CONTEXT_POLYFILLS = {
      [OES_vertex_array_object]: {
        meta: {
          suffix: "OES"
        },
        createVertexArray: () => {
          assert6(false, ERR_VAO_NOT_SUPPORTED);
        },
        deleteVertexArray: () => {
        },
        bindVertexArray: () => {
        },
        isVertexArray: () => false
      },
      [ANGLE_instanced_arrays]: {
        meta: {
          suffix: "ANGLE"
        },
        vertexAttribDivisor(location, divisor) {
          assert6(divisor === 0, "WebGL instanced rendering not supported");
        },
        drawElementsInstanced: () => {
        },
        drawArraysInstanced: () => {
        }
      },
      [WEBGL_draw_buffers2]: {
        meta: {
          suffix: "WEBGL"
        },
        drawBuffers: () => {
          assert6(false);
        }
      },
      [EXT_disjoint_timer_query2]: {
        meta: {
          suffix: "EXT"
        },
        createQuery: () => {
          assert6(false);
        },
        deleteQuery: () => {
          assert6(false);
        },
        beginQuery: () => {
          assert6(false);
        },
        endQuery: () => {
        },
        getQuery(handle, pname) {
          return this.getQueryObject(handle, pname);
        },
        getQueryParameter(handle, pname) {
          return this.getQueryObject(handle, pname);
        },
        getQueryObject: () => {
        }
      }
    };
    WEBGL2_CONTEXT_OVERRIDES = {
      readBuffer: (gl, originalFunc, attachment) => {
        if (isWebGL2(gl)) {
          originalFunc(attachment);
        } else {
        }
      },
      getVertexAttrib: (gl, originalFunc, location, pname) => {
        const {
          webgl2,
          ext
        } = getExtensionData(gl, ANGLE_instanced_arrays);
        let result;
        switch (pname) {
          case 35069:
            result = !webgl2 ? false : void 0;
            break;
          case 35070:
            result = !webgl2 && !ext ? 0 : void 0;
            break;
          default:
        }
        return result !== void 0 ? result : originalFunc(location, pname);
      },
      getProgramParameter: (gl, originalFunc, program, pname) => {
        if (!isWebGL2(gl)) {
          switch (pname) {
            case 35967:
              return 35981;
            case 35971:
              return 0;
            case 35382:
              return 0;
            default:
          }
        }
        return originalFunc(program, pname);
      },
      getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
        if (!isWebGL2(gl)) {
          switch (pname) {
            case 32937:
              return new Int32Array([0]);
            default:
          }
        }
        return gl.getInternalformatParameter(target, format, pname);
      },
      getTexParameter(gl, originalFunc, target, pname) {
        switch (pname) {
          case 34046:
            const {
              extensions
            } = gl.luma;
            const ext = extensions[EXT_texture_filter_anisotropic2];
            pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
            break;
          default:
        }
        return originalFunc(target, pname);
      },
      getParameter: getParameterPolyfill,
      hint(gl, originalFunc, pname, value4) {
        return originalFunc(pname, value4);
      }
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  const {
    luma
  } = gl;
  if (!luma.polyfilled) {
    polyfillVertexArrayObject(gl);
    initializeExtensions(gl);
    installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
    installOverrides(gl, {
      target: luma,
      target2: gl
    });
    luma.polyfilled = true;
  }
  return gl;
}
function initializeExtensions(gl) {
  gl.luma.extensions = {};
  const EXTENSIONS2 = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS2) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}
function installOverrides(gl, _ref) {
  let {
    target,
    target2
  } = _ref;
  Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
    if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
      };
      const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}
function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== "overrides") {
      polyfillExtension(gl, {
        extension,
        target: gl.luma,
        target2: gl
      });
    }
  }
}
function polyfillExtension(gl, _ref2) {
  let {
    extension,
    target,
    target2
  } = _ref2;
  const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
  assert6(defaults);
  const {
    meta = {}
  } = defaults;
  const {
    suffix = ""
  } = meta;
  const ext = gl.getExtension(extension);
  for (const key of Object.keys(defaults)) {
    const extKey = "".concat(key).concat(suffix);
    let polyfill = null;
    if (key === "meta") {
    } else if (typeof gl[key] === "function") {
    } else if (ext && typeof ext[extKey] === "function") {
      polyfill = function() {
        return ext[extKey](...arguments);
      };
    } else if (typeof defaults[key] === "function") {
      polyfill = defaults[key].bind(target);
    }
    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}
var init_polyfill_context = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js"() {
    init_polyfill_vertex_array_object();
    init_assert6();
    init_polyfill_table();
    globalThis.polyfillContext = polyfillContext;
  }
});

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}
function getValue(glEnum, values, cache2) {
  return values[glEnum] !== void 0 ? values[glEnum] : cache2[glEnum];
}
var GL_PARAMETER_DEFAULTS, enable, hint, pixelStorei, drawFramebuffer, readFramebuffer, GL_PARAMETER_SETTERS, GL_COMPOSITE_PARAMETER_SETTERS, GL_HOOKED_SETTERS, isEnabled, GL_PARAMETER_GETTERS;
var init_webgl_parameter_tables = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js"() {
    init_webgl_checks();
    GL_PARAMETER_DEFAULTS = {
      [3042]: false,
      [32773]: new Float32Array([0, 0, 0, 0]),
      [32777]: 32774,
      [34877]: 32774,
      [32969]: 1,
      [32968]: 0,
      [32971]: 1,
      [32970]: 0,
      [3106]: new Float32Array([0, 0, 0, 0]),
      [3107]: [true, true, true, true],
      [2884]: false,
      [2885]: 1029,
      [2929]: false,
      [2931]: 1,
      [2932]: 513,
      [2928]: new Float32Array([0, 1]),
      [2930]: true,
      [3024]: true,
      [36006]: null,
      [2886]: 2305,
      [33170]: 4352,
      [2849]: 1,
      [32823]: false,
      [32824]: 0,
      [10752]: 0,
      [32938]: 1,
      [32939]: false,
      [3089]: false,
      [3088]: new Int32Array([0, 0, 1024, 1024]),
      [2960]: false,
      [2961]: 0,
      [2968]: 4294967295,
      [36005]: 4294967295,
      [2962]: 519,
      [2967]: 0,
      [2963]: 4294967295,
      [34816]: 519,
      [36003]: 0,
      [36004]: 4294967295,
      [2964]: 7680,
      [2965]: 7680,
      [2966]: 7680,
      [34817]: 7680,
      [34818]: 7680,
      [34819]: 7680,
      [2978]: [0, 0, 1024, 1024],
      [3333]: 4,
      [3317]: 4,
      [37440]: false,
      [37441]: false,
      [37443]: 37444,
      [35723]: 4352,
      [36010]: null,
      [35977]: false,
      [3330]: 0,
      [3332]: 0,
      [3331]: 0,
      [3314]: 0,
      [32878]: 0,
      [3316]: 0,
      [3315]: 0,
      [32877]: 0
    };
    enable = (gl, value4, key) => value4 ? gl.enable(key) : gl.disable(key);
    hint = (gl, value4, key) => gl.hint(key, value4);
    pixelStorei = (gl, value4, key) => gl.pixelStorei(key, value4);
    drawFramebuffer = (gl, value4) => {
      const target = isWebGL2(gl) ? 36009 : 36160;
      return gl.bindFramebuffer(target, value4);
    };
    readFramebuffer = (gl, value4) => {
      return gl.bindFramebuffer(36008, value4);
    };
    GL_PARAMETER_SETTERS = {
      [3042]: enable,
      [32773]: (gl, value4) => gl.blendColor(...value4),
      [32777]: "blendEquation",
      [34877]: "blendEquation",
      [32969]: "blendFunc",
      [32968]: "blendFunc",
      [32971]: "blendFunc",
      [32970]: "blendFunc",
      [3106]: (gl, value4) => gl.clearColor(...value4),
      [3107]: (gl, value4) => gl.colorMask(...value4),
      [2884]: enable,
      [2885]: (gl, value4) => gl.cullFace(value4),
      [2929]: enable,
      [2931]: (gl, value4) => gl.clearDepth(value4),
      [2932]: (gl, value4) => gl.depthFunc(value4),
      [2928]: (gl, value4) => gl.depthRange(...value4),
      [2930]: (gl, value4) => gl.depthMask(value4),
      [3024]: enable,
      [35723]: hint,
      [36006]: drawFramebuffer,
      [2886]: (gl, value4) => gl.frontFace(value4),
      [33170]: hint,
      [2849]: (gl, value4) => gl.lineWidth(value4),
      [32823]: enable,
      [32824]: "polygonOffset",
      [10752]: "polygonOffset",
      [35977]: enable,
      [32938]: "sampleCoverage",
      [32939]: "sampleCoverage",
      [3089]: enable,
      [3088]: (gl, value4) => gl.scissor(...value4),
      [2960]: enable,
      [2961]: (gl, value4) => gl.clearStencil(value4),
      [2968]: (gl, value4) => gl.stencilMaskSeparate(1028, value4),
      [36005]: (gl, value4) => gl.stencilMaskSeparate(1029, value4),
      [2962]: "stencilFuncFront",
      [2967]: "stencilFuncFront",
      [2963]: "stencilFuncFront",
      [34816]: "stencilFuncBack",
      [36003]: "stencilFuncBack",
      [36004]: "stencilFuncBack",
      [2964]: "stencilOpFront",
      [2965]: "stencilOpFront",
      [2966]: "stencilOpFront",
      [34817]: "stencilOpBack",
      [34818]: "stencilOpBack",
      [34819]: "stencilOpBack",
      [2978]: (gl, value4) => gl.viewport(...value4),
      [3333]: pixelStorei,
      [3317]: pixelStorei,
      [37440]: pixelStorei,
      [37441]: pixelStorei,
      [37443]: pixelStorei,
      [3330]: pixelStorei,
      [3332]: pixelStorei,
      [3331]: pixelStorei,
      [36010]: readFramebuffer,
      [3314]: pixelStorei,
      [32878]: pixelStorei,
      [3316]: pixelStorei,
      [3315]: pixelStorei,
      [32877]: pixelStorei,
      framebuffer: (gl, framebuffer) => {
        const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
        return gl.bindFramebuffer(36160, handle);
      },
      blend: (gl, value4) => value4 ? gl.enable(3042) : gl.disable(3042),
      blendColor: (gl, value4) => gl.blendColor(...value4),
      blendEquation: (gl, args) => {
        args = isArray(args) ? args : [args, args];
        gl.blendEquationSeparate(...args);
      },
      blendFunc: (gl, args) => {
        args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
        gl.blendFuncSeparate(...args);
      },
      clearColor: (gl, value4) => gl.clearColor(...value4),
      clearDepth: (gl, value4) => gl.clearDepth(value4),
      clearStencil: (gl, value4) => gl.clearStencil(value4),
      colorMask: (gl, value4) => gl.colorMask(...value4),
      cull: (gl, value4) => value4 ? gl.enable(2884) : gl.disable(2884),
      cullFace: (gl, value4) => gl.cullFace(value4),
      depthTest: (gl, value4) => value4 ? gl.enable(2929) : gl.disable(2929),
      depthFunc: (gl, value4) => gl.depthFunc(value4),
      depthMask: (gl, value4) => gl.depthMask(value4),
      depthRange: (gl, value4) => gl.depthRange(...value4),
      dither: (gl, value4) => value4 ? gl.enable(3024) : gl.disable(3024),
      derivativeHint: (gl, value4) => {
        gl.hint(35723, value4);
      },
      frontFace: (gl, value4) => gl.frontFace(value4),
      mipmapHint: (gl, value4) => gl.hint(33170, value4),
      lineWidth: (gl, value4) => gl.lineWidth(value4),
      polygonOffsetFill: (gl, value4) => value4 ? gl.enable(32823) : gl.disable(32823),
      polygonOffset: (gl, value4) => gl.polygonOffset(...value4),
      sampleCoverage: (gl, value4) => gl.sampleCoverage(...value4),
      scissorTest: (gl, value4) => value4 ? gl.enable(3089) : gl.disable(3089),
      scissor: (gl, value4) => gl.scissor(...value4),
      stencilTest: (gl, value4) => value4 ? gl.enable(2960) : gl.disable(2960),
      stencilMask: (gl, value4) => {
        value4 = isArray(value4) ? value4 : [value4, value4];
        const [mask, backMask] = value4;
        gl.stencilMaskSeparate(1028, mask);
        gl.stencilMaskSeparate(1029, backMask);
      },
      stencilFunc: (gl, args) => {
        args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
        const [func, ref, mask, backFunc, backRef, backMask] = args;
        gl.stencilFuncSeparate(1028, func, ref, mask);
        gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
      },
      stencilOp: (gl, args) => {
        args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
        const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
        gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
        gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
      },
      viewport: (gl, value4) => gl.viewport(...value4)
    };
    GL_COMPOSITE_PARAMETER_SETTERS = {
      blendEquation: (gl, values, cache2) => gl.blendEquationSeparate(getValue(32777, values, cache2), getValue(34877, values, cache2)),
      blendFunc: (gl, values, cache2) => gl.blendFuncSeparate(getValue(32969, values, cache2), getValue(32968, values, cache2), getValue(32971, values, cache2), getValue(32970, values, cache2)),
      polygonOffset: (gl, values, cache2) => gl.polygonOffset(getValue(32824, values, cache2), getValue(10752, values, cache2)),
      sampleCoverage: (gl, values, cache2) => gl.sampleCoverage(getValue(32938, values, cache2), getValue(32939, values, cache2)),
      stencilFuncFront: (gl, values, cache2) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache2), getValue(2967, values, cache2), getValue(2963, values, cache2)),
      stencilFuncBack: (gl, values, cache2) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache2), getValue(36003, values, cache2), getValue(36004, values, cache2)),
      stencilOpFront: (gl, values, cache2) => gl.stencilOpSeparate(1028, getValue(2964, values, cache2), getValue(2965, values, cache2), getValue(2966, values, cache2)),
      stencilOpBack: (gl, values, cache2) => gl.stencilOpSeparate(1029, getValue(34817, values, cache2), getValue(34818, values, cache2), getValue(34819, values, cache2))
    };
    GL_HOOKED_SETTERS = {
      enable: (update, capability) => update({
        [capability]: true
      }),
      disable: (update, capability) => update({
        [capability]: false
      }),
      pixelStorei: (update, pname, value4) => update({
        [pname]: value4
      }),
      hint: (update, pname, hint2) => update({
        [pname]: hint2
      }),
      bindFramebuffer: (update, target, framebuffer) => {
        switch (target) {
          case 36160:
            return update({
              [36006]: framebuffer,
              [36010]: framebuffer
            });
          case 36009:
            return update({
              [36006]: framebuffer
            });
          case 36008:
            return update({
              [36010]: framebuffer
            });
          default:
            return null;
        }
      },
      blendColor: (update, r, g, b, a2) => update({
        [32773]: new Float32Array([r, g, b, a2])
      }),
      blendEquation: (update, mode) => update({
        [32777]: mode,
        [34877]: mode
      }),
      blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
        [32777]: modeRGB,
        [34877]: modeAlpha
      }),
      blendFunc: (update, src, dst) => update({
        [32969]: src,
        [32968]: dst,
        [32971]: src,
        [32970]: dst
      }),
      blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
        [32969]: srcRGB,
        [32968]: dstRGB,
        [32971]: srcAlpha,
        [32970]: dstAlpha
      }),
      clearColor: (update, r, g, b, a2) => update({
        [3106]: new Float32Array([r, g, b, a2])
      }),
      clearDepth: (update, depth) => update({
        [2931]: depth
      }),
      clearStencil: (update, s) => update({
        [2961]: s
      }),
      colorMask: (update, r, g, b, a2) => update({
        [3107]: [r, g, b, a2]
      }),
      cullFace: (update, mode) => update({
        [2885]: mode
      }),
      depthFunc: (update, func) => update({
        [2932]: func
      }),
      depthRange: (update, zNear, zFar) => update({
        [2928]: new Float32Array([zNear, zFar])
      }),
      depthMask: (update, mask) => update({
        [2930]: mask
      }),
      frontFace: (update, face) => update({
        [2886]: face
      }),
      lineWidth: (update, width) => update({
        [2849]: width
      }),
      polygonOffset: (update, factor, units) => update({
        [32824]: factor,
        [10752]: units
      }),
      sampleCoverage: (update, value4, invert4) => update({
        [32938]: value4,
        [32939]: invert4
      }),
      scissor: (update, x, y, width, height) => update({
        [3088]: new Int32Array([x, y, width, height])
      }),
      stencilMask: (update, mask) => update({
        [2968]: mask,
        [36005]: mask
      }),
      stencilMaskSeparate: (update, face, mask) => update({
        [face === 1028 ? 2968 : 36005]: mask
      }),
      stencilFunc: (update, func, ref, mask) => update({
        [2962]: func,
        [2967]: ref,
        [2963]: mask,
        [34816]: func,
        [36003]: ref,
        [36004]: mask
      }),
      stencilFuncSeparate: (update, face, func, ref, mask) => update({
        [face === 1028 ? 2962 : 34816]: func,
        [face === 1028 ? 2967 : 36003]: ref,
        [face === 1028 ? 2963 : 36004]: mask
      }),
      stencilOp: (update, fail, zfail, zpass) => update({
        [2964]: fail,
        [2965]: zfail,
        [2966]: zpass,
        [34817]: fail,
        [34818]: zfail,
        [34819]: zpass
      }),
      stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
        [face === 1028 ? 2964 : 34817]: fail,
        [face === 1028 ? 2965 : 34818]: zfail,
        [face === 1028 ? 2966 : 34819]: zpass
      }),
      viewport: (update, x, y, width, height) => update({
        [2978]: [x, y, width, height]
      })
    };
    isEnabled = (gl, key) => gl.isEnabled(key);
    GL_PARAMETER_GETTERS = {
      [3042]: isEnabled,
      [2884]: isEnabled,
      [2929]: isEnabled,
      [3024]: isEnabled,
      [32823]: isEnabled,
      [32926]: isEnabled,
      [32928]: isEnabled,
      [3089]: isEnabled,
      [2960]: isEnabled,
      [35977]: isEnabled
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var init_utils = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/utils.js"() {
  }
});

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
function installGetterOverride(gl, functionName) {
  const originalGetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function get2() {
    const pname = arguments.length <= 0 ? void 0 : arguments[0];
    if (!(pname in gl.state.cache)) {
      return originalGetterFunc(...arguments);
    }
    return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
  };
  Object.defineProperty(gl[functionName], "name", {
    value: "".concat(functionName, "-from-cache"),
    configurable: false
  });
}
function installSetterSpy(gl, functionName, setter) {
  const originalSetterFunc = gl[functionName].bind(gl);
  gl[functionName] = function set2() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    const {
      valueChanged,
      oldValue
    } = setter(gl.state._updateCache, ...params);
    if (valueChanged) {
      originalSetterFunc(...params);
    }
    return oldValue;
  };
  Object.defineProperty(gl[functionName], "name", {
    value: "".concat(functionName, "-to-cache"),
    configurable: false
  });
}
function installProgramSpy(gl) {
  const originalUseProgram = gl.useProgram.bind(gl);
  gl.useProgram = function useProgramLuma(handle) {
    if (gl.state.program !== handle) {
      originalUseProgram(handle);
      gl.state.program = handle;
    }
  };
}
function trackContextState(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    enable: enable2 = true,
    copyState
  } = options;
  assert6(copyState !== void 0);
  if (!gl.state) {
    const {
      polyfillContext: polyfillContext2
    } = globalThis;
    if (polyfillContext2) {
      polyfillContext2(gl);
    }
    gl.state = new GLState(gl, {
      copyState
    });
    installProgramSpy(gl);
    for (const key in GL_HOOKED_SETTERS) {
      const setter = GL_HOOKED_SETTERS[key];
      installSetterSpy(gl, key, setter);
    }
    installGetterOverride(gl, "getParameter");
    installGetterOverride(gl, "isEnabled");
  }
  gl.state.enable = enable2;
  return gl;
}
function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {
      copyState: false
    });
  }
  gl.state.push();
}
function popContextState(gl) {
  assert6(gl.state);
  gl.state.pop();
}
var GLState;
var init_track_context_state = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js"() {
    init_webgl_parameter_tables();
    init_unified_parameter_api();
    init_assert6();
    init_utils();
    GLState = class {
      constructor(gl) {
        let {
          copyState = false,
          log: log3 = () => {
          }
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.program = null;
        this.stateStack = [];
        this.enable = true;
        this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
        this.log = log3;
        this._updateCache = this._updateCache.bind(this);
        Object.seal(this);
      }
      push() {
        let values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.stateStack.push({});
      }
      pop() {
        assert6(this.stateStack.length > 0);
        const oldValues = this.stateStack[this.stateStack.length - 1];
        setParameters(this.gl, oldValues);
        this.stateStack.pop();
      }
      _updateCache(values) {
        let valueChanged = false;
        let oldValue;
        const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
        for (const key in values) {
          assert6(key !== void 0);
          const value4 = values[key];
          const cached = this.cache[key];
          if (!deepArrayEqual(value4, cached)) {
            valueChanged = true;
            oldValue = cached;
            if (oldValues && !(key in oldValues)) {
              oldValues[key] = cached;
            }
            this.cache[key] = value4;
          }
        }
        return {
          valueChanged,
          oldValue
        };
      }
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
function setParameters(gl, values) {
  assert6(isWebGL(gl), "setParameters requires a WebGL context");
  if (isObjectEmpty(values)) {
    return;
  }
  const compositeSetters = {};
  for (const key in values) {
    const glConstant = Number(key);
    const setter = GL_PARAMETER_SETTERS[key];
    if (setter) {
      if (typeof setter === "string") {
        compositeSetters[setter] = true;
      } else {
        setter(gl, values[key], glConstant);
      }
    }
  }
  const cache2 = gl.state && gl.state.cache;
  if (cache2) {
    for (const key in compositeSetters) {
      const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
      compositeSetter(gl, values, cache2);
    }
  }
}
function getParameters(gl, parameters) {
  parameters = parameters || GL_PARAMETER_DEFAULTS;
  if (typeof parameters === "number") {
    const key = parameters;
    const getter = GL_PARAMETER_GETTERS[key];
    return getter ? getter(gl, key) : gl.getParameter(key);
  }
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
  const state = {};
  for (const key of parameterKeys) {
    const getter = GL_PARAMETER_GETTERS[key];
    state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  }
  return state;
}
function resetParameters(gl) {
  setParameters(gl, GL_PARAMETER_DEFAULTS);
}
function withParameters(gl, parameters, func) {
  if (isObjectEmpty(parameters)) {
    return func(gl);
  }
  const {
    nocatch = true
  } = parameters;
  pushContextState(gl);
  setParameters(gl, parameters);
  let value4;
  if (nocatch) {
    value4 = func(gl);
    popContextState(gl);
  } else {
    try {
      value4 = func(gl);
    } finally {
      popContextState(gl);
    }
  }
  return value4;
}
var init_unified_parameter_api = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js"() {
    init_webgl_parameter_tables();
    init_track_context_state();
    init_assert6();
    init_webgl_checks();
    init_utils();
  }
});

// node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
function cssToDeviceRatio(gl) {
  const {
    luma
  } = gl;
  if (gl.canvas && luma) {
    const cachedSize = luma.canvasSizeInfo;
    const clientWidth = "clientWidth" in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
  }
  return 1;
}
function cssToDevicePixels(gl, cssPixel) {
  let yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}
function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);
  let t = scaleX(pixel[0] + 1, ratio, width);
  const xHigh = t === width - 1 ? t : t - 1;
  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    t = t === 0 ? t : t + 1;
    yHigh = y;
    y = t;
  } else {
    yHigh = t === height - 1 ? t : t - 1;
  }
  return {
    x,
    y,
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}
function scaleX(x, ratio, width) {
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}
function scaleY(y, ratio, height, yInvert) {
  return yInvert ? Math.max(0, height - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height - 1);
}
var init_device_pixels = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js"() {
  }
});

// node_modules/@luma.gl/gltools/dist/esm/context/context.js
function createGLContext() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  assert6(isBrowser6, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    width,
    height
  } = options;
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    console.error(message);
    return null;
  }
  options.onError = onError;
  let gl;
  const {
    canvas
  } = options;
  const targetCanvas = getCanvas({
    canvas,
    width,
    height,
    onError
  });
  gl = createBrowserContext(targetCanvas, options);
  if (!gl) {
    return null;
  }
  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
function instrumentGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!gl || gl._instrumented) {
    return gl;
  }
  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, CONTEXT_DEFAULTS, options);
  const {
    manageState,
    debug: debug2
  } = options;
  if (manageState) {
    trackContextState(gl, {
      copyState: false,
      log: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return log.log(1, ...args)();
      }
    });
  }
  if (isBrowser6 && debug2) {
    if (!globalThis.makeDebugContext) {
      log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = globalThis.makeDebugContext(gl, options);
      log.level = Math.max(log.level, 1);
    }
  }
  gl._instrumented = true;
  return gl;
}
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(7936);
  const rendererMasked = gl.getParameter(7937);
  const ext = gl.getExtension("WEBGL_debug_renderer_info");
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(7938),
    shadingLanguageVersion: gl.getParameter(35724)
  };
}
function resizeGLContext(gl) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (gl.canvas) {
    const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }
  const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}
function createBrowserContext(canvas, options) {
  const {
    onError
  } = options;
  let errorMessage = null;
  const onCreateError = (error2) => errorMessage = error2.statusMessage || errorMessage;
  canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
  const {
    webgl1 = true,
    webgl2 = true
  } = options;
  let gl = null;
  if (webgl2) {
    gl = gl || canvas.getContext("webgl2", options);
    gl = gl || canvas.getContext("experimental-webgl2", options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext("webgl", options);
    gl = gl || canvas.getContext("experimental-webgl", options);
  }
  canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
  if (!gl) {
    return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
  }
  if (options.onContextLost) {
    canvas.addEventListener("webglcontextlost", options.onContextLost, false);
  }
  if (options.onContextRestored) {
    canvas.addEventListener("webglcontextrestored", options.onContextRestored, false);
  }
  return gl;
}
function getCanvas(_ref) {
  let {
    canvas,
    width = 800,
    height = 600,
    onError
  } = _ref;
  let targetCanvas;
  if (typeof canvas === "string") {
    const isPageLoaded = isPage && document.readyState === "complete";
    if (!isPageLoaded) {
      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = document.createElement("canvas");
    targetCanvas.id = "lumagl-canvas";
    targetCanvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : "100%";
    targetCanvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : "100%";
    document.body.insertBefore(targetCanvas, document.body.firstChild);
  }
  return targetCanvas;
}
function logInfo(gl) {
  const webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
  const debug2 = gl.debug ? " debug" : "";
  log.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver))();
}
function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return 2;
  }
  return 1;
}
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  let clientWidth = "width" in options ? options.width : gl.canvas.clientWidth;
  let clientHeight = "height" in options ? options.height : gl.canvas.clientHeight;
  if (!clientWidth || !clientHeight) {
    log.log(1, "Canvas clientWidth/clientHeight is 0")();
    devicePixelRatio = 1;
    clientWidth = gl.canvas.width || 1;
    clientHeight = gl.canvas.height || 1;
  }
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      log.warn("Device pixel ratio clamped")();
      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }
    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
var isBrowser6, isPage, CONTEXT_DEFAULTS;
var init_context = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/context/context.js"() {
    init_esm6();
    init_track_context_state();
    init_log3();
    init_assert6();
    init_device_pixels();
    init_webgl_checks();
    isBrowser6 = isBrowser4();
    isPage = isBrowser6 && typeof document !== "undefined";
    CONTEXT_DEFAULTS = {
      webgl2: true,
      webgl1: true,
      throwOnError: true,
      manageState: true,
      canvas: null,
      debug: false,
      width: 800,
      height: 600
    };
  }
});

// node_modules/@luma.gl/gltools/dist/esm/index.js
var init_esm9 = __esm({
  "node_modules/@luma.gl/gltools/dist/esm/index.js"() {
    init_log3();
    init_webgl_checks();
    init_polyfill_context();
    init_unified_parameter_api();
    init_track_context_state();
    init_context();
    init_device_pixels();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/init.js
var VERSION6, STARTUP_MESSAGE, StatsManager, lumaStats, init_default3;
var init_init4 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/init.js"() {
    init_esm9();
    init_esm();
    init_esm6();
    VERSION6 = true ? "8.5.20" : "untranspiled source";
    STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
    StatsManager = class {
      constructor() {
        this.stats = /* @__PURE__ */ new Map();
      }
      get(name) {
        if (!this.stats.has(name)) {
          this.stats.set(name, new Stats({
            id: name
          }));
        }
        return this.stats.get(name);
      }
    };
    lumaStats = new StatsManager();
    if (globalThis.luma && globalThis.luma.VERSION !== VERSION6) {
      throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION6));
    }
    if (!globalThis.luma) {
      if (isBrowser4()) {
        log.log(1, "luma.gl ".concat(VERSION6, " - ").concat(STARTUP_MESSAGE))();
      }
      globalThis.luma = globalThis.luma || {
        VERSION: VERSION6,
        version: VERSION6,
        log,
        stats: lumaStats,
        globals: {
          modules: {},
          nodeIO: {}
        }
      };
    }
    init_default3 = globalThis.luma;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
function requestAnimationFrame2(callback) {
  return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}
var init_request_animation_frame = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
function assert7(condition, message) {
  if (!condition) {
    throw new Error(message || "luma.gl: assertion failed.");
  }
}
var init_assert7 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
function getKeyValue(gl, name) {
  if (typeof name !== "string") {
    return name;
  }
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }
  name = name.replace(/^.*\./, "");
  const value4 = gl[name];
  assert7(value4 !== void 0, "Accessing undefined constant GL.".concat(name));
  return value4;
}
function getKey(gl, value4) {
  value4 = Number(value4);
  for (const key in gl) {
    if (gl[key] === value4) {
      return "GL.".concat(key);
    }
  }
  return String(value4);
}
var init_constants_to_keys = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js"() {
    init_assert7();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
function uid() {
  let id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  uidCounters[id] = uidCounters[id] || 1;
  const count4 = uidCounters[id]++;
  return "".concat(id, "-").concat(count4);
}
function isPowerOfTwo(n) {
  assert7(typeof n === "number", "Input must be a number");
  return n && (n & n - 1) === 0;
}
function isObjectEmpty2(obj) {
  let isEmpty = true;
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  return isEmpty;
}
var uidCounters;
var init_utils2 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/utils.js"() {
    init_assert7();
    uidCounters = {};
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
function stubRemovedMethods(instance, className, version3, methodNames) {
  const upgradeMessage = "See luma.gl ".concat(version3, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
  const prototype = Object.getPrototypeOf(instance);
  methodNames.forEach((methodName) => {
    if (prototype.methodName) {
      return;
    }
    prototype[methodName] = () => {
      log.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
      throw new Error(methodName);
    };
  });
}
var init_stub_methods = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js"() {
    init_esm9();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
var ERR_RESOURCE_METHOD_UNDEFINED, Resource;
var init_resource = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/resource.js"() {
    init_esm9();
    init_init4();
    init_constants_to_keys();
    init_assert7();
    init_utils2();
    init_stub_methods();
    ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
    Resource = class {
      get [Symbol.toStringTag]() {
        return "Resource";
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGLContext(gl);
        const {
          id,
          userData = {}
        } = opts;
        this.gl = gl;
        this.gl2 = gl;
        this.id = id || uid(this[Symbol.toStringTag]);
        this.userData = userData;
        this._bound = false;
        this._handle = opts.handle;
        if (this._handle === void 0) {
          this._handle = this._createHandle();
        }
        this.byteLength = 0;
        this._addStats();
      }
      toString() {
        return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
      }
      get handle() {
        return this._handle;
      }
      delete() {
        let {
          deleteChildren = false
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const children = this._handle && this._deleteHandle(this._handle);
        if (this._handle) {
          this._removeStats();
        }
        this._handle = null;
        if (children && deleteChildren) {
          children.filter(Boolean).forEach((child) => child.delete());
        }
        return this;
      }
      bind() {
        let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
        if (typeof funcOrHandle !== "function") {
          this._bindHandle(funcOrHandle);
          return this;
        }
        let value4;
        if (!this._bound) {
          this._bindHandle(this.handle);
          this._bound = true;
          value4 = funcOrHandle();
          this._bound = false;
          this._bindHandle(null);
        } else {
          value4 = funcOrHandle();
        }
        return value4;
      }
      unbind() {
        this.bind(null);
      }
      getParameter(pname) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        pname = getKeyValue(this.gl, pname);
        assert7(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
          const isWebgl2 = isWebGL2(this.gl);
          const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (!parameterAvailable) {
            const webgl1Default = parameter.webgl1;
            const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
            const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
            return defaultValue;
          }
        }
        return this._getParameter(pname, opts);
      }
      getParameters() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          parameters,
          keys
        } = options;
        const PARAMETERS = this.constructor.PARAMETERS || {};
        const isWebgl2 = isWebGL2(this.gl);
        const values = {};
        const parameterKeys = parameters || Object.keys(PARAMETERS);
        for (const pname of parameterKeys) {
          const parameter = PARAMETERS[pname];
          const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (parameterAvailable) {
            const key = keys ? getKey(this.gl, pname) : pname;
            values[key] = this.getParameter(pname, options);
            if (keys && parameter.type === "GLenum") {
              values[key] = getKey(this.gl, values[key]);
            }
          }
        }
        return values;
      }
      setParameter(pname, value4) {
        pname = getKeyValue(this.gl, pname);
        assert7(pname);
        const parameters = this.constructor.PARAMETERS || {};
        const parameter = parameters[pname];
        if (parameter) {
          const isWebgl2 = isWebGL2(this.gl);
          const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
          if (!parameterAvailable) {
            throw new Error("Parameter not available on this platform");
          }
          if (parameter.type === "GLenum") {
            value4 = getKeyValue(value4);
          }
        }
        this._setParameter(pname, value4);
        return this;
      }
      setParameters(parameters) {
        for (const pname in parameters) {
          this.setParameter(pname, parameters[pname]);
        }
        return this;
      }
      stubRemovedMethods(className, version3, methodNames) {
        return stubRemovedMethods(this, className, version3, methodNames);
      }
      initialize(opts) {
      }
      _createHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _deleteHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _bindHandle(handle) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _getOptsFromHandle() {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _getParameter(pname, opts) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _setParameter(pname, value4) {
        throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
      }
      _context() {
        this.gl.luma = this.gl.luma || {};
        return this.gl.luma;
      }
      _addStats() {
        const name = this[Symbol.toStringTag];
        const stats = lumaStats.get("Resource Counts");
        stats.get("Resources Created").incrementCount();
        stats.get("".concat(name, "s Created")).incrementCount();
        stats.get("".concat(name, "s Active")).incrementCount();
      }
      _removeStats() {
        const name = this[Symbol.toStringTag];
        const stats = lumaStats.get("Resource Counts");
        stats.get("".concat(name, "s Active")).decrementCount();
      }
      _trackAllocatedMemory(bytes) {
        let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
        this._trackAllocatedMemoryForContext(bytes, name);
        this._trackAllocatedMemoryForContext(bytes, name, this.gl.canvas && this.gl.canvas.id);
        this.byteLength = bytes;
      }
      _trackAllocatedMemoryForContext(bytes) {
        let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
        let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
        const stats = lumaStats.get("Memory Usage".concat(id));
        stats.get("GPU Memory").addCount(bytes);
        stats.get("".concat(name, " Memory")).addCount(bytes);
      }
      _trackDeallocatedMemory() {
        let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
        this._trackDeallocatedMemoryForContext(name);
        this._trackDeallocatedMemoryForContext(name, this.gl.canvas && this.gl.canvas.id);
        this.byteLength = 0;
      }
      _trackDeallocatedMemoryForContext() {
        let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
        let id = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const stats = lumaStats.get("Memory Usage".concat(id));
        stats.get("GPU Memory").subtractCount(this.byteLength);
        stats.get("".concat(name, " Memory")).subtractCount(this.byteLength);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
function getGLTypeFromTypedArray(arrayOrType) {
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}
function getTypedArrayFromGLType(glType) {
  let {
    clamped = true
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function flipRows(_ref) {
  let {
    data,
    width,
    height,
    bytesPerPixel = 4,
    temp
  } = _ref;
  const bytesPerRow = width * bytesPerPixel;
  temp = temp || new Uint8Array(bytesPerRow);
  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    data.set(temp, bottomOffset);
  }
}
function scalePixels2(_ref2) {
  let {
    data,
    width,
    height
  } = _ref2;
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }
  return {
    data: newData,
    width: newWidth,
    height: newHeight
  };
}
var ERR_TYPE_DEDUCTION;
var init_typed_array_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js"() {
    ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
function checkProps(className, props, propChecks) {
  const {
    removedProps = {},
    deprecatedProps = {},
    replacedProps = {}
  } = propChecks;
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
      log.removed("".concat(className, ".").concat(propName), replacement)();
    }
  }
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
    }
  }
  let newProps = null;
  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      log.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }
  return newProps || props;
}
var init_check_props = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js"() {
    init_esm9();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
var DEFAULT_ACCESSOR_VALUES, PROP_CHECKS, Accessor;
var init_accessor = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js"() {
    init_typed_array_utils();
    init_assert7();
    init_check_props();
    DEFAULT_ACCESSOR_VALUES = {
      offset: 0,
      stride: 0,
      type: 5126,
      size: 1,
      divisor: 0,
      normalized: false,
      integer: false
    };
    PROP_CHECKS = {
      deprecatedProps: {
        instanced: "divisor",
        isInstanced: "divisor"
      }
    };
    Accessor = class _Accessor {
      static getBytesPerElement(accessor) {
        const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT;
      }
      static getBytesPerVertex(accessor) {
        assert7(accessor.size);
        const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
        return ArrayType.BYTES_PER_ELEMENT * accessor.size;
      }
      static resolve() {
        for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
          accessors[_key] = arguments[_key];
        }
        return new _Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
      }
      constructor() {
        for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          accessors[_key2] = arguments[_key2];
        }
        accessors.forEach((accessor) => this._assign(accessor));
        Object.freeze(this);
      }
      toString() {
        return JSON.stringify(this);
      }
      get BYTES_PER_ELEMENT() {
        return _Accessor.getBytesPerElement(this);
      }
      get BYTES_PER_VERTEX() {
        return _Accessor.getBytesPerVertex(this);
      }
      _assign() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        props = checkProps("Accessor", props, PROP_CHECKS);
        if (props.type !== void 0) {
          this.type = props.type;
          if (props.type === 5124 || props.type === 5125) {
            this.integer = true;
          }
        }
        if (props.size !== void 0) {
          this.size = props.size;
        }
        if (props.offset !== void 0) {
          this.offset = props.offset;
        }
        if (props.stride !== void 0) {
          this.stride = props.stride;
        }
        if (props.normalized !== void 0) {
          this.normalized = props.normalized;
        }
        if (props.integer !== void 0) {
          this.integer = props.integer;
        }
        if (props.divisor !== void 0) {
          this.divisor = props.divisor;
        }
        if (props.buffer !== void 0) {
          this.buffer = props.buffer;
        }
        if (props.index !== void 0) {
          if (typeof props.index === "boolean") {
            this.index = props.index ? 1 : 0;
          } else {
            this.index = props.index;
          }
        }
        if (props.instanced !== void 0) {
          this.divisor = props.instanced ? 1 : 0;
        }
        if (props.isInstanced !== void 0) {
          this.divisor = props.isInstanced ? 1 : 0;
        }
        return this;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
var DEBUG_DATA_LENGTH, DEPRECATED_PROPS, PROP_CHECKS_INITIALIZE, PROP_CHECKS_SET_PROPS, Buffer;
var init_buffer = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js"() {
    init_resource();
    init_accessor();
    init_typed_array_utils();
    init_esm9();
    init_assert7();
    init_check_props();
    DEBUG_DATA_LENGTH = 10;
    DEPRECATED_PROPS = {
      offset: "accessor.offset",
      stride: "accessor.stride",
      type: "accessor.type",
      size: "accessor.size",
      divisor: "accessor.divisor",
      normalized: "accessor.normalized",
      integer: "accessor.integer",
      instanced: "accessor.divisor",
      isInstanced: "accessor.divisor"
    };
    PROP_CHECKS_INITIALIZE = {
      removedProps: {},
      replacedProps: {
        bytes: "byteLength"
      },
      deprecatedProps: DEPRECATED_PROPS
    };
    PROP_CHECKS_SET_PROPS = {
      removedProps: DEPRECATED_PROPS
    };
    Buffer = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Buffer";
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
        this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
        this.initialize(props);
        Object.seal(this);
      }
      getElementCount() {
        let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
      }
      getVertexCount() {
        let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
        return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (ArrayBuffer.isView(props)) {
          props = {
            data: props
          };
        }
        if (Number.isFinite(props)) {
          props = {
            byteLength: props
          };
        }
        props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
        this.usage = props.usage || 35044;
        this.debugData = null;
        this.setAccessor(Object.assign({}, props, props.accessor));
        if (props.data) {
          this._setData(props.data, props.offset, props.byteLength);
        } else {
          this._setByteLength(props.byteLength || 0);
        }
        return this;
      }
      setProps(props) {
        props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
        if ("accessor" in props) {
          this.setAccessor(props.accessor);
        }
        return this;
      }
      setAccessor(accessor) {
        accessor = Object.assign({}, accessor);
        delete accessor.buffer;
        this.accessor = new Accessor(accessor);
        return this;
      }
      reallocate(byteLength) {
        if (byteLength > this.byteLength) {
          this._setByteLength(byteLength);
          return true;
        }
        this.bytesUsed = byteLength;
        return false;
      }
      setData(props) {
        return this.initialize(props);
      }
      subData(props) {
        if (ArrayBuffer.isView(props)) {
          props = {
            data: props
          };
        }
        const {
          data,
          offset = 0,
          srcOffset = 0
        } = props;
        const byteLength = props.byteLength || props.length;
        assert7(data);
        const target = this.gl.webgl2 ? 36663 : this.target;
        this.gl.bindBuffer(target, this.handle);
        if (srcOffset !== 0 || byteLength !== void 0) {
          assertWebGL2Context(this.gl);
          this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
        } else {
          this.gl.bufferSubData(target, offset, data);
        }
        this.gl.bindBuffer(target, null);
        this.debugData = null;
        this._inferType(data);
        return this;
      }
      copyData(_ref) {
        let {
          sourceBuffer,
          readOffset = 0,
          writeOffset = 0,
          size
        } = _ref;
        const {
          gl
        } = this;
        assertWebGL2Context(gl);
        gl.bindBuffer(36662, sourceBuffer.handle);
        gl.bindBuffer(36663, this.handle);
        gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);
        gl.bindBuffer(36662, null);
        gl.bindBuffer(36663, null);
        this.debugData = null;
        return this;
      }
      getData() {
        let {
          dstData = null,
          srcByteOffset = 0,
          dstOffset = 0,
          length: length5 = 0
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        assertWebGL2Context(this.gl);
        const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
          clamped: false
        });
        const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
        const dstElementOffset = dstOffset;
        let dstAvailableElementCount;
        let dstElementCount;
        if (dstData) {
          dstElementCount = dstData.length;
          dstAvailableElementCount = dstElementCount - dstElementOffset;
        } else {
          dstAvailableElementCount = Math.min(sourceAvailableElementCount, length5 || sourceAvailableElementCount);
          dstElementCount = dstElementOffset + dstAvailableElementCount;
        }
        const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
        length5 = length5 || copyElementCount;
        assert7(length5 <= copyElementCount);
        dstData = dstData || new ArrayType(dstElementCount);
        this.gl.bindBuffer(36662, this.handle);
        this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length5);
        this.gl.bindBuffer(36662, null);
        return dstData;
      }
      bind() {
        let {
          target = this.target,
          index = this.accessor && this.accessor.index,
          offset = 0,
          size
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (target === 35345 || target === 35982) {
          if (size !== void 0) {
            this.gl.bindBufferRange(target, index, this.handle, offset, size);
          } else {
            assert7(offset === 0);
            this.gl.bindBufferBase(target, index, this.handle);
          }
        } else {
          this.gl.bindBuffer(target, this.handle);
        }
        return this;
      }
      unbind() {
        let {
          target = this.target,
          index = this.accessor && this.accessor.index
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const isIndexedBuffer = target === 35345 || target === 35982;
        if (isIndexedBuffer) {
          this.gl.bindBufferBase(target, index, null);
        } else {
          this.gl.bindBuffer(target, null);
        }
        return this;
      }
      getDebugData() {
        if (!this.debugData) {
          this.debugData = this.getData({
            length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
          });
          return {
            data: this.debugData,
            changed: true
          };
        }
        return {
          data: this.debugData,
          changed: false
        };
      }
      invalidateDebugData() {
        this.debugData = null;
      }
      _setData(data) {
        let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
        assert7(ArrayBuffer.isView(data));
        this._trackDeallocatedMemory();
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, byteLength, this.usage);
        this.gl.bufferSubData(target, offset, data);
        this.gl.bindBuffer(target, null);
        this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        const type = getGLTypeFromTypedArray(data);
        assert7(type);
        this.setAccessor(new Accessor(this.accessor, {
          type
        }));
        return this;
      }
      _setByteLength(byteLength) {
        let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
        assert7(byteLength >= 0);
        this._trackDeallocatedMemory();
        let data = byteLength;
        if (byteLength === 0) {
          data = new Float32Array(0);
        }
        const target = this._getTarget();
        this.gl.bindBuffer(target, this.handle);
        this.gl.bufferData(target, data, usage);
        this.gl.bindBuffer(target, null);
        this.usage = usage;
        this.debugData = null;
        this.bytesUsed = byteLength;
        this._trackAllocatedMemory(byteLength);
        return this;
      }
      _getTarget() {
        return this.gl.webgl2 ? 36663 : this.target;
      }
      _getAvailableElementCount(srcByteOffset) {
        const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
          clamped: false
        });
        const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
        return this.getElementCount() - sourceElementOffset;
      }
      _inferType(data) {
        if (!this.accessor.type) {
          this.setAccessor(new Accessor(this.accessor, {
            type: getGLTypeFromTypedArray(data)
          }));
        }
      }
      _createHandle() {
        return this.gl.createBuffer();
      }
      _deleteHandle() {
        this.gl.deleteBuffer(this.handle);
        this._trackDeallocatedMemory();
      }
      _getParameter(pname) {
        this.gl.bindBuffer(this.target, this.handle);
        const value4 = this.gl.getBufferParameter(this.target, pname);
        this.gl.bindBuffer(this.target, null);
        return value4;
      }
      get type() {
        log.deprecated("Buffer.type", "Buffer.accessor.type")();
        return this.accessor.type;
      }
      get bytes() {
        log.deprecated("Buffer.bytes", "Buffer.byteLength")();
        return this.byteLength;
      }
      setByteLength(byteLength) {
        log.deprecated("setByteLength", "reallocate")();
        return this.reallocate(byteLength);
      }
      updateAccessor(opts) {
        log.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
        this.accessor = new Accessor(this.accessor, opts);
        return this;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (info.gl1 === void 0 && info.gl2 === void 0) {
    return true;
  }
  const value4 = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value4 === "string" ? gl.getExtension(value4) : value4;
}
function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  switch (info && info.types[0]) {
    case 5126:
      return gl.getExtension("OES_texture_float_linear");
    case 5131:
      return gl.getExtension("OES_texture_half_float_linear");
    default:
      return true;
  }
}
var TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES;
var init_texture_formats = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js"() {
    init_esm9();
    TEXTURE_FORMATS = {
      [6407]: {
        dataFormat: 6407,
        types: [5121, 33635]
      },
      [6408]: {
        dataFormat: 6408,
        types: [5121, 32819, 32820]
      },
      [6406]: {
        dataFormat: 6406,
        types: [5121]
      },
      [6409]: {
        dataFormat: 6409,
        types: [5121]
      },
      [6410]: {
        dataFormat: 6410,
        types: [5121]
      },
      [33326]: {
        dataFormat: 6403,
        types: [5126],
        gl2: true
      },
      [33328]: {
        dataFormat: 33319,
        types: [5126],
        gl2: true
      },
      [34837]: {
        dataFormat: 6407,
        types: [5126],
        gl2: true
      },
      [34836]: {
        dataFormat: 6408,
        types: [5126],
        gl2: true
      }
    };
    DATA_FORMAT_CHANNELS = {
      [6403]: 1,
      [36244]: 1,
      [33319]: 2,
      [33320]: 2,
      [6407]: 3,
      [36248]: 3,
      [6408]: 4,
      [36249]: 4,
      [6402]: 1,
      [34041]: 1,
      [6406]: 1,
      [6409]: 1,
      [6410]: 2
    };
    TYPE_SIZES = {
      [5126]: 4,
      [5125]: 4,
      [5124]: 4,
      [5123]: 2,
      [5122]: 2,
      [5131]: 2,
      [5120]: 1,
      [5121]: 1
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
var NPOT_MIN_FILTERS, WebGLBuffer, Texture;
var init_texture = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture.js"() {
    init_esm9();
    init_resource();
    init_buffer();
    init_texture_formats();
    init_assert7();
    init_utils2();
    NPOT_MIN_FILTERS = [9729, 9728];
    WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
    };
    Texture = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Texture";
      }
      static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          format,
          linearFiltering
        } = opts;
        let supported = true;
        if (format) {
          supported = supported && isFormatSupported(gl, format);
          supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
        }
        return supported;
      }
      constructor(gl, props) {
        const {
          id = uid("texture"),
          handle,
          target
        } = props;
        super(gl, {
          id,
          handle
        });
        this.target = target;
        this.textureUnit = void 0;
        this.loaded = false;
        this.width = void 0;
        this.height = void 0;
        this.depth = void 0;
        this.format = void 0;
        this.type = void 0;
        this.dataFormat = void 0;
        this.border = void 0;
        this.textureUnit = void 0;
        this.mipmaps = void 0;
      }
      toString() {
        return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let data = props.data;
        if (data instanceof Promise) {
          data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
            pixels: resolvedImageData,
            data: resolvedImageData
          })));
          return this;
        }
        const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
        if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
          this._video = null;
          data.addEventListener("loadeddata", () => this.initialize(props));
          return this;
        }
        const {
          pixels = null,
          format = 6408,
          border = 0,
          recreate = false,
          parameters = {},
          pixelStore = {},
          textureUnit = void 0
        } = props;
        if (!data) {
          data = pixels;
        }
        let {
          width,
          height,
          dataFormat,
          type,
          compressed = false,
          mipmaps = true
        } = props;
        const {
          depth = 0
        } = props;
        ({
          width,
          height,
          compressed,
          dataFormat,
          type
        } = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        }));
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.format = format;
        this.type = type;
        this.dataFormat = dataFormat;
        this.border = border;
        this.textureUnit = textureUnit;
        if (Number.isFinite(this.textureUnit)) {
          this.gl.activeTexture(33984 + this.textureUnit);
          this.gl.bindTexture(this.target, this.handle);
        }
        if (mipmaps && this._isNPOT()) {
          log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
          mipmaps = false;
          this._updateForNPOT(parameters);
        }
        this.mipmaps = mipmaps;
        this.setImageData({
          data,
          width,
          height,
          depth,
          format,
          type,
          dataFormat,
          border,
          mipmaps,
          parameters: pixelStore,
          compressed
        });
        if (mipmaps) {
          this.generateMipmap();
        }
        this.setParameters(parameters);
        if (recreate) {
          this.data = data;
        }
        if (isVideo) {
          this._video = {
            video: data,
            parameters,
            lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
          };
        }
        return this;
      }
      update() {
        if (this._video) {
          const {
            video,
            parameters,
            lastTime
          } = this._video;
          if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
            return;
          }
          this.setSubImageData({
            data: video,
            parameters
          });
          if (this.mipmaps) {
            this.generateMipmap();
          }
          this._video.lastTime = video.currentTime;
        }
      }
      resize(_ref) {
        let {
          height,
          width,
          mipmaps = false
        } = _ref;
        if (width !== this.width || height !== this.height) {
          return this.initialize({
            width,
            height,
            format: this.format,
            type: this.type,
            dataFormat: this.dataFormat,
            border: this.border,
            mipmaps
          });
        }
        return this;
      }
      generateMipmap() {
        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._isNPOT()) {
          log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
          return this;
        }
        this.mipmaps = true;
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, params, () => {
          this.gl.generateMipmap(this.target);
        });
        this.gl.bindTexture(this.target, null);
        return this;
      }
      setImageData(options) {
        this._trackDeallocatedMemory("Texture");
        const {
          target = this.target,
          pixels = null,
          level = 0,
          format = this.format,
          border = this.border,
          offset = 0,
          parameters = {}
        } = options;
        let {
          data = null,
          type = this.type,
          width = this.width,
          height = this.height,
          dataFormat = this.dataFormat,
          compressed = false
        } = options;
        if (!data) {
          data = pixels;
        }
        ({
          type,
          dataFormat,
          compressed,
          width,
          height
        } = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        }));
        const {
          gl
        } = this;
        gl.bindTexture(this.target, this.handle);
        let dataType = null;
        ({
          data,
          dataType
        } = this._getDataType({
          data,
          compressed
        }));
        let gl2;
        let compressedTextureSize = 0;
        withParameters(this.gl, parameters, () => {
          switch (dataType) {
            case "null":
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
              break;
            case "typed-array":
              gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
              break;
            case "buffer":
              gl2 = assertWebGL2Context(gl);
              gl2.bindBuffer(35052, data.handle || data);
              gl2.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
              gl2.bindBuffer(35052, null);
              break;
            case "browser-object":
              if (isWebGL2(gl)) {
                gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
              } else {
                gl.texImage2D(target, level, format, dataFormat, type, data);
              }
              break;
            case "compressed":
              for (const [levelIndex, levelData] of data.entries()) {
                gl.compressedTexImage2D(target, levelIndex, levelData.format, levelData.width, levelData.height, border, levelData.data);
                compressedTextureSize += levelData.levelSize;
              }
              break;
            default:
              assert7(false, "Unknown image data type");
          }
        });
        if (dataType === "compressed") {
          this._trackAllocatedMemory(compressedTextureSize, "Texture");
        } else if (data && data.byteLength) {
          this._trackAllocatedMemory(data.byteLength, "Texture");
        } else {
          const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
          const channelSize = TYPE_SIZES[this.type] || 1;
          this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
      }
      setSubImageData(_ref2) {
        let {
          target = this.target,
          pixels = null,
          data = null,
          x = 0,
          y = 0,
          width = this.width,
          height = this.height,
          level = 0,
          format = this.format,
          type = this.type,
          dataFormat = this.dataFormat,
          compressed = false,
          offset = 0,
          border = this.border,
          parameters = {}
        } = _ref2;
        ({
          type,
          dataFormat,
          compressed,
          width,
          height
        } = this._deduceParameters({
          format,
          type,
          dataFormat,
          compressed,
          data,
          width,
          height
        }));
        assert7(this.depth === 0, "texSubImage not supported for 3D textures");
        if (!data) {
          data = pixels;
        }
        if (data && data.data) {
          const ndarray = data;
          data = ndarray.data;
          width = ndarray.shape[0];
          height = ndarray.shape[1];
        }
        if (data instanceof Buffer) {
          data = data.handle;
        }
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, parameters, () => {
          if (compressed) {
            this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
          } else if (data === null) {
            this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
          } else if (ArrayBuffer.isView(data)) {
            this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
          } else if (data instanceof WebGLBuffer) {
            const gl2 = assertWebGL2Context(this.gl);
            gl2.bindBuffer(35052, data);
            gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
          } else if (isWebGL2(this.gl)) {
            const gl2 = assertWebGL2Context(this.gl);
            gl2.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
          } else {
            this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
          }
        });
        this.gl.bindTexture(this.target, null);
      }
      copyFramebuffer() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
      }
      getActiveUnit() {
        return this.gl.getParameter(34016) - 33984;
      }
      bind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
        const {
          gl
        } = this;
        if (textureUnit !== void 0) {
          this.textureUnit = textureUnit;
          gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, this.handle);
        return textureUnit;
      }
      unbind() {
        let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
        const {
          gl
        } = this;
        if (textureUnit !== void 0) {
          this.textureUnit = textureUnit;
          gl.activeTexture(33984 + textureUnit);
        }
        gl.bindTexture(this.target, null);
        return textureUnit;
      }
      _getDataType(_ref3) {
        let {
          data,
          compressed = false
        } = _ref3;
        if (compressed) {
          return {
            data,
            dataType: "compressed"
          };
        }
        if (data === null) {
          return {
            data,
            dataType: "null"
          };
        }
        if (ArrayBuffer.isView(data)) {
          return {
            data,
            dataType: "typed-array"
          };
        }
        if (data instanceof Buffer) {
          return {
            data: data.handle,
            dataType: "buffer"
          };
        }
        if (data instanceof WebGLBuffer) {
          return {
            data,
            dataType: "buffer"
          };
        }
        return {
          data,
          dataType: "browser-object"
        };
      }
      _deduceParameters(opts) {
        const {
          format,
          data
        } = opts;
        let {
          width,
          height,
          dataFormat,
          type,
          compressed
        } = opts;
        const textureFormat = TEXTURE_FORMATS[format];
        dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
        type = type || textureFormat && textureFormat.types[0];
        compressed = compressed || textureFormat && textureFormat.compressed;
        ({
          width,
          height
        } = this._deduceImageSize(data, width, height));
        return {
          dataFormat,
          type,
          compressed,
          width,
          height,
          format,
          data
        };
      }
      _deduceImageSize(data, width, height) {
        let size;
        if (typeof ImageData !== "undefined" && data instanceof ImageData) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
          size = {
            width: data.naturalWidth,
            height: data.naturalHeight
          };
        } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
          size = {
            width: data.width,
            height: data.height
          };
        } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
          size = {
            width: data.videoWidth,
            height: data.videoHeight
          };
        } else if (!data) {
          size = {
            width: width >= 0 ? width : 1,
            height: height >= 0 ? height : 1
          };
        } else {
          size = {
            width,
            height
          };
        }
        assert7(size, "Could not deduced texture size");
        assert7(width === void 0 || size.width === width, "Deduced texture width does not match supplied width");
        assert7(height === void 0 || size.height === height, "Deduced texture height does not match supplied height");
        return size;
      }
      _createHandle() {
        return this.gl.createTexture();
      }
      _deleteHandle() {
        this.gl.deleteTexture(this.handle);
        this._trackDeallocatedMemory("Texture");
      }
      _getParameter(pname) {
        switch (pname) {
          case 4096:
            return this.width;
          case 4097:
            return this.height;
          default:
            this.gl.bindTexture(this.target, this.handle);
            const value4 = this.gl.getTexParameter(this.target, pname);
            this.gl.bindTexture(this.target, null);
            return value4;
        }
      }
      _setParameter(pname, param) {
        this.gl.bindTexture(this.target, this.handle);
        param = this._getNPOTParam(pname, param);
        switch (pname) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.handle, pname, param);
            break;
          case 4096:
          case 4097:
            assert7(false);
            break;
          default:
            this.gl.texParameteri(this.target, pname, param);
            break;
        }
        this.gl.bindTexture(this.target, null);
        return this;
      }
      _isNPOT() {
        if (isWebGL2(this.gl)) {
          return false;
        }
        if (!this.width || !this.height) {
          return false;
        }
        return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
      }
      _updateForNPOT(parameters) {
        if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
          parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
        }
        if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
          parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
        }
        if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
          parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
        }
      }
      _getNPOTParam(pname, param) {
        if (this._isNPOT()) {
          switch (pname) {
            case 10241:
              if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
                param = 9729;
              }
              break;
            case 10242:
            case 10243:
              if (param !== 33071) {
                param = 33071;
              }
              break;
            default:
              break;
          }
        }
        return param;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
function loadImage2(url, opts) {
  assert7(typeof url === "string");
  url = pathPrefix2 + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
      image.crossOrigin = opts && opts.crossOrigin || "anonymous";
      image.src = url;
    } catch (error2) {
      reject(error2);
    }
  });
}
var pathPrefix2;
var init_load_file = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js"() {
    init_assert7();
    pathPrefix2 = "";
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
var Texture2D;
var init_texture_2d = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js"() {
    init_esm9();
    init_texture();
    init_load_file();
    Texture2D = class extends Texture {
      get [Symbol.toStringTag]() {
        return "Texture2D";
      }
      static isSupported(gl, opts) {
        return Texture.isSupported(gl, opts);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGLContext(gl);
        if (props instanceof Promise || typeof props === "string") {
          props = {
            data: props
          };
        }
        if (typeof props.data === "string") {
          props = Object.assign({}, props, {
            data: loadImage2(props.data)
          });
        }
        super(gl, Object.assign({}, props, {
          target: 3553
        }));
        this.initialize(props);
        Object.seal(this);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
var FACES, TextureCube;
var init_texture_cube = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js"() {
    init_esm9();
    init_texture();
    FACES = [34069, 34070, 34071, 34072, 34073, 34074];
    TextureCube = class extends Texture {
      get [Symbol.toStringTag]() {
        return "TextureCube";
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGLContext(gl);
        super(gl, Object.assign({}, props, {
          target: 34067
        }));
        this.initialize(props);
        Object.seal(this);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          mipmaps = true,
          parameters = {}
        } = props;
        this.opts = props;
        this.setCubeMapImageData(props).then(() => {
          this.loaded = true;
          if (mipmaps) {
            this.generateMipmap(props);
          }
          this.setParameters(parameters);
        });
        return this;
      }
      subImage(_ref) {
        let {
          face,
          data,
          x = 0,
          y = 0,
          mipmapLevel = 0
        } = _ref;
        return this._subImage({
          target: face,
          data,
          x,
          y,
          mipmapLevel
        });
      }
      async setCubeMapImageData(_ref2) {
        let {
          width,
          height,
          pixels,
          data,
          border = 0,
          format = 6408,
          type = 5121
        } = _ref2;
        const {
          gl
        } = this;
        const imageDataMap = pixels || data;
        const resolvedFaces = await Promise.all(FACES.map((face) => {
          const facePixels = imageDataMap[face];
          return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
        }));
        this.bind();
        FACES.forEach((face, index) => {
          if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
            log.warn("".concat(this.id, " has mipmap and multiple LODs."))();
          }
          resolvedFaces[index].forEach((image, lodLevel) => {
            if (width && height) {
              gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
            } else {
              gl.texImage2D(face, lodLevel, format, format, type, image);
            }
          });
        });
        this.unbind();
      }
      setImageDataForFace(options) {
        const {
          face,
          width,
          height,
          pixels,
          data,
          border = 0,
          format = 6408,
          type = 5121
        } = options;
        const {
          gl
        } = this;
        const imageData = pixels || data;
        this.bind();
        if (imageData instanceof Promise) {
          imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options, {
            face,
            data: resolvedImageData,
            pixels: resolvedImageData
          })));
        } else if (this.width || this.height) {
          gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
        } else {
          gl.texImage2D(face, 0, format, format, type, imageData);
        }
        return this;
      }
    };
    TextureCube.FACES = FACES;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
var Texture3D;
var init_texture_3d = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js"() {
    init_esm9();
    init_texture();
    init_texture_formats();
    init_buffer();
    Texture3D = class extends Texture {
      get [Symbol.toStringTag]() {
        return "Texture3D";
      }
      static isSupported(gl) {
        return isWebGL2(gl);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGL2Context(gl);
        props = Object.assign({
          depth: 1
        }, props, {
          target: 32879,
          unpackFlipY: false
        });
        super(gl, props);
        this.initialize(props);
        Object.seal(this);
      }
      setImageData(_ref) {
        let {
          level = 0,
          dataFormat = 6408,
          width,
          height,
          depth = 1,
          border = 0,
          format,
          type = 5121,
          offset = 0,
          data,
          parameters = {}
        } = _ref;
        this._trackDeallocatedMemory("Texture");
        this.gl.bindTexture(this.target, this.handle);
        withParameters(this.gl, parameters, () => {
          if (ArrayBuffer.isView(data)) {
            this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, data);
          }
          if (data instanceof Buffer) {
            this.gl.bindBuffer(35052, data.handle);
            this.gl.texImage3D(this.target, level, dataFormat, width, height, depth, border, format, type, offset);
          }
        });
        if (data && data.byteLength) {
          this._trackAllocatedMemory(data.byteLength, "Texture");
        } else {
          const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
          const channelSize = TYPE_SIZES[this.type] || 1;
          this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
        }
        this.loaded = true;
        return this;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
var EXT_FLOAT_WEBGL2, renderbuffer_formats_default;
var init_renderbuffer_formats = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js"() {
    EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
    renderbuffer_formats_default = {
      [33189]: {
        bpp: 2
      },
      [33190]: {
        gl2: true,
        bpp: 3
      },
      [36012]: {
        gl2: true,
        bpp: 4
      },
      [36168]: {
        bpp: 1
      },
      [34041]: {
        bpp: 4
      },
      [35056]: {
        gl2: true,
        bpp: 4
      },
      [36013]: {
        gl2: true,
        bpp: 5
      },
      [32854]: {
        bpp: 2
      },
      [36194]: {
        bpp: 2
      },
      [32855]: {
        bpp: 2
      },
      [33321]: {
        gl2: true,
        bpp: 1
      },
      [33330]: {
        gl2: true,
        bpp: 1
      },
      [33329]: {
        gl2: true,
        bpp: 1
      },
      [33332]: {
        gl2: true,
        bpp: 2
      },
      [33331]: {
        gl2: true,
        bpp: 2
      },
      [33334]: {
        gl2: true,
        bpp: 4
      },
      [33333]: {
        gl2: true,
        bpp: 4
      },
      [33323]: {
        gl2: true,
        bpp: 2
      },
      [33336]: {
        gl2: true,
        bpp: 2
      },
      [33335]: {
        gl2: true,
        bpp: 2
      },
      [33338]: {
        gl2: true,
        bpp: 4
      },
      [33337]: {
        gl2: true,
        bpp: 4
      },
      [33340]: {
        gl2: true,
        bpp: 8
      },
      [33339]: {
        gl2: true,
        bpp: 8
      },
      [32849]: {
        gl2: true,
        bpp: 3
      },
      [32856]: {
        gl2: true,
        bpp: 4
      },
      [32857]: {
        gl2: true,
        bpp: 4
      },
      [36220]: {
        gl2: true,
        bpp: 4
      },
      [36238]: {
        gl2: true,
        bpp: 4
      },
      [36975]: {
        gl2: true,
        bpp: 4
      },
      [36214]: {
        gl2: true,
        bpp: 8
      },
      [36232]: {
        gl2: true,
        bpp: 8
      },
      [36226]: {
        gl2: true,
        bpp: 16
      },
      [36208]: {
        gl2: true,
        bpp: 16
      },
      [33325]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 2
      },
      [33327]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 4
      },
      [34842]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 8
      },
      [33326]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 4
      },
      [33328]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 8
      },
      [34836]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 16
      },
      [35898]: {
        gl2: EXT_FLOAT_WEBGL2,
        bpp: 4
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
function isFormatSupported2(gl, format, formats) {
  const info = formats[format];
  if (!info) {
    return false;
  }
  const value4 = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
  if (typeof value4 === "string") {
    return gl.getExtension(value4);
  }
  return value4;
}
var Renderbuffer;
var init_renderbuffer = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js"() {
    init_resource();
    init_renderbuffer_formats();
    init_esm9();
    init_assert7();
    Renderbuffer = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Renderbuffer";
      }
      static isSupported(gl) {
        let {
          format
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
          format: null
        };
        return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
      }
      static getSamplesForFormat(gl, _ref) {
        let {
          format
        } = _ref;
        return gl.getInternalformatParameter(36161, format, 32937);
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, opts);
        this.initialize(opts);
        Object.seal(this);
      }
      initialize(_ref2) {
        let {
          format,
          width = 1,
          height = 1,
          samples = 0
        } = _ref2;
        assert7(format, "Needs format");
        this._trackDeallocatedMemory();
        this.gl.bindRenderbuffer(36161, this.handle);
        if (samples !== 0 && isWebGL2(this.gl)) {
          this.gl.renderbufferStorageMultisample(36161, samples, format, width, height);
        } else {
          this.gl.renderbufferStorage(36161, format, width, height);
        }
        this.format = format;
        this.width = width;
        this.height = height;
        this.samples = samples;
        this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
        return this;
      }
      resize(_ref3) {
        let {
          width,
          height
        } = _ref3;
        if (width !== this.width || height !== this.height) {
          return this.initialize({
            width,
            height,
            format: this.format,
            samples: this.samples
          });
        }
        return this;
      }
      _createHandle() {
        return this.gl.createRenderbuffer();
      }
      _deleteHandle() {
        this.gl.deleteRenderbuffer(this.handle);
        this._trackDeallocatedMemory();
      }
      _bindHandle(handle) {
        this.gl.bindRenderbuffer(36161, handle);
      }
      _syncHandle(handle) {
        this.format = this.getParameter(36164);
        this.width = this.getParameter(36162);
        this.height = this.getParameter(36163);
        this.samples = this.getParameter(36011);
      }
      _getParameter(pname) {
        this.gl.bindRenderbuffer(36161, this.handle);
        const value4 = this.gl.getRenderbufferParameter(36161, pname);
        return value4;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
function clear(gl) {
  let {
    framebuffer = null,
    color = null,
    depth = null,
    stencil = null
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const parameters = {};
  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }
  let clearFlags = 0;
  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }
  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }
  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }
  assert7(clearFlags !== 0, ERR_ARGUMENTS);
  withParameters(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}
function clearBuffer(gl) {
  let {
    framebuffer = null,
    buffer = GL_COLOR,
    drawBuffer = 0,
    value: value4 = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  assertWebGL2Context(gl);
  withParameters(gl, {
    framebuffer
  }, () => {
    switch (buffer) {
      case GL_COLOR:
        switch (value4.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value4);
            break;
          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value4);
            break;
          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value4);
        }
        break;
      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value4]);
        break;
      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value4]);
        break;
      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value4;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;
      default:
        assert7(false, ERR_ARGUMENTS);
    }
  });
}
var GL_DEPTH_BUFFER_BIT, GL_STENCIL_BUFFER_BIT, GL_COLOR_BUFFER_BIT, GL_COLOR, GL_DEPTH, GL_STENCIL, GL_DEPTH_STENCIL, ERR_ARGUMENTS;
var init_clear = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/clear.js"() {
    init_esm9();
    init_assert7();
    GL_DEPTH_BUFFER_BIT = 256;
    GL_STENCIL_BUFFER_BIT = 1024;
    GL_COLOR_BUFFER_BIT = 16384;
    GL_COLOR = 6144;
    GL_DEPTH = 6145;
    GL_STENCIL = 6146;
    GL_DEPTH_STENCIL = 34041;
    ERR_ARGUMENTS = "clear: bad arguments";
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
function glFormatToComponents(format) {
  switch (format) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      assert7(false);
      return 0;
  }
}
function glTypeToBytes(type) {
  switch (type) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    default:
      assert7(false);
      return 0;
  }
}
var init_format_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js"() {
    init_assert7();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
function readPixelsToArray(source) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408
  } = options;
  let {
    sourceAttachment = 36064,
    target = null,
    sourceWidth,
    sourceHeight,
    sourceType
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert7(framebuffer);
  const {
    gl,
    handle,
    attachments
  } = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  if (sourceAttachment === 36064 && handle === null) {
    sourceAttachment = 1028;
  }
  assert7(attachments[sourceAttachment]);
  sourceType = sourceType || attachments[sourceAttachment].type;
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);
  sourceType = sourceType || getGLTypeFromTypedArray(target);
  const prevHandle = gl.bindFramebuffer(36160, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function readPixelsToBuffer(source, _ref) {
  let {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = 6408,
    target = null,
    targetByteOffset = 0,
    sourceWidth,
    sourceHeight,
    sourceType
  } = _ref;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert7(framebuffer);
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;
  const gl2 = assertWebGL2Context(framebuffer.gl);
  sourceType = sourceType || (target ? target.type : 5121);
  if (!target) {
    const components = glFormatToComponents(sourceFormat);
    const byteCount = glTypeToBytes(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new Buffer(gl2, {
      byteLength,
      accessor: {
        type: sourceType,
        size: components
      }
    });
  }
  target.bind({
    target: 35051
  });
  withParameters(gl2, {
    framebuffer
  }, () => {
    gl2.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, targetByteOffset);
  });
  target.unbind({
    target: 35051
  });
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}
function copyToDataUrl(source) {
  let {
    sourceAttachment = 36064,
    targetMaxHeight = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let data = readPixelsToArray(source, {
    sourceAttachment
  });
  let {
    width,
    height
  } = source;
  while (height > targetMaxHeight) {
    ({
      data,
      width,
      height
    } = scalePixels2({
      data,
      width,
      height
    }));
  }
  flipRows({
    data,
    width,
    height
  });
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext("2d");
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);
  return canvas.toDataURL();
}
function copyToTexture(source, target) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    sourceX = 0,
    sourceY = 0,
    targetMipmaplevel = 0,
    targetInternalFormat = 6408
  } = options;
  let {
    targetX,
    targetY,
    targetZ,
    width,
    height
  } = options;
  const {
    framebuffer,
    deleteFramebuffer
  } = getFramebuffer(source);
  assert7(framebuffer);
  const {
    gl,
    handle
  } = framebuffer;
  const isSubCopy = typeof targetX !== "undefined" || typeof targetY !== "undefined" || typeof targetZ !== "undefined";
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(36160, handle);
  assert7(target);
  let texture = null;
  if (target instanceof Texture) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }
  if (!isSubCopy) {
    gl.copyTexImage2D(target, targetMipmaplevel, targetInternalFormat, sourceX, sourceY, width, height, 0);
  } else {
    switch (target) {
      case 3553:
      case 34067:
        gl.copyTexSubImage2D(target, targetMipmaplevel, targetX, targetY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        const gl2 = assertWebGL2Context(gl);
        gl2.copyTexSubImage3D(target, targetMipmaplevel, targetX, targetY, targetZ, sourceX, sourceY, width, height);
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  gl.bindFramebuffer(36160, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return texture;
}
function getFramebuffer(source) {
  if (!(source instanceof Framebuffer)) {
    return {
      framebuffer: toFramebuffer(source),
      deleteFramebuffer: true
    };
  }
  return {
    framebuffer: source,
    deleteFramebuffer: false
  };
}
function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  type = type || 5121;
  const ArrayType = getTypedArrayFromGLType(type, {
    clamped: false
  });
  const components = glFormatToComponents(format);
  return new ArrayType(width * height * components);
}
var init_copy_and_blit = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js"() {
    init_buffer();
    init_framebuffer();
    init_texture();
    init_esm9();
    init_typed_array_utils();
    init_typed_array_utils();
    init_format_utils();
    init_texture_utils();
    init_assert7();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js
var webgl_limits_table_default;
var init_webgl_limits_table = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/webgl-limits-table.js"() {
    webgl_limits_table_default = {
      [33902]: {
        gl1: new Float32Array([1, 1])
      },
      [33901]: {
        gl1: new Float32Array([1, 1])
      },
      [3379]: {
        gl1: 64,
        gl2: 2048
      },
      [34076]: {
        gl1: 16
      },
      [34930]: {
        gl1: 8
      },
      [35661]: {
        gl1: 8
      },
      [35660]: {
        gl1: 0
      },
      [34024]: {
        gl1: 1
      },
      [36348]: {
        gl1: 8
      },
      [34921]: {
        gl1: 8
      },
      [36347]: {
        gl1: 128
      },
      [36349]: {
        gl1: 16
      },
      [3386]: {
        gl1: new Int32Array([0, 0])
      },
      [32883]: {
        gl1: 0,
        gl2: 256
      },
      [35071]: {
        gl1: 0,
        gl2: 256
      },
      [37447]: {
        gl1: 0,
        gl2: 0
      },
      [36063]: {
        gl1: 0,
        gl2: 4
      },
      [35379]: {
        gl1: 0,
        gl2: 0
      },
      [35374]: {
        gl1: 0,
        gl2: 0
      },
      [35377]: {
        gl1: 0,
        gl2: 0
      },
      [34852]: {
        gl1: 0,
        gl2: 4
      },
      [36203]: {
        gl1: 0,
        gl2: 0
      },
      [33001]: {
        gl1: 0,
        gl2: 0
      },
      [33e3]: {
        gl1: 0,
        gl2: 0
      },
      [37157]: {
        gl1: 0,
        gl2: 0
      },
      [35373]: {
        gl1: 0,
        gl2: 0
      },
      [35657]: {
        gl1: 0,
        gl2: 0
      },
      [36183]: {
        gl1: 0,
        gl2: 0
      },
      [37137]: {
        gl1: 0,
        gl2: 0
      },
      [34045]: {
        gl1: 0,
        gl2: 0
      },
      [35978]: {
        gl1: 0,
        gl2: 0
      },
      [35979]: {
        gl1: 0,
        gl2: 0
      },
      [35968]: {
        gl1: 0,
        gl2: 0
      },
      [35376]: {
        gl1: 0,
        gl2: 0
      },
      [35375]: {
        gl1: 0,
        gl2: 0
      },
      [35659]: {
        gl1: 0,
        gl2: 0
      },
      [37154]: {
        gl1: 0,
        gl2: 0
      },
      [35371]: {
        gl1: 0,
        gl2: 0
      },
      [35658]: {
        gl1: 0,
        gl2: 0
      },
      [35076]: {
        gl1: 0,
        gl2: -8,
        negative: true
      },
      [35077]: {
        gl1: 0,
        gl2: 7
      },
      [35380]: {
        gl1: 0,
        gl2: 0
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/limits.js
var init_limits = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/limits.js"() {
    init_webgl_limits_table();
    init_esm9();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
function checkFloat32ColorAttachment(gl) {
  const testTexture = new Texture2D(gl, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  });
  const testFb = new Framebuffer(gl, {
    id: "test-framebuffer",
    check: false,
    attachments: {
      [36064]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  return status === 36053;
}
var FEATURES, webgl_features_table_default;
var init_webgl_features_table = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js"() {
    init_framebuffer();
    init_texture_2d();
    FEATURES = {
      WEBGL2: "WEBGL2",
      VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
      TIMER_QUERY: "TIMER_QUERY",
      INSTANCED_RENDERING: "INSTANCED_RENDERING",
      MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
      ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
      BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
      FLOAT_BLEND: "FLOAT_BLEND",
      COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
      TEXTURE_DEPTH: "TEXTURE_DEPTH",
      TEXTURE_FLOAT: "TEXTURE_FLOAT",
      TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
      TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
      TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
      TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
      COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
      COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
      COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
      GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
      GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
      GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
      GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
    };
    webgl_features_table_default = {
      [FEATURES.WEBGL2]: [false, true],
      [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
      [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
      [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
      [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
      [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
      [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
      [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
      [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
      [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
      [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
      [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
      [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
      [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
      [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
      [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
      [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
      [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
      [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
      [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
      [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
      [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/features.js
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every((feature) => {
    return isFeatureSupported(gl, feature);
  });
}
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  for (const cap in webgl_features_table_default) {
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }
  return gl.luma.caps;
}
function isFeatureSupported(gl, cap) {
  gl.luma = gl.luma || {};
  gl.luma.caps = gl.luma.caps || {};
  if (gl.luma.caps[cap] === void 0) {
    gl.luma.caps[cap] = queryFeature(gl, cap);
  }
  if (!gl.luma.caps[cap]) {
    log.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
  }
  return gl.luma.caps[cap];
}
function queryFeature(gl, cap) {
  const feature = webgl_features_table_default[cap];
  assert7(feature, cap);
  let isSupported;
  const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
  if (typeof featureDefinition === "function") {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === "string") {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === "boolean") {
    isSupported = featureDefinition;
  } else {
    assert7(false);
  }
  return isSupported;
}
var LOG_UNSUPPORTED_FEATURE;
var init_features = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/features.js"() {
    init_webgl_features_table();
    init_esm9();
    init_assert7();
    LOG_UNSUPPORTED_FEATURE = 2;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js
var init_check_old_ie = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/check-old-ie.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js
var init_check_glsl_extension = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/check-glsl-extension.js"() {
    init_check_old_ie();
    init_webgl_features_table();
    init_assert7();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/features/index.js
var init_features2 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/features/index.js"() {
    init_limits();
    init_webgl_features_table();
    init_features();
    init_check_glsl_extension();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
function mapIndexToCubeMapFace(layer) {
  return layer < 34069 ? layer + 34069 : layer;
}
function _getFrameBufferStatus(status) {
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || "Framebuffer error ".concat(status);
}
var ERR_MULTIPLE_RENDERTARGETS, Framebuffer, FRAMEBUFFER_ATTACHMENT_PARAMETERS;
var init_framebuffer = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js"() {
    init_esm9();
    init_resource();
    init_texture_2d();
    init_renderbuffer();
    init_clear();
    init_copy_and_blit();
    init_features2();
    init_constants_to_keys();
    init_assert7();
    ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
    Framebuffer = class _Framebuffer extends Resource {
      get [Symbol.toStringTag]() {
        return "Framebuffer";
      }
      static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          colorBufferFloat,
          colorBufferHalfFloat
        } = options;
        let supported = true;
        if (colorBufferFloat) {
          supported = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
        }
        if (colorBufferHalfFloat) {
          supported = supported && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
        }
        return supported;
      }
      static getDefaultFramebuffer(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new _Framebuffer(gl, {
          id: "default-framebuffer",
          handle: null,
          attachments: {}
        });
        return gl.luma.defaultFramebuffer;
      }
      get MAX_COLOR_ATTACHMENTS() {
        const gl2 = assertWebGL2Context(this.gl);
        return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
      }
      get MAX_DRAW_BUFFERS() {
        const gl2 = assertWebGL2Context(this.gl);
        return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, opts);
        this.width = null;
        this.height = null;
        this.attachments = {};
        this.readBuffer = 36064;
        this.drawBuffers = [36064];
        this.ownResources = [];
        this.initialize(opts);
        Object.seal(this);
      }
      get color() {
        return this.attachments[36064] || null;
      }
      get texture() {
        return this.attachments[36064] || null;
      }
      get depth() {
        return this.attachments[36096] || this.attachments[33306] || null;
      }
      get stencil() {
        return this.attachments[36128] || this.attachments[33306] || null;
      }
      initialize(_ref) {
        let {
          width = 1,
          height = 1,
          attachments = null,
          color = true,
          depth = true,
          stencil = false,
          check = true,
          readBuffer = void 0,
          drawBuffers = void 0
        } = _ref;
        assert7(width >= 0 && height >= 0, "Width and height need to be integers");
        this.width = width;
        this.height = height;
        if (attachments) {
          for (const attachment in attachments) {
            const target = attachments[attachment];
            const object = Array.isArray(target) ? target[0] : target;
            object.resize({
              width,
              height
            });
          }
        } else {
          attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
        }
        this.update({
          clearAttachments: true,
          attachments,
          readBuffer,
          drawBuffers
        });
        if (attachments && check) {
          this.checkStatus();
        }
      }
      delete() {
        for (const resource of this.ownResources) {
          resource.delete();
        }
        super.delete();
        return this;
      }
      update(_ref2) {
        let {
          attachments = {},
          readBuffer,
          drawBuffers,
          clearAttachments = false,
          resizeAttachments = true
        } = _ref2;
        this.attach(attachments, {
          clearAttachments,
          resizeAttachments
        });
        const {
          gl
        } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        if (readBuffer) {
          this._setReadBuffer(readBuffer);
        }
        if (drawBuffers) {
          this._setDrawBuffers(drawBuffers);
        }
        gl.bindFramebuffer(36160, prevHandle || null);
        return this;
      }
      resize() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        let {
          width,
          height
        } = options;
        if (this.handle === null) {
          assert7(width === void 0 && height === void 0);
          this.width = this.gl.drawingBufferWidth;
          this.height = this.gl.drawingBufferHeight;
          return this;
        }
        if (width === void 0) {
          width = this.gl.drawingBufferWidth;
        }
        if (height === void 0) {
          height = this.gl.drawingBufferHeight;
        }
        if (width !== this.width && height !== this.height) {
          log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height))();
        }
        for (const attachmentPoint in this.attachments) {
          this.attachments[attachmentPoint].resize({
            width,
            height
          });
        }
        this.width = width;
        this.height = height;
        return this;
      }
      attach(attachments) {
        let {
          clearAttachments = false,
          resizeAttachments = true
        } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const newAttachments = {};
        if (clearAttachments) {
          Object.keys(this.attachments).forEach((key) => {
            newAttachments[key] = null;
          });
        }
        Object.assign(newAttachments, attachments);
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        for (const key in newAttachments) {
          assert7(key !== void 0, "Misspelled framebuffer binding point?");
          const attachment = Number(key);
          const descriptor = newAttachments[attachment];
          let object = descriptor;
          if (!object) {
            this._unattach(attachment);
          } else if (object instanceof Renderbuffer) {
            this._attachRenderbuffer({
              attachment,
              renderbuffer: object
            });
          } else if (Array.isArray(descriptor)) {
            const [texture, layer = 0, level = 0] = descriptor;
            object = texture;
            this._attachTexture({
              attachment,
              texture,
              layer,
              level
            });
          } else {
            this._attachTexture({
              attachment,
              texture: object,
              layer: 0,
              level: 0
            });
          }
          if (resizeAttachments && object) {
            object.resize({
              width: this.width,
              height: this.height
            });
          }
        }
        this.gl.bindFramebuffer(36160, prevHandle || null);
        Object.assign(this.attachments, attachments);
        Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
          delete this.attachments[key];
        });
      }
      checkStatus() {
        const {
          gl
        } = this;
        const status = this.getStatus();
        if (status !== 36053) {
          throw new Error(_getFrameBufferStatus(status));
        }
        return this;
      }
      getStatus() {
        const {
          gl
        } = this;
        const prevHandle = gl.bindFramebuffer(36160, this.handle);
        const status = gl.checkFramebufferStatus(36160);
        gl.bindFramebuffer(36160, prevHandle || null);
        return status;
      }
      clear() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          color,
          depth,
          stencil,
          drawBuffers = []
        } = options;
        const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
        if (color || depth || stencil) {
          clear(this.gl, {
            color,
            depth,
            stencil
          });
        }
        drawBuffers.forEach((value4, drawBuffer) => {
          clearBuffer(this.gl, {
            drawBuffer,
            value: value4
          });
        });
        this.gl.bindFramebuffer(36160, prevHandle || null);
        return this;
      }
      readPixels() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
        return null;
      }
      readPixelsToBuffer() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
        return null;
      }
      copyToDataUrl() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
        return null;
      }
      copyToImage() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
        return null;
      }
      copyToTexture() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
        return null;
      }
      blit() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
        return null;
      }
      invalidate(_ref3) {
        let {
          attachments = [],
          x = 0,
          y = 0,
          width,
          height
        } = _ref3;
        const gl2 = assertWebGL2Context(this.gl);
        const prevHandle = gl2.bindFramebuffer(36008, this.handle);
        const invalidateAll = x === 0 && y === 0 && width === void 0 && height === void 0;
        if (invalidateAll) {
          gl2.invalidateFramebuffer(36008, attachments);
        } else {
          gl2.invalidateFramebuffer(36008, attachments, x, y, width, height);
        }
        gl2.bindFramebuffer(36008, prevHandle);
        return this;
      }
      getAttachmentParameter(attachment, pname, keys) {
        let value4 = this._getAttachmentParameterFallback(pname);
        if (value4 === null) {
          this.gl.bindFramebuffer(36160, this.handle);
          value4 = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
          this.gl.bindFramebuffer(36160, null);
        }
        if (keys && value4 > 1e3) {
          value4 = getKey(this.gl, value4);
        }
        return value4;
      }
      getAttachmentParameters() {
        let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
        let keys = arguments.length > 1 ? arguments[1] : void 0;
        let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
        const values = {};
        for (const pname of parameters) {
          const key = keys ? getKey(this.gl, pname) : pname;
          values[key] = this.getAttachmentParameter(attachment, pname, keys);
        }
        return values;
      }
      getParameters() {
        let keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        const attachments = Object.keys(this.attachments);
        const parameters = {};
        for (const attachmentName of attachments) {
          const attachment = Number(attachmentName);
          const key = keys ? getKey(this.gl, attachment) : attachment;
          parameters[key] = this.getAttachmentParameters(attachment, keys);
        }
        return parameters;
      }
      show() {
        if (typeof window !== "undefined") {
          window.open(copyToDataUrl(this), "luma-debug-texture");
        }
        return this;
      }
      log() {
        let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (logLevel > log.level || typeof window === "undefined") {
          return this;
        }
        message = message || "Framebuffer ".concat(this.id);
        const image = copyToDataUrl(this, {
          targetMaxHeight: 100
        });
        log.image({
          logLevel,
          message,
          image
        }, message)();
        return this;
      }
      bind() {
        let {
          target = 36160
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.gl.bindFramebuffer(target, this.handle);
        return this;
      }
      unbind() {
        let {
          target = 36160
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.gl.bindFramebuffer(target, null);
        return this;
      }
      _createDefaultAttachments(color, depth, stencil, width, height) {
        let defaultAttachments = null;
        if (color) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[36064] = new Texture2D(this.gl, {
            id: "".concat(this.id, "-color0"),
            pixels: null,
            format: 6408,
            type: 5121,
            width,
            height,
            mipmaps: false,
            parameters: {
              [10241]: 9729,
              [10240]: 9729,
              [10242]: 33071,
              [10243]: 33071
            }
          });
          this.ownResources.push(defaultAttachments[36064]);
        }
        if (depth && stencil) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[33306] = new Renderbuffer(this.gl, {
            id: "".concat(this.id, "-depth-stencil"),
            format: 35056,
            width,
            height: 111
          });
          this.ownResources.push(defaultAttachments[33306]);
        } else if (depth) {
          defaultAttachments = defaultAttachments || {};
          defaultAttachments[36096] = new Renderbuffer(this.gl, {
            id: "".concat(this.id, "-depth"),
            format: 33189,
            width,
            height
          });
          this.ownResources.push(defaultAttachments[36096]);
        } else if (stencil) {
          assert7(false);
        }
        return defaultAttachments;
      }
      _unattach(attachment) {
        const oldAttachment = this.attachments[attachment];
        if (!oldAttachment) {
          return;
        }
        if (oldAttachment instanceof Renderbuffer) {
          this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
        } else {
          this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
        }
        delete this.attachments[attachment];
      }
      _attachRenderbuffer(_ref4) {
        let {
          attachment = 36064,
          renderbuffer
        } = _ref4;
        const {
          gl
        } = this;
        gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
        this.attachments[attachment] = renderbuffer;
      }
      _attachTexture(_ref5) {
        let {
          attachment = 36064,
          texture,
          layer,
          level
        } = _ref5;
        const {
          gl
        } = this;
        gl.bindTexture(texture.target, texture.handle);
        switch (texture.target) {
          case 35866:
          case 32879:
            const gl2 = assertWebGL2Context(gl);
            gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
            break;
          case 34067:
            const face = mapIndexToCubeMapFace(layer);
            gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
            break;
          case 3553:
            gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
            break;
          default:
            assert7(false, "Illegal texture type");
        }
        gl.bindTexture(texture.target, null);
        this.attachments[attachment] = texture;
      }
      _setReadBuffer(readBuffer) {
        const gl2 = getWebGL2Context(this.gl);
        if (gl2) {
          gl2.readBuffer(readBuffer);
        } else {
          assert7(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
        }
        this.readBuffer = readBuffer;
      }
      _setDrawBuffers(drawBuffers) {
        const {
          gl
        } = this;
        const gl2 = assertWebGL2Context(gl);
        if (gl2) {
          gl2.drawBuffers(drawBuffers);
        } else {
          const ext = gl.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ext.drawBuffersWEBGL(drawBuffers);
          } else {
            assert7(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
          }
        }
        this.drawBuffers = drawBuffers;
      }
      _getAttachmentParameterFallback(pname) {
        const caps = getFeatures(this.gl);
        switch (pname) {
          case 36052:
            return !caps.WEBGL2 ? 0 : null;
          case 33298:
          case 33299:
          case 33300:
          case 33301:
          case 33302:
          case 33303:
            return !caps.WEBGL2 ? 8 : null;
          case 33297:
            return !caps.WEBGL2 ? 5125 : null;
          case 33296:
            return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
          default:
            return null;
        }
      }
      _createHandle() {
        return this.gl.createFramebuffer();
      }
      _deleteHandle() {
        this.gl.deleteFramebuffer(this.handle);
      }
      _bindHandle(handle) {
        return this.gl.bindFramebuffer(36160, handle);
      }
    };
    FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
    Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
function cloneTextureFrom(refTexture, overrides) {
  assert7(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
  const TextureType = refTexture.constructor;
  const {
    gl,
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  } = refTexture;
  const textureOptions = Object.assign({
    width,
    height,
    format,
    type,
    dataFormat,
    border,
    mipmaps
  }, overrides);
  return new TextureType(gl, textureOptions);
}
function toFramebuffer(texture, opts) {
  const {
    gl,
    width,
    height,
    id
  } = texture;
  const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
    id: "framebuffer-for-".concat(id),
    width,
    height,
    attachments: {
      [36064]: texture
    }
  }));
  return framebuffer;
}
var init_texture_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js"() {
    init_texture_2d();
    init_texture_cube();
    init_texture_3d();
    init_framebuffer();
    init_assert7();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
function getShaderName(shader) {
  let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}
var init_get_shader_name = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return "fragment";
    case GL_VERTEX_SHADER:
      return "vertex";
    default:
      return "unknown type";
  }
}
var GL_FRAGMENT_SHADER, GL_VERTEX_SHADER;
var init_get_shader_type_name = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js"() {
    GL_FRAGMENT_SHADER = 35632;
    GL_VERTEX_SHADER = 35633;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};
  const name = shaderName || getShaderName(src) || "(unnamed)";
  const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name);
  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    const segments = errorString.split(":");
    const type = segments[0];
    const line = parseInt(segments[2], 10);
    if (isNaN(line)) {
      throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
    }
    if (type !== "WARNING") {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }
  const lines = addLineNumbers(src);
  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}
function formatErrors(errors, lines) {
  let message = "";
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }
    message += "".concat(line, "\n");
    if (errors[i + 1]) {
      const error2 = errors[i + 1];
      const segments = error2.split(":", 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error2.substring(segments.join(":").length + 1).trim();
      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
    }
  }
  return message;
}
function addLineNumbers(string) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = String(i + start);
    const digits = lineNumber.length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}
function padLeft(string, digits) {
  let result = "";
  for (let i = 0; i < digits; ++i) {
    result += " ";
  }
  return "".concat(result).concat(string);
}
var init_format_glsl_error = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js"() {
    init_get_shader_name();
    init_get_shader_type_name();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
function getShaderVersion(source) {
  let version3 = 100;
  const words = source.match(/[^\s]+/g);
  if (words.length >= 2 && words[0] === "#version") {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version3 = v;
    }
  }
  return version3;
}
var init_get_shader_version = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js
var init_glsl_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/glsl-utils/index.js"() {
    init_format_glsl_error();
    init_get_shader_name();
    init_get_shader_version();
    init_get_shader_type_name();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
var ERR_SOURCE, Shader, VertexShader, FragmentShader;
var init_shader = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/shader.js"() {
    init_esm9();
    init_glsl_utils();
    init_assert7();
    init_utils2();
    init_resource();
    ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
    Shader = class _Shader extends Resource {
      get [Symbol.toStringTag]() {
        return "Shader";
      }
      static getTypeName(shaderType) {
        switch (shaderType) {
          case 35633:
            return "vertex-shader";
          case 35632:
            return "fragment-shader";
          default:
            assert7(false);
            return "unknown";
        }
      }
      constructor(gl, props) {
        assertWebGLContext(gl);
        assert7(typeof props.source === "string", ERR_SOURCE);
        const id = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(_Shader.getTypeName(props.shaderType)));
        super(gl, {
          id
        });
        this.shaderType = props.shaderType;
        this.source = props.source;
        this.initialize(props);
      }
      initialize(_ref) {
        let {
          source
        } = _ref;
        const shaderName = getShaderName(source, null);
        if (shaderName) {
          this.id = uid(shaderName);
        }
        this._compile(source);
      }
      getParameter(pname) {
        return this.gl.getShaderParameter(this.handle, pname);
      }
      toString() {
        return "".concat(_Shader.getTypeName(this.shaderType), ":").concat(this.id);
      }
      getName() {
        return getShaderName(this.source) || "unnamed-shader";
      }
      getSource() {
        return this.gl.getShaderSource(this.handle);
      }
      getTranslatedSource() {
        const extension = this.gl.getExtension("WEBGL_debug_shaders");
        return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
      }
      _compile() {
        let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
        if (!source.startsWith("#version ")) {
          source = "#version 100\n".concat(source);
        }
        this.source = source;
        this.gl.shaderSource(this.handle, this.source);
        this.gl.compileShader(this.handle);
        const compileStatus = this.getParameter(35713);
        if (!compileStatus) {
          const infoLog = this.gl.getShaderInfoLog(this.handle);
          const {
            shaderName,
            errors,
            warnings
          } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
          log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
          log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
          throw new Error("GLSL compilation errors in ".concat(shaderName));
        }
      }
      _deleteHandle() {
        this.gl.deleteShader(this.handle);
      }
      _getOptsFromHandle() {
        return {
          type: this.getParameter(35663),
          source: this.getSource()
        };
      }
    };
    VertexShader = class extends Shader {
      get [Symbol.toStringTag]() {
        return "VertexShader";
      }
      constructor(gl, props) {
        if (typeof props === "string") {
          props = {
            source: props
          };
        }
        super(gl, Object.assign({}, props, {
          shaderType: 35633
        }));
      }
      _createHandle() {
        return this.gl.createShader(35633);
      }
    };
    FragmentShader = class extends Shader {
      get [Symbol.toStringTag]() {
        return "FragmentShader";
      }
      constructor(gl, props) {
        if (typeof props === "string") {
          props = {
            source: props
          };
        }
        super(gl, Object.assign({}, props, {
          shaderType: 35632
        }));
      }
      _createHandle() {
        return this.gl.createShader(35632);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
function toTypedArray(value4, uniformLength, Type, cache2) {
  if (uniformLength === 1 && typeof value4 === "boolean") {
    value4 = value4 ? 1 : 0;
  }
  if (Number.isFinite(value4)) {
    array1[0] = value4;
    value4 = array1;
  }
  const length5 = value4.length;
  if (length5 % uniformLength) {
    log.warn("Uniform size should be multiples of ".concat(uniformLength), value4)();
  }
  if (value4 instanceof Type) {
    return value4;
  }
  let result = cache2[length5];
  if (!result) {
    result = new Type(length5);
    cache2[length5] = result;
  }
  for (let i = 0; i < length5; i++) {
    result[i] = value4[i];
  }
  return result;
}
function toFloatArray(value4, uniformLength) {
  return toTypedArray(value4, uniformLength, Float32Array, FLOAT_ARRAY);
}
function toIntArray(value4, uniformLength) {
  return toTypedArray(value4, uniformLength, Int32Array, INT_ARRAY);
}
function toUIntArray(value4, uniformLength) {
  return toTypedArray(value4, uniformLength, Uint32Array, UINT_ARRAY);
}
function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error("Unknown GLSL uniform type ".concat(info.type));
  }
  return setter().bind(null, gl, location);
}
function parseUniformName(name) {
  if (name[name.length - 1] !== "]") {
    return {
      name,
      length: 1,
      isArray: false
    };
  }
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches4 = name.match(UNIFORM_NAME_REGEXP);
  if (!matches4 || matches4.length < 2) {
    throw new Error("Failed to parse GLSL uniform name ".concat(name));
  }
  return {
    name: matches4[1],
    length: matches4[2] || 1,
    isArray: Boolean(matches4[2])
  };
}
function checkUniformValues(uniforms3, source, uniformMap) {
  for (const uniformName in uniforms3) {
    const value4 = uniforms3[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
    if (shouldCheck && !checkUniformValue(value4)) {
      source = source ? "".concat(source, " ") : "";
      console.error("".concat(source, " Bad uniform ").concat(uniformName), value4);
      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
    }
  }
  return true;
}
function checkUniformValue(value4) {
  if (Array.isArray(value4) || ArrayBuffer.isView(value4)) {
    return checkUniformArray(value4);
  }
  if (isFinite(value4)) {
    return true;
  } else if (value4 === true || value4 === false) {
    return true;
  } else if (value4 instanceof Texture) {
    return true;
  } else if (value4 instanceof Renderbuffer) {
    return true;
  } else if (value4 instanceof Framebuffer) {
    return Boolean(value4.texture);
  }
  return false;
}
function copyUniform(uniforms3, key, value4) {
  if (Array.isArray(value4) || ArrayBuffer.isView(value4)) {
    if (uniforms3[key]) {
      const dest = uniforms3[key];
      for (let i = 0, len2 = value4.length; i < len2; ++i) {
        dest[i] = value4[i];
      }
    } else {
      uniforms3[key] = value4.slice();
    }
  } else {
    uniforms3[key] = value4;
  }
}
function checkUniformArray(value4) {
  if (value4.length === 0) {
    return false;
  }
  const checkLength = Math.min(value4.length, 16);
  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value4[i])) {
      return false;
    }
  }
  return true;
}
function getSamplerSetter() {
  let cache2 = null;
  return (gl, location, value4) => {
    const update = cache2 !== value4;
    if (update) {
      gl.uniform1i(location, value4);
      cache2 = value4;
    }
    return update;
  };
}
function getArraySetter(functionName, toArray, size, uniformSetter) {
  let cache2 = null;
  let cacheLength = null;
  return (gl, location, value4) => {
    const arrayValue = toArray(value4, size);
    const length5 = arrayValue.length;
    let update = false;
    if (cache2 === null) {
      cache2 = new Float32Array(length5);
      cacheLength = length5;
      update = true;
    } else {
      assert7(cacheLength === length5, "Uniform length cannot change.");
      for (let i = 0; i < length5; ++i) {
        if (arrayValue[i] !== cache2[i]) {
          update = true;
          break;
        }
      }
    }
    if (update) {
      uniformSetter(gl, functionName, location, arrayValue);
      cache2.set(arrayValue);
    }
    return update;
  };
}
function setVectorUniform(gl, functionName, location, value4) {
  gl[functionName](location, value4);
}
function setMatrixUniform(gl, functionName, location, value4) {
  gl[functionName](location, false, value4);
}
var UNIFORM_SETTERS, FLOAT_ARRAY, INT_ARRAY, UINT_ARRAY, array1;
var init_uniforms = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js"() {
    init_esm9();
    init_framebuffer();
    init_renderbuffer();
    init_texture();
    init_assert7();
    UNIFORM_SETTERS = {
      [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
      [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
      [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
      [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
      [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
      [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
      [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
      [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
      [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
      [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
      [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
      [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
      [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
      [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
      [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
      [35678]: getSamplerSetter,
      [35680]: getSamplerSetter,
      [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
      [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
      [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
      [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
      [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
      [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
      [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
      [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
      [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
      [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
      [35678]: getSamplerSetter,
      [35680]: getSamplerSetter,
      [35679]: getSamplerSetter,
      [35682]: getSamplerSetter,
      [36289]: getSamplerSetter,
      [36292]: getSamplerSetter,
      [36293]: getSamplerSetter,
      [36298]: getSamplerSetter,
      [36299]: getSamplerSetter,
      [36300]: getSamplerSetter,
      [36303]: getSamplerSetter,
      [36306]: getSamplerSetter,
      [36307]: getSamplerSetter,
      [36308]: getSamplerSetter,
      [36311]: getSamplerSetter
    };
    FLOAT_ARRAY = {};
    INT_ARRAY = {};
    UINT_ARRAY = {};
    array1 = [0];
  }
});

// node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;
    case GL_LINES:
      return GL_LINES;
    case GL_LINE_STRIP:
      return GL_LINES;
    case GL_LINE_LOOP:
      return GL_LINES;
    case GL_TRIANGLES:
      return GL_TRIANGLES;
    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;
    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;
    default:
      assert7(false);
      return 0;
  }
}
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
  if (!typeAndSize) {
    return null;
  }
  const [type, components] = typeAndSize;
  return {
    type,
    components
  };
}
function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;
    default:
  }
  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
    if (compType === type && compComponents === components) {
      return {
        glType,
        name
      };
    }
  }
  return null;
}
var GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_POINTS, GL_LINES, GL_LINE_LOOP, GL_LINE_STRIP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_FLOAT, GL_FLOAT_VEC2, GL_FLOAT_VEC3, GL_FLOAT_VEC4, GL_INT, GL_INT_VEC2, GL_INT_VEC3, GL_INT_VEC4, GL_UNSIGNED_INT, GL_UNSIGNED_INT_VEC2, GL_UNSIGNED_INT_VEC3, GL_UNSIGNED_INT_VEC4, GL_BOOL, GL_BOOL_VEC2, GL_BOOL_VEC3, GL_BOOL_VEC4, GL_FLOAT_MAT2, GL_FLOAT_MAT3, GL_FLOAT_MAT4, GL_FLOAT_MAT2x3, GL_FLOAT_MAT2x4, GL_FLOAT_MAT3x2, GL_FLOAT_MAT3x4, GL_FLOAT_MAT4x2, GL_FLOAT_MAT4x3, COMPOSITE_GL_TYPES;
var init_attribute_utils = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js"() {
    init_assert7();
    GL_BYTE = 5120;
    GL_UNSIGNED_BYTE = 5121;
    GL_SHORT = 5122;
    GL_UNSIGNED_SHORT = 5123;
    GL_POINTS = 0;
    GL_LINES = 1;
    GL_LINE_LOOP = 2;
    GL_LINE_STRIP = 3;
    GL_TRIANGLES = 4;
    GL_TRIANGLE_STRIP = 5;
    GL_TRIANGLE_FAN = 6;
    GL_FLOAT = 5126;
    GL_FLOAT_VEC2 = 35664;
    GL_FLOAT_VEC3 = 35665;
    GL_FLOAT_VEC4 = 35666;
    GL_INT = 5124;
    GL_INT_VEC2 = 35667;
    GL_INT_VEC3 = 35668;
    GL_INT_VEC4 = 35669;
    GL_UNSIGNED_INT = 5125;
    GL_UNSIGNED_INT_VEC2 = 36294;
    GL_UNSIGNED_INT_VEC3 = 36295;
    GL_UNSIGNED_INT_VEC4 = 36296;
    GL_BOOL = 35670;
    GL_BOOL_VEC2 = 35671;
    GL_BOOL_VEC3 = 35672;
    GL_BOOL_VEC4 = 35673;
    GL_FLOAT_MAT2 = 35674;
    GL_FLOAT_MAT3 = 35675;
    GL_FLOAT_MAT4 = 35676;
    GL_FLOAT_MAT2x3 = 35685;
    GL_FLOAT_MAT2x4 = 35686;
    GL_FLOAT_MAT3x2 = 35687;
    GL_FLOAT_MAT3x4 = 35688;
    GL_FLOAT_MAT4x2 = 35689;
    GL_FLOAT_MAT4x3 = 35690;
    COMPOSITE_GL_TYPES = {
      [GL_FLOAT]: [GL_FLOAT, 1, "float"],
      [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
      [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
      [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
      [GL_INT]: [GL_INT, 1, "int"],
      [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
      [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
      [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
      [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
      [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
      [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
      [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
      [GL_BOOL]: [GL_FLOAT, 1, "bool"],
      [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
      [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
      [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
      [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
      [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
      [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
      [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
      [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
      [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
      [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
      [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
      [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
var ProgramConfiguration;
var init_program_configuration = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js"() {
    init_accessor();
    init_esm9();
    init_attribute_utils();
    ProgramConfiguration = class {
      constructor(program) {
        this.id = program.id;
        this.attributeInfos = [];
        this.attributeInfosByName = {};
        this.attributeInfosByLocation = [];
        this.varyingInfos = [];
        this.varyingInfosByName = {};
        Object.seal(this);
        this._readAttributesFromProgram(program);
        this._readVaryingsFromProgram(program);
      }
      getAttributeInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return this.attributeInfosByLocation[location];
        }
        return this.attributeInfosByName[locationOrName] || null;
      }
      getAttributeLocation(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.location : -1;
      }
      getAttributeAccessor(locationOrName) {
        const attributeInfo = this.getAttributeInfo(locationOrName);
        return attributeInfo ? attributeInfo.accessor : null;
      }
      getVaryingInfo(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return this.varyingInfos[location];
        }
        return this.varyingInfosByName[locationOrName] || null;
      }
      getVaryingIndex(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.location : -1;
      }
      getVaryingAccessor(locationOrName) {
        const varying = this.getVaryingInfo();
        return varying ? varying.accessor : null;
      }
      _readAttributesFromProgram(program) {
        const {
          gl
        } = program;
        const count4 = gl.getProgramParameter(program.handle, 35721);
        for (let index = 0; index < count4; index++) {
          const {
            name,
            type,
            size
          } = gl.getActiveAttrib(program.handle, index);
          const location = gl.getAttribLocation(program.handle, name);
          if (location >= 0) {
            this._addAttribute(location, name, type, size);
          }
        }
        this.attributeInfos.sort((a2, b) => a2.location - b.location);
      }
      _readVaryingsFromProgram(program) {
        const {
          gl
        } = program;
        if (!isWebGL2(gl)) {
          return;
        }
        const count4 = gl.getProgramParameter(program.handle, 35971);
        for (let location = 0; location < count4; location++) {
          const {
            name,
            type,
            size
          } = gl.getTransformFeedbackVarying(program.handle, location);
          this._addVarying(location, name, type, size);
        }
        this.varyingInfos.sort((a2, b) => a2.location - b.location);
      }
      _addAttribute(location, name, compositeType, size) {
        const {
          type,
          components
        } = decomposeCompositeGLType(compositeType);
        const accessor = {
          type,
          size: size * components
        };
        this._inferProperties(location, name, accessor);
        const attributeInfo = {
          location,
          name,
          accessor: new Accessor(accessor)
        };
        this.attributeInfos.push(attributeInfo);
        this.attributeInfosByLocation[location] = attributeInfo;
        this.attributeInfosByName[attributeInfo.name] = attributeInfo;
      }
      _inferProperties(location, name, accessor) {
        if (/instance/i.test(name)) {
          accessor.divisor = 1;
        }
      }
      _addVarying(location, name, compositeType, size) {
        const {
          type,
          components
        } = decomposeCompositeGLType(compositeType);
        const accessor = new Accessor({
          type,
          size: size * components
        });
        const varying = {
          location,
          name,
          accessor
        };
        this.varyingInfos.push(varying);
        this.varyingInfosByName[varying.name] = varying;
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/program.js
var LOG_PROGRAM_PERF_PRIORITY, GL_SEPARATE_ATTRIBS, V6_DEPRECATED_METHODS, Program;
var init_program = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/program.js"() {
    init_resource();
    init_texture();
    init_framebuffer();
    init_uniforms();
    init_shader();
    init_program_configuration();
    init_uniforms();
    init_esm9();
    init_constants_to_keys();
    init_attribute_utils();
    init_assert7();
    init_utils2();
    LOG_PROGRAM_PERF_PRIORITY = 4;
    GL_SEPARATE_ATTRIBS = 35981;
    V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
    Program = class extends Resource {
      get [Symbol.toStringTag]() {
        return "Program";
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, props);
        this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
        this._isCached = false;
        this.initialize(props);
        Object.seal(this);
        this._setId(props.id);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          hash,
          vs: vs9,
          fs: fs6,
          varyings,
          bufferMode = GL_SEPARATE_ATTRIBS
        } = props;
        this.hash = hash || "";
        this.vs = typeof vs9 === "string" ? new VertexShader(this.gl, {
          id: "".concat(props.id, "-vs"),
          source: vs9
        }) : vs9;
        this.fs = typeof fs6 === "string" ? new FragmentShader(this.gl, {
          id: "".concat(props.id, "-fs"),
          source: fs6
        }) : fs6;
        assert7(this.vs instanceof VertexShader);
        assert7(this.fs instanceof FragmentShader);
        this.uniforms = {};
        this._textureUniforms = {};
        if (varyings && varyings.length > 0) {
          assertWebGL2Context(this.gl);
          this.varyings = varyings;
          this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
        }
        this._compileAndLink();
        this._readUniformLocationsFromLinkedProgram();
        this.configuration = new ProgramConfiguration(this);
        return this.setProps(props);
      }
      delete() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._isCached) {
          return this;
        }
        return super.delete(options);
      }
      setProps(props) {
        if ("uniforms" in props) {
          this.setUniforms(props.uniforms);
        }
        return this;
      }
      draw(_ref) {
        let {
          logPriority,
          drawMode = 4,
          vertexCount,
          offset = 0,
          start,
          end,
          isIndexed = false,
          indexType = 5123,
          instanceCount = 0,
          isInstanced = instanceCount > 0,
          vertexArray = null,
          transformFeedback,
          framebuffer,
          parameters = {},
          uniforms: uniforms3,
          samplers
        } = _ref;
        if (uniforms3 || samplers) {
          log.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
          this.setUniforms(uniforms3 || {});
        }
        if (log.priority >= logPriority) {
          const fb = framebuffer ? framebuffer.id : "default";
          const message = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
          log.log(logPriority, message)();
        }
        assert7(vertexArray);
        this.gl.useProgram(this.handle);
        if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
          return false;
        }
        vertexArray.bindForDraw(vertexCount, instanceCount, () => {
          if (framebuffer !== void 0) {
            parameters = Object.assign({}, parameters, {
              framebuffer
            });
          }
          if (transformFeedback) {
            const primitiveMode = getPrimitiveDrawMode(drawMode);
            transformFeedback.begin(primitiveMode);
          }
          this._bindTextures();
          withParameters(this.gl, parameters, () => {
            if (isIndexed && isInstanced) {
              this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
            } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start) && !isNaN(end)) {
              this.gl2.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
            } else if (isIndexed) {
              this.gl.drawElements(drawMode, vertexCount, indexType, offset);
            } else if (isInstanced) {
              this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
            } else {
              this.gl.drawArrays(drawMode, offset, vertexCount);
            }
          });
          if (transformFeedback) {
            transformFeedback.end();
          }
        });
        return true;
      }
      setUniforms() {
        let uniforms3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (log.priority >= 2) {
          checkUniformValues(uniforms3, this.id, this._uniformSetters);
        }
        this.gl.useProgram(this.handle);
        for (const uniformName in uniforms3) {
          const uniform = uniforms3[uniformName];
          const uniformSetter = this._uniformSetters[uniformName];
          if (uniformSetter) {
            let value4 = uniform;
            let textureUpdate = false;
            if (value4 instanceof Framebuffer) {
              value4 = value4.texture;
            }
            if (value4 instanceof Texture) {
              textureUpdate = this.uniforms[uniformName] !== uniform;
              if (textureUpdate) {
                if (uniformSetter.textureIndex === void 0) {
                  uniformSetter.textureIndex = this._textureIndexCounter++;
                }
                const texture = value4;
                const {
                  textureIndex
                } = uniformSetter;
                texture.bind(textureIndex);
                value4 = textureIndex;
                this._textureUniforms[uniformName] = texture;
              } else {
                value4 = uniformSetter.textureIndex;
              }
            } else if (this._textureUniforms[uniformName]) {
              delete this._textureUniforms[uniformName];
            }
            if (uniformSetter(value4) || textureUpdate) {
              copyUniform(this.uniforms, uniformName, uniform);
            }
          }
        }
        return this;
      }
      _areTexturesRenderable() {
        let texturesRenderable = true;
        for (const uniformName in this._textureUniforms) {
          const texture = this._textureUniforms[uniformName];
          texture.update();
          texturesRenderable = texturesRenderable && texture.loaded;
        }
        return texturesRenderable;
      }
      _bindTextures() {
        for (const uniformName in this._textureUniforms) {
          const textureIndex = this._uniformSetters[uniformName].textureIndex;
          this._textureUniforms[uniformName].bind(textureIndex);
        }
      }
      _createHandle() {
        return this.gl.createProgram();
      }
      _deleteHandle() {
        this.gl.deleteProgram(this.handle);
      }
      _getOptionsFromHandle(handle) {
        const shaderHandles = this.gl.getAttachedShaders(handle);
        const opts = {};
        for (const shaderHandle of shaderHandles) {
          const type = this.gl.getShaderParameter(this.handle, 35663);
          switch (type) {
            case 35633:
              opts.vs = new VertexShader({
                handle: shaderHandle
              });
              break;
            case 35632:
              opts.fs = new FragmentShader({
                handle: shaderHandle
              });
              break;
            default:
          }
        }
        return opts;
      }
      _getParameter(pname) {
        return this.gl.getProgramParameter(this.handle, pname);
      }
      _setId(id) {
        if (!id) {
          const programName = this._getName();
          this.id = uid(programName);
        }
      }
      _getName() {
        let programName = this.vs.getName() || this.fs.getName();
        programName = programName.replace(/shader/i, "");
        programName = programName ? "".concat(programName, "-program") : "program";
        return programName;
      }
      _compileAndLink() {
        const {
          gl
        } = this;
        gl.attachShader(this.handle, this.vs.handle);
        gl.attachShader(this.handle, this.fs.handle);
        log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        gl.linkProgram(this.handle);
        log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
        if (gl.debug || log.level > 0) {
          const linked = gl.getProgramParameter(this.handle, 35714);
          if (!linked) {
            throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
          }
          gl.validateProgram(this.handle);
          const validated = gl.getProgramParameter(this.handle, 35715);
          if (!validated) {
            throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
          }
        }
      }
      _readUniformLocationsFromLinkedProgram() {
        const {
          gl
        } = this;
        this._uniformSetters = {};
        this._uniformCount = this._getParameter(35718);
        for (let i = 0; i < this._uniformCount; i++) {
          const info = this.gl.getActiveUniform(this.handle, i);
          const {
            name
          } = parseUniformName(info.name);
          let location = gl.getUniformLocation(this.handle, name);
          this._uniformSetters[name] = getUniformSetter(gl, location, info);
          if (info.size > 1) {
            for (let l = 0; l < info.size; l++) {
              location = gl.getUniformLocation(this.handle, "".concat(name, "[").concat(l, "]"));
              this._uniformSetters["".concat(name, "[").concat(l, "]")] = getUniformSetter(gl, location, info);
            }
          }
        }
        this._textureIndexCounter = 0;
      }
      getActiveUniforms(uniformIndices, pname) {
        return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
      }
      getUniformBlockIndex(blockName) {
        return this.gl2.getUniformBlockIndex(this.handle, blockName);
      }
      getActiveUniformBlockParameter(blockIndex, pname) {
        return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
      }
      uniformBlockBinding(blockIndex, blockBinding) {
        this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/query.js
var GL_QUERY_RESULT, GL_QUERY_RESULT_AVAILABLE, GL_TIME_ELAPSED_EXT, GL_GPU_DISJOINT_EXT2, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_ANY_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED_CONSERVATIVE, Query;
var init_query = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/query.js"() {
    init_resource();
    init_features2();
    init_esm9();
    init_assert7();
    GL_QUERY_RESULT = 34918;
    GL_QUERY_RESULT_AVAILABLE = 34919;
    GL_TIME_ELAPSED_EXT = 35007;
    GL_GPU_DISJOINT_EXT2 = 36795;
    GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
    GL_ANY_SAMPLES_PASSED = 35887;
    GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
    Query = class _Query extends Resource {
      get [Symbol.toStringTag]() {
        return "Query";
      }
      static isSupported(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        const webgl2 = isWebGL2(gl);
        const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
        let supported = webgl2 || hasTimerQuery;
        for (const key of opts) {
          switch (key) {
            case "queries":
              supported = supported && webgl2;
              break;
            case "timers":
              supported = supported && hasTimerQuery;
              break;
            default:
              assert7(false);
          }
        }
        return supported;
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(gl, opts);
        this.target = null;
        this._queryPending = false;
        this._pollingPromise = null;
        Object.seal(this);
      }
      beginTimeElapsedQuery() {
        return this.begin(GL_TIME_ELAPSED_EXT);
      }
      beginOcclusionQuery() {
        let {
          conservative = false
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
      }
      beginTransformFeedbackQuery() {
        return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
      }
      begin(target) {
        if (this._queryPending) {
          return this;
        }
        this.target = target;
        this.gl2.beginQuery(this.target, this.handle);
        return this;
      }
      end() {
        if (this._queryPending) {
          return this;
        }
        if (this.target) {
          this.gl2.endQuery(this.target);
          this.target = null;
          this._queryPending = true;
        }
        return this;
      }
      isResultAvailable() {
        if (!this._queryPending) {
          return false;
        }
        const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
        if (resultAvailable) {
          this._queryPending = false;
        }
        return resultAvailable;
      }
      isTimerDisjoint() {
        return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
      }
      getResult() {
        return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
      }
      getTimerMilliseconds() {
        return this.getResult() / 1e6;
      }
      createPoll() {
        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
        if (this._pollingPromise) {
          return this._pollingPromise;
        }
        let counter2 = 0;
        this._pollingPromise = new Promise((resolve, reject) => {
          const poll = () => {
            if (this.isResultAvailable()) {
              resolve(this.getResult());
              this._pollingPromise = null;
            } else if (counter2++ > limit) {
              reject("Timed out");
              this._pollingPromise = null;
            } else {
              requestAnimationFrame(poll);
            }
          };
          requestAnimationFrame(poll);
        });
        return this._pollingPromise;
      }
      _createHandle() {
        return _Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
      }
      _deleteHandle() {
        this.gl2.deleteQuery(this.handle);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
var TransformFeedback;
var init_transform_feedback = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js"() {
    init_esm9();
    init_resource();
    init_buffer();
    init_utils2();
    TransformFeedback = class extends Resource {
      get [Symbol.toStringTag]() {
        return "TransformFeedback";
      }
      static isSupported(gl) {
        return isWebGL2(gl);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assertWebGL2Context(gl);
        super(gl, props);
        this.initialize(props);
        this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
        Object.seal(this);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.buffers = {};
        this.unused = {};
        this.configuration = null;
        this.bindOnUse = true;
        if (!isObjectEmpty2(this.buffers)) {
          this.bind(() => this._unbindBuffers());
        }
        this.setProps(props);
        return this;
      }
      setProps(props) {
        if ("program" in props) {
          this.configuration = props.program && props.program.configuration;
        }
        if ("configuration" in props) {
          this.configuration = props.configuration;
        }
        if ("bindOnUse" in props) {
          props = props.bindOnUse;
        }
        if ("buffers" in props) {
          this.setBuffers(props.buffers);
        }
      }
      setBuffers() {
        let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.bind(() => {
          for (const bufferName in buffers) {
            this.setBuffer(bufferName, buffers[bufferName]);
          }
        });
        return this;
      }
      setBuffer(locationOrName, bufferOrParams) {
        const location = this._getVaryingIndex(locationOrName);
        const {
          buffer,
          byteSize,
          byteOffset
        } = this._getBufferParams(bufferOrParams);
        if (location < 0) {
          this.unused[locationOrName] = buffer;
          log.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
          return this;
        }
        this.buffers[location] = bufferOrParams;
        if (!this.bindOnUse) {
          this._bindBuffer(location, buffer, byteOffset, byteSize);
        }
        return this;
      }
      begin() {
        let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        this.gl.bindTransformFeedback(36386, this.handle);
        this._bindBuffers();
        this.gl.beginTransformFeedback(primitiveMode);
        return this;
      }
      end() {
        this.gl.endTransformFeedback();
        this._unbindBuffers();
        this.gl.bindTransformFeedback(36386, null);
        return this;
      }
      _getBufferParams(bufferOrParams) {
        let byteOffset;
        let byteSize;
        let buffer;
        if (bufferOrParams instanceof Buffer === false) {
          buffer = bufferOrParams.buffer;
          byteSize = bufferOrParams.byteSize;
          byteOffset = bufferOrParams.byteOffset;
        } else {
          buffer = bufferOrParams;
        }
        if (byteOffset !== void 0 || byteSize !== void 0) {
          byteOffset = byteOffset || 0;
          byteSize = byteSize || buffer.byteLength - byteOffset;
        }
        return {
          buffer,
          byteOffset,
          byteSize
        };
      }
      _getVaryingInfo(locationOrName) {
        return this.configuration && this.configuration.getVaryingInfo(locationOrName);
      }
      _getVaryingIndex(locationOrName) {
        if (this.configuration) {
          return this.configuration.getVaryingInfo(locationOrName).location;
        }
        const location = Number(locationOrName);
        return Number.isFinite(location) ? location : -1;
      }
      _bindBuffers() {
        if (this.bindOnUse) {
          for (const bufferIndex in this.buffers) {
            const {
              buffer,
              byteSize,
              byteOffset
            } = this._getBufferParams(this.buffers[bufferIndex]);
            this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
          }
        }
      }
      _unbindBuffers() {
        if (this.bindOnUse) {
          for (const bufferIndex in this.buffers) {
            this._bindBuffer(bufferIndex, null);
          }
        }
      }
      _bindBuffer(index, buffer) {
        let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        let byteSize = arguments.length > 3 ? arguments[3] : void 0;
        const handle = buffer && buffer.handle;
        if (!handle || byteSize === void 0) {
          this.gl.bindBufferBase(35982, index, handle);
        } else {
          this.gl.bindBufferRange(35982, index, handle, byteOffset, byteSize);
        }
        return this;
      }
      _createHandle() {
        return this.gl.createTransformFeedback();
      }
      _deleteHandle() {
        this.gl.deleteTransformFeedback(this.handle);
      }
      _bindHandle(handle) {
        this.gl.bindTransformFeedback(36386, this.handle);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}
function getScratchArray(Type, length5) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length5);
  return new Type(scratchArrayBuffer, 0, length5);
}
function fillArray(_ref) {
  let {
    target,
    source,
    start = 0,
    count: count4 = 1
  } = _ref;
  const length5 = source.length;
  const total = count4 * length5;
  let copied = 0;
  for (let i = start; copied < length5; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
var arrayBuffer;
var init_array_utils_flat = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js"() {
    arrayBuffer = null;
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
var ERR_ELEMENTS, VertexArrayObject;
var init_vertex_array_object = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js"() {
    init_resource();
    init_buffer();
    init_esm9();
    init_array_utils_flat();
    init_assert7();
    init_esm6();
    ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
    VertexArrayObject = class _VertexArrayObject extends Resource {
      get [Symbol.toStringTag]() {
        return "VertexArrayObject";
      }
      static isSupported(gl) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (options.constantAttributeZero) {
          return isWebGL2(gl) || getBrowser() === "Chrome";
        }
        return true;
      }
      static getDefaultArray(gl) {
        gl.luma = gl.luma || {};
        if (!gl.luma.defaultVertexArray) {
          gl.luma.defaultVertexArray = new _VertexArrayObject(gl, {
            handle: null,
            isDefaultArray: true
          });
        }
        return gl.luma.defaultVertexArray;
      }
      static getMaxAttributes(gl) {
        _VertexArrayObject.MAX_ATTRIBUTES = _VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
        return _VertexArrayObject.MAX_ATTRIBUTES;
      }
      static setConstant(gl, location, array) {
        switch (array.constructor) {
          case Float32Array:
            _VertexArrayObject._setConstantFloatArray(gl, location, array);
            break;
          case Int32Array:
            _VertexArrayObject._setConstantIntArray(gl, location, array);
            break;
          case Uint32Array:
            _VertexArrayObject._setConstantUintArray(gl, location, array);
            break;
          default:
            assert7(false);
        }
      }
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        super(gl, Object.assign({}, opts, {
          id
        }));
        this.buffer = null;
        this.bufferValue = null;
        this.isDefaultArray = opts.isDefaultArray || false;
        this.gl2 = gl;
        this.initialize(opts);
        Object.seal(this);
      }
      delete() {
        super.delete();
        if (this.buffer) {
          this.buffer.delete();
        }
        return this;
      }
      get MAX_ATTRIBUTES() {
        return _VertexArrayObject.getMaxAttributes(this.gl);
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return this.setProps(props);
      }
      setProps(props) {
        return this;
      }
      setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        assert7(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
        this.bind(() => {
          this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
        });
        return this;
      }
      setBuffer(location, buffer, accessor) {
        if (buffer.target === 34963) {
          return this.setElementBuffer(buffer, accessor);
        }
        const {
          size,
          type,
          stride,
          offset,
          normalized,
          integer,
          divisor
        } = accessor;
        const {
          gl,
          gl2
        } = this;
        location = Number(location);
        this.bind(() => {
          gl.bindBuffer(34962, buffer.handle);
          if (integer) {
            assert7(isWebGL2(gl));
            gl2.vertexAttribIPointer(location, size, type, stride, offset);
          } else {
            gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
          }
          gl.enableVertexAttribArray(location);
          gl2.vertexAttribDivisor(location, divisor || 0);
        });
        return this;
      }
      enable(location) {
        let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        const disablingAttributeZero = !enable2 && location === 0 && !_VertexArrayObject.isSupported(this.gl, {
          constantAttributeZero: true
        });
        if (!disablingAttributeZero) {
          location = Number(location);
          this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location) : this.gl.disableVertexAttribArray(location));
        }
        return this;
      }
      getConstantBuffer(elementCount, value4) {
        const constantValue = this._normalizeConstantArrayValue(value4);
        const byteLength = constantValue.byteLength * elementCount;
        const length5 = constantValue.length * elementCount;
        let updateNeeded = !this.buffer;
        this.buffer = this.buffer || new Buffer(this.gl, byteLength);
        updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
        updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
        if (updateNeeded) {
          const typedArray = getScratchArray(value4.constructor, length5);
          fillArray({
            target: typedArray,
            source: constantValue,
            start: 0,
            count: length5
          });
          this.buffer.subData(typedArray);
          this.bufferValue = value4;
        }
        return this.buffer;
      }
      _normalizeConstantArrayValue(arrayValue) {
        if (Array.isArray(arrayValue)) {
          return new Float32Array(arrayValue);
        }
        return arrayValue;
      }
      _compareConstantArrayValues(v1, v2) {
        if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
          return false;
        }
        for (let i = 0; i < v1.length; ++i) {
          if (v1[i] !== v2[i]) {
            return false;
          }
        }
        return true;
      }
      static _setConstantFloatArray(gl, location, array) {
        switch (array.length) {
          case 1:
            gl.vertexAttrib1fv(location, array);
            break;
          case 2:
            gl.vertexAttrib2fv(location, array);
            break;
          case 3:
            gl.vertexAttrib3fv(location, array);
            break;
          case 4:
            gl.vertexAttrib4fv(location, array);
            break;
          default:
            assert7(false);
        }
      }
      static _setConstantIntArray(gl, location, array) {
        assert7(isWebGL2(gl));
        switch (array.length) {
          case 1:
            gl.vertexAttribI1iv(location, array);
            break;
          case 2:
            gl.vertexAttribI2iv(location, array);
            break;
          case 3:
            gl.vertexAttribI3iv(location, array);
            break;
          case 4:
            gl.vertexAttribI4iv(location, array);
            break;
          default:
            assert7(false);
        }
      }
      static _setConstantUintArray(gl, location, array) {
        assert7(isWebGL2(gl));
        switch (array.length) {
          case 1:
            gl.vertexAttribI1uiv(location, array);
            break;
          case 2:
            gl.vertexAttribI2uiv(location, array);
            break;
          case 3:
            gl.vertexAttribI3uiv(location, array);
            break;
          case 4:
            gl.vertexAttribI4uiv(location, array);
            break;
          default:
            assert7(false);
        }
      }
      _createHandle() {
        const gl2 = this.gl;
        return gl2.createVertexArray();
      }
      _deleteHandle(handle) {
        this.gl2.deleteVertexArray(handle);
        return [this.elements];
      }
      _bindHandle(handle) {
        this.gl2.bindVertexArray(handle);
      }
      _getParameter(pname, _ref) {
        let {
          location
        } = _ref;
        assert7(Number.isFinite(location));
        return this.bind(() => {
          switch (pname) {
            case 34373:
              return this.gl.getVertexAttribOffset(location, pname);
            default:
              return this.gl.getVertexAttrib(location, pname);
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
var ERR_ATTRIBUTE_TYPE, MULTI_LOCATION_ATTRIBUTE_REGEXP, DEPRECATIONS_V6, VertexArray;
var init_vertex_array = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js"() {
    init_esm9();
    init_accessor();
    init_buffer();
    init_vertex_array_object();
    init_assert7();
    init_stub_methods();
    ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
    MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
    DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
    VertexArray = class {
      constructor(gl) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const id = opts.id || opts.program && opts.program.id;
        this.id = id;
        this.gl = gl;
        this.configuration = null;
        this.elements = null;
        this.elementsAccessor = null;
        this.values = null;
        this.accessors = null;
        this.unused = null;
        this.drawParams = null;
        this.buffer = null;
        this.attributes = {};
        this.vertexArrayObject = new VertexArrayObject(gl);
        stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
        this.initialize(opts);
        Object.seal(this);
      }
      delete() {
        if (this.buffer) {
          this.buffer.delete();
        }
        this.vertexArrayObject.delete();
      }
      initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.reset();
        this.configuration = null;
        this.bindOnUse = false;
        return this.setProps(props);
      }
      reset() {
        this.elements = null;
        this.elementsAccessor = null;
        const {
          MAX_ATTRIBUTES
        } = this.vertexArrayObject;
        this.values = new Array(MAX_ATTRIBUTES).fill(null);
        this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
        this.unused = {};
        this.drawParams = null;
        return this;
      }
      setProps(props) {
        if ("program" in props) {
          this.configuration = props.program && props.program.configuration;
        }
        if ("configuration" in props) {
          this.configuration = props.configuration;
        }
        if ("attributes" in props) {
          this.setAttributes(props.attributes);
        }
        if ("elements" in props) {
          this.setElementBuffer(props.elements);
        }
        if ("bindOnUse" in props) {
          props = props.bindOnUse;
        }
        return this;
      }
      clearDrawParams() {
        this.drawParams = null;
      }
      getDrawParams() {
        this.drawParams = this.drawParams || this._updateDrawParams();
        return this.drawParams;
      }
      setAttributes(attributes) {
        Object.assign(this.attributes, attributes);
        this.vertexArrayObject.bind(() => {
          for (const locationOrName in attributes) {
            const value4 = attributes[locationOrName];
            this._setAttribute(locationOrName, value4);
          }
          this.gl.bindBuffer(34962, null);
        });
        return this;
      }
      setElementBuffer() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.elements = elementBuffer;
        this.elementsAccessor = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
        return this;
      }
      setBuffer(locationOrName, buffer) {
        let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (buffer.target === 34963) {
          return this.setElementBuffer(buffer, appAccessor);
        }
        const {
          location,
          accessor
        } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
        if (location >= 0) {
          this.values[location] = buffer;
          this.accessors[location] = accessor;
          this.clearDrawParams();
          this.vertexArrayObject.setBuffer(location, buffer, accessor);
        }
        return this;
      }
      setConstant(locationOrName, arrayValue) {
        let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const {
          location,
          accessor
        } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
          size: arrayValue.length
        }, appAccessor));
        if (location >= 0) {
          arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
          this.values[location] = arrayValue;
          this.accessors[location] = accessor;
          this.clearDrawParams();
          this.vertexArrayObject.enable(location, false);
        }
        return this;
      }
      unbindBuffers() {
        this.vertexArrayObject.bind(() => {
          if (this.elements) {
            this.vertexArrayObject.setElementBuffer(null);
          }
          this.buffer = this.buffer || new Buffer(this.gl, {
            accessor: {
              size: 4
            }
          });
          for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
            if (this.values[location] instanceof Buffer) {
              this.gl.disableVertexAttribArray(location);
              this.gl.bindBuffer(34962, this.buffer.handle);
              this.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);
            }
          }
        });
        return this;
      }
      bindBuffers() {
        this.vertexArrayObject.bind(() => {
          if (this.elements) {
            this.setElementBuffer(this.elements);
          }
          for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
            const buffer = this.values[location];
            if (buffer instanceof Buffer) {
              this.setBuffer(location, buffer);
            }
          }
        });
        return this;
      }
      bindForDraw(vertexCount, instanceCount, func) {
        let value4;
        this.vertexArrayObject.bind(() => {
          this._setConstantAttributes(vertexCount, instanceCount);
          value4 = func();
        });
        return value4;
      }
      _resolveLocationAndAccessor(locationOrName, value4, valueAccessor, appAccessor) {
        const INVALID_RESULT = {
          location: -1,
          accessor: null
        };
        const {
          location,
          name
        } = this._getAttributeIndex(locationOrName);
        if (!Number.isFinite(location) || location < 0) {
          this.unused[locationOrName] = value4;
          log.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
          return INVALID_RESULT;
        }
        const accessInfo = this._getAttributeInfo(name || location);
        if (!accessInfo) {
          return INVALID_RESULT;
        }
        const currentAccessor = this.accessors[location] || {};
        const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
        const {
          size,
          type
        } = accessor;
        assert7(Number.isFinite(size) && Number.isFinite(type));
        return {
          location,
          accessor
        };
      }
      _getAttributeInfo(attributeName) {
        return this.configuration && this.configuration.getAttributeInfo(attributeName);
      }
      _getAttributeIndex(locationOrName) {
        const location = Number(locationOrName);
        if (Number.isFinite(location)) {
          return {
            location
          };
        }
        const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
        const name = multiLocation ? multiLocation[1] : locationOrName;
        const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
        if (this.configuration) {
          return {
            location: this.configuration.getAttributeLocation(name) + locationOffset,
            name
          };
        }
        return {
          location: -1
        };
      }
      _setAttribute(locationOrName, value4) {
        if (value4 instanceof Buffer) {
          this.setBuffer(locationOrName, value4);
        } else if (Array.isArray(value4) && value4.length && value4[0] instanceof Buffer) {
          const buffer = value4[0];
          const accessor = value4[1];
          this.setBuffer(locationOrName, buffer, accessor);
        } else if (ArrayBuffer.isView(value4) || Array.isArray(value4)) {
          const constant = value4;
          this.setConstant(locationOrName, constant);
        } else if (value4.buffer instanceof Buffer) {
          const accessor = value4;
          this.setBuffer(locationOrName, accessor.buffer, accessor);
        } else {
          throw new Error(ERR_ATTRIBUTE_TYPE);
        }
      }
      _setConstantAttributes(vertexCount, instanceCount) {
        const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
        let constant = this.values[0];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttributeZero(constant, elementCount);
        }
        for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          constant = this.values[location];
          if (ArrayBuffer.isView(constant)) {
            this._setConstantAttribute(location, constant);
          }
        }
      }
      _setConstantAttributeZero(constant, elementCount) {
        if (VertexArrayObject.isSupported(this.gl, {
          constantAttributeZero: true
        })) {
          this._setConstantAttribute(0, constant);
          return;
        }
        const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
        this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
      }
      _setConstantAttribute(location, constant) {
        VertexArrayObject.setConstant(this.gl, location, constant);
      }
      _updateDrawParams() {
        const drawParams = {
          isIndexed: false,
          isInstanced: false,
          indexCount: Infinity,
          vertexCount: Infinity,
          instanceCount: Infinity
        };
        for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
          this._updateDrawParamsForLocation(drawParams, location);
        }
        if (this.elements) {
          drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
          drawParams.isIndexed = true;
          drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
          drawParams.indexOffset = this.elementsAccessor.offset || 0;
        }
        if (drawParams.indexCount === Infinity) {
          drawParams.indexCount = 0;
        }
        if (drawParams.vertexCount === Infinity) {
          drawParams.vertexCount = 0;
        }
        if (drawParams.instanceCount === Infinity) {
          drawParams.instanceCount = 0;
        }
        return drawParams;
      }
      _updateDrawParamsForLocation(drawParams, location) {
        const value4 = this.values[location];
        const accessor = this.accessors[location];
        if (!value4) {
          return;
        }
        const {
          divisor
        } = accessor;
        const isInstanced = divisor > 0;
        drawParams.isInstanced = drawParams.isInstanced || isInstanced;
        if (value4 instanceof Buffer) {
          const buffer = value4;
          if (isInstanced) {
            const instanceCount = buffer.getVertexCount(accessor);
            drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
          } else {
            const vertexCount = buffer.getVertexCount(accessor);
            drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
          }
        }
      }
      setElements() {
        let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        log.deprecated("setElements", "setElementBuffer")();
        return this.setElementBuffer(elementBuffer, accessor);
      }
    };
  }
});

// node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js
var init_uniform_buffer_layout = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/classes/uniform-buffer-layout.js"() {
    init_attribute_utils();
    init_assert7();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
function formatArrayValue(v, opts) {
  const {
    maxElts = 16,
    size = 1
  } = opts;
  let string = "[";
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? " " : "");
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? "..." : "]";
  return "".concat(string).concat(terminator);
}
function formatValue(v) {
  let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const EPSILON5 = 1e-16;
  const {
    isInteger = false
  } = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON5) {
    return isInteger ? "0" : "0.";
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf(".0");
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}
var init_format_value = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js"() {
  }
});

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
function getDebugTableForUniforms(_ref) {
  let {
    header = "Uniforms",
    program,
    uniforms: uniforms3,
    undefinedOnly = false
  } = _ref;
  assert7(program);
  const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
  const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
  const uniformLocations = program._uniformSetters;
  const table = {};
  const uniformNames = Object.keys(uniformLocations).sort();
  let count4 = 0;
  for (const uniformName of uniformNames) {
    if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms: uniforms3,
        uniformName,
        undefinedOnly
      })) {
        count4++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({
        table,
        header,
        uniforms: uniforms3,
        uniformName,
        undefinedOnly
      })) {
        count4++;
      }
    }
  }
  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({
        table,
        header,
        uniforms: uniforms3,
        uniformName,
        undefinedOnly
      })) {
        count4++;
      }
    }
  }
  let unusedCount = 0;
  const unusedTable = {};
  if (!undefinedOnly) {
    for (const uniformName in uniforms3) {
      const uniform = uniforms3[uniformName];
      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: "NOT USED: ".concat(uniform),
          [header]: formatValue(uniform)
        };
      }
    }
  }
  return {
    table,
    count: count4,
    unusedTable,
    unusedCount
  };
}
function addUniformToTable(_ref2) {
  let {
    table,
    header,
    uniforms: uniforms3,
    uniformName,
    undefinedOnly
  } = _ref2;
  const value4 = uniforms3[uniformName];
  const isDefined = isUniformDefined(value4);
  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      [header]: isDefined ? formatValue(value4) : "N/A",
      "Uniform Type": isDefined ? value4 : "NOT PROVIDED"
    };
    return true;
  }
  return false;
}
function isUniformDefined(value4) {
  return value4 !== void 0 && value4 !== null;
}
var init_debug_uniforms = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js"() {
    init_assert7();
    init_format_value();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
function getDebugTableForVertexArray(_ref) {
  let {
    vertexArray,
    header = "Attributes"
  } = _ref;
  if (!vertexArray.configuration) {
    return {};
  }
  const table = {};
  if (vertexArray.elements) {
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }
  const attributes = vertexArray.values;
  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);
    if (info) {
      let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
      const accessor = vertexArray.accessors[info.location];
      if (accessor) {
        rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
      }
      table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
    }
  }
  return table;
}
function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {
    gl
  } = vertexArray;
  if (!attribute) {
    return {
      [header]: "null",
      "Format ": "N/A"
    };
  }
  let type = "NOT PROVIDED";
  let size = 1;
  let verts = 0;
  let bytes = 0;
  let isInteger;
  let marker;
  let value4;
  if (accessor) {
    type = accessor.type;
    size = accessor.size;
    type = String(type).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
  }
  if (attribute instanceof Buffer) {
    const buffer = attribute;
    const {
      data,
      changed
    } = buffer.getDebugData();
    marker = changed ? "*" : "";
    value4 = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;
    let format;
    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
    } else {
      isInteger = true;
      format = "".concat(bytes, " bytes");
    }
    return {
      [header]: "".concat(marker).concat(formatValue(value4, {
        size,
        isInteger
      })),
      "Format ": format
    };
  }
  value4 = attribute;
  size = attribute.length;
  type = String(attribute.constructor.name).replace("Array", "");
  isInteger = type.indexOf("nt") !== -1;
  return {
    [header]: "".concat(formatValue(value4, {
      size,
      isInteger
    }), " (constant)"),
    "Format ": "".concat(size, "x").concat(type, " (constant)")
  };
}
function getGLSLDeclaration(name, accessor) {
  const {
    type,
    size
  } = accessor;
  const typeAndName = getCompositeGLType(type, size);
  return typeAndName ? "".concat(name, " (").concat(typeAndName.name, ")") : name;
}
var init_debug_vertex_array = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js"() {
    init_buffer();
    init_constants_to_keys();
    init_attribute_utils();
    init_format_value();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
function getDebugTableForProgramConfiguration(config2) {
  const table = {};
  const header = "Accessors for ".concat(config2.id);
  for (const attributeInfo of config2.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration2(attributeInfo);
      table["in ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(attributeInfo.accessor)
      };
    }
  }
  for (const varyingInfo of config2.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration2(varyingInfo);
      table["out ".concat(glslDeclaration)] = {
        [header]: JSON.stringify(varyingInfo.accessor)
      };
    }
  }
  return table;
}
function getGLSLDeclaration2(attributeInfo) {
  const {
    type,
    size
  } = attributeInfo.accessor;
  const typeAndName = getCompositeGLType(type, size);
  if (typeAndName) {
    return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
  }
  return attributeInfo.name;
}
var init_debug_program_configuration = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js"() {
    init_attribute_utils();
  }
});

// node_modules/@luma.gl/webgl/dist/esm/index.js
var init_esm10 = __esm({
  "node_modules/@luma.gl/webgl/dist/esm/index.js"() {
    init_init4();
    init_request_animation_frame();
    init_texture_utils();
    init_constants_to_keys();
    init_limits();
    init_webgl_features_table();
    init_features();
    init_check_glsl_extension();
    init_accessor();
    init_buffer();
    init_shader();
    init_program();
    init_framebuffer();
    init_renderbuffer();
    init_texture_2d();
    init_texture_cube();
    init_clear();
    init_copy_and_blit();
    init_query();
    init_texture_3d();
    init_transform_feedback();
    init_vertex_array_object();
    init_vertex_array();
    init_uniform_buffer_layout();
    init_load_file();
    init_get_shader_name();
    init_get_shader_version();
    init_esm9();
    init_assert7();
    init_utils2();
    init_uniforms();
    init_debug_uniforms();
    init_debug_vertex_array();
    init_debug_program_configuration();
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
var isPage2, statIdCounter, AnimationLoop;
var init_animation_loop = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js"() {
    init_esm9();
    init_esm10();
    init_esm6();
    isPage2 = isBrowser4() && typeof document !== "undefined";
    statIdCounter = 0;
    AnimationLoop = class {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          onCreateContext = (opts) => createGLContext(opts),
          onAddHTML = null,
          onInitialize = () => {
          },
          onRender = () => {
          },
          onFinalize = () => {
          },
          onError,
          gl = null,
          glOptions = {},
          debug: debug2 = false,
          createFramebuffer = false,
          autoResizeViewport = true,
          autoResizeDrawingBuffer = true,
          stats = lumaStats.get("animation-loop-".concat(statIdCounter++))
        } = props;
        let {
          useDevicePixels = true
        } = props;
        if ("useDevicePixelRatio" in props) {
          log.deprecated("useDevicePixelRatio", "useDevicePixels")();
          useDevicePixels = props.useDevicePixelRatio;
        }
        this.props = {
          onCreateContext,
          onAddHTML,
          onInitialize,
          onRender,
          onFinalize,
          onError,
          gl,
          glOptions,
          debug: debug2,
          createFramebuffer
        };
        this.gl = gl;
        this.needsRedraw = null;
        this.timeline = null;
        this.stats = stats;
        this.cpuTime = this.stats.get("CPU Time");
        this.gpuTime = this.stats.get("GPU Time");
        this.frameRate = this.stats.get("Frame Rate");
        this._initialized = false;
        this._running = false;
        this._animationFrameId = null;
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._cpuStartTime = 0;
        this.setProps({
          autoResizeViewport,
          autoResizeDrawingBuffer,
          useDevicePixels
        });
        this.start = this.start.bind(this);
        this.stop = this.stop.bind(this);
        this._pageLoadPromise = null;
        this._onMousemove = this._onMousemove.bind(this);
        this._onMouseleave = this._onMouseleave.bind(this);
      }
      delete() {
        this.stop();
        this._setDisplay(null);
      }
      setNeedsRedraw(reason) {
        assert7(typeof reason === "string");
        this.needsRedraw = this.needsRedraw || reason;
        return this;
      }
      setProps(props) {
        if ("autoResizeViewport" in props) {
          this.autoResizeViewport = props.autoResizeViewport;
        }
        if ("autoResizeDrawingBuffer" in props) {
          this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
        }
        if ("useDevicePixels" in props) {
          this.useDevicePixels = props.useDevicePixels;
        }
        return this;
      }
      start() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this._running) {
          return this;
        }
        this._running = true;
        const startPromise = this._getPageLoadPromise().then(() => {
          if (!this._running || this._initialized) {
            return null;
          }
          this._createWebGLContext(opts);
          this._createFramebuffer();
          this._startEventHandling();
          this._initializeCallbackData();
          this._updateCallbackData();
          this._resizeCanvasDrawingBuffer();
          this._resizeViewport();
          this._gpuTimeQuery = Query.isSupported(this.gl, ["timers"]) ? new Query(this.gl) : null;
          this._initialized = true;
          return this.onInitialize(this.animationProps);
        }).then((appContext) => {
          if (this._running) {
            this._addCallbackData(appContext || {});
            if (appContext !== false) {
              this._startLoop();
            }
          }
        });
        if (this.props.onError) {
          startPromise.catch(this.props.onError);
        }
        return this;
      }
      redraw() {
        if (this.isContextLost()) {
          return this;
        }
        this._beginTimers();
        this._setupFrame();
        this._updateCallbackData();
        this._renderFrame(this.animationProps);
        this._clearNeedsRedraw();
        if (this.offScreen && this.gl.commit) {
          this.gl.commit();
        }
        if (this._resolveNextFrame) {
          this._resolveNextFrame(this);
          this._nextFramePromise = null;
          this._resolveNextFrame = null;
        }
        this._endTimers();
        return this;
      }
      stop() {
        if (this._running) {
          this._finalizeCallbackData();
          this._cancelAnimationFrame(this._animationFrameId);
          this._nextFramePromise = null;
          this._resolveNextFrame = null;
          this._animationFrameId = null;
          this._running = false;
        }
        return this;
      }
      attachTimeline(timeline) {
        this.timeline = timeline;
        return this.timeline;
      }
      detachTimeline() {
        this.timeline = null;
      }
      waitForRender() {
        this.setNeedsRedraw("waitForRender");
        if (!this._nextFramePromise) {
          this._nextFramePromise = new Promise((resolve) => {
            this._resolveNextFrame = resolve;
          });
        }
        return this._nextFramePromise;
      }
      async toDataURL() {
        this.setNeedsRedraw("toDataURL");
        await this.waitForRender();
        return this.gl.canvas.toDataURL();
      }
      isContextLost() {
        return this.gl.isContextLost();
      }
      onCreateContext() {
        return this.props.onCreateContext(...arguments);
      }
      onInitialize() {
        return this.props.onInitialize(...arguments);
      }
      onRender() {
        return this.props.onRender(...arguments);
      }
      onFinalize() {
        return this.props.onFinalize(...arguments);
      }
      getHTMLControlValue(id) {
        let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        const element = document.getElementById(id);
        return element ? Number(element.value) : defaultValue;
      }
      setViewParameters() {
        log.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
        return this;
      }
      _startLoop() {
        const renderFrame = () => {
          if (!this._running) {
            return;
          }
          this.redraw();
          this._animationFrameId = this._requestAnimationFrame(renderFrame);
        };
        this._cancelAnimationFrame(this._animationFrameId);
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
      }
      _getPageLoadPromise() {
        if (!this._pageLoadPromise) {
          this._pageLoadPromise = isPage2 ? new Promise((resolve, reject) => {
            if (isPage2 && document.readyState === "complete") {
              resolve(document);
              return;
            }
            window.addEventListener("load", () => {
              resolve(document);
            });
          }) : Promise.resolve({});
        }
        return this._pageLoadPromise;
      }
      _setDisplay(display) {
        if (this.display) {
          this.display.delete();
          this.display.animationLoop = null;
        }
        if (display) {
          display.animationLoop = this;
        }
        this.display = display;
      }
      _cancelAnimationFrame(animationFrameId) {
        if (this.display && this.display.cancelAnimationFrame) {
          return this.display.cancelAnimationFrame(animationFrameId);
        }
        return cancelAnimationFrame(animationFrameId);
      }
      _requestAnimationFrame(renderFrameCallback) {
        if (this._running) {
          if (this.display && this.display.requestAnimationFrame) {
            return this.display.requestAnimationFrame(renderFrameCallback);
          }
          return requestAnimationFrame2(renderFrameCallback);
        }
        return void 0;
      }
      _renderFrame() {
        if (this.display) {
          this.display._renderFrame(...arguments);
          return;
        }
        this.onRender(...arguments);
      }
      _clearNeedsRedraw() {
        this.needsRedraw = null;
      }
      _setupFrame() {
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._resizeFramebuffer();
      }
      _initializeCallbackData() {
        this.animationProps = {
          gl: this.gl,
          stop: this.stop,
          canvas: this.gl.canvas,
          framebuffer: this.framebuffer,
          useDevicePixels: this.useDevicePixels,
          needsRedraw: null,
          startTime: Date.now(),
          engineTime: 0,
          tick: 0,
          tock: 0,
          time: 0,
          _timeline: this.timeline,
          _loop: this,
          _animationLoop: this,
          _mousePosition: null
        };
      }
      _updateCallbackData() {
        const {
          width,
          height,
          aspect
        } = this._getSizeAndAspect();
        if (width !== this.animationProps.width || height !== this.animationProps.height) {
          this.setNeedsRedraw("drawing buffer resized");
        }
        if (aspect !== this.animationProps.aspect) {
          this.setNeedsRedraw("drawing buffer aspect changed");
        }
        this.animationProps.width = width;
        this.animationProps.height = height;
        this.animationProps.aspect = aspect;
        this.animationProps.needsRedraw = this.needsRedraw;
        this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
        if (this.timeline) {
          this.timeline.update(this.animationProps.engineTime);
        }
        this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
        this.animationProps.tock++;
        this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
        this.animationProps._offScreen = this.offScreen;
      }
      _finalizeCallbackData() {
        this.onFinalize(this.animationProps);
      }
      _addCallbackData(appContext) {
        if (typeof appContext === "object" && appContext !== null) {
          this.animationProps = Object.assign({}, this.animationProps, appContext);
        }
      }
      _createWebGLContext(opts) {
        this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
        opts = Object.assign({}, opts, this.props.glOptions);
        this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
        if (!isWebGL(this.gl)) {
          throw new Error("AnimationLoop.onCreateContext - illegal context returned");
        }
        resetParameters(this.gl);
        this._createInfoDiv();
      }
      _createInfoDiv() {
        if (this.gl.canvas && this.props.onAddHTML) {
          const wrapperDiv = document.createElement("div");
          document.body.appendChild(wrapperDiv);
          wrapperDiv.style.position = "relative";
          const div = document.createElement("div");
          div.style.position = "absolute";
          div.style.left = "10px";
          div.style.bottom = "10px";
          div.style.width = "300px";
          div.style.background = "white";
          wrapperDiv.appendChild(this.gl.canvas);
          wrapperDiv.appendChild(div);
          const html = this.props.onAddHTML(div);
          if (html) {
            div.innerHTML = html;
          }
        }
      }
      _getSizeAndAspect() {
        const width = this.gl.drawingBufferWidth;
        const height = this.gl.drawingBufferHeight;
        let aspect = 1;
        const {
          canvas
        } = this.gl;
        if (canvas && canvas.clientHeight) {
          aspect = canvas.clientWidth / canvas.clientHeight;
        } else if (width > 0 && height > 0) {
          aspect = width / height;
        }
        return {
          width,
          height,
          aspect
        };
      }
      _resizeViewport() {
        if (this.autoResizeViewport) {
          this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        }
      }
      _resizeCanvasDrawingBuffer() {
        if (this.autoResizeDrawingBuffer) {
          resizeGLContext(this.gl, {
            useDevicePixels: this.useDevicePixels
          });
        }
      }
      _createFramebuffer() {
        if (this.props.createFramebuffer) {
          this.framebuffer = new Framebuffer(this.gl);
        }
      }
      _resizeFramebuffer() {
        if (this.framebuffer) {
          this.framebuffer.resize({
            width: this.gl.drawingBufferWidth,
            height: this.gl.drawingBufferHeight
          });
        }
      }
      _beginTimers() {
        this.frameRate.timeEnd();
        this.frameRate.timeStart();
        if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
          this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
        }
        if (this._gpuTimeQuery) {
          this._gpuTimeQuery.beginTimeElapsedQuery();
        }
        this.cpuTime.timeStart();
      }
      _endTimers() {
        this.cpuTime.timeEnd();
        if (this._gpuTimeQuery) {
          this._gpuTimeQuery.end();
        }
      }
      _startEventHandling() {
        const {
          canvas
        } = this.gl;
        if (canvas) {
          canvas.addEventListener("mousemove", this._onMousemove);
          canvas.addEventListener("mouseleave", this._onMouseleave);
        }
      }
      _onMousemove(e2) {
        this.animationProps._mousePosition = [e2.offsetX, e2.offsetY];
      }
      _onMouseleave(e2) {
        this.animationProps._mousePosition = null;
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
var VERTEX_SHADER, FRAGMENT_SHADER;
var init_constants = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js"() {
    VERTEX_SHADER = "vs";
    FRAGMENT_SHADER = "fs";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
function assert8(condition, message) {
  if (!condition) {
    throw new Error(message || "shadertools: assertion failed.");
  }
}
var init_assert8 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/index.js
var init_utils3 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/index.js"() {
    init_assert8();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
function parsePropTypes(propDefs) {
  const propTypes = {};
  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }
  return propTypes;
}
function parsePropType(propDef) {
  let type = getTypeOf(propDef);
  if (type === "object") {
    if (!propDef) {
      return {
        type: "object",
        value: null
      };
    }
    if ("type" in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }
    if (!("value" in propDef)) {
      return {
        type: "object",
        value: propDef
      };
    }
    type = getTypeOf(propDef.value);
    return Object.assign({
      type
    }, propDef, TYPE_DEFINITIONS[type]);
  }
  return Object.assign({
    type,
    value: propDef
  }, TYPE_DEFINITIONS[type]);
}
function getTypeOf(value4) {
  if (Array.isArray(value4) || ArrayBuffer.isView(value4)) {
    return "array";
  }
  return typeof value4;
}
var TYPE_DEFINITIONS;
var init_prop_types = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js"() {
    TYPE_DEFINITIONS = {
      number: {
        validate(value4, propType) {
          return Number.isFinite(value4) && (!("max" in propType) || value4 <= propType.max) && (!("min" in propType) || value4 >= propType.min);
        }
      },
      array: {
        validate(value4, propType) {
          return Array.isArray(value4) || ArrayBuffer.isView(value4);
        }
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;
    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }
  return module;
}
function normalizeInjections(injections) {
  const result = {
    vs: {},
    fs: {}
  };
  for (const hook in injections) {
    let injection = injections[hook];
    const stage = hook.slice(0, 2);
    if (typeof injection === "string") {
      injection = {
        order: 0,
        injection
      };
    }
    result[stage][hook] = injection;
  }
  return result;
}
var VERTEX_SHADER2, FRAGMENT_SHADER2, ShaderModule;
var init_shader_module = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js"() {
    init_utils3();
    init_prop_types();
    VERTEX_SHADER2 = "vs";
    FRAGMENT_SHADER2 = "fs";
    ShaderModule = class {
      constructor(_ref) {
        let {
          name,
          vs: vs9,
          fs: fs6,
          dependencies = [],
          uniforms: uniforms3,
          getUniforms: getUniforms9,
          deprecations = [],
          defines = {},
          inject = {},
          vertexShader,
          fragmentShader
        } = _ref;
        assert8(typeof name === "string");
        this.name = name;
        this.vs = vs9 || vertexShader;
        this.fs = fs6 || fragmentShader;
        this.getModuleUniforms = getUniforms9;
        this.dependencies = dependencies;
        this.deprecations = this._parseDeprecationDefinitions(deprecations);
        this.defines = defines;
        this.injections = normalizeInjections(inject);
        if (uniforms3) {
          this.uniforms = parsePropTypes(uniforms3);
        }
      }
      getModuleSource(type) {
        let moduleSource;
        switch (type) {
          case VERTEX_SHADER2:
            moduleSource = this.vs || "";
            break;
          case FRAGMENT_SHADER2:
            moduleSource = this.fs || "";
            break;
          default:
            assert8(false);
        }
        return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
      }
      getUniforms(opts, uniforms3) {
        if (this.getModuleUniforms) {
          return this.getModuleUniforms(opts, uniforms3);
        }
        if (this.uniforms) {
          return this._defaultGetUniforms(opts);
        }
        return {};
      }
      getDefines() {
        return this.defines;
      }
      checkDeprecations(shaderSource, log3) {
        this.deprecations.forEach((def) => {
          if (def.regex.test(shaderSource)) {
            if (def.deprecated) {
              log3.deprecated(def.old, def.new)();
            } else {
              log3.removed(def.old, def.new)();
            }
          }
        });
      }
      _parseDeprecationDefinitions(deprecations) {
        deprecations.forEach((def) => {
          switch (def.type) {
            case "function":
              def.regex = new RegExp("\\b".concat(def.old, "\\("));
              break;
            default:
              def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
          }
        });
        return deprecations;
      }
      _defaultGetUniforms() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const uniforms3 = {};
        const propTypes = this.uniforms;
        for (const key in propTypes) {
          const propDef = propTypes[key];
          if (key in opts && !propDef.private) {
            if (propDef.validate) {
              assert8(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
            }
            uniforms3[key] = opts[key];
          } else {
            uniforms3[key] = propDef.value;
          }
        }
        return uniforms3;
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
function resolveModules(modules) {
  return getShaderDependencies(instantiateModules(modules));
}
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({
    modules,
    level: 0,
    moduleMap,
    moduleDepth
  });
  return Object.keys(moduleDepth).sort((a2, b) => moduleDepth[b] - moduleDepth[a2]).map((name) => moduleMap[name]);
}
function getDependencyGraph(_ref) {
  let {
    modules,
    level,
    moduleMap,
    moduleDepth
  } = _ref;
  if (level >= 5) {
    throw new Error("Possible loop in shader dependency graph");
  }
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({
        modules: module.dependencies,
        level: level + 1,
        moduleMap,
        moduleDepth
      });
    }
  }
}
function instantiateModules(modules, seen) {
  return modules.map((module) => {
    if (module instanceof ShaderModule) {
      return module;
    }
    assert8(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
    assert8(module.name, "shader module has no name");
    module = new ShaderModule(module);
    module.dependencies = instantiateModules(module.dependencies);
    return module;
  });
}
var init_resolve_modules = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js"() {
    init_shader_module();
    init_utils3();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
function isOldIE2() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const navigator2 = typeof window !== "undefined" ? window.navigator || {} : {};
  const userAgent2 = opts.userAgent || navigator2.userAgent || "";
  const isMSIE = userAgent2.indexOf("MSIE ") !== -1;
  const isTrident = userAgent2.indexOf("Trident/") !== -1;
  return isMSIE || isTrident;
}
var init_is_old_ie = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
function isWebGL22(gl) {
  if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
    return true;
  }
  return Boolean(gl && gl._version === 2);
}
function getContextInfo2(gl) {
  const info = gl.getExtension("WEBGL_debug_renderer_info");
  const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
  const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}
function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return "NVIDIA";
  }
  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return "INTEL";
  }
  if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
    return "AMD";
  }
  return "UNKNOWN GPU";
}
function canCompileGLGSExtension2(gl, cap) {
  let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const feature = WEBGL_FEATURES[cap];
  assert8(feature, cap);
  if (!isOldIE2(opts)) {
    return true;
  }
  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }
  const extensionName = feature[0];
  const behavior = opts.behavior || "enable";
  const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
  const shader = gl.createShader(35633);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, 35713);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}
function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  assert8(feature, cap);
  const extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
  const value4 = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
  assert8(value4 === false || value4 === true);
  return value4;
}
function hasFeatures2(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every((feature) => getFeature(gl, feature));
}
var GL_VENDOR, GL_RENDERER, GL_VERSION, GL_SHADING_LANGUAGE_VERSION, WEBGL_FEATURES, FEATURES2, compiledGlslExtensions;
var init_webgl_info = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js"() {
    init_is_old_ie();
    init_assert8();
    GL_VENDOR = 7936;
    GL_RENDERER = 7937;
    GL_VERSION = 7938;
    GL_SHADING_LANGUAGE_VERSION = 35724;
    WEBGL_FEATURES = {
      GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
      GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
      GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
      GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
    };
    FEATURES2 = {};
    Object.keys(WEBGL_FEATURES).forEach((key) => {
      FEATURES2[key] = key;
    });
    compiledGlslExtensions = {};
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
function getPlatformShaderDefines(gl) {
  const debugInfo = getContextInfo2(gl);
  switch (debugInfo.gpuVendor.toLowerCase()) {
    case "nvidia":
      return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
    case "intel":
      return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    case "amd":
      return "#define AMD_GPU\n";
    default:
      return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
  }
}
function getVersionDefines(gl, glslVersion, isFragment) {
  let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
  if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
    versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension2(gl, FEATURES2.GLSL_DERIVATIVES)) {
    versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension2(gl, FEATURES2.GLSL_FRAG_DATA, {
    behavior: "require"
  })) {
    versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
  }
  if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
  }
  return versionDefines;
}
var init_platform_defines = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js"() {
    init_webgl_info();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
var MODULE_INJECTORS_VS, MODULE_INJECTORS_FS;
var init_module_injectors = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js"() {
    MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
    MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
function injectShader(source, type, inject) {
  let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  const isVertex = type === VERTEX_SHADER;
  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a2, b) => a2.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len2 = fragmentData.length; i < len2; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = "".concat(fragments.join("\n"), "\n");
    switch (key) {
      case "vs:#decl":
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "vs:#main-start":
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "vs:#main-end":
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      case "fs:#decl":
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case "fs:#main-start":
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
        }
        break;
      case "fs:#main-end":
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
        }
        break;
      default:
        source = source.replace(key, (match) => match + fragmentString);
    }
  }
  source = source.replace(DECLARATION_INJECT_MARKER, "");
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
  }
  return source;
}
function combineInjects(injects) {
  const result = {};
  assert8(Array.isArray(injects) && injects.length > 1);
  injects.forEach((inject) => {
    for (const key in inject) {
      result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
    }
  });
  return result;
}
var MODULE_INJECTORS, DECLARATION_INJECT_MARKER, REGEX_START_OF_MAIN, REGEX_END_OF_MAIN, fragments;
var init_inject_shader = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js"() {
    init_module_injectors();
    init_constants();
    init_utils3();
    MODULE_INJECTORS = {
      [VERTEX_SHADER]: MODULE_INJECTORS_VS,
      [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
    };
    DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
    REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
    REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
    fragments = [];
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
function testVariable(qualifier) {
  return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
    case 100:
      return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
    default:
      throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
  }
}
function convertShader(source, replacements) {
  for (const [pattern, replacement] of replacements) {
    source = source.replace(pattern, replacement);
  }
  return source;
}
function convertFragmentShaderTo300(source) {
  source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
  } else {
    const outputName = "fragmentColor";
    source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
  }
  return source;
}
function convertFragmentShaderTo100(source) {
  source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
  const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
  if (outputMatch) {
    const outputName = outputMatch[1];
    source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
  }
  return source;
}
var ES300_REPLACEMENTS, ES300_VERTEX_REPLACEMENTS, ES300_FRAGMENT_REPLACEMENTS, ES100_REPLACEMENTS, ES100_VERTEX_REPLACEMENTS, ES100_FRAGMENT_REPLACEMENTS, ES100_FRAGMENT_OUTPUT_NAME, ES300_FRAGMENT_OUTPUT_REGEX, REGEX_START_OF_MAIN2;
var init_transpile_shader = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js"() {
    ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
    ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
    ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
    ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
    ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
    ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
    ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
    ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
    REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
function assembleShaders(gl, opts) {
  const {
    vs: vs9,
    fs: fs6
  } = opts;
  const modules = resolveModules(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {
      source: vs9,
      type: VERTEX_SHADER,
      modules
    })),
    fs: assembleShader(gl, Object.assign({}, opts, {
      source: fs6,
      type: FRAGMENT_SHADER,
      modules
    })),
    getUniforms: assembleGetUniforms(modules)
  };
}
function assembleShader(gl, _ref) {
  let {
    id,
    source,
    type,
    modules,
    defines = {},
    hookFunctions = [],
    inject = {},
    transpileToGLSL100 = false,
    prologue = true,
    log: log3
  } = _ref;
  assert8(typeof source === "string", "shader source must be a string");
  const isVertex = type === VERTEX_SHADER;
  const sourceLines = source.split("\n");
  let glslVersion = 100;
  let versionLine = "";
  let coreSource = source;
  if (sourceLines[0].indexOf("#version ") === 0) {
    glslVersion = 300;
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join("\n");
  } else {
    versionLine = "#version ".concat(glslVersion);
  }
  const allDefines = {};
  modules.forEach((module) => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);
  let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
    id,
    source,
    type
  }), "\n").concat(getShaderType({
    type
  }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
  const hookFunctionMap = normalizeHookFunctions(hookFunctions);
  const hookInjections = {};
  const declInjections = {};
  const mainInjections = {};
  for (const key in inject) {
    const injection = typeof inject[key] === "string" ? {
      injection: inject[key],
      order: 0
    } : inject[key];
    const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (match) {
      const hash = match[2];
      const name = match[3];
      if (hash) {
        if (name === "decl") {
          declInjections[key] = [injection];
        } else {
          mainInjections[key] = [injection];
        }
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      mainInjections[key] = [injection];
    }
  }
  for (const module of modules) {
    if (log3) {
      module.checkDeprecations(coreSource, log3);
    }
    const moduleSource = module.getModuleSource(type, glslVersion);
    assembledSource += moduleSource;
    const injections = module.injections[type];
    for (const key in injections) {
      const match = key.match(/^(v|f)s:#([\w-]+)$/);
      if (match) {
        const name = match[2];
        const injectionType = name === "decl" ? declInjections : mainInjections;
        injectionType[key] = injectionType[key] || [];
        injectionType[key].push(injections[key]);
      } else {
        hookInjections[key] = hookInjections[key] || [];
        hookInjections[key].push(injections[key]);
      }
    }
  }
  assembledSource += INJECT_SHADER_DECLARATIONS;
  assembledSource = injectShader(assembledSource, type, declInjections);
  assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
  assembledSource += coreSource;
  assembledSource = injectShader(assembledSource, type, mainInjections);
  assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
  return assembledSource;
}
function assembleGetUniforms(modules) {
  return function getUniforms9(opts) {
    const uniforms3 = {};
    for (const module of modules) {
      const moduleUniforms = module.getUniforms(opts, uniforms3);
      Object.assign(uniforms3, moduleUniforms);
    }
    return uniforms3;
  };
}
function getShaderType(_ref2) {
  let {
    type
  } = _ref2;
  return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
}
function getShaderName2(_ref3) {
  let {
    id,
    source,
    type
  } = _ref3;
  const injectShaderName = id && typeof id === "string" && source.indexOf("SHADER_NAME") === -1;
  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : "";
}
function getApplicationDefines() {
  let defines = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let count4 = 0;
  let sourceText = "";
  for (const define2 in defines) {
    if (count4 === 0) {
      sourceText += "\n// APPLICATION DEFINES\n";
    }
    count4++;
    const value4 = defines[define2];
    if (value4 || Number.isFinite(value4)) {
      sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines[define2], "\n");
    }
  }
  if (count4 === 0) {
    sourceText += "\n";
  }
  return sourceText;
}
function getHookFunctions(hookFunctions, hookInjections) {
  let result = "";
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += "void ".concat(hookFunction.signature, " {\n");
    if (hookFunction.header) {
      result += "  ".concat(hookFunction.header);
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a2, b) => a2.order - b.order);
      for (const injection of injections) {
        result += "  ".concat(injection.injection, "\n");
      }
    }
    if (hookFunction.footer) {
      result += "  ".concat(hookFunction.footer);
    }
    result += "}\n";
  }
  return result;
}
function normalizeHookFunctions(hookFunctions) {
  const result = {
    vs: {},
    fs: {}
  };
  hookFunctions.forEach((hook) => {
    let opts;
    if (typeof hook !== "string") {
      opts = hook;
      hook = opts.hook;
    } else {
      opts = {};
    }
    hook = hook.trim();
    const [stage, signature] = hook.split(":");
    const name = hook.replace(/\(.+/, "");
    result[stage][name] = Object.assign(opts, {
      signature
    });
  });
  return result;
}
var INJECT_SHADER_DECLARATIONS, SHADER_TYPE, FRAGMENT_SHADER_PROLOGUE;
var init_assemble_shaders = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js"() {
    init_constants();
    init_resolve_modules();
    init_platform_defines();
    init_inject_shader();
    init_transpile_shader();
    init_utils3();
    INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
    SHADER_TYPE = {
      [VERTEX_SHADER]: "vertex",
      [FRAGMENT_SHADER]: "fragment"
    };
    FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, "").split(/\s+/);
  const [qualifier, type, definition] = words;
  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }
  const name = definition.split(";")[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    version: version3 = 100,
    input,
    inputType,
    output
  } = options;
  if (!input) {
    if (version3 === 300) {
      return FS300;
    } else if (version3 > 300) {
      return "#version ".concat(version3, "\n").concat(FS_GLES);
    }
    return FS100;
  }
  const outputValue = convertToVec4(input, inputType);
  if (version3 >= 300) {
    return "#version ".concat(version3, " ").concat(version3 === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }
  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case "float":
      return "x";
    case "vec2":
      return "xy";
    case "vec3":
      return "xyz";
    case "vec4":
      return "xyzw";
    default:
      assert8(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
    default:
      assert8(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case "float":
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
    case "vec2":
      return "vec4(".concat(variable, ", 0.0, 1.0)");
    case "vec3":
      return "vec4(".concat(variable, ", 1.0)");
    case "vec4":
      return variable;
    default:
      assert8(false);
      return null;
  }
}
var FS100, FS_GLES, FS300;
var init_shader_utils = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js"() {
    init_utils3();
    FS100 = "void main() {gl_FragColor = vec4(0);}";
    FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
    FS300 = "#version 300 es\n".concat(FS_GLES);
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js
var init_random = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/utils/random.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
var fp32shader, fp32;
var init_fp32 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js"() {
    fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
    fp32 = {
      name: "fp32",
      vs: fp32shader,
      fs: null
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js
function fp64ify(a2) {
  let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const hiPart = Math.fround(a2);
  const loPart = a2 - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}
function fp64LowPart(a2) {
  return a2 - Math.fround(a2);
}
function fp64ifyMatrix4(matrix) {
  const matrixFP64 = new Float32Array(32);
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}
var init_fp64_utils = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-utils.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js
var fp64_arithmetic_glsl_default;
var init_fp64_arithmetic_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-arithmetic.glsl.js"() {
    fp64_arithmetic_glsl_default = "uniform float ONE;\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js
var fp64_functions_glsl_default;
var init_fp64_functions_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64-functions.glsl.js"() {
    fp64_functions_glsl_default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09);\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09);\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10);\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11);\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12);\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13);\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14);\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15);\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\nvec2 exp_fp64(vec2 a) {\n\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n\n\n\n\n\n  s = sum_fp64(s, t);\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n\n\n\n\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js
function getUniforms() {
  return CONST_UNIFORMS;
}
var CONST_UNIFORMS, fp64arithmetic, fp64;
var init_fp64 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js"() {
    init_fp64_utils();
    init_fp64_arithmetic_glsl();
    init_fp64_functions_glsl();
    CONST_UNIFORMS = {
      ONE: 1
    };
    fp64arithmetic = {
      name: "fp64-arithmetic",
      vs: fp64_arithmetic_glsl_default,
      fs: null,
      getUniforms,
      fp64ify,
      fp64LowPart,
      fp64ifyMatrix4
    };
    fp64 = {
      name: "fp64",
      vs: fp64_functions_glsl_default,
      fs: null,
      dependencies: [fp64arithmetic],
      fp64ify,
      fp64LowPart,
      fp64ifyMatrix4
    };
  }
});

// node_modules/@math.gl/core/dist/esm/lib/assert.js
function assert9(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
var init_assert9 = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/assert.js"() {
  }
});

// node_modules/@math.gl/core/dist/esm/lib/common.js
function formatValue2(value4, {
  precision = config.precision
} = {}) {
  value4 = round(value4);
  return "".concat(parseFloat(value4.toPrecision(precision)));
}
function isArray2(value4) {
  return Array.isArray(value4) || ArrayBuffer.isView(value4) && !(value4 instanceof DataView);
}
function toRadians(degrees2) {
  return radians(degrees2);
}
function toDegrees(radians2) {
  return degrees(radians2);
}
function radians(degrees2, result) {
  return map(degrees2, (degrees3) => degrees3 * DEGREES_TO_RADIANS, result);
}
function degrees(radians2, result) {
  return map(radians2, (radians3) => radians3 * RADIANS_TO_DEGREES, result);
}
function clamp(value4, min, max) {
  return map(value4, (value5) => Math.max(min, Math.min(max, value5)));
}
function lerp(a2, b, t) {
  if (isArray2(a2)) {
    return a2.map((ai, i) => lerp(ai, b[i], t));
  }
  return t * b + (1 - t) * a2;
}
function equals(a2, b, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a2 === b) {
      return true;
    }
    if (isArray2(a2) && isArray2(b)) {
      if (a2.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a2.length; ++i) {
        if (!equals(a2[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a2 && a2.equals) {
      return a2.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a2);
    }
    if (typeof a2 === "number" && typeof b === "number") {
      return Math.abs(a2 - b) <= config.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value4) {
  return Math.round(value4 / config.EPSILON) * config.EPSILON;
}
function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}
function map(value4, func, result) {
  if (isArray2(value4)) {
    const array = value4;
    result = result || duplicateArray(array);
    for (let i = 0; i < result.length && i < array.length; ++i) {
      result[i] = func(value4[i], i, result);
    }
    return result;
  }
  return func(value4);
}
var RADIANS_TO_DEGREES, DEGREES_TO_RADIANS, config;
var init_common = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/common.js"() {
    init_assert9();
    RADIANS_TO_DEGREES = 1 / Math.PI * 180;
    DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
    config = {
      EPSILON: 1e-12,
      debug: false,
      precision: 4,
      printTypes: false,
      printDegrees: false,
      printRowMajor: true
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }
  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }
  return ExtendableBuiltin;
}
var MathArray;
var init_math_array = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/base/math-array.js"() {
    init_common();
    MathArray = class extends _extendableBuiltin(Array) {
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(array, offset = 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = array[i + offset];
        }
        return this.check();
      }
      toArray(targetArray = [], offset = 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          targetArray[offset + i] = this[i];
        }
        return targetArray;
      }
      from(arrayOrObject) {
        return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
      }
      to(arrayOrObject) {
        if (arrayOrObject === this) {
          return this;
        }
        return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
      }
      toTarget(target) {
        return target ? this.to(target) : this;
      }
      toFloat32Array() {
        return new Float32Array(this);
      }
      toString() {
        return this.formatString(config);
      }
      formatString(opts) {
        let string = "";
        for (let i = 0; i < this.ELEMENTS; ++i) {
          string += (i > 0 ? ", " : "") + formatValue2(this[i], opts);
        }
        return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string, "]");
      }
      equals(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (let i = 0; i < this.ELEMENTS; ++i) {
          if (!equals(this[i], array[i])) {
            return false;
          }
        }
        return true;
      }
      exactEquals(array) {
        if (!array || this.length !== array.length) {
          return false;
        }
        for (let i = 0; i < this.ELEMENTS; ++i) {
          if (this[i] !== array[i]) {
            return false;
          }
        }
        return true;
      }
      negate() {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = -this[i];
        }
        return this.check();
      }
      lerp(a2, b, t) {
        if (t === void 0) {
          return this.lerp(this, a2, b);
        }
        for (let i = 0; i < this.ELEMENTS; ++i) {
          const ai = a2[i];
          this[i] = ai + t * (b[i] - ai);
        }
        return this.check();
      }
      min(vector) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(vector[i], this[i]);
        }
        return this.check();
      }
      max(vector) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.max(vector[i], this[i]);
        }
        return this.check();
      }
      clamp(minVector, maxVector) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
        }
        return this.check();
      }
      add(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] += vector[i];
          }
        }
        return this.check();
      }
      subtract(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] -= vector[i];
          }
        }
        return this.check();
      }
      scale(scale6) {
        if (typeof scale6 === "number") {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] *= scale6;
          }
        } else {
          for (let i = 0; i < this.ELEMENTS && i < scale6.length; ++i) {
            this[i] *= scale6[i];
          }
        }
        return this.check();
      }
      multiplyByScalar(scalar) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scalar;
        }
        return this.check();
      }
      check() {
        if (config.debug && !this.validate()) {
          throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
        }
        return this;
      }
      validate() {
        let valid = this.length === this.ELEMENTS;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          valid = valid && Number.isFinite(this[i]);
        }
        return valid;
      }
      sub(a2) {
        return this.subtract(a2);
      }
      setScalar(a2) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = a2;
        }
        return this.check();
      }
      addScalar(a2) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] += a2;
        }
        return this.check();
      }
      subScalar(a2) {
        return this.addScalar(-a2);
      }
      multiplyScalar(scalar) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scalar;
        }
        return this.check();
      }
      divideScalar(a2) {
        return this.multiplyByScalar(1 / a2);
      }
      clampScalar(min, max) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] = Math.min(Math.max(this[i], min), max);
        }
        return this.check();
      }
      get elements() {
        return this;
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/lib/validators.js
function validateVector(v, length5) {
  if (v.length !== length5) {
    return false;
  }
  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value4) {
  if (!Number.isFinite(value4)) {
    throw new Error("Invalid number ".concat(value4));
  }
  return value4;
}
function checkVector(v, length5, callerName = "") {
  if (config.debug && !validateVector(v, length5)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }
  return v;
}
var init_validators = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/validators.js"() {
    init_common();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/base/vector.js
var Vector;
var init_vector = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/base/vector.js"() {
    init_math_array();
    init_validators();
    init_assert9();
    Vector = class extends MathArray {
      get x() {
        return this[0];
      }
      set x(value4) {
        this[0] = checkNumber(value4);
      }
      get y() {
        return this[1];
      }
      set y(value4) {
        this[1] = checkNumber(value4);
      }
      len() {
        return Math.sqrt(this.lengthSquared());
      }
      magnitude() {
        return this.len();
      }
      lengthSquared() {
        let length5 = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          length5 += this[i] * this[i];
        }
        return length5;
      }
      magnitudeSquared() {
        return this.lengthSquared();
      }
      distance(mathArray) {
        return Math.sqrt(this.distanceSquared(mathArray));
      }
      distanceSquared(mathArray) {
        let length5 = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          const dist = this[i] - mathArray[i];
          length5 += dist * dist;
        }
        return checkNumber(length5);
      }
      dot(mathArray) {
        let product = 0;
        for (let i = 0; i < this.ELEMENTS; ++i) {
          product += this[i] * mathArray[i];
        }
        return checkNumber(product);
      }
      normalize() {
        const length5 = this.magnitude();
        if (length5 !== 0) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] /= length5;
          }
        }
        return this.check();
      }
      multiply(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] *= vector[i];
          }
        }
        return this.check();
      }
      divide(...vectors) {
        for (const vector of vectors) {
          for (let i = 0; i < this.ELEMENTS; ++i) {
            this[i] /= vector[i];
          }
        }
        return this.check();
      }
      lengthSq() {
        return this.lengthSquared();
      }
      distanceTo(vector) {
        return this.distance(vector);
      }
      distanceToSquared(vector) {
        return this.distanceSquared(vector);
      }
      getComponent(i) {
        assert9(i >= 0 && i < this.ELEMENTS, "index is out of range");
        return checkNumber(this[i]);
      }
      setComponent(i, value4) {
        assert9(i >= 0 && i < this.ELEMENTS, "index is out of range");
        this[i] = value4;
        return this.check();
      }
      addVectors(a2, b) {
        return this.copy(a2).add(b);
      }
      subVectors(a2, b) {
        return this.copy(a2).subtract(b);
      }
      multiplyVectors(a2, b) {
        return this.copy(a2).multiply(b);
      }
      addScaledVector(a2, b) {
        return this.add(new this.constructor(a2).multiplyScalar(b));
      }
    };
  }
});

// node_modules/gl-matrix/esm/common.js
var EPSILON, ARRAY_TYPE, degree;
var init_common2 = __esm({
  "node_modules/gl-matrix/esm/common.js"() {
    EPSILON = 1e-6;
    ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
    degree = Math.PI / 180;
    if (!Math.hypot)
      Math.hypot = function() {
        var y = 0, i = arguments.length;
        while (i--) {
          y += arguments[i] * arguments[i];
        }
        return Math.sqrt(y);
      };
  }
});

// node_modules/gl-matrix/esm/vec2.js
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function add(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  return out;
}
function subtract(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  return out;
}
function scale(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  return out;
}
function length(a2) {
  var x = a2[0], y = a2[1];
  return Math.hypot(x, y);
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function lerp2(out, a2, b, t) {
  var ax = a2[0], ay = a2[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
function transformMat2(out, a2, m) {
  var x = a2[0], y = a2[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a2, m) {
  var x = a2[0], y = a2[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat3(out, a2, m) {
  var x = a2[0], y = a2[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat4(out, a2, m) {
  var x = a2[0];
  var y = a2[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
var sub, forEach3;
var init_vec2 = __esm({
  "node_modules/gl-matrix/esm/vec2.js"() {
    init_common2();
    sub = subtract;
    forEach3 = function() {
      var vec = create();
      return function(a2, stride, offset, count4, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 2;
        }
        if (!offset) {
          offset = 0;
        }
        if (count4) {
          l = Math.min(count4 * stride + offset, a2.length);
        } else {
          l = a2.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a2[i];
          vec[1] = a2[i + 1];
          fn(vec, vec, arg);
          a2[i] = vec[0];
          a2[i + 1] = vec[1];
        }
        return a2;
      };
    }();
  }
});

// node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
function vec2_transformMat4AsVector(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const w = m[3] * x + m[7] * y || 1;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a2[2];
  return out;
}
function vec4_transformMat2(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function vec4_transformMat3(out, a2, m) {
  const x = a2[0];
  const y = a2[1];
  const z = a2[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a2[3];
  return out;
}
var init_gl_matrix_extras = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js"() {
  }
});

// node_modules/@math.gl/core/dist/esm/classes/vector2.js
var Vector2;
var init_vector2 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/vector2.js"() {
    init_vector();
    init_common();
    init_validators();
    init_vec2();
    init_gl_matrix_extras();
    Vector2 = class extends Vector {
      constructor(x = 0, y = 0) {
        super(2);
        if (isArray2(x) && arguments.length === 1) {
          this.copy(x);
        } else {
          if (config.debug) {
            checkNumber(x);
            checkNumber(y);
          }
          this[0] = x;
          this[1] = y;
        }
      }
      set(x, y) {
        this[0] = x;
        this[1] = y;
        return this.check();
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        return this.check();
      }
      fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
        }
        this[0] = object.x;
        this[1] = object.y;
        return this.check();
      }
      toObject(object) {
        object.x = this[0];
        object.y = this[1];
        return object;
      }
      get ELEMENTS() {
        return 2;
      }
      horizontalAngle() {
        return Math.atan2(this.y, this.x);
      }
      verticalAngle() {
        return Math.atan2(this.x, this.y);
      }
      transform(matrix4) {
        return this.transformAsPoint(matrix4);
      }
      transformAsPoint(matrix4) {
        transformMat4(this, this, matrix4);
        return this.check();
      }
      transformAsVector(matrix4) {
        vec2_transformMat4AsVector(this, this, matrix4);
        return this.check();
      }
      transformByMatrix3(matrix3) {
        transformMat3(this, this, matrix3);
        return this.check();
      }
      transformByMatrix2x3(matrix2x3) {
        transformMat2d(this, this, matrix2x3);
        return this.check();
      }
      transformByMatrix2(matrix2) {
        transformMat2(this, this, matrix2);
        return this.check();
      }
    };
  }
});

// node_modules/gl-matrix/esm/vec3.js
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function length2(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add2(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  return out;
}
function subtract2(out, a2, b) {
  out[0] = a2[0] - b[0];
  out[1] = a2[1] - b[1];
  out[2] = a2[2] - b[2];
  return out;
}
function multiply(out, a2, b) {
  out[0] = a2[0] * b[0];
  out[1] = a2[1] * b[1];
  out[2] = a2[2] * b[2];
  return out;
}
function squaredLength(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  return x * x + y * y + z * z;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function normalize(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var len2 = x * x + y * y + z * z;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = a2[0] * len2;
  out[1] = a2[1] * len2;
  out[2] = a2[2] * len2;
  return out;
}
function dot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cross(out, a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp3(out, a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function transformMat42(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat32(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a2, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a2[0], y = a2[1], z = a2[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a2, b, rad) {
  var p = [], r = [];
  p[0] = a2[0] - b[0];
  p[1] = a2[1] - b[1];
  p[2] = a2[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a2, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
var sub2, mul, len, sqrLen, forEach4;
var init_vec3 = __esm({
  "node_modules/gl-matrix/esm/vec3.js"() {
    init_common2();
    sub2 = subtract2;
    mul = multiply;
    len = length2;
    sqrLen = squaredLength;
    forEach4 = function() {
      var vec = create2();
      return function(a2, stride, offset, count4, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 3;
        }
        if (!offset) {
          offset = 0;
        }
        if (count4) {
          l = Math.min(count4 * stride + offset, a2.length);
        } else {
          l = a2.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a2[i];
          vec[1] = a2[i + 1];
          vec[2] = a2[i + 2];
          fn(vec, vec, arg);
          a2[i] = vec[0];
          a2[i + 1] = vec[1];
          a2[i + 2] = vec[2];
        }
        return a2;
      };
    }();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/vector3.js
var ORIGIN, ZERO, Vector3;
var init_vector3 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/vector3.js"() {
    init_vector();
    init_common();
    init_validators();
    init_vec3();
    init_gl_matrix_extras();
    ORIGIN = [0, 0, 0];
    Vector3 = class _Vector3 extends Vector {
      static get ZERO() {
        if (!ZERO) {
          ZERO = new _Vector3(0, 0, 0);
          Object.freeze(ZERO);
        }
        return ZERO;
      }
      constructor(x = 0, y = 0, z = 0) {
        super(-0, -0, -0);
        if (arguments.length === 1 && isArray2(x)) {
          this.copy(x);
        } else {
          if (config.debug) {
            checkNumber(x);
            checkNumber(y);
            checkNumber(z);
          }
          this[0] = x;
          this[1] = y;
          this[2] = z;
        }
      }
      set(x, y, z) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this.check();
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        return this.check();
      }
      fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
          checkNumber(object.z);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        return this.check();
      }
      toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        return object;
      }
      get ELEMENTS() {
        return 3;
      }
      get z() {
        return this[2];
      }
      set z(value4) {
        this[2] = checkNumber(value4);
      }
      angle(vector) {
        return angle(this, vector);
      }
      cross(vector) {
        cross(this, this, vector);
        return this.check();
      }
      rotateX({
        radians: radians2,
        origin = ORIGIN
      }) {
        rotateX(this, this, origin, radians2);
        return this.check();
      }
      rotateY({
        radians: radians2,
        origin = ORIGIN
      }) {
        rotateY(this, this, origin, radians2);
        return this.check();
      }
      rotateZ({
        radians: radians2,
        origin = ORIGIN
      }) {
        rotateZ(this, this, origin, radians2);
        return this.check();
      }
      transform(matrix4) {
        return this.transformAsPoint(matrix4);
      }
      transformAsPoint(matrix4) {
        transformMat42(this, this, matrix4);
        return this.check();
      }
      transformAsVector(matrix4) {
        vec3_transformMat4AsVector(this, this, matrix4);
        return this.check();
      }
      transformByMatrix3(matrix3) {
        transformMat32(this, this, matrix3);
        return this.check();
      }
      transformByMatrix2(matrix2) {
        vec3_transformMat2(this, this, matrix2);
        return this.check();
      }
      transformByQuaternion(quaternion) {
        transformQuat(this, this, quaternion);
        return this.check();
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/vector4.js
var ZERO2, Vector4;
var init_vector4 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/vector4.js"() {
    init_vector();
    init_common();
    init_validators();
    init_vec3();
    init_gl_matrix_extras();
    Vector4 = class _Vector4 extends Vector {
      static get ZERO() {
        if (!ZERO2) {
          ZERO2 = new _Vector4(0, 0, 0, 0);
          Object.freeze(ZERO2);
        }
        return ZERO2;
      }
      constructor(x = 0, y = 0, z = 0, w = 0) {
        super(-0, -0, -0, -0);
        if (isArray2(x) && arguments.length === 1) {
          this.copy(x);
        } else {
          if (config.debug) {
            checkNumber(x);
            checkNumber(y);
            checkNumber(z);
            checkNumber(w);
          }
          this[0] = x;
          this[1] = y;
          this[2] = z;
          this[3] = w;
        }
      }
      set(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this.check();
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        return this.check();
      }
      fromObject(object) {
        if (config.debug) {
          checkNumber(object.x);
          checkNumber(object.y);
          checkNumber(object.z);
          checkNumber(object.w);
        }
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        this[3] = object.w;
        return this;
      }
      toObject(object) {
        object.x = this[0];
        object.y = this[1];
        object.z = this[2];
        object.w = this[3];
        return object;
      }
      get ELEMENTS() {
        return 4;
      }
      get z() {
        return this[2];
      }
      set z(value4) {
        this[2] = checkNumber(value4);
      }
      get w() {
        return this[3];
      }
      set w(value4) {
        this[3] = checkNumber(value4);
      }
      transform(matrix4) {
        transformMat42(this, this, matrix4);
        return this.check();
      }
      transformByMatrix3(matrix3) {
        vec4_transformMat3(this, this, matrix3);
        return this.check();
      }
      transformByMatrix2(matrix2) {
        vec4_transformMat2(this, this, matrix2);
        return this.check();
      }
      transformByQuaternion(quaternion) {
        transformQuat(this, this, quaternion);
        return this.check();
      }
      applyMatrix4(m) {
        m.transform(this, this);
        return this;
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
var Matrix;
var init_matrix = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/base/matrix.js"() {
    init_math_array();
    init_validators();
    init_common();
    Matrix = class extends MathArray {
      toString() {
        let string = "[";
        if (config.printRowMajor) {
          string += "row-major:";
          for (let row = 0; row < this.RANK; ++row) {
            for (let col = 0; col < this.RANK; ++col) {
              string += " ".concat(this[col * this.RANK + row]);
            }
          }
        } else {
          string += "column-major:";
          for (let i = 0; i < this.ELEMENTS; ++i) {
            string += " ".concat(this[i]);
          }
        }
        string += "]";
        return string;
      }
      getElementIndex(row, col) {
        return col * this.RANK + row;
      }
      getElement(row, col) {
        return this[col * this.RANK + row];
      }
      setElement(row, col, value4) {
        this[col * this.RANK + row] = checkNumber(value4);
        return this;
      }
      getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
        const firstIndex = columnIndex * this.RANK;
        for (let i = 0; i < this.RANK; ++i) {
          result[i] = this[firstIndex + i];
        }
        return result;
      }
      setColumn(columnIndex, columnVector) {
        const firstIndex = columnIndex * this.RANK;
        for (let i = 0; i < this.RANK; ++i) {
          this[firstIndex + i] = columnVector[i];
        }
        return this;
      }
    };
  }
});

// node_modules/gl-matrix/esm/mat3.js
function create3() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply2(out, a2, b) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a2, v) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a2, rad) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale2(out, a2, v) {
  var x = v[0], y = v[1];
  out[0] = x * a2[0];
  out[1] = x * a2[1];
  out[2] = x * a2[2];
  out[3] = y * a2[3];
  out[4] = y * a2[4];
  out[5] = y * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
var init_mat3 = __esm({
  "node_modules/gl-matrix/esm/mat3.js"() {
    init_common2();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/matrix3.js
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3();
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}
var INDICES, IDENTITY_MATRIX, Matrix3, ZERO_MATRIX3, IDENTITY_MATRIX3;
var init_matrix3 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/matrix3.js"() {
    init_matrix();
    init_validators();
    init_gl_matrix_extras();
    init_mat3();
    init_vec2();
    init_vec3();
    (function(INDICES3) {
      INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
      INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
      INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
      INDICES3[INDICES3["COL1ROW0"] = 3] = "COL1ROW0";
      INDICES3[INDICES3["COL1ROW1"] = 4] = "COL1ROW1";
      INDICES3[INDICES3["COL1ROW2"] = 5] = "COL1ROW2";
      INDICES3[INDICES3["COL2ROW0"] = 6] = "COL2ROW0";
      INDICES3[INDICES3["COL2ROW1"] = 7] = "COL2ROW1";
      INDICES3[INDICES3["COL2ROW2"] = 8] = "COL2ROW2";
    })(INDICES || (INDICES = {}));
    IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    Matrix3 = class extends Matrix {
      static get IDENTITY() {
        return getIdentityMatrix();
      }
      static get ZERO() {
        return getZeroMatrix();
      }
      get ELEMENTS() {
        return 9;
      }
      get RANK() {
        return 3;
      }
      get INDICES() {
        return INDICES;
      }
      constructor(array, ...args) {
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
        if (arguments.length === 1 && Array.isArray(array)) {
          this.copy(array);
        } else if (args.length > 0) {
          this.copy([array, ...args]);
        } else {
          this.identity();
        }
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        return this.check();
      }
      identity() {
        return this.copy(IDENTITY_MATRIX);
      }
      fromObject(object) {
        return this.check();
      }
      fromQuaternion(q) {
        fromQuat(this, q);
        return this.check();
      }
      set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m01;
        this[4] = m11;
        this[5] = m21;
        this[6] = m02;
        this[7] = m12;
        this[8] = m22;
        return this.check();
      }
      setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m01;
        this[4] = m11;
        this[5] = m21;
        this[6] = m02;
        this[7] = m12;
        this[8] = m22;
        return this.check();
      }
      determinant() {
        return determinant(this);
      }
      transpose() {
        transpose(this, this);
        return this.check();
      }
      invert() {
        invert(this, this);
        return this.check();
      }
      multiplyLeft(a2) {
        multiply2(this, a2, this);
        return this.check();
      }
      multiplyRight(a2) {
        multiply2(this, this, a2);
        return this.check();
      }
      rotate(radians2) {
        rotate(this, this, radians2);
        return this.check();
      }
      scale(factor) {
        if (Array.isArray(factor)) {
          scale2(this, this, factor);
        } else {
          scale2(this, this, [factor, factor]);
        }
        return this.check();
      }
      translate(vec) {
        translate(this, this, vec);
        return this.check();
      }
      transform(vector, result) {
        let out;
        switch (vector.length) {
          case 2:
            out = transformMat3(result || [-0, -0], vector, this);
            break;
          case 3:
            out = transformMat32(result || [-0, -0, -0], vector, this);
            break;
          case 4:
            out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(out, vector.length);
        return out;
      }
      transformVector(vector, result) {
        return this.transform(vector, result);
      }
      transformVector2(vector, result) {
        return this.transform(vector, result);
      }
      transformVector3(vector, result) {
        return this.transform(vector, result);
      }
    };
  }
});

// node_modules/gl-matrix/esm/mat4.js
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a12 = a2[6], a13 = a2[7];
    var a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert2(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function determinant2(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply3(out, a2, b) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a2, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a2 === out) {
    out[12] = a2[0] * x + a2[4] * y + a2[8] * z + a2[12];
    out[13] = a2[1] * x + a2[5] * y + a2[9] * z + a2[13];
    out[14] = a2[2] * x + a2[6] * y + a2[10] * z + a2[14];
    out[15] = a2[3] * x + a2[7] * y + a2[11] * z + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a2[12];
    out[13] = a01 * x + a11 * y + a21 * z + a2[13];
    out[14] = a02 * x + a12 * y + a22 * z + a2[14];
    out[15] = a03 * x + a13 * y + a23 * z + a2[15];
  }
  return out;
}
function scale3(out, a2, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a2[0] * x;
  out[1] = a2[1] * x;
  out[2] = a2[2] * x;
  out[3] = a2[3] * x;
  out[4] = a2[4] * y;
  out[5] = a2[5] * y;
  out[6] = a2[6] * y;
  out[7] = a2[7] * y;
  out[8] = a2[8] * z;
  out[9] = a2[9] * z;
  out[10] = a2[10] * z;
  out[11] = a2[11] * z;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate2(out, a2, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len2 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len2 < EPSILON) {
    return null;
  }
  len2 = 1 / len2;
  x *= len2;
  y *= len2;
  z *= len2;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX2(out, a2, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY2(out, a2, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ2(out, a2, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function fromQuat2(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len2;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len2 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len2;
  z1 *= len2;
  z2 *= len2;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len2 = Math.hypot(x0, x1, x2);
  if (!len2) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len2 = 1 / len2;
    x0 *= len2;
    x1 *= len2;
    x2 *= len2;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len2 = Math.hypot(y0, y1, y2);
  if (!len2) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len2 = 1 / len2;
    y0 *= len2;
    y1 *= len2;
    y2 *= len2;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function equals2(a2, b) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7];
  var a8 = a2[8], a9 = a2[9], a10 = a2[10], a11 = a2[11];
  var a12 = a2[12], a13 = a2[13], a14 = a2[14], a15 = a2[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var perspective, ortho;
var init_mat4 = __esm({
  "node_modules/gl-matrix/esm/mat4.js"() {
    init_common2();
    perspective = perspectiveNO;
    ortho = orthoNO;
  }
});

// node_modules/gl-matrix/esm/vec4.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function add3(out, a2, b) {
  out[0] = a2[0] + b[0];
  out[1] = a2[1] + b[1];
  out[2] = a2[2] + b[2];
  out[3] = a2[3] + b[3];
  return out;
}
function scale4(out, a2, b) {
  out[0] = a2[0] * b;
  out[1] = a2[1] * b;
  out[2] = a2[2] * b;
  out[3] = a2[3] * b;
  return out;
}
function length3(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w = a2[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w = a2[3];
  return x * x + y * y + z * z + w * w;
}
function normalize2(out, a2) {
  var x = a2[0];
  var y = a2[1];
  var z = a2[2];
  var w = a2[3];
  var len2 = x * x + y * y + z * z + w * w;
  if (len2 > 0) {
    len2 = 1 / Math.sqrt(len2);
  }
  out[0] = x * len2;
  out[1] = y * len2;
  out[2] = z * len2;
  out[3] = w * len2;
  return out;
}
function dot2(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2] + a2[3] * b[3];
}
function lerp4(out, a2, b, t) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  var aw = a2[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function transformMat43(out, a2, m) {
  var x = a2[0], y = a2[1], z = a2[2], w = a2[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a2, q) {
  var x = a2[0], y = a2[1], z = a2[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a2[3];
  return out;
}
var forEach5;
var init_vec4 = __esm({
  "node_modules/gl-matrix/esm/vec4.js"() {
    init_common2();
    forEach5 = function() {
      var vec = create4();
      return function(a2, stride, offset, count4, fn, arg) {
        var i, l;
        if (!stride) {
          stride = 4;
        }
        if (!offset) {
          offset = 0;
        }
        if (count4) {
          l = Math.min(count4 * stride + offset, a2.length);
        } else {
          l = a2.length;
        }
        for (i = offset; i < l; i += stride) {
          vec[0] = a2[i];
          vec[1] = a2[i + 1];
          vec[2] = a2[i + 2];
          vec[3] = a2[i + 3];
          fn(vec, vec, arg);
          a2[i] = vec[0];
          a2[i + 1] = vec[1];
          a2[i + 2] = vec[2];
          a2[i + 3] = vec[3];
        }
        return a2;
      };
    }();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/matrix4.js
function getZeroMatrix2() {
  if (!ZERO3) {
    ZERO3 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO3);
  }
  return ZERO3;
}
function getIdentityMatrix2() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }
  return IDENTITY;
}
function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error("expected radians");
  }
}
function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}
var INDICES2, DEFAULT_FOVY, DEFAULT_ASPECT, DEFAULT_NEAR, DEFAULT_FAR, IDENTITY_MATRIX2, Matrix4, ZERO3, IDENTITY;
var init_matrix4 = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/matrix4.js"() {
    init_matrix();
    init_validators();
    init_gl_matrix_extras();
    init_mat4();
    init_vec2();
    init_vec3();
    init_vec4();
    (function(INDICES3) {
      INDICES3[INDICES3["COL0ROW0"] = 0] = "COL0ROW0";
      INDICES3[INDICES3["COL0ROW1"] = 1] = "COL0ROW1";
      INDICES3[INDICES3["COL0ROW2"] = 2] = "COL0ROW2";
      INDICES3[INDICES3["COL0ROW3"] = 3] = "COL0ROW3";
      INDICES3[INDICES3["COL1ROW0"] = 4] = "COL1ROW0";
      INDICES3[INDICES3["COL1ROW1"] = 5] = "COL1ROW1";
      INDICES3[INDICES3["COL1ROW2"] = 6] = "COL1ROW2";
      INDICES3[INDICES3["COL1ROW3"] = 7] = "COL1ROW3";
      INDICES3[INDICES3["COL2ROW0"] = 8] = "COL2ROW0";
      INDICES3[INDICES3["COL2ROW1"] = 9] = "COL2ROW1";
      INDICES3[INDICES3["COL2ROW2"] = 10] = "COL2ROW2";
      INDICES3[INDICES3["COL2ROW3"] = 11] = "COL2ROW3";
      INDICES3[INDICES3["COL3ROW0"] = 12] = "COL3ROW0";
      INDICES3[INDICES3["COL3ROW1"] = 13] = "COL3ROW1";
      INDICES3[INDICES3["COL3ROW2"] = 14] = "COL3ROW2";
      INDICES3[INDICES3["COL3ROW3"] = 15] = "COL3ROW3";
    })(INDICES2 || (INDICES2 = {}));
    DEFAULT_FOVY = 45 * Math.PI / 180;
    DEFAULT_ASPECT = 1;
    DEFAULT_NEAR = 0.1;
    DEFAULT_FAR = 500;
    IDENTITY_MATRIX2 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    Matrix4 = class extends Matrix {
      static get IDENTITY() {
        return getIdentityMatrix2();
      }
      static get ZERO() {
        return getZeroMatrix2();
      }
      get ELEMENTS() {
        return 16;
      }
      get RANK() {
        return 4;
      }
      get INDICES() {
        return INDICES2;
      }
      constructor(array) {
        super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
        if (arguments.length === 1 && Array.isArray(array)) {
          this.copy(array);
        } else {
          this.identity();
        }
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        this[4] = array[4];
        this[5] = array[5];
        this[6] = array[6];
        this[7] = array[7];
        this[8] = array[8];
        this[9] = array[9];
        this[10] = array[10];
        this[11] = array[11];
        this[12] = array[12];
        this[13] = array[13];
        this[14] = array[14];
        this[15] = array[15];
        return this.check();
      }
      set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
      }
      setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this[0] = m00;
        this[1] = m10;
        this[2] = m20;
        this[3] = m30;
        this[4] = m01;
        this[5] = m11;
        this[6] = m21;
        this[7] = m31;
        this[8] = m02;
        this[9] = m12;
        this[10] = m22;
        this[11] = m32;
        this[12] = m03;
        this[13] = m13;
        this[14] = m23;
        this[15] = m33;
        return this.check();
      }
      toRowMajor(result) {
        result[0] = this[0];
        result[1] = this[4];
        result[2] = this[8];
        result[3] = this[12];
        result[4] = this[1];
        result[5] = this[5];
        result[6] = this[9];
        result[7] = this[13];
        result[8] = this[2];
        result[9] = this[6];
        result[10] = this[10];
        result[11] = this[14];
        result[12] = this[3];
        result[13] = this[7];
        result[14] = this[11];
        result[15] = this[15];
        return result;
      }
      identity() {
        return this.copy(IDENTITY_MATRIX2);
      }
      fromObject(object) {
        return this.check();
      }
      fromQuaternion(quaternion) {
        fromQuat2(this, quaternion);
        return this.check();
      }
      frustum(view) {
        const {
          left,
          right,
          bottom,
          top,
          near = DEFAULT_NEAR,
          far = DEFAULT_FAR
        } = view;
        if (far === Infinity) {
          computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
        } else {
          frustum(this, left, right, bottom, top, near, far);
        }
        return this.check();
      }
      lookAt(view) {
        const {
          eye,
          center = [0, 0, 0],
          up = [0, 1, 0]
        } = view;
        lookAt(this, eye, center, up);
        return this.check();
      }
      ortho(view) {
        const {
          left,
          right,
          bottom,
          top,
          near = DEFAULT_NEAR,
          far = DEFAULT_FAR
        } = view;
        ortho(this, left, right, bottom, top, near, far);
        return this.check();
      }
      orthographic(view) {
        const {
          fovy = DEFAULT_FOVY,
          aspect = DEFAULT_ASPECT,
          focalDistance = 1,
          near = DEFAULT_NEAR,
          far = DEFAULT_FAR
        } = view;
        checkRadians(fovy);
        const halfY = fovy / 2;
        const top = focalDistance * Math.tan(halfY);
        const right = top * aspect;
        return this.ortho({
          left: -right,
          right,
          bottom: -top,
          top,
          near,
          far
        });
      }
      perspective(view) {
        const {
          fovy = 45 * Math.PI / 180,
          aspect = 1,
          near = 0.1,
          far = 500
        } = view;
        checkRadians(fovy);
        perspective(this, fovy, aspect, near, far);
        return this.check();
      }
      determinant() {
        return determinant2(this);
      }
      getScale(result = [-0, -0, -0]) {
        result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
        result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
        result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
        return result;
      }
      getTranslation(result = [-0, -0, -0]) {
        result[0] = this[12];
        result[1] = this[13];
        result[2] = this[14];
        return result;
      }
      getRotation(result, scaleResult) {
        result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
        scaleResult = scaleResult || [-0, -0, -0];
        const scale6 = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale6[0];
        const inverseScale1 = 1 / scale6[1];
        const inverseScale2 = 1 / scale6[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = 0;
        result[4] = this[4] * inverseScale0;
        result[5] = this[5] * inverseScale1;
        result[6] = this[6] * inverseScale2;
        result[7] = 0;
        result[8] = this[8] * inverseScale0;
        result[9] = this[9] * inverseScale1;
        result[10] = this[10] * inverseScale2;
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = 1;
        return result;
      }
      getRotationMatrix3(result, scaleResult) {
        result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
        scaleResult = scaleResult || [-0, -0, -0];
        const scale6 = this.getScale(scaleResult);
        const inverseScale0 = 1 / scale6[0];
        const inverseScale1 = 1 / scale6[1];
        const inverseScale2 = 1 / scale6[2];
        result[0] = this[0] * inverseScale0;
        result[1] = this[1] * inverseScale1;
        result[2] = this[2] * inverseScale2;
        result[3] = this[4] * inverseScale0;
        result[4] = this[5] * inverseScale1;
        result[5] = this[6] * inverseScale2;
        result[6] = this[8] * inverseScale0;
        result[7] = this[9] * inverseScale1;
        result[8] = this[10] * inverseScale2;
        return result;
      }
      transpose() {
        transpose2(this, this);
        return this.check();
      }
      invert() {
        invert2(this, this);
        return this.check();
      }
      multiplyLeft(a2) {
        multiply3(this, a2, this);
        return this.check();
      }
      multiplyRight(a2) {
        multiply3(this, this, a2);
        return this.check();
      }
      rotateX(radians2) {
        rotateX2(this, this, radians2);
        return this.check();
      }
      rotateY(radians2) {
        rotateY2(this, this, radians2);
        return this.check();
      }
      rotateZ(radians2) {
        rotateZ2(this, this, radians2);
        return this.check();
      }
      rotateXYZ(angleXYZ) {
        return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
      }
      rotateAxis(radians2, axis) {
        rotate2(this, this, radians2, axis);
        return this.check();
      }
      scale(factor) {
        scale3(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
        return this.check();
      }
      translate(vector) {
        translate2(this, this, vector);
        return this.check();
      }
      transform(vector, result) {
        if (vector.length === 4) {
          result = transformMat43(result || [-0, -0, -0, -0], vector, this);
          checkVector(result, 4);
          return result;
        }
        return this.transformAsPoint(vector, result);
      }
      transformAsPoint(vector, result) {
        const {
          length: length5
        } = vector;
        let out;
        switch (length5) {
          case 2:
            out = transformMat4(result || [-0, -0], vector, this);
            break;
          case 3:
            out = transformMat42(result || [-0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(out, vector.length);
        return out;
      }
      transformAsVector(vector, result) {
        let out;
        switch (vector.length) {
          case 2:
            out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
            break;
          case 3:
            out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
            break;
          default:
            throw new Error("Illegal vector");
        }
        checkVector(out, vector.length);
        return out;
      }
      transformPoint(vector, result) {
        return this.transformAsPoint(vector, result);
      }
      transformVector(vector, result) {
        return this.transformAsPoint(vector, result);
      }
      transformDirection(vector, result) {
        return this.transformAsVector(vector, result);
      }
      makeRotationX(radians2) {
        return this.identity().rotateX(radians2);
      }
      makeTranslation(x, y, z) {
        return this.identity().translate([x, y, z]);
      }
    };
  }
});

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply4(out, a2, b) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  var x = a2[0], y = a2[1], z = a2[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function slerp(out, a2, b, t) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert3(out, a2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var dot4 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  var invDot = dot4 ? 1 / dot4 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
var add4, scale5, dot3, lerp5, length4, squaredLength3, normalize3, rotationTo, sqlerp, setAxes;
var init_quat = __esm({
  "node_modules/gl-matrix/esm/quat.js"() {
    init_common2();
    init_mat3();
    init_vec3();
    init_vec4();
    add4 = add3;
    scale5 = scale4;
    dot3 = dot2;
    lerp5 = lerp4;
    length4 = length3;
    squaredLength3 = squaredLength2;
    normalize3 = normalize2;
    rotationTo = function() {
      var tmpvec3 = create2();
      var xUnitVec3 = fromValues(1, 0, 0);
      var yUnitVec3 = fromValues(0, 1, 0);
      return function(out, a2, b) {
        var dot4 = dot(a2, b);
        if (dot4 < -0.999999) {
          cross(tmpvec3, xUnitVec3, a2);
          if (len(tmpvec3) < 1e-6)
            cross(tmpvec3, yUnitVec3, a2);
          normalize(tmpvec3, tmpvec3);
          setAxisAngle(out, tmpvec3, Math.PI);
          return out;
        } else if (dot4 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross(tmpvec3, a2, b);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot4;
          return normalize3(out, out);
        }
      };
    }();
    sqlerp = function() {
      var temp1 = create5();
      var temp2 = create5();
      return function(out, a2, b, c, d, t) {
        slerp(temp1, a2, d, t);
        slerp(temp2, b, c, t);
        slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
      };
    }();
    setAxes = function() {
      var matr = create3();
      return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize3(out, fromMat3(out, matr));
      };
    }();
  }
});

// node_modules/@math.gl/core/dist/esm/classes/quaternion.js
var IDENTITY_QUATERNION, Quaternion;
var init_quaternion = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/quaternion.js"() {
    init_math_array();
    init_validators();
    init_vector4();
    init_quat();
    init_vec4();
    IDENTITY_QUATERNION = [0, 0, 0, 1];
    Quaternion = class extends MathArray {
      constructor(x = 0, y = 0, z = 0, w = 1) {
        super(-0, -0, -0, -0);
        if (Array.isArray(x) && arguments.length === 1) {
          this.copy(x);
        } else {
          this.set(x, y, z, w);
        }
      }
      copy(array) {
        this[0] = array[0];
        this[1] = array[1];
        this[2] = array[2];
        this[3] = array[3];
        return this.check();
      }
      set(x, y, z, w) {
        this[0] = x;
        this[1] = y;
        this[2] = z;
        this[3] = w;
        return this.check();
      }
      fromObject(object) {
        this[0] = object.x;
        this[1] = object.y;
        this[2] = object.z;
        this[3] = object.w;
        return this.check();
      }
      fromMatrix3(m) {
        fromMat3(this, m);
        return this.check();
      }
      fromAxisRotation(axis, rad) {
        setAxisAngle(this, axis, rad);
        return this.check();
      }
      identity() {
        identity2(this);
        return this.check();
      }
      setAxisAngle(axis, rad) {
        return this.fromAxisRotation(axis, rad);
      }
      get ELEMENTS() {
        return 4;
      }
      get x() {
        return this[0];
      }
      set x(value4) {
        this[0] = checkNumber(value4);
      }
      get y() {
        return this[1];
      }
      set y(value4) {
        this[1] = checkNumber(value4);
      }
      get z() {
        return this[2];
      }
      set z(value4) {
        this[2] = checkNumber(value4);
      }
      get w() {
        return this[3];
      }
      set w(value4) {
        this[3] = checkNumber(value4);
      }
      len() {
        return length4(this);
      }
      lengthSquared() {
        return squaredLength3(this);
      }
      dot(a2) {
        return dot3(this, a2);
      }
      rotationTo(vectorA, vectorB) {
        rotationTo(this, vectorA, vectorB);
        return this.check();
      }
      add(a2) {
        add4(this, this, a2);
        return this.check();
      }
      calculateW() {
        calculateW(this, this);
        return this.check();
      }
      conjugate() {
        conjugate(this, this);
        return this.check();
      }
      invert() {
        invert3(this, this);
        return this.check();
      }
      lerp(a2, b, t) {
        if (t === void 0) {
          return this.lerp(this, a2, b);
        }
        lerp5(this, a2, b, t);
        return this.check();
      }
      multiplyRight(a2) {
        multiply4(this, this, a2);
        return this.check();
      }
      multiplyLeft(a2) {
        multiply4(this, a2, this);
        return this.check();
      }
      normalize() {
        const length5 = this.len();
        const l = length5 > 0 ? 1 / length5 : 0;
        this[0] = this[0] * l;
        this[1] = this[1] * l;
        this[2] = this[2] * l;
        this[3] = this[3] * l;
        if (length5 === 0) {
          this[3] = 1;
        }
        return this.check();
      }
      rotateX(rad) {
        rotateX3(this, this, rad);
        return this.check();
      }
      rotateY(rad) {
        rotateY3(this, this, rad);
        return this.check();
      }
      rotateZ(rad) {
        rotateZ3(this, this, rad);
        return this.check();
      }
      scale(b) {
        scale5(this, this, b);
        return this.check();
      }
      slerp(arg0, arg1, arg2) {
        let start;
        let target;
        let ratio;
        switch (arguments.length) {
          case 1:
            ({
              start = IDENTITY_QUATERNION,
              target,
              ratio
            } = arg0);
            break;
          case 2:
            start = this;
            target = arg0;
            ratio = arg1;
            break;
          default:
            start = arg0;
            target = arg1;
            ratio = arg2;
        }
        slerp(this, start, target, ratio);
        return this.check();
      }
      transformVector4(vector, result = new Vector4()) {
        transformQuat2(result, vector, this);
        return checkVector(result, 4);
      }
      lengthSq() {
        return this.lengthSquared();
      }
      setFromAxisAngle(axis, rad) {
        return this.setAxisAngle(axis, rad);
      }
      premultiply(a2) {
        return this.multiplyLeft(a2);
      }
      multiply(a2) {
        return this.multiplyRight(a2);
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js
var EPSILON2, EARTH_RADIUS_METERS, SphericalCoordinates;
var init_spherical_coordinates = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js"() {
    init_defineProperty();
    init_vector3();
    init_common();
    init_common();
    init_vec3();
    EPSILON2 = 1e-6;
    EARTH_RADIUS_METERS = 6371e3;
    SphericalCoordinates = class _SphericalCoordinates {
      constructor({
        phi = 0,
        theta = 0,
        radius = 1,
        bearing,
        pitch,
        altitude,
        radiusScale = EARTH_RADIUS_METERS
      } = {}) {
        _defineProperty(this, "phi", void 0);
        _defineProperty(this, "theta", void 0);
        _defineProperty(this, "radius", void 0);
        _defineProperty(this, "radiusScale", void 0);
        this.phi = phi;
        this.theta = theta;
        this.radius = radius || altitude || 1;
        this.radiusScale = radiusScale || 1;
        if (bearing !== void 0) {
          this.bearing = bearing;
        }
        if (pitch !== void 0) {
          this.pitch = pitch;
        }
        this.check();
      }
      toString() {
        return this.formatString(config);
      }
      formatString({
        printTypes = false
      }) {
        const f = formatValue2;
        return "".concat(printTypes ? "Spherical" : "", "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
      }
      equals(other) {
        return equals(this.radius, other.radius) && equals(this.theta, other.theta) && equals(this.phi, other.phi);
      }
      exactEquals(other) {
        return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
      }
      get bearing() {
        return 180 - degrees(this.phi);
      }
      set bearing(v) {
        this.phi = Math.PI - radians(v);
      }
      get pitch() {
        return degrees(this.theta);
      }
      set pitch(v) {
        this.theta = radians(v);
      }
      get longitude() {
        return degrees(this.phi);
      }
      get latitude() {
        return degrees(this.theta);
      }
      get lng() {
        return degrees(this.phi);
      }
      get lat() {
        return degrees(this.theta);
      }
      get z() {
        return (this.radius - 1) * this.radiusScale;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this.check();
      }
      clone() {
        return new _SphericalCoordinates().copy(this);
      }
      copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this.check();
      }
      fromLngLatZ([lng, lat, z]) {
        this.radius = 1 + z / this.radiusScale;
        this.phi = radians(lat);
        this.theta = radians(lng);
        return this.check();
      }
      fromVector3(v) {
        this.radius = length2(v);
        if (this.radius > 0) {
          this.theta = Math.atan2(v[0], v[1]);
          this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));
        }
        return this.check();
      }
      toVector3() {
        return new Vector3(0, 0, this.radius).rotateX({
          radians: this.theta
        }).rotateZ({
          radians: this.phi
        });
      }
      makeSafe() {
        this.phi = Math.max(EPSILON2, Math.min(Math.PI - EPSILON2, this.phi));
        return this;
      }
      check() {
        if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
          throw new Error("SphericalCoordinates: some fields set to invalid numbers");
        }
        return this;
      }
    };
  }
});

// node_modules/@math.gl/core/dist/esm/classes/euler.js
var RotationOrder;
var init_euler = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/euler.js"() {
    init_math_array();
    init_quaternion();
    init_common();
    init_validators();
    (function(RotationOrder2) {
      RotationOrder2[RotationOrder2["ZYX"] = 0] = "ZYX";
      RotationOrder2[RotationOrder2["YXZ"] = 1] = "YXZ";
      RotationOrder2[RotationOrder2["XZY"] = 2] = "XZY";
      RotationOrder2[RotationOrder2["ZXY"] = 3] = "ZXY";
      RotationOrder2[RotationOrder2["YZX"] = 4] = "YZX";
      RotationOrder2[RotationOrder2["XYZ"] = 5] = "XYZ";
    })(RotationOrder || (RotationOrder = {}));
  }
});

// node_modules/@math.gl/core/dist/esm/classes/pose.js
var init_pose = __esm({
  "node_modules/@math.gl/core/dist/esm/classes/pose.js"() {
    init_defineProperty();
    init_matrix4();
    init_vector3();
    init_euler();
  }
});

// node_modules/@math.gl/core/dist/esm/lib/math-utils.js
var math_utils_default;
var init_math_utils = __esm({
  "node_modules/@math.gl/core/dist/esm/lib/math-utils.js"() {
    math_utils_default = {
      EPSILON1: 0.1,
      EPSILON2: 0.01,
      EPSILON3: 1e-3,
      EPSILON4: 1e-4,
      EPSILON5: 1e-5,
      EPSILON6: 1e-6,
      EPSILON7: 1e-7,
      EPSILON8: 1e-8,
      EPSILON9: 1e-9,
      EPSILON10: 1e-10,
      EPSILON11: 1e-11,
      EPSILON12: 1e-12,
      EPSILON13: 1e-13,
      EPSILON14: 1e-14,
      EPSILON15: 1e-15,
      EPSILON16: 1e-16,
      EPSILON17: 1e-17,
      EPSILON18: 1e-18,
      EPSILON19: 1e-19,
      EPSILON20: 1e-20,
      PI_OVER_TWO: Math.PI / 2,
      PI_OVER_FOUR: Math.PI / 4,
      PI_OVER_SIX: Math.PI / 6,
      TWO_PI: Math.PI * 2
    };
  }
});

// node_modules/@math.gl/core/dist/esm/index.js
var init_esm11 = __esm({
  "node_modules/@math.gl/core/dist/esm/index.js"() {
    init_vector2();
    init_vector3();
    init_vector4();
    init_matrix3();
    init_matrix4();
    init_quaternion();
    init_spherical_coordinates();
    init_pose();
    init_euler();
    init_math_utils();
    init_assert9();
    init_common();
    init_spherical_coordinates();
    init_pose();
    init_euler();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js
function getUniforms2() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  let prevUniforms = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const uniforms3 = {};
  if (opts.modelMatrix !== void 0) {
    uniforms3.modelMatrix = opts.modelMatrix;
  }
  if (opts.viewMatrix !== void 0) {
    uniforms3.viewMatrix = opts.viewMatrix;
  }
  if (opts.projectionMatrix !== void 0) {
    uniforms3.projectionMatrix = opts.projectionMatrix;
  }
  if (opts.cameraPositionWorld !== void 0) {
    uniforms3.cameraPositionWorld = opts.cameraPositionWorld;
  }
  if (opts.projectionMatrix !== void 0 || opts.viewMatrix !== void 0) {
    uniforms3.viewProjectionMatrix = new Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
  }
  return uniforms3;
}
var IDENTITY_MATRIX4, DEFAULT_MODULE_OPTIONS, common, vs, fs, project;
var init_project = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/project/project.js"() {
    init_esm11();
    IDENTITY_MATRIX4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    DEFAULT_MODULE_OPTIONS = {
      modelMatrix: IDENTITY_MATRIX4,
      viewMatrix: IDENTITY_MATRIX4,
      projectionMatrix: IDENTITY_MATRIX4,
      cameraPositionWorld: [0, 0, 0]
    };
    common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
    vs = "".concat(common, "\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
    fs = "\n".concat(common);
    project = {
      name: "project",
      getUniforms: getUniforms2,
      vs,
      fs
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js
var lights_glsl_default;
var init_lights_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js"() {
    lights_glsl_default = "#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js
function convertColor() {
  let {
    color = [0, 0, 0],
    intensity = 1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return color.map((component) => component * intensity / 255);
}
function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};
  if (ambientLight) {
    lightSourceUniforms["lighting_uAmbientLight.color"] = convertColor(ambientLight);
  } else {
    lightSourceUniforms["lighting_uAmbientLight.color"] = [0, 0, 0];
  }
  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}
function getUniforms3() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS;
  if ("lightSources" in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;
    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }
    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }
  if ("lights" in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };
    for (const light of opts.lights || []) {
      switch (light.type) {
        case "ambient":
          lightSources.ambientLight = light;
          break;
        case "directional":
          lightSources.directionalLights.push(light);
          break;
        case "point":
          lightSources.pointLights.push(light);
          break;
        default:
      }
    }
    return getUniforms3({
      lightSources
    });
  }
  return {};
}
var INITIAL_MODULE_OPTIONS, lights;
var init_lights = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js"() {
    init_lights_glsl();
    INITIAL_MODULE_OPTIONS = {
      lightSources: {}
    };
    lights = {
      name: "lights",
      vs: lights_glsl_default,
      fs: lights_glsl_default,
      getUniforms: getUniforms3,
      defines: {
        MAX_LIGHTS: 3
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js
function getUniforms4() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS2;
  const uniforms3 = {};
  if (opts.lightDirection) {
    uniforms3.dirlight_uLightDirection = opts.lightDirection;
  }
  return uniforms3;
}
var DEFAULT_LIGHT_DIRECTION, DEFAULT_MODULE_OPTIONS2, vs2, fs2, dirlight;
var init_dirlight = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/dirlight/dirlight.js"() {
    init_project();
    DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
    DEFAULT_MODULE_OPTIONS2 = {
      lightDirection: DEFAULT_LIGHT_DIRECTION
    };
    vs2 = null;
    fs2 = "uniform vec3 dirlight_uLightDirection;\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
    dirlight = {
      name: "dirlight",
      vs: vs2,
      fs: fs2,
      getUniforms: getUniforms4,
      dependencies: [project]
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
function getUniforms5() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS3;
  const uniforms3 = {};
  if (opts.pickingSelectedColor !== void 0) {
    if (!opts.pickingSelectedColor) {
      uniforms3.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms3.picking_uSelectedColorValid = 1;
      uniforms3.picking_uSelectedColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, (x) => x / 255);
    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }
    uniforms3.picking_uHighlightColor = color;
  }
  if (opts.pickingActive !== void 0) {
    uniforms3.picking_uActive = Boolean(opts.pickingActive);
    uniforms3.picking_uAttribute = Boolean(opts.pickingAttribute);
  }
  return uniforms3;
}
var DEFAULT_HIGHLIGHT_COLOR, DEFAULT_MODULE_OPTIONS3, vs3, fs3, picking;
var init_picking = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js"() {
    DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
    DEFAULT_MODULE_OPTIONS3 = {
      pickingSelectedColor: null,
      pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
      pickingActive: false,
      pickingAttribute: false
    };
    vs3 = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
    fs3 = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
    picking = {
      name: "picking",
      vs: vs3,
      fs: fs3,
      getUniforms: getUniforms5
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js
var phong_lighting_glsl_default;
var init_phong_lighting_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js"() {
    phong_lighting_glsl_default = "\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js
function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map((x) => x / 255)
  };
}
function getUniforms6() {
  let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS2;
  if (!("material" in opts)) {
    return {};
  }
  const {
    material
  } = opts;
  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }
  return getMaterialUniforms(material);
}
var INITIAL_MODULE_OPTIONS2, gouraudLighting, phongLighting;
var init_phong_lighting = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js"() {
    init_lights();
    init_phong_lighting_glsl();
    INITIAL_MODULE_OPTIONS2 = {};
    gouraudLighting = {
      name: "gouraud-lighting",
      dependencies: [lights],
      vs: phong_lighting_glsl_default,
      defines: {
        LIGHTING_VERTEX: 1
      },
      getUniforms: getUniforms6
    };
    phongLighting = {
      name: "phong-lighting",
      dependencies: [lights],
      fs: phong_lighting_glsl_default,
      defines: {
        LIGHTING_FRAGMENT: 1
      },
      getUniforms: getUniforms6
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js
var pbr_vertex_glsl_default;
var init_pbr_vertex_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-vertex.glsl.js"() {
    pbr_vertex_glsl_default = "uniform mat4 u_MVPMatrix;\nuniform mat4 u_ModelMatrix;\nuniform mat4 u_NormalMatrix;\n\nvarying vec3 pbr_vPosition;\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n# ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n# else\nvarying vec3 pbr_vNormal;\n# endif\n#endif\n\nvoid pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)\n{\n  vec4 pos = u_ModelMatrix * position;\n  pbr_vPosition = vec3(pos.xyz) / pos.w;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\n  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));\n  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));\n  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;\n  pbr_vTBN = mat3(tangentW, bitangentW, normalW);\n#else\n  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));\n#endif\n#endif\n\n#ifdef HAS_UV\n  pbr_vUV = uv;\n#else\n  pbr_vUV = vec2(0.,0.);\n#endif\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js
var pbr_fragment_glsl_default;
var init_pbr_fragment_glsl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr-fragment.glsl.js"() {
    pbr_fragment_glsl_default = "#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)\n# error PBR fragment shader: Texture LOD is not available\n#endif\n\n#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)\n# error PBR fragment shader: Derivatives are not available\n#endif\n\n\n#if (__VERSION__ < 300)\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)\n#else\n  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)\n#endif\n\nprecision highp float;\n\nuniform bool pbr_uUnlit;\n\n#ifdef USE_IBL\nuniform samplerCube u_DiffuseEnvSampler;\nuniform samplerCube u_SpecularEnvSampler;\nuniform sampler2D u_brdfLUT;\nuniform vec2 u_ScaleIBLAmbient;\n#endif\n\n#ifdef HAS_BASECOLORMAP\nuniform sampler2D u_BaseColorSampler;\n#endif\n#ifdef HAS_NORMALMAP\nuniform sampler2D u_NormalSampler;\nuniform float u_NormalScale;\n#endif\n#ifdef HAS_EMISSIVEMAP\nuniform sampler2D u_EmissiveSampler;\nuniform vec3 u_EmissiveFactor;\n#endif\n#ifdef HAS_METALROUGHNESSMAP\nuniform sampler2D u_MetallicRoughnessSampler;\n#endif\n#ifdef HAS_OCCLUSIONMAP\nuniform sampler2D u_OcclusionSampler;\nuniform float u_OcclusionStrength;\n#endif\n\n#ifdef ALPHA_CUTOFF\nuniform float u_AlphaCutoff;\n#endif\n\nuniform vec2 u_MetallicRoughnessValues;\nuniform vec4 u_BaseColorFactor;\n\nuniform vec3 u_Camera;\n#ifdef PBR_DEBUG\nuniform vec4 u_ScaleDiffBaseMR;\nuniform vec4 u_ScaleFGDSpec;\n#endif\n\nvarying vec3 pbr_vPosition;\n\nvarying vec2 pbr_vUV;\n\n#ifdef HAS_NORMALS\n#ifdef HAS_TANGENTS\nvarying mat3 pbr_vTBN;\n#else\nvarying vec3 pbr_vNormal;\n#endif\n#endif\n\n\nstruct PBRInfo\n{\n  float NdotL;\n  float NdotV;\n  float NdotH;\n  float LdotH;\n  float VdotH;\n  float perceptualRoughness;\n  float metalness;\n  vec3 reflectance0;\n  vec3 reflectance90;\n  float alphaRoughness;\n  vec3 diffuseColor;\n  vec3 specularColor;\n  vec3 n;\n  vec3 v;\n};\n\nconst float M_PI = 3.141592653589793;\nconst float c_MinRoughness = 0.04;\n\nvec4 SRGBtoLINEAR(vec4 srgbIn)\n{\n#ifdef MANUAL_SRGB\n#ifdef SRGB_FAST_APPROXIMATION\n  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));\n#else\n  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);\n  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );\n#endif\n  return vec4(linOut,srgbIn.w);;\n#else\n  return srgbIn;\n#endif\n}\n\nvec3 getNormal()\n{\n#ifndef HAS_TANGENTS\n  vec3 pos_dx = dFdx(pbr_vPosition);\n  vec3 pos_dy = dFdy(pbr_vPosition);\n  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));\n  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));\n  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n\n#ifdef HAS_NORMALS\n  vec3 ng = normalize(pbr_vNormal);\n#else\n  vec3 ng = cross(pos_dx, pos_dy);\n#endif\n\n  t = normalize(t - ng * dot(ng, t));\n  vec3 b = normalize(cross(ng, t));\n  mat3 tbn = mat3(t, b, ng);\n#else\n  mat3 tbn = pbr_vTBN;\n#endif\n\n#ifdef HAS_NORMALMAP\n  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;\n  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));\n#else\n  vec3 n = normalize(tbn[2].xyz);\n#endif\n\n  return n;\n}\n\n\n#ifdef USE_IBL\nvec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)\n{\n  float mipCount = 9.0;\n  float lod = (pbrInputs.perceptualRoughness * mipCount);\n  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,\n    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;\n  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;\n\n#ifdef USE_TEX_LOD\n  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;\n#else\n  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;\n#endif\n\n  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;\n  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);\n  diffuse *= u_ScaleIBLAmbient.x;\n  specular *= u_ScaleIBLAmbient.y;\n\n  return diffuse + specular;\n}\n#endif\n\n\nvec3 diffuse(PBRInfo pbrInputs)\n{\n  return pbrInputs.diffuseColor / M_PI;\n}\n\nvec3 specularReflection(PBRInfo pbrInputs)\n{\n  return pbrInputs.reflectance0 +\n    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *\n    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);\n}\n\n\n\nfloat geometricOcclusion(PBRInfo pbrInputs)\n{\n  float NdotL = pbrInputs.NdotL;\n  float NdotV = pbrInputs.NdotV;\n  float r = pbrInputs.alphaRoughness;\n\n  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));\n  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));\n  return attenuationL * attenuationV;\n}\n\n\n\n\n\nfloat microfacetDistribution(PBRInfo pbrInputs)\n{\n  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;\n  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;\n  return roughnessSq / (M_PI * f * f);\n}\n\nvoid PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {\n  pbrInputs.NdotL = 1.0;\n  pbrInputs.NdotH = 0.0;\n  pbrInputs.LdotH = 0.0;\n  pbrInputs.VdotH = 1.0;\n}\n\nvoid PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {\n  vec3 n = pbrInputs.n;\n  vec3 v = pbrInputs.v;\n  vec3 l = normalize(lightDirection);\n  vec3 h = normalize(l+v);\n\n  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);\n  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);\n  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);\n  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);\n}\n\nvoid PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {\n  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);\n  PBRInfo_setDirectionalLight(pbrInputs, light_direction);\n}\n\nvec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {\n  vec3 F = specularReflection(pbrInputs);\n  float G = geometricOcclusion(pbrInputs);\n  float D = microfacetDistribution(pbrInputs);\n  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);\n  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);\n  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);\n}\n\nvec4 pbr_filterColor(vec4 colorUnused)\n{\n#ifdef HAS_BASECOLORMAP\n  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;\n#else\n  vec4 baseColor = u_BaseColorFactor;\n#endif\n\n#ifdef ALPHA_CUTOFF\n  if (baseColor.a < u_AlphaCutoff) {\n    discard;\n  }\n#endif\n\n  vec3 color = vec3(0, 0, 0);\n\n  if(pbr_uUnlit){\n    color.rgb = baseColor.rgb;\n  }\n  else{\n\n\n    float perceptualRoughness = u_MetallicRoughnessValues.y;\n    float metallic = u_MetallicRoughnessValues.x;\n#ifdef HAS_METALROUGHNESSMAP\n\n    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);\n    perceptualRoughness = mrSample.g * perceptualRoughness;\n    metallic = mrSample.b * metallic;\n#endif\n    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);\n    metallic = clamp(metallic, 0.0, 1.0);\n\n    float alphaRoughness = perceptualRoughness * perceptualRoughness;\n\n    vec3 f0 = vec3(0.04);\n    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);\n    diffuseColor *= 1.0 - metallic;\n    vec3 specularColor = mix(f0, baseColor.rgb, metallic);\n    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n\n\n\n    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);\n    vec3 specularEnvironmentR0 = specularColor.rgb;\n    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;\n\n    vec3 n = getNormal();\n    vec3 v = normalize(u_Camera - pbr_vPosition);\n\n    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);\n    vec3 reflection = -normalize(reflect(v, n));\n\n    PBRInfo pbrInputs = PBRInfo(\n      0.0,\n      NdotV,\n      0.0,\n      0.0,\n      0.0,\n      perceptualRoughness,\n      metallic,\n      specularEnvironmentR0,\n      specularEnvironmentR90,\n      alphaRoughness,\n      diffuseColor,\n      specularColor,\n      n,\n      v\n    );\n\n#ifdef USE_LIGHTS\n    PBRInfo_setAmbientLight(pbrInputs);\n    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {\n      if (i < lighting_uDirectionalLightCount) {\n        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);\n        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);\n      }\n    }\n    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {\n      if (i < lighting_uPointLightCount) {\n        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);\n        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));\n        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);\n      }\n    }\n#endif\n#ifdef USE_IBL\n    color += getIBLContribution(pbrInputs, n, reflection);\n#endif\n#ifdef HAS_OCCLUSIONMAP\n    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;\n    color = mix(color, color * ao, u_OcclusionStrength);\n#endif\n\n#ifdef HAS_EMISSIVEMAP\n    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;\n    color += emissive;\n#endif\n\n#ifdef PBR_DEBUG\n\n\n\n\n\n    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);\n    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);\n    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);\n#endif\n\n  }\n\n  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);\n}\n";
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js
var pbr;
var init_pbr = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/pbr/pbr.js"() {
    init_lights();
    init_pbr_vertex_glsl();
    init_pbr_fragment_glsl();
    pbr = {
      name: "pbr",
      vs: pbr_vertex_glsl_default,
      fs: pbr_fragment_glsl_default,
      defines: {
        LIGHTING_FRAGMENT: 1
      },
      dependencies: [lights]
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js
var init_tiltshift = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/tiltshift.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js
var init_triangleblur = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/triangleblur.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js
var init_zoomblur = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-blur-filters/zoomblur.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js
var init_brightnesscontrast = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/brightnesscontrast.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js
var init_denoise = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/denoise.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js
var init_huesaturation = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/huesaturation.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js
var init_noise = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/noise.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js
var init_sepia = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/sepia.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js
var init_vibrance = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vibrance.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js
var init_vignette = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-adjust-filters/vignette.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js
var uniforms;
var init_colorhalftone = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/colorhalftone.js"() {
    uniforms = {
      center: [0.5, 0.5],
      angle: {
        value: 1.1,
        softMin: 0,
        softMax: Math.PI / 2
      },
      size: {
        value: 4,
        min: 1,
        softMin: 3,
        softMax: 20
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js
var uniforms2;
var init_dotscreen = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/dotscreen.js"() {
    uniforms2 = {
      center: [0.5, 0.5],
      angle: {
        value: 1.1,
        softMin: 0,
        softMax: Math.PI / 2
      },
      size: {
        value: 3,
        min: 1,
        softMin: 3,
        softMax: 20
      }
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js
var init_edgework = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/edgework.js"() {
    init_random();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js
var init_hexagonalpixelate = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/hexagonalpixelate.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js
var init_ink = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/ink.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js
var init_magnify = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-fun-filters/magnify.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js
var init_warp = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/warp.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js
var init_bulgepinch = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/bulgepinch.js"() {
    init_warp();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js
var init_swirl = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/image-warp-filters/swirl.js"() {
    init_warp();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js
var init_fxaa = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js"() {
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
var vs4, transform;
var init_transform = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js"() {
    vs4 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
    transform = {
      name: "transform",
      vs: vs4,
      fs: null
    };
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/modules/index.js
var init_modules = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/modules/index.js"() {
    init_random();
    init_fp32();
    init_fp64();
    init_project();
    init_lights();
    init_dirlight();
    init_picking();
    init_phong_lighting();
    init_pbr();
    init_tiltshift();
    init_triangleblur();
    init_zoomblur();
    init_brightnesscontrast();
    init_denoise();
    init_huesaturation();
    init_noise();
    init_sepia();
    init_vibrance();
    init_vignette();
    init_colorhalftone();
    init_dotscreen();
    init_edgework();
    init_hexagonalpixelate();
    init_ink();
    init_magnify();
    init_bulgepinch();
    init_swirl();
    init_warp();
    init_fxaa();
    init_transform();
  }
});

// node_modules/@luma.gl/shadertools/dist/esm/index.js
var init_esm12 = __esm({
  "node_modules/@luma.gl/shadertools/dist/esm/index.js"() {
    init_assemble_shaders();
    init_inject_shader();
    init_shader_module();
    init_shader_utils();
    init_modules();
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
var ProgramManager;
var init_program_manager = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js"() {
    init_esm12();
    init_esm10();
    ProgramManager = class _ProgramManager {
      static getDefaultProgramManager(gl) {
        gl.luma = gl.luma || {};
        gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new _ProgramManager(gl);
        return gl.luma.defaultProgramManager;
      }
      constructor(gl) {
        this.gl = gl;
        this._programCache = {};
        this._getUniforms = {};
        this._registeredModules = {};
        this._hookFunctions = [];
        this._defaultModules = [];
        this._hashes = {};
        this._hashCounter = 0;
        this.stateHash = 0;
        this._useCounts = {};
      }
      addDefaultModule(module) {
        if (!this._defaultModules.find((m) => m.name === module.name)) {
          this._defaultModules.push(module);
        }
        this.stateHash++;
      }
      removeDefaultModule(module) {
        const moduleName = typeof module === "string" ? module : module.name;
        this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
        this.stateHash++;
      }
      addShaderHook(hook, opts) {
        if (opts) {
          hook = Object.assign(opts, {
            hook
          });
        }
        this._hookFunctions.push(hook);
        this.stateHash++;
      }
      get() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          vs: vs9 = "",
          fs: fs6 = "",
          defines = {},
          inject = {},
          varyings = [],
          bufferMode = 35981,
          transpileToGLSL100 = false
        } = props;
        const modules = this._getModuleList(props.modules);
        const vsHash = this._getHash(vs9);
        const fsHash = this._getHash(fs6);
        const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
        const varyingHashes = varyings.map((v) => this._getHash(v));
        const defineKeys = Object.keys(defines).sort();
        const injectKeys = Object.keys(inject).sort();
        const defineHashes = [];
        const injectHashes = [];
        for (const key of defineKeys) {
          defineHashes.push(this._getHash(key));
          defineHashes.push(this._getHash(defines[key]));
        }
        for (const key of injectKeys) {
          injectHashes.push(this._getHash(key));
          injectHashes.push(this._getHash(inject[key]));
        }
        const hash = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
        if (!this._programCache[hash]) {
          const assembled = assembleShaders(this.gl, {
            vs: vs9,
            fs: fs6,
            modules,
            inject,
            defines,
            hookFunctions: this._hookFunctions,
            transpileToGLSL100
          });
          this._programCache[hash] = new Program(this.gl, {
            hash,
            vs: assembled.vs,
            fs: assembled.fs,
            varyings,
            bufferMode
          });
          this._getUniforms[hash] = assembled.getUniforms || ((x) => {
          });
          this._useCounts[hash] = 0;
        }
        this._useCounts[hash]++;
        return this._programCache[hash];
      }
      getUniforms(program) {
        return this._getUniforms[program.hash] || null;
      }
      release(program) {
        const hash = program.hash;
        this._useCounts[hash]--;
        if (this._useCounts[hash] === 0) {
          this._programCache[hash].delete();
          delete this._programCache[hash];
          delete this._getUniforms[hash];
          delete this._useCounts[hash];
        }
      }
      _getHash(key) {
        if (this._hashes[key] === void 0) {
          this._hashes[key] = this._hashCounter++;
        }
        return this._hashes[key];
      }
      _getModuleList() {
        let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        const modules = new Array(this._defaultModules.length + appModules.length);
        const seen = {};
        let count4 = 0;
        for (let i = 0, len2 = this._defaultModules.length; i < len2; ++i) {
          const module = this._defaultModules[i];
          const name = module.name;
          modules[count4++] = module;
          seen[name] = true;
        }
        for (let i = 0, len2 = appModules.length; i < len2; ++i) {
          const module = appModules[i];
          const name = module.name;
          if (!seen[name]) {
            modules[count4++] = module;
            seen[name] = true;
          }
        }
        modules.length = count4;
        return modules;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;
  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);
    if (name === "indices") {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      const accessor = {
        ...attribute
      };
      delete accessor.value;
      buffers[remappedName] = [new Buffer(gl, typedArray), accessor];
      inferAttributeAccessor(name, accessor);
    }
  }
  if (indices) {
    const data = indices.value || indices;
    assert7(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
    };
    buffers.indices = [new Buffer(gl, {
      data,
      target: 34963
    }), accessor];
  }
  return buffers;
}
function mapAttributeName(name, options) {
  const {
    attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
  } = options || {};
  return attributeMap && attributeMap[name] || name;
}
function inferAttributeAccessor(attributeName, attribute) {
  let category;
  switch (attributeName) {
    case "texCoords":
    case "texCoord1":
    case "texCoord2":
    case "texCoord3":
      category = "uvs";
      break;
    case "vertices":
    case "positions":
    case "normals":
    case "pickingColors":
      category = "vectors";
      break;
    default:
  }
  switch (category) {
    case "vectors":
      attribute.size = attribute.size || 3;
      break;
    case "uvs":
      attribute.size = attribute.size || 2;
      break;
    default:
  }
  assert7(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
}
var GLTF_TO_LUMA_ATTRIBUTE_MAP;
var init_model_utils = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js"() {
    init_esm10();
    GLTF_TO_LUMA_ATTRIBUTE_MAP = {
      POSITION: "positions",
      NORMAL: "normals",
      COLOR_0: "colors",
      TEXCOORD_0: "texCoords",
      TEXCOORD_1: "texCoords1",
      TEXCOORD_2: "texCoords2"
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/lib/model.js
var LOG_DRAW_PRIORITY, LOG_DRAW_TIMEOUT, ERR_MODEL_PARAMS, NOOP, DRAW_PARAMS, Model;
var init_model = __esm({
  "node_modules/@luma.gl/engine/dist/esm/lib/model.js"() {
    init_esm9();
    init_program_manager();
    init_esm10();
    init_esm10();
    init_model_utils();
    LOG_DRAW_PRIORITY = 2;
    LOG_DRAW_TIMEOUT = 1e4;
    ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
    NOOP = () => {
    };
    DRAW_PARAMS = {};
    Model = class {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          id = uid("model")
        } = props;
        assert7(isWebGL(gl));
        this.id = id;
        this.gl = gl;
        this.id = props.id || uid("Model");
        this.lastLogTime = 0;
        this.animated = false;
        this.initialize(props);
      }
      initialize(props) {
        this.props = {};
        this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
        this._programManagerState = -1;
        this._managedProgram = false;
        const {
          program = null,
          vs: vs9,
          fs: fs6,
          modules,
          defines,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = props;
        this.programProps = {
          program,
          vs: vs9,
          fs: fs6,
          modules,
          defines,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        };
        this.program = null;
        this.vertexArray = null;
        this._programDirty = true;
        this.userData = {};
        this.needsRedraw = true;
        this._attributes = {};
        this.attributes = {};
        this.uniforms = {};
        this.pickable = true;
        this._checkProgram();
        this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
        this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
        this.vertexCount = props.vertexCount || 0;
        this.geometryBuffers = {};
        this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
        this._setModelProps(props);
        this.geometry = {};
        assert7(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
      }
      setProps(props) {
        this._setModelProps(props);
      }
      delete() {
        for (const key in this._attributes) {
          if (this._attributes[key] !== this.attributes[key]) {
            this._attributes[key].delete();
          }
        }
        if (this._managedProgram) {
          this.programManager.release(this.program);
          this._managedProgram = false;
        }
        this.vertexArray.delete();
        this._deleteGeometryBuffers();
      }
      getDrawMode() {
        return this.drawMode;
      }
      getVertexCount() {
        return this.vertexCount;
      }
      getInstanceCount() {
        return this.instanceCount;
      }
      getAttributes() {
        return this.attributes;
      }
      getProgram() {
        return this.program;
      }
      setProgram(props) {
        const {
          program,
          vs: vs9,
          fs: fs6,
          modules,
          defines,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = props;
        this.programProps = {
          program,
          vs: vs9,
          fs: fs6,
          modules,
          defines,
          inject,
          varyings,
          bufferMode,
          transpileToGLSL100
        };
        this._programDirty = true;
      }
      getUniforms() {
        return this.uniforms;
      }
      setDrawMode(drawMode) {
        this.drawMode = drawMode;
        return this;
      }
      setVertexCount(vertexCount) {
        assert7(Number.isFinite(vertexCount));
        this.vertexCount = vertexCount;
        return this;
      }
      setInstanceCount(instanceCount) {
        assert7(Number.isFinite(instanceCount));
        this.instanceCount = instanceCount;
        return this;
      }
      setGeometry(geometry) {
        this.drawMode = geometry.drawMode;
        this.vertexCount = geometry.getVertexCount();
        this._deleteGeometryBuffers();
        this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
        this.vertexArray.setAttributes(this.geometryBuffers);
        return this;
      }
      setAttributes() {
        let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (isObjectEmpty2(attributes)) {
          return this;
        }
        const normalizedAttributes = {};
        for (const name in attributes) {
          const attribute = attributes[name];
          normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
        }
        this.vertexArray.setAttributes(normalizedAttributes);
        return this;
      }
      setUniforms() {
        let uniforms3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        Object.assign(this.uniforms, uniforms3);
        return this;
      }
      getModuleUniforms(opts) {
        this._checkProgram();
        const getUniforms9 = this.programManager.getUniforms(this.program);
        if (getUniforms9) {
          return getUniforms9(opts);
        }
        return {};
      }
      updateModuleSettings(opts) {
        const uniforms3 = this.getModuleUniforms(opts || {});
        return this.setUniforms(uniforms3);
      }
      clear(opts) {
        clear(this.program.gl, opts);
        return this;
      }
      draw() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._checkProgram();
        const {
          moduleSettings = null,
          framebuffer,
          uniforms: uniforms3 = {},
          attributes = {},
          transformFeedback = this.transformFeedback,
          parameters = {},
          vertexArray = this.vertexArray
        } = opts;
        this.setAttributes(attributes);
        this.updateModuleSettings(moduleSettings);
        this.setUniforms(uniforms3);
        let logPriority;
        if (log.priority >= LOG_DRAW_PRIORITY) {
          logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
        }
        const drawParams = this.vertexArray.getDrawParams();
        const {
          isIndexed = drawParams.isIndexed,
          indexType = drawParams.indexType,
          indexOffset = drawParams.indexOffset,
          vertexArrayInstanced = drawParams.isInstanced
        } = this.props;
        if (vertexArrayInstanced && !this.isInstanced) {
          log.warn("Found instanced attributes on non-instanced model", this.id)();
        }
        const {
          isInstanced,
          instanceCount
        } = this;
        const {
          onBeforeRender = NOOP,
          onAfterRender = NOOP
        } = this.props;
        onBeforeRender();
        this.program.setUniforms(this.uniforms);
        const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
          logPriority,
          uniforms: null,
          framebuffer,
          parameters,
          drawMode: this.getDrawMode(),
          vertexCount: this.getVertexCount(),
          vertexArray,
          transformFeedback,
          isIndexed,
          indexType,
          isInstanced,
          instanceCount,
          offset: isIndexed ? indexOffset : 0
        }));
        onAfterRender();
        if (log.priority >= LOG_DRAW_PRIORITY) {
          this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
        }
        return didDraw;
      }
      transform() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          discard = true,
          feedbackBuffers,
          unbindModels = []
        } = opts;
        let {
          parameters
        } = opts;
        if (feedbackBuffers) {
          this._setFeedbackBuffers(feedbackBuffers);
        }
        if (discard) {
          parameters = Object.assign({}, parameters, {
            [35977]: discard
          });
        }
        unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
        try {
          this.draw(Object.assign({}, opts, {
            parameters
          }));
        } finally {
          unbindModels.forEach((model) => model.vertexArray.bindBuffers());
        }
        return this;
      }
      render() {
        let uniforms3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        log.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
        return this.setUniforms(uniforms3).draw();
      }
      _setModelProps(props) {
        Object.assign(this.props, props);
        if ("uniforms" in props) {
          this.setUniforms(props.uniforms);
        }
        if ("pickable" in props) {
          this.pickable = props.pickable;
        }
        if ("instanceCount" in props) {
          this.instanceCount = props.instanceCount;
        }
        if ("geometry" in props) {
          this.setGeometry(props.geometry);
        }
        if ("attributes" in props) {
          this.setAttributes(props.attributes);
        }
        if ("_feedbackBuffers" in props) {
          this._setFeedbackBuffers(props._feedbackBuffers);
        }
      }
      _checkProgram() {
        const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
        if (!needsUpdate) {
          return;
        }
        let {
          program
        } = this.programProps;
        if (program) {
          this._managedProgram = false;
        } else {
          const {
            vs: vs9,
            fs: fs6,
            modules,
            inject,
            defines,
            varyings,
            bufferMode,
            transpileToGLSL100
          } = this.programProps;
          program = this.programManager.get({
            vs: vs9,
            fs: fs6,
            modules,
            inject,
            defines,
            varyings,
            bufferMode,
            transpileToGLSL100
          });
          if (this.program && this._managedProgram) {
            this.programManager.release(this.program);
          }
          this._programManagerState = this.programManager.stateHash;
          this._managedProgram = true;
        }
        assert7(program instanceof Program, "Model needs a program");
        this._programDirty = false;
        if (program === this.program) {
          return;
        }
        this.program = program;
        if (this.vertexArray) {
          this.vertexArray.setProps({
            program: this.program,
            attributes: this.vertexArray.attributes
          });
        } else {
          this.vertexArray = new VertexArray(this.gl, {
            program: this.program
          });
        }
        this.setUniforms(Object.assign({}, this.getModuleUniforms()));
      }
      _deleteGeometryBuffers() {
        for (const name in this.geometryBuffers) {
          const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
          if (buffer instanceof Buffer) {
            buffer.delete();
          }
        }
      }
      _setAnimationProps(animationProps) {
        if (this.animated) {
          assert7(animationProps, "Model.draw(): animated uniforms but no animationProps");
        }
      }
      _setFeedbackBuffers() {
        let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (isObjectEmpty2(feedbackBuffers)) {
          return this;
        }
        const {
          gl
        } = this.program;
        this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
          program: this.program
        });
        this.transformFeedback.setBuffers(feedbackBuffers);
        return this;
      }
      _logDrawCallStart(logLevel) {
        const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
        if (Date.now() - this.lastLogTime < logDrawTimeout) {
          return void 0;
        }
        this.lastLogTime = Date.now();
        log.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
          collapsed: log.level <= 2
        })();
        return logLevel;
      }
      _logDrawCallEnd(logLevel, vertexArray, uniforms3, framebuffer) {
        if (logLevel === void 0) {
          return;
        }
        const attributeTable = getDebugTableForVertexArray({
          vertexArray,
          header: "".concat(this.id, " attributes"),
          attributes: this._attributes
        });
        const {
          table: uniformTable,
          unusedTable,
          unusedCount
        } = getDebugTableForUniforms({
          header: "".concat(this.id, " uniforms"),
          program: this.program,
          uniforms: Object.assign({}, this.program.uniforms, uniforms3)
        });
        const {
          table: missingTable,
          count: missingCount
        } = getDebugTableForUniforms({
          header: "".concat(this.id, " uniforms"),
          program: this.program,
          uniforms: Object.assign({}, this.program.uniforms, uniforms3),
          undefinedOnly: true
        });
        if (missingCount > 0) {
          log.log("MISSING UNIFORMS", Object.keys(missingTable))();
        }
        if (unusedCount > 0) {
          log.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
        }
        const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
        log.table(logLevel, attributeTable)();
        log.table(logLevel, uniformTable)();
        log.table(logLevel + 1, configTable)();
        if (framebuffer) {
          framebuffer.log({
            logLevel: LOG_DRAW_PRIORITY,
            message: "Rendered to ".concat(framebuffer.id)
          });
        }
        log.groupEnd(LOG_DRAW_PRIORITY)();
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
var BufferTransform;
var init_buffer_transform = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js"() {
    init_esm9();
    init_esm10();
    init_esm10();
    BufferTransform = class {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.currentIndex = 0;
        this.feedbackMap = {};
        this.varyings = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
      }
      setupResources(opts) {
        for (const binding of this.bindings) {
          this._setupTransformFeedback(binding, opts);
        }
      }
      updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          varyings
        } = this;
        if (varyings.length > 0) {
          props = Object.assign({}, props, {
            varyings
          });
        }
        return props;
      }
      getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const binding = this.bindings[this.currentIndex];
        const {
          sourceBuffers,
          transformFeedback
        } = binding;
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        return {
          attributes,
          transformFeedback
        };
      }
      swap() {
        if (this.feedbackMap) {
          this.currentIndex = this._getNextIndex();
          return true;
        }
        return false;
      }
      update() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupBuffers(opts);
      }
      getBuffer(varyingName) {
        const {
          feedbackBuffers
        } = this.bindings[this.currentIndex];
        const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
        if (!bufferOrParams) {
          return null;
        }
        return bufferOrParams instanceof Buffer ? bufferOrParams : bufferOrParams.buffer;
      }
      getData() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          varyingName
        } = options;
        const buffer = this.getBuffer(varyingName);
        if (buffer) {
          return buffer.getData();
        }
        return null;
      }
      delete() {
        for (const name in this.resources) {
          this.resources[name].delete();
        }
      }
      _initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupBuffers(props);
        this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
        if (this.varyings.length > 0) {
          assert7(isWebGL2(this.gl));
        }
      }
      _getFeedbackBuffers(props) {
        const {
          sourceBuffers = {}
        } = props;
        const feedbackBuffers = {};
        if (this.bindings[this.currentIndex]) {
          Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
        }
        if (this.feedbackMap) {
          for (const sourceName in this.feedbackMap) {
            const feedbackName = this.feedbackMap[sourceName];
            if (sourceName in sourceBuffers) {
              feedbackBuffers[feedbackName] = sourceName;
            }
          }
        }
        Object.assign(feedbackBuffers, props.feedbackBuffers);
        for (const bufferName in feedbackBuffers) {
          const bufferOrRef = feedbackBuffers[bufferName];
          if (typeof bufferOrRef === "string") {
            const sourceBuffer = sourceBuffers[bufferOrRef];
            const {
              byteLength,
              usage,
              accessor
            } = sourceBuffer;
            feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
              byteLength,
              usage,
              accessor
            });
          }
        }
        return feedbackBuffers;
      }
      _setupBuffers() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceBuffers = null
        } = props;
        Object.assign(this.feedbackMap, props.feedbackMap);
        const feedbackBuffers = this._getFeedbackBuffers(props);
        this._updateBindings({
          sourceBuffers,
          feedbackBuffers
        });
      }
      _setupTransformFeedback(binding, _ref) {
        let {
          model
        } = _ref;
        const {
          program
        } = model;
        binding.transformFeedback = new TransformFeedback(this.gl, {
          program,
          buffers: binding.feedbackBuffers
        });
      }
      _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this.feedbackMap) {
          const {
            sourceBuffers,
            feedbackBuffers
          } = this._swapBuffers(this.bindings[this.currentIndex]);
          const nextIndex = this._getNextIndex();
          this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
            sourceBuffers,
            feedbackBuffers
          });
        }
      }
      _updateBinding(binding, opts) {
        if (!binding) {
          return {
            sourceBuffers: Object.assign({}, opts.sourceBuffers),
            feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
          };
        }
        Object.assign(binding.sourceBuffers, opts.sourceBuffers);
        Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
        if (binding.transformFeedback) {
          binding.transformFeedback.setBuffers(binding.feedbackBuffers);
        }
        return binding;
      }
      _swapBuffers(opts) {
        if (!this.feedbackMap) {
          return null;
        }
        const sourceBuffers = Object.assign({}, opts.sourceBuffers);
        const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
        for (const srcName in this.feedbackMap) {
          const dstName = this.feedbackMap[srcName];
          sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
          feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
          assert7(feedbackBuffers[dstName] instanceof Buffer);
        }
        return {
          sourceBuffers,
          feedbackBuffers
        };
      }
      _createNewBuffer(name, opts) {
        const buffer = new Buffer(this.gl, opts);
        if (this.resources[name]) {
          this.resources[name].delete();
        }
        this.resources[name] = buffer;
        return buffer;
      }
      _getNextIndex() {
        return (this.currentIndex + 1) % 2;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
function updateForTextures(_ref) {
  let {
    vs: vs9,
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref;
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs9;
  let finalInject = {};
  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split("\n");
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);
        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = combineInjects([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }
      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });
    if (targetTextureVarying) {
      assert7(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        "vs:#decl": uniformDeclaration,
        "vs:#main-start": posInstructions
      };
      finalInject = combineInjects([finalInject, inject]);
    }
    updatedVs = updateVsLines.join("\n");
  }
  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms(_ref2) {
  let {
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref2;
  const uniforms3 = {};
  let width;
  let height;
  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms3["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }
  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms3["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }
  return uniforms3;
}
function getAttributeDefinition(line) {
  return getQualifierDetails(line, ["attribute", "in"]);
}
function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}
function getVaryingType(line, varying) {
  const qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
  if (!qualaiferDetails) {
    return null;
  }
  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);
  if (!attributeData) {
    return null;
  }
  const {
    type,
    name
  } = attributeData;
  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = typeToChannelSuffix(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      "vs:#decl": uniformDeclerations,
      "vs:#main-start": sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }
  return null;
}
var SAMPLER_UNIFORM_PREFIX, SIZE_UNIFORM_PREFIX, VS_POS_VARIABLE;
var init_transform_shader_utils = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js"() {
    init_esm10();
    init_esm12();
    SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
    SIZE_UNIFORM_PREFIX = "transform_uSize_";
    VS_POS_VARIABLE = "transform_position";
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
var SRC_TEX_PARAMETER_OVERRIDES, FS_OUTPUT_VARIABLE, TextureTransform;
var init_texture_transform = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js"() {
    init_esm10();
    init_esm12();
    init_transform_shader_utils();
    SRC_TEX_PARAMETER_OVERRIDES = {
      [10241]: 9728,
      [10240]: 9728,
      [10242]: 33071,
      [10243]: 33071
    };
    FS_OUTPUT_VARIABLE = "transform_output";
    TextureTransform = class {
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.id = this.currentIndex = 0;
        this._swapTexture = null;
        this.targetTextureVarying = null;
        this.targetTextureType = null;
        this.samplerTextureMap = null;
        this.bindings = [];
        this.resources = {};
        this._initialize(props);
        Object.seal(this);
      }
      updateModelProps() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const updatedModelProps = this._processVertexShader(props);
        return Object.assign({}, props, updatedModelProps);
      }
      getDrawOptions() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceBuffers,
          sourceTextures,
          framebuffer,
          targetTexture
        } = this.bindings[this.currentIndex];
        const attributes = Object.assign({}, sourceBuffers, opts.attributes);
        const uniforms3 = Object.assign({}, opts.uniforms);
        const parameters = Object.assign({}, opts.parameters);
        let discard = opts.discard;
        if (this.hasSourceTextures || this.hasTargetTexture) {
          attributes.transform_elementID = this.elementIDBuffer;
          for (const sampler in this.samplerTextureMap) {
            const textureName = this.samplerTextureMap[sampler];
            uniforms3[sampler] = sourceTextures[textureName];
          }
          this._setSourceTextureParameters();
          const sizeUniforms = getSizeUniforms({
            sourceTextureMap: sourceTextures,
            targetTextureVarying: this.targetTextureVarying,
            targetTexture
          });
          Object.assign(uniforms3, sizeUniforms);
        }
        if (this.hasTargetTexture) {
          discard = false;
          parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
        }
        return {
          attributes,
          framebuffer,
          uniforms: uniforms3,
          discard,
          parameters
        };
      }
      swap() {
        if (this._swapTexture) {
          this.currentIndex = this._getNextIndex();
          return true;
        }
        return false;
      }
      update() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this._setupTextures(opts);
      }
      getTargetTexture() {
        const {
          targetTexture
        } = this.bindings[this.currentIndex];
        return targetTexture;
      }
      getData() {
        let {
          packed = false
        } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          framebuffer
        } = this.bindings[this.currentIndex];
        const pixels = readPixelsToArray(framebuffer);
        if (!packed) {
          return pixels;
        }
        const ArrayType = pixels.constructor;
        const channelCount = typeToChannelCount(this.targetTextureType);
        const packedPixels = new ArrayType(pixels.length * channelCount / 4);
        let packCount = 0;
        for (let i = 0; i < pixels.length; i += 4) {
          for (let j = 0; j < channelCount; j++) {
            packedPixels[packCount++] = pixels[i + j];
          }
        }
        return packedPixels;
      }
      getFramebuffer() {
        const currentResources = this.bindings[this.currentIndex];
        return currentResources.framebuffer;
      }
      delete() {
        if (this.ownTexture) {
          this.ownTexture.delete();
        }
        if (this.elementIDBuffer) {
          this.elementIDBuffer.delete();
        }
      }
      _initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          _targetTextureVarying,
          _swapTexture
        } = props;
        this._swapTexture = _swapTexture;
        this.targetTextureVarying = _targetTextureVarying;
        this.hasTargetTexture = _targetTextureVarying;
        this._setupTextures(props);
      }
      _createTargetTexture(props) {
        const {
          sourceTextures,
          textureOrReference
        } = props;
        if (textureOrReference instanceof Texture2D) {
          return textureOrReference;
        }
        const refTexture = sourceTextures[textureOrReference];
        if (!refTexture) {
          return null;
        }
        this._targetRefTexName = textureOrReference;
        return this._createNewTexture(refTexture);
      }
      _setupTextures() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceBuffers,
          _sourceTextures = {},
          _targetTexture
        } = props;
        const targetTexture = this._createTargetTexture({
          sourceTextures: _sourceTextures,
          textureOrReference: _targetTexture
        });
        this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
        this._updateBindings({
          sourceBuffers,
          sourceTextures: _sourceTextures,
          targetTexture
        });
        if ("elementCount" in props) {
          this._updateElementIDBuffer(props.elementCount);
        }
      }
      _updateElementIDBuffer(elementCount) {
        if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
          return;
        }
        const elementIds = new Float32Array(elementCount);
        elementIds.forEach((_, index, array) => {
          array[index] = index;
        });
        if (!this.elementIDBuffer) {
          this.elementIDBuffer = new Buffer(this.gl, {
            data: elementIds,
            accessor: {
              size: 1
            }
          });
        } else {
          this.elementIDBuffer.setData({
            data: elementIds
          });
        }
        this.elementCount = elementCount;
      }
      _updateBindings(opts) {
        this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
        if (this._swapTexture) {
          const {
            sourceTextures,
            targetTexture
          } = this._swapTextures(this.bindings[this.currentIndex]);
          const nextIndex = this._getNextIndex();
          this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
            sourceTextures,
            targetTexture
          });
        }
      }
      _updateBinding(binding, opts) {
        const {
          sourceBuffers,
          sourceTextures,
          targetTexture
        } = opts;
        if (!binding) {
          binding = {
            sourceBuffers: {},
            sourceTextures: {},
            targetTexture: null
          };
        }
        Object.assign(binding.sourceTextures, sourceTextures);
        Object.assign(binding.sourceBuffers, sourceBuffers);
        if (targetTexture) {
          binding.targetTexture = targetTexture;
          const {
            width,
            height
          } = targetTexture;
          const {
            framebuffer
          } = binding;
          if (framebuffer) {
            framebuffer.update({
              attachments: {
                [36064]: targetTexture
              },
              resizeAttachments: false
            });
            framebuffer.resize({
              width,
              height
            });
          } else {
            binding.framebuffer = new Framebuffer(this.gl, {
              id: "transform-framebuffer",
              width,
              height,
              attachments: {
                [36064]: targetTexture
              }
            });
          }
        }
        return binding;
      }
      _setSourceTextureParameters() {
        const index = this.currentIndex;
        const {
          sourceTextures
        } = this.bindings[index];
        for (const name in sourceTextures) {
          sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
        }
      }
      _swapTextures(opts) {
        if (!this._swapTexture) {
          return null;
        }
        const sourceTextures = Object.assign({}, opts.sourceTextures);
        sourceTextures[this._swapTexture] = opts.targetTexture;
        const targetTexture = opts.sourceTextures[this._swapTexture];
        return {
          sourceTextures,
          targetTexture
        };
      }
      _createNewTexture(refTexture) {
        const texture = cloneTextureFrom(refTexture, {
          parameters: {
            [10241]: 9728,
            [10240]: 9728,
            [10242]: 33071,
            [10243]: 33071
          },
          pixelStore: {
            [37440]: false
          }
        });
        if (this.ownTexture) {
          this.ownTexture.delete();
        }
        this.ownTexture = texture;
        return texture;
      }
      _getNextIndex() {
        return (this.currentIndex + 1) % 2;
      }
      _processVertexShader() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          sourceTextures,
          targetTexture
        } = this.bindings[this.currentIndex];
        const {
          vs: vs9,
          uniforms: uniforms3,
          targetTextureType,
          inject,
          samplerTextureMap
        } = updateForTextures({
          vs: props.vs,
          sourceTextureMap: sourceTextures,
          targetTextureVarying: this.targetTextureVarying,
          targetTexture
        });
        const combinedInject = combineInjects([props.inject || {}, inject]);
        this.targetTextureType = targetTextureType;
        this.samplerTextureMap = samplerTextureMap;
        const fs6 = props._fs || getPassthroughFS({
          version: getShaderVersion(vs9),
          input: this.targetTextureVarying,
          inputType: targetTextureType,
          output: FS_OUTPUT_VARIABLE
        });
        const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
        return {
          vs: vs9,
          fs: fs6,
          modules,
          uniforms: uniforms3,
          inject: combinedInject
        };
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/transform/transform.js
function canCreateBufferTransform(props) {
  if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }
  return false;
}
function canCreateTextureTransform(props) {
  if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }
  return false;
}
var Transform;
var init_transform2 = __esm({
  "node_modules/@luma.gl/engine/dist/esm/transform/transform.js"() {
    init_esm12();
    init_buffer_transform();
    init_texture_transform();
    init_esm9();
    init_esm10();
    init_model();
    Transform = class {
      static isSupported(gl) {
        return isWebGL2(gl);
      }
      constructor(gl) {
        let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.gl = gl;
        this.model = null;
        this.elementCount = 0;
        this.bufferTransform = null;
        this.textureTransform = null;
        this.elementIDBuffer = null;
        this._initialize(props);
        Object.seal(this);
      }
      delete() {
        const {
          model,
          bufferTransform,
          textureTransform
        } = this;
        if (model) {
          model.delete();
        }
        if (bufferTransform) {
          bufferTransform.delete();
        }
        if (textureTransform) {
          textureTransform.delete();
        }
      }
      run() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          clearRenderTarget = true
        } = opts;
        const updatedOpts = this._updateDrawOptions(opts);
        if (clearRenderTarget && updatedOpts.framebuffer) {
          updatedOpts.framebuffer.clear({
            color: true
          });
        }
        this.model.transform(updatedOpts);
      }
      swap() {
        let swapped = false;
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          swapped = swapped || resourceTransform.swap();
        }
        assert7(swapped, "Nothing to swap");
      }
      getBuffer() {
        let varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
      }
      getData() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          const data = resourceTransform.getData(opts);
          if (data) {
            return data;
          }
        }
        return null;
      }
      getFramebuffer() {
        return this.textureTransform && this.textureTransform.getFramebuffer();
      }
      update() {
        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if ("elementCount" in opts) {
          this.model.setVertexCount(opts.elementCount);
        }
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          resourceTransform.update(opts);
        }
      }
      _initialize() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          gl
        } = this;
        this._buildResourceTransforms(gl, props);
        props = this._updateModelProps(props);
        this.model = new Model(gl, Object.assign({}, props, {
          fs: props.fs || getPassthroughFS({
            version: getShaderVersion(props.vs)
          }),
          id: props.id || "transform-model",
          drawMode: props.drawMode || 0,
          vertexCount: props.elementCount
        }));
        this.bufferTransform && this.bufferTransform.setupResources({
          model: this.model
        });
      }
      _updateModelProps(props) {
        let updatedProps = Object.assign({}, props);
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          updatedProps = resourceTransform.updateModelProps(updatedProps);
        }
        return updatedProps;
      }
      _buildResourceTransforms(gl, props) {
        if (canCreateBufferTransform(props)) {
          this.bufferTransform = new BufferTransform(gl, props);
        }
        if (canCreateTextureTransform(props)) {
          this.textureTransform = new TextureTransform(gl, props);
        }
        assert7(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
      }
      _updateDrawOptions(opts) {
        let updatedOpts = Object.assign({}, opts);
        const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
        for (const resourceTransform of resourceTransforms) {
          updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
        }
        return updatedOpts;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
var DRAW_MODE, Geometry;
var init_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js"() {
    init_esm10();
    DRAW_MODE = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    };
    Geometry = class {
      static get DRAW_MODE() {
        return DRAW_MODE;
      }
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("geometry"),
          drawMode = DRAW_MODE.TRIANGLES,
          attributes = {},
          indices = null,
          vertexCount = null
        } = props;
        this.id = id;
        this.drawMode = drawMode | 0;
        this.attributes = {};
        this.userData = {};
        this._setAttributes(attributes, indices);
        this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
      }
      get mode() {
        return this.drawMode;
      }
      getVertexCount() {
        return this.vertexCount;
      }
      getAttributes() {
        return this.indices ? {
          indices: this.indices,
          ...this.attributes
        } : this.attributes;
      }
      _print(attributeName) {
        return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
      }
      _setAttributes(attributes, indices) {
        if (indices) {
          this.indices = ArrayBuffer.isView(indices) ? {
            value: indices,
            size: 1
          } : indices;
        }
        for (const attributeName in attributes) {
          let attribute = attributes[attributeName];
          attribute = ArrayBuffer.isView(attribute) ? {
            value: attribute
          } : attribute;
          assert7(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
          if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
            attribute.size = 3;
          }
          if (attributeName === "indices") {
            assert7(!this.indices);
            this.indices = attribute;
          } else {
            this.attributes[attributeName] = attribute;
          }
        }
        if (this.indices && this.indices.isIndexed !== void 0) {
          this.indices = Object.assign({}, this.indices);
          delete this.indices.isIndexed;
        }
        return this;
      }
      _calculateVertexCount(attributes, indices) {
        if (indices) {
          return indices.value.length;
        }
        let vertexCount = Infinity;
        for (const attributeName in attributes) {
          const attribute = attributes[attributeName];
          const {
            value: value4,
            size,
            constant
          } = attribute;
          if (!constant && value4 && size >= 1) {
            vertexCount = Math.min(vertexCount, value4.length / size);
          }
        }
        assert7(Number.isFinite(vertexCount));
        return vertexCount;
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js
function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = "y",
    topCap = false,
    bottomCap = false
  } = props;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;
  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  let i3 = 0;
  let i2 = 0;
  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;
    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }
    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin2 = msin(j * mpi * 2 / nradial);
      const cos2 = mcos(j * mpi * 2 / nradial);
      positions[i3 + indexOffset[0]] = sin2 * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos2 * ringRadius;
      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin2 * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos2 * cosSlant;
      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;
      i2 += 2;
      i3 += 3;
    }
  }
  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
var INDEX_OFFSETS, TruncatedConeGeometry;
var init_truncated_cone_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/truncated-cone-geometry.js"() {
    init_geometry();
    init_esm10();
    INDEX_OFFSETS = {
      x: [2, 0, 1],
      y: [0, 1, 2],
      z: [1, 2, 0]
    };
    TruncatedConeGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("truncated-code-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateTruncatedCone(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js
var ConeGeometry;
var init_cone_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/cone-geometry.js"() {
    init_truncated_cone_geometry();
    init_esm10();
    ConeGeometry = class extends TruncatedConeGeometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("cone-geometry"),
          radius = 1,
          cap = true
        } = props;
        super({
          ...props,
          id,
          topRadius: 0,
          topCap: Boolean(cap),
          bottomCap: Boolean(cap),
          bottomRadius: radius
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js
var CUBE_INDICES, CUBE_POSITIONS, CUBE_NORMALS, CUBE_TEX_COORDS, ATTRIBUTES, CubeGeometry;
var init_cube_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/cube-geometry.js"() {
    init_geometry();
    init_esm10();
    CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
    CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
    CUBE_NORMALS = new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
    CUBE_TEX_COORDS = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);
    ATTRIBUTES = {
      POSITION: {
        size: 3,
        value: new Float32Array(CUBE_POSITIONS)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(CUBE_NORMALS)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(CUBE_TEX_COORDS)
      }
    };
    CubeGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("cube-geometry")
        } = props;
        super({
          ...props,
          id,
          indices: {
            size: 1,
            value: new Uint16Array(CUBE_INDICES)
          },
          attributes: {
            ...ATTRIBUTES,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js
var CylinderGeometry;
var init_cylinder_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/cylinder-geometry.js"() {
    init_truncated_cone_geometry();
    init_esm10();
    CylinderGeometry = class extends TruncatedConeGeometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("cylinder-geometry"),
          radius = 1
        } = props;
        super({
          ...props,
          id,
          bottomRadius: radius,
          topRadius: radius
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js
function tesselateIcosaHedron(props) {
  const {
    iterations = 0
  } = props;
  const PI2 = Math.PI;
  const PI22 = PI2 * 2;
  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];
  positions.push();
  indices.push();
  const getMiddlePoint = (() => {
    const pointMemo = {};
    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = "".concat(mini, "|").concat(maxi);
      if (key in pointMemo) {
        return pointMemo[key];
      }
      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len2 = Math.sqrt(xm * xm + ym * ym + zm * zm);
      xm /= len2;
      ym /= len2;
      zm /= len2;
      positions.push(xm, ym, zm);
      return pointMemo[key] = positions.length / 3 - 1;
    };
  })();
  for (let i = 0; i < iterations; i++) {
    const indices2 = [];
    for (let j = 0; j < indices.length; j += 3) {
      const a2 = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);
      indices2.push(c, indices[j + 0], a2, a2, indices[j + 1], b, b, indices[j + 2], c, a2, b, c);
    }
    indices = indices2;
  }
  const normals = new Array(positions.length);
  const texCoords = new Array(positions.length / 3 * 2);
  const l = indices.length;
  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI2;
    const v1 = theta1 / PI2;
    const u1 = 1 - phi1 / PI22;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI2;
    const v2 = theta2 / PI2;
    const u2 = 1 - phi2 / PI22;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI2;
    const v3 = theta3 / PI2;
    const u3 = 1 - phi3 / PI22;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new Vector3(vec1).cross(vec2).normalize();
    let newIndex;
    if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }
    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;
    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;
    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }
  return {
    indices: {
      size: 1,
      value: new Uint16Array(indices)
    },
    attributes: {
      POSITION: {
        size: 3,
        value: new Float32Array(positions)
      },
      NORMAL: {
        size: 3,
        value: new Float32Array(normals)
      },
      TEXCOORD_0: {
        size: 2,
        value: new Float32Array(texCoords)
      }
    }
  };
}
var ICO_POSITIONS, ICO_INDICES, IcoSphereGeometry;
var init_ico_sphere_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/ico-sphere-geometry.js"() {
    init_esm11();
    init_geometry();
    init_esm10();
    ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
    ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];
    IcoSphereGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("ico-sphere-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateIcosaHedron(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js
function unpackIndexedGeometry(geometry) {
  const {
    indices,
    attributes
  } = geometry;
  if (!indices) {
    return geometry;
  }
  const vertexCount = indices.value.length;
  const unpackedAttributes = {};
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {
      constant,
      value: value4,
      size
    } = attribute;
    if (constant || !size) {
      continue;
    }
    const unpackedValue = new value4.constructor(vertexCount * size);
    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];
      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value4[index * size + i];
      }
    }
    unpackedAttributes[attributeName] = {
      size,
      value: unpackedValue
    };
  }
  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}
var init_geometry_utils = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometry/geometry-utils.js"() {
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js
function tesselatePlane(props) {
  const {
    type = "x,y",
    offset = 0,
    flipCull = false,
    unpack = false
  } = props;
  const coords = type.split(",");
  let c1len = props["".concat(coords[0], "len")] || 1;
  const c2len = props["".concat(coords[1], "len")] || 1;
  const subdivisions1 = props["n".concat(coords[0])] || 1;
  const subdivisions2 = props["n".concat(coords[1])] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  if (flipCull) {
    c1len = -c1len;
  }
  let i2 = 0;
  let i3 = 0;
  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;
      switch (type) {
        case "x,y":
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;
        case "x,z":
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;
        case "y,z":
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;
          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;
        default:
          throw new Error("PlaneGeometry: unknown type");
      }
      i2 += 2;
      i3 += 3;
    }
  }
  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);
  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }
  const geometry = {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
  return unpack ? unpackIndexedGeometry(geometry) : geometry;
}
var PlaneGeometry;
var init_plane_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/plane-geometry.js"() {
    init_geometry();
    init_geometry_utils();
    init_esm10();
    PlaneGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("plane-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselatePlane(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js
function tesselateSphere(props) {
  const {
    nlat = 10,
    nlong = 10
  } = props;
  let {
    radius = 1
  } = props;
  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);
  if (typeof radius === "number") {
    const value4 = radius;
    radius = (n1, n2, n3, u, v) => value4;
  }
  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const IndexType = numVertices > 65535 ? Uint32Array : Uint16Array;
  const indices = new IndexType(nlat * nlong * 6);
  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;
      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;
      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      const r = radius(ux, uy, uz, u, v);
      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;
      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;
      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }
  const numVertsAround = nlong + 1;
  for (let x = 0; x < nlong; x++) {
    for (let y = 0; y < nlat; y++) {
      const index = (x * nlat + y) * 6;
      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;
      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }
  return {
    indices: {
      size: 1,
      value: indices
    },
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      },
      TEXCOORD_0: {
        size: 2,
        value: texCoords
      }
    }
  };
}
var SphereGeometry;
var init_sphere_geometry = __esm({
  "node_modules/@luma.gl/engine/dist/esm/geometries/sphere-geometry.js"() {
    init_geometry();
    init_esm10();
    SphereGeometry = class extends Geometry {
      constructor() {
        let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const {
          id = uid("sphere-geometry")
        } = props;
        const {
          indices,
          attributes
        } = tesselateSphere(props);
        super({
          ...props,
          id,
          indices,
          attributes: {
            ...attributes,
            ...props.attributes
          }
        });
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
var channelHandles, animationHandles, Timeline;
var init_timeline = __esm({
  "node_modules/@luma.gl/engine/dist/esm/animation/timeline.js"() {
    channelHandles = 1;
    animationHandles = 1;
    Timeline = class {
      constructor() {
        this.time = 0;
        this.channels = /* @__PURE__ */ new Map();
        this.animations = /* @__PURE__ */ new Map();
        this.playing = false;
        this.lastEngineTime = -1;
      }
      addChannel(props) {
        const {
          delay = 0,
          duration = Number.POSITIVE_INFINITY,
          rate = 1,
          repeat = 1
        } = props;
        const handle = channelHandles++;
        const channel = {
          time: 0,
          delay,
          duration,
          rate,
          repeat
        };
        this._setChannelTime(channel, this.time);
        this.channels.set(handle, channel);
        return handle;
      }
      removeChannel(handle) {
        this.channels.delete(handle);
        for (const [animationHandle, animation] of this.animations) {
          if (animation.channel === handle) {
            this.detachAnimation(animationHandle);
          }
        }
      }
      isFinished(handle) {
        const channel = this.channels.get(handle);
        if (channel === void 0) {
          return false;
        }
        return this.time >= channel.delay + channel.duration * channel.repeat;
      }
      getTime(handle) {
        if (handle === void 0) {
          return this.time;
        }
        const channel = this.channels.get(handle);
        if (channel === void 0) {
          return -1;
        }
        return channel.time;
      }
      setTime(time) {
        this.time = Math.max(0, time);
        const channels = this.channels.values();
        for (const channel of channels) {
          this._setChannelTime(channel, this.time);
        }
        const animations = this.animations.values();
        for (const animationData of animations) {
          const {
            animation,
            channel
          } = animationData;
          animation.setTime(this.getTime(channel));
        }
      }
      play() {
        this.playing = true;
      }
      pause() {
        this.playing = false;
        this.lastEngineTime = -1;
      }
      reset() {
        this.setTime(0);
      }
      attachAnimation(animation, channelHandle) {
        const animationHandle = animationHandles++;
        this.animations.set(animationHandle, {
          animation,
          channel: channelHandle
        });
        animation.setTime(this.getTime(channelHandle));
        return animationHandle;
      }
      detachAnimation(handle) {
        this.animations.delete(handle);
      }
      update(engineTime) {
        if (this.playing) {
          if (this.lastEngineTime === -1) {
            this.lastEngineTime = engineTime;
          }
          this.setTime(this.time + (engineTime - this.lastEngineTime));
          this.lastEngineTime = engineTime;
        }
      }
      _setChannelTime(channel, time) {
        const offsetTime = time - channel.delay;
        const totalDuration = channel.duration * channel.repeat;
        if (offsetTime >= totalDuration) {
          channel.time = channel.duration * channel.rate;
        } else {
          channel.time = Math.max(0, offsetTime) % channel.duration;
          channel.time *= channel.rate;
        }
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js
var init_key_frames = __esm({
  "node_modules/@luma.gl/engine/dist/esm/animation/key-frames.js"() {
  }
});

// node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js
var CLIPSPACE_VERTEX_SHADER, POSITIONS, ClipSpace;
var init_clip_space = __esm({
  "node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js"() {
    init_model();
    init_geometry();
    CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
    POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
    ClipSpace = class extends Model {
      constructor(gl, opts) {
        const TEX_COORDS = POSITIONS.map((coord) => coord === -1 ? 0 : coord);
        super(gl, Object.assign({}, opts, {
          vs: CLIPSPACE_VERTEX_SHADER,
          geometry: new Geometry({
            drawMode: 5,
            vertexCount: 4,
            attributes: {
              aClipSpacePosition: {
                size: 2,
                value: new Float32Array(POSITIONS)
              },
              aTexCoord: {
                size: 2,
                value: new Float32Array(TEX_COORDS)
              },
              aCoordinate: {
                size: 2,
                value: new Float32Array(TEX_COORDS)
              }
            }
          })
        }));
        this.setVertexCount(4);
      }
    };
  }
});

// node_modules/@luma.gl/engine/dist/esm/index.js
var init_esm13 = __esm({
  "node_modules/@luma.gl/engine/dist/esm/index.js"() {
    init_animation_loop();
    init_model();
    init_program_manager();
    init_transform2();
    init_geometry();
    init_cone_geometry();
    init_cube_geometry();
    init_cylinder_geometry();
    init_ico_sphere_geometry();
    init_plane_geometry();
    init_sphere_geometry();
    init_truncated_cone_geometry();
    init_timeline();
    init_key_frames();
    init_clip_space();
  }
});

// node_modules/@luma.gl/core/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  AnimationLoop: () => AnimationLoop,
  Buffer: () => Buffer,
  ClipSpace: () => ClipSpace,
  ConeGeometry: () => ConeGeometry,
  CubeGeometry: () => CubeGeometry,
  CylinderGeometry: () => CylinderGeometry,
  FEATURES: () => FEATURES,
  FragmentShader: () => FragmentShader,
  Framebuffer: () => Framebuffer,
  Geometry: () => Geometry,
  IcoSphereGeometry: () => IcoSphereGeometry,
  Model: () => Model,
  PlaneGeometry: () => PlaneGeometry,
  Program: () => Program,
  ProgramManager: () => ProgramManager,
  Renderbuffer: () => Renderbuffer,
  SphereGeometry: () => SphereGeometry,
  Texture2D: () => Texture2D,
  Texture3D: () => Texture3D,
  TextureCube: () => TextureCube,
  Timeline: () => Timeline,
  Transform: () => Transform,
  TransformFeedback: () => TransformFeedback,
  TruncatedConeGeometry: () => TruncatedConeGeometry,
  VertexShader: () => VertexShader,
  assert: () => assert7,
  clear: () => clear,
  cloneTextureFrom: () => cloneTextureFrom,
  copyToTexture: () => copyToTexture,
  createGLContext: () => createGLContext,
  cssToDevicePixels: () => cssToDevicePixels,
  cssToDeviceRatio: () => cssToDeviceRatio,
  dirlight: () => dirlight,
  fp32: () => fp32,
  fp64: () => fp64,
  getParameters: () => getParameters,
  gouraudLighting: () => gouraudLighting,
  hasFeature: () => hasFeature,
  hasFeatures: () => hasFeatures,
  instrumentGLContext: () => instrumentGLContext,
  isWebGL: () => isWebGL,
  isWebGL2: () => isWebGL2,
  log: () => log,
  lumaStats: () => lumaStats,
  normalizeShaderModule: () => normalizeShaderModule,
  pbr: () => pbr,
  phongLighting: () => phongLighting,
  picking: () => picking,
  project: () => project,
  readPixelsToArray: () => readPixelsToArray,
  readPixelsToBuffer: () => readPixelsToBuffer,
  resetParameters: () => resetParameters,
  setParameters: () => setParameters,
  uid: () => uid,
  withParameters: () => withParameters
});
var init_esm14 = __esm({
  "node_modules/@luma.gl/core/dist/esm/index.js"() {
    init_esm9();
    init_esm10();
    init_esm13();
    init_esm12();
    init_esm10();
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js
var vs5, fs4, geometry_default;
var init_geometry2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js"() {
    vs5 = "\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry;\n";
    fs4 = "\n#define SMOOTH_EDGE_RADIUS 0.5\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n";
    geometry_default = {
      name: "geometry",
      vs: vs5,
      fs: fs4
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/constants.js
var COORDINATE_SYSTEM, PROJECTION_MODE, EVENTS;
var init_constants2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/constants.js"() {
    init_log2();
    COORDINATE_SYSTEM = {
      DEFAULT: -1,
      LNGLAT: 1,
      METER_OFFSETS: 2,
      LNGLAT_OFFSETS: 3,
      CARTESIAN: 0
    };
    Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
      get: function get() {
        return log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")() || 0;
      }
    });
    PROJECTION_MODE = {
      WEB_MERCATOR: 1,
      GLOBE: 2,
      WEB_MERCATOR_AUTO_OFFSET: 4,
      IDENTITY: 0
    };
    EVENTS = {
      click: {
        handler: "onClick"
      },
      panstart: {
        handler: "onDragStart"
      },
      panmove: {
        handler: "onDrag"
      },
      panend: {
        handler: "onDragEnd"
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js
var COORDINATE_SYSTEM_GLSL_CONSTANTS, PROJECTION_MODE_GLSL_CONSTANTS, project_glsl_default;
var init_project_glsl = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js"() {
    init_constants2();
    COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map(function(key) {
      return "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(COORDINATE_SYSTEM[key], ";");
    }).join("");
    PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map(function(key) {
      return "const int PROJECTION_MODE_".concat(key, " = ").concat(PROJECTION_MODE[key], ";");
    }).join("");
    project_glsl_default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform float project_uAntimeridian;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z;\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy;\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter;\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    dy = clamp(dy, -1., 1.);\n  }\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x - project_uAntimeridian, 360.0) + project_uAntimeridian;\n  }\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy) * WORLD_SCALE,\n        project_size(position_world.z),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n    position_world += project_uModelMatrix * vec4(position64Low, 0.0);\n  }\n\n  return project_offset_(position_world);\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\n");
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/memoize.js
function isEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (Array.isArray(a2)) {
    var len2 = a2.length;
    if (!b || b.length !== len2) {
      return false;
    }
    for (var i = 0; i < len2; i++) {
      if (a2[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function memoize(compute) {
  var cachedArgs = {};
  var cachedResult;
  return function(args) {
    for (var key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
var init_memoize = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/memoize.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/assert.js
function assert10(condition, message) {
  if (!condition) {
    throw new Error(message || "deck.gl: assertion failed.");
  }
}
var init_assert10 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/assert.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js
function getOffsetOrigin(viewport, coordinateSystem) {
  var coordinateOrigin = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_COORDINATE_ORIGIN;
  var shaderCoordinateOrigin = coordinateOrigin;
  var geospatialOrigin;
  var offsetMode = true;
  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }
  switch (viewport.projectionMode) {
    case PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        offsetMode = false;
      }
      break;
    case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }
      break;
    case PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      break;
    case PROJECTION_MODE.GLOBE:
      offsetMode = false;
      break;
    default:
      offsetMode = false;
  }
  shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}
function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  var viewMatrixUncentered = viewport.viewMatrixUncentered, projectionMatrix = viewport.projectionMatrix;
  var viewMatrix2 = viewport.viewMatrix, viewProjectionMatrix = viewport.viewProjectionMatrix;
  var projectionCenter = ZERO_VECTOR;
  var cameraPosCommon = viewport.cameraPosition;
  var _getOffsetOrigin = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin), geospatialOrigin = _getOffsetOrigin.geospatialOrigin, shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin, offsetMode = _getOffsetOrigin.offsetMode;
  if (offsetMode) {
    var positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - positionCommonSpace[0], cameraPosCommon[1] - positionCommonSpace[1], cameraPosCommon[2] - positionCommonSpace[2]];
    positionCommonSpace[3] = 1;
    projectionCenter = transformMat43([], positionCommonSpace, viewProjectionMatrix);
    viewMatrix2 = viewMatrixUncentered || viewMatrix2;
    viewProjectionMatrix = multiply3([], projectionMatrix, viewMatrix2);
    viewProjectionMatrix = multiply3([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }
  return {
    viewMatrix: viewMatrix2,
    viewProjectionMatrix,
    projectionCenter,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}
function getUniformsFromViewport() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, viewport = _ref.viewport, _ref$devicePixelRatio = _ref.devicePixelRatio, devicePixelRatio = _ref$devicePixelRatio === void 0 ? 1 : _ref$devicePixelRatio, _ref$modelMatrix = _ref.modelMatrix, modelMatrix = _ref$modelMatrix === void 0 ? null : _ref$modelMatrix, _ref$coordinateSystem = _ref.coordinateSystem, coordinateSystem = _ref$coordinateSystem === void 0 ? COORDINATE_SYSTEM.DEFAULT : _ref$coordinateSystem, coordinateOrigin = _ref.coordinateOrigin, _ref$autoWrapLongitud = _ref.autoWrapLongitude, autoWrapLongitude = _ref$autoWrapLongitud === void 0 ? false : _ref$autoWrapLongitud, projectionMode = _ref.projectionMode, positionOrigin = _ref.positionOrigin;
  assert10(viewport);
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  var uniforms3 = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms3.project_uWrapLongitude = autoWrapLongitude;
  uniforms3.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX5;
  return uniforms3;
}
function calculateViewportUniforms(_ref2) {
  var viewport = _ref2.viewport, devicePixelRatio = _ref2.devicePixelRatio, coordinateSystem = _ref2.coordinateSystem, coordinateOrigin = _ref2.coordinateOrigin;
  var _calculateMatrixAndOf = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin), projectionCenter = _calculateMatrixAndOf.projectionCenter, viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix, cameraPosCommon = _calculateMatrixAndOf.cameraPosCommon, shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin, geospatialOrigin = _calculateMatrixAndOf.geospatialOrigin;
  var distanceScales = viewport.getDistanceScales();
  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  var uniforms3 = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCenter: projectionCenter,
    project_uAntimeridian: (viewport.longitude || 0) - 180,
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: viewport.focalDistance || 1,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uCameraPosition: cameraPosCommon
  };
  if (geospatialOrigin) {
    var distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms3.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms3.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;
      case COORDINATE_SYSTEM.LNGLAT:
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        uniforms3.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms3.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;
      case COORDINATE_SYSTEM.CARTESIAN:
        uniforms3.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms3.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;
      default:
        break;
    }
  }
  return uniforms3;
}
var ZERO_VECTOR, VECTOR_TO_POINT_MATRIX, IDENTITY_MATRIX5, DEFAULT_PIXELS_PER_UNIT2, DEFAULT_COORDINATE_ORIGIN, getMemoizedViewportUniforms;
var init_viewport_uniforms = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js"() {
    init_mat4();
    init_vec4();
    init_constants2();
    init_memoize();
    init_assert10();
    ZERO_VECTOR = [0, 0, 0, 0];
    VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
    IDENTITY_MATRIX5 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
    DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
    getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js
function getUniforms7() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : INITIAL_MODULE_OPTIONS3;
  if (opts.viewport) {
    return getUniformsFromViewport(opts);
  }
  return {};
}
var INITIAL_MODULE_OPTIONS3, project_default;
var init_project2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js"() {
    init_esm14();
    init_project_glsl();
    init_viewport_uniforms();
    INITIAL_MODULE_OPTIONS3 = {};
    project_default = {
      name: "project",
      dependencies: [fp32],
      vs: project_glsl_default,
      getUniforms: getUniforms7
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js
var vs6, project32_default;
var init_project32 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js"() {
    init_project2();
    vs6 = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    mat3 rotation = project_get_orientation_matrix(projectedPosition);\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
    project32_default = {
      name: "project32",
      dependencies: [project_default],
      vs: vs6
    };
  }
});

// node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var init_arrayWithHoles = __esm({
  "node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/math.gl/dist/esm/index.js
var init_esm15 = __esm({
  "node_modules/math.gl/dist/esm/index.js"() {
    init_esm11();
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function transformVector(matrix, vector) {
  const result = transformMat43([], vector, matrix);
  scale4(result, result, 1 / result[3]);
  return result;
}
function mod(value4, divisor) {
  const modulus = value4 % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function lerp6(start, end, step) {
  return step * end + (1 - step) * start;
}
function clamp2(x, min, max) {
  return x < min ? min : x > max ? max : x;
}
function ieLog2(x) {
  return Math.log(x) * Math.LOG2E;
}
var log22;
var init_math_utils2 = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/math-utils.js"() {
    init_vec4();
    log22 = Math.log2 || ieLog2;
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/assert.js
function assert11(condition, message) {
  if (!condition) {
    throw new Error(message || "@math.gl/web-mercator: assertion failed.");
  }
}
var init_assert11 = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/assert.js"() {
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
function zoomToScale(zoom) {
  return Math.pow(2, zoom);
}
function scaleToZoom(scale6) {
  return log22(scale6);
}
function lngLatToWorld(lngLat) {
  const [lng, lat] = lngLat;
  assert11(Number.isFinite(lng));
  assert11(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
  const lambda2 = lng * DEGREES_TO_RADIANS2;
  const phi2 = lat * DEGREES_TO_RADIANS2;
  const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
  const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
  return [x, y];
}
function worldToLngLat(xy) {
  const [x, y] = xy;
  const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
  const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
  return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
}
function getMeterZoom(options) {
  const {
    latitude
  } = options;
  assert11(Number.isFinite(latitude));
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
}
function getDistanceScales(options) {
  const {
    latitude,
    longitude,
    highPrecision = false
  } = options;
  assert11(Number.isFinite(latitude) && Number.isFinite(longitude));
  const worldSize = TILE_SIZE;
  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
  const unitsPerDegreeX = worldSize / 360;
  const unitsPerDegreeY = unitsPerDegreeX / latCosine;
  const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
  const result = {
    unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
    metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
    unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
    degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
  };
  if (highPrecision) {
    const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
    const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
    const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
    const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
    result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
    result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
  }
  return result;
}
function addMetersToLngLat(lngLatZ, xyz) {
  const [longitude, latitude, z0] = lngLatZ;
  const [x, y, z] = xyz;
  const {
    unitsPerMeter: unitsPerMeter2,
    unitsPerMeter2: unitsPerMeter22
  } = getDistanceScales({
    longitude,
    latitude,
    highPrecision: true
  });
  const worldspace = lngLatToWorld(lngLatZ);
  worldspace[0] += x * (unitsPerMeter2[0] + unitsPerMeter22[0] * y);
  worldspace[1] += y * (unitsPerMeter2[1] + unitsPerMeter22[1] * y);
  const newLngLat = worldToLngLat(worldspace);
  const newZ = (z0 || 0) + (z || 0);
  return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
}
function getViewMatrix(options) {
  const {
    height,
    pitch,
    bearing,
    altitude,
    scale: scale6,
    center
  } = options;
  const vm = createMat4();
  translate2(vm, vm, [0, 0, -altitude]);
  rotateX2(vm, vm, -pitch * DEGREES_TO_RADIANS2);
  rotateZ2(vm, vm, bearing * DEGREES_TO_RADIANS2);
  const relativeScale = scale6 / height;
  scale3(vm, vm, [relativeScale, relativeScale, relativeScale]);
  if (center) {
    translate2(vm, vm, negate2([], center));
  }
  return vm;
}
function getProjectionParameters(options) {
  const {
    width,
    height,
    altitude,
    pitch = 0,
    offset,
    center,
    scale: scale6,
    nearZMultiplier = 1,
    farZMultiplier = 1
  } = options;
  let {
    fovy = altitudeToFovy(DEFAULT_ALTITUDE)
  } = options;
  if (altitude !== void 0) {
    fovy = altitudeToFovy(altitude);
  }
  const fovRadians = fovy * DEGREES_TO_RADIANS2;
  const pitchRadians = pitch * DEGREES_TO_RADIANS2;
  const focalDistance = fovyToAltitude(fovy);
  let cameraToSeaLevelDistance = focalDistance;
  if (center) {
    cameraToSeaLevelDistance += center[2] * scale6 / Math.cos(pitchRadians) / height;
  }
  const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height);
  const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
  const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
  const horizonDistance = cameraToSeaLevelDistance * 10;
  const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
  return {
    fov: fovRadians,
    aspect: width / height,
    focalDistance,
    near: nearZMultiplier,
    far: farZ
  };
}
function getProjectionMatrix(options) {
  const {
    fov,
    aspect,
    near,
    far
  } = getProjectionParameters(options);
  const projectionMatrix = perspective([], fov, aspect, near, far);
  return projectionMatrix;
}
function altitudeToFovy(altitude) {
  return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
}
function fovyToAltitude(fovy) {
  return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
}
function worldToPixels(xyz, pixelProjectionMatrix) {
  const [x, y, z = 0] = xyz;
  assert11(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
  return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
}
function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
  const [x, y, z] = xyz;
  assert11(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
  if (Number.isFinite(z)) {
    const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
    return coord;
  }
  const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);
  const z0 = coord0[2];
  const z1 = coord1[2];
  const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
  return lerp2([], coord0, coord1, t);
}
var PI, PI_4, DEGREES_TO_RADIANS2, RADIANS_TO_DEGREES2, TILE_SIZE, EARTH_CIRCUMFERENCE, MAX_LATITUDE, DEFAULT_ALTITUDE;
var init_web_mercator_utils = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js"() {
    init_math_utils2();
    init_mat4();
    init_vec2();
    init_vec3();
    init_assert11();
    PI = Math.PI;
    PI_4 = PI / 4;
    DEGREES_TO_RADIANS2 = PI / 180;
    RADIANS_TO_DEGREES2 = 180 / PI;
    TILE_SIZE = 512;
    EARTH_CIRCUMFERENCE = 4003e4;
    MAX_LATITUDE = 85.051129;
    DEFAULT_ALTITUDE = 1.5;
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
function fitBounds(options) {
  const {
    width,
    height,
    bounds,
    minExtent = 0,
    maxZoom = 24,
    offset = [0, 0]
  } = options;
  const [[west, south], [east, north]] = bounds;
  const padding = getPaddingObject(options.padding);
  const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
  const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
  const size = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
  const targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
  assert11(targetSize[0] > 0 && targetSize[1] > 0);
  const scaleX2 = targetSize[0] / size[0];
  const scaleY2 = targetSize[1] / size[1];
  const offsetX = (padding.right - padding.left) / 2 / scaleX2;
  const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
  const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
  const centerLngLat = worldToLngLat(center);
  const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
  assert11(Number.isFinite(zoom));
  return {
    longitude: centerLngLat[0],
    latitude: centerLngLat[1],
    zoom
  };
}
function getPaddingObject(padding = 0) {
  if (typeof padding === "number") {
    return {
      top: padding,
      bottom: padding,
      left: padding,
      right: padding
    };
  }
  assert11(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
  return padding;
}
var init_fit_bounds = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js"() {
    init_assert11();
    init_math_utils2();
    init_web_mercator_utils();
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
function getBounds(viewport, z = 0) {
  const {
    width,
    height,
    unproject
  } = viewport;
  const unprojectOps = {
    targetZ: z
  };
  const bottomLeft = unproject([0, height], unprojectOps);
  const bottomRight = unproject([width, height], unprojectOps);
  let topLeft;
  let topRight;
  const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
  const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
  if (halfFov > angleToGround - 0.01) {
    topLeft = unprojectOnFarPlane(viewport, 0, z);
    topRight = unprojectOnFarPlane(viewport, width, z);
  } else {
    topLeft = unproject([0, 0], unprojectOps);
    topRight = unproject([width, 0], unprojectOps);
  }
  return [bottomLeft, bottomRight, topRight, topLeft];
}
function unprojectOnFarPlane(viewport, x, targetZ) {
  const {
    pixelUnprojectionMatrix
  } = viewport;
  const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);
  const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
  const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
  const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
  const coord = lerp2([], coord0, coord1, t);
  const result = worldToLngLat(coord);
  result.push(targetZ);
  return result;
}
var DEGREES_TO_RADIANS3;
var init_get_bounds = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js"() {
    init_web_mercator_utils();
    init_vec2();
    init_math_utils2();
    DEGREES_TO_RADIANS3 = Math.PI / 180;
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js
var WebMercatorViewport;
var init_web_mercator_viewport = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js"() {
    init_defineProperty();
    init_math_utils2();
    init_web_mercator_utils();
    init_fit_bounds();
    init_get_bounds();
    init_mat4();
    init_vec2();
    init_vec3();
    WebMercatorViewport = class _WebMercatorViewport {
      constructor(props = {
        width: 1,
        height: 1
      }) {
        _defineProperty(this, "latitude", void 0);
        _defineProperty(this, "longitude", void 0);
        _defineProperty(this, "zoom", void 0);
        _defineProperty(this, "pitch", void 0);
        _defineProperty(this, "bearing", void 0);
        _defineProperty(this, "altitude", void 0);
        _defineProperty(this, "fovy", void 0);
        _defineProperty(this, "meterOffset", void 0);
        _defineProperty(this, "center", void 0);
        _defineProperty(this, "width", void 0);
        _defineProperty(this, "height", void 0);
        _defineProperty(this, "scale", void 0);
        _defineProperty(this, "distanceScales", void 0);
        _defineProperty(this, "viewMatrix", void 0);
        _defineProperty(this, "projectionMatrix", void 0);
        _defineProperty(this, "viewProjectionMatrix", void 0);
        _defineProperty(this, "pixelProjectionMatrix", void 0);
        _defineProperty(this, "pixelUnprojectionMatrix", void 0);
        _defineProperty(this, "equals", (viewport) => {
          if (!(viewport instanceof _WebMercatorViewport)) {
            return false;
          }
          return viewport.width === this.width && viewport.height === this.height && equals2(viewport.projectionMatrix, this.projectionMatrix) && equals2(viewport.viewMatrix, this.viewMatrix);
        });
        _defineProperty(this, "project", (lngLatZ, options = {}) => {
          const {
            topLeft = true
          } = options;
          const worldPosition = this.projectPosition(lngLatZ);
          const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
          const [x, y] = coord;
          const y2 = topLeft ? y : this.height - y;
          return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];
        });
        _defineProperty(this, "unproject", (xyz, options = {}) => {
          const {
            topLeft = true,
            targetZ = void 0
          } = options;
          const [x, y, z] = xyz;
          const y2 = topLeft ? y : this.height - y;
          const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
          const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
          const [X, Y, Z] = this.unprojectPosition(coord);
          if (Number.isFinite(z)) {
            return [X, Y, Z];
          }
          return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
        });
        _defineProperty(this, "projectPosition", (xyz) => {
          const [X, Y] = lngLatToWorld(xyz);
          const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
          return [X, Y, Z];
        });
        _defineProperty(this, "unprojectPosition", (xyz) => {
          const [X, Y] = worldToLngLat(xyz);
          const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
          return [X, Y, Z];
        });
        let {
          width,
          height,
          altitude = null,
          fovy = null
        } = props;
        const {
          latitude = 0,
          longitude = 0,
          zoom = 0,
          pitch = 0,
          bearing = 0,
          position = null,
          nearZMultiplier = 0.02,
          farZMultiplier = 1.01
        } = props;
        width = width || 1;
        height = height || 1;
        if (fovy === null && altitude === null) {
          altitude = DEFAULT_ALTITUDE;
          fovy = altitudeToFovy(altitude);
        } else if (fovy === null) {
          fovy = altitudeToFovy(altitude);
        } else if (altitude === null) {
          altitude = fovyToAltitude(fovy);
        }
        const scale6 = zoomToScale(zoom);
        altitude = Math.max(0.75, altitude);
        const distanceScales = getDistanceScales({
          longitude,
          latitude
        });
        const center = lngLatToWorld([longitude, latitude]);
        center.push(0);
        if (position) {
          add2(center, center, mul([], position, distanceScales.unitsPerMeter));
        }
        this.projectionMatrix = getProjectionMatrix({
          width,
          height,
          scale: scale6,
          center,
          pitch,
          fovy,
          nearZMultiplier,
          farZMultiplier
        });
        this.viewMatrix = getViewMatrix({
          height,
          scale: scale6,
          center,
          pitch,
          bearing,
          altitude
        });
        this.width = width;
        this.height = height;
        this.scale = scale6;
        this.latitude = latitude;
        this.longitude = longitude;
        this.zoom = zoom;
        this.pitch = pitch;
        this.bearing = bearing;
        this.altitude = altitude;
        this.fovy = fovy;
        this.center = center;
        this.meterOffset = position || [0, 0, 0];
        this.distanceScales = distanceScales;
        this._initMatrices();
        Object.freeze(this);
      }
      _initMatrices() {
        const {
          width,
          height,
          projectionMatrix,
          viewMatrix: viewMatrix2
        } = this;
        const vpm = createMat4();
        multiply3(vpm, vpm, projectionMatrix);
        multiply3(vpm, vpm, viewMatrix2);
        this.viewProjectionMatrix = vpm;
        const m = createMat4();
        scale3(m, m, [width / 2, -height / 2, 1]);
        translate2(m, m, [1, -1, 0]);
        multiply3(m, m, vpm);
        const mInverse = invert2(createMat4(), m);
        if (!mInverse) {
          throw new Error("Pixel project matrix not invertible");
        }
        this.pixelProjectionMatrix = m;
        this.pixelUnprojectionMatrix = mInverse;
      }
      projectFlat(lngLat) {
        return lngLatToWorld(lngLat);
      }
      unprojectFlat(xy) {
        return worldToLngLat(xy);
      }
      getMapCenterByLngLatPosition({
        lngLat,
        pos
      }) {
        const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
        const toLocation = lngLatToWorld(lngLat);
        const translate3 = add([], toLocation, negate([], fromLocation));
        const newCenter = add([], this.center, translate3);
        return worldToLngLat(newCenter);
      }
      fitBounds(bounds, options = {}) {
        const {
          width,
          height
        } = this;
        const {
          longitude,
          latitude,
          zoom
        } = fitBounds(Object.assign({
          width,
          height,
          bounds
        }, options));
        return new _WebMercatorViewport({
          width,
          height,
          longitude,
          latitude,
          zoom
        });
      }
      getBounds(options) {
        const corners = this.getBoundingRegion(options);
        const west = Math.min(...corners.map((p) => p[0]));
        const east = Math.max(...corners.map((p) => p[0]));
        const south = Math.min(...corners.map((p) => p[1]));
        const north = Math.max(...corners.map((p) => p[1]));
        return [[west, south], [east, north]];
      }
      getBoundingRegion(options = {}) {
        return getBounds(this, options.z || 0);
      }
      getLocationAtPoint({
        lngLat,
        pos
      }) {
        return this.getMapCenterByLngLatPosition({
          lngLat,
          pos
        });
      }
    };
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
function normalizeViewportProps(props) {
  const {
    width,
    height,
    pitch = 0
  } = props;
  let {
    longitude,
    latitude,
    zoom,
    bearing = 0
  } = props;
  if (longitude < -180 || longitude > 180) {
    longitude = mod(longitude + 180, 360) - 180;
  }
  if (bearing < -180 || bearing > 180) {
    bearing = mod(bearing + 180, 360) - 180;
  }
  const minZoom = log22(height / TILE_SIZE2);
  if (zoom <= minZoom) {
    zoom = minZoom;
    latitude = 0;
  } else {
    const halfHeightPixels = height / 2 / Math.pow(2, zoom);
    const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
    if (latitude < minLatitude) {
      latitude = minLatitude;
    } else {
      const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
      if (latitude > maxLatitude) {
        latitude = maxLatitude;
      }
    }
  }
  return {
    width,
    height,
    longitude,
    latitude,
    zoom,
    pitch,
    bearing
  };
}
var TILE_SIZE2;
var init_normalize_viewport_props = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js"() {
    init_web_mercator_utils();
    init_math_utils2();
    TILE_SIZE2 = 512;
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js
function flyToViewport(startProps, endProps, t, options) {
  const {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0
  } = getFlyToTransitionParams(startProps, endProps, options);
  if (u1 < EPSILON3) {
    const viewport = {};
    for (const key of VIEWPORT_TRANSITION_PROPS) {
      const startValue = startProps[key];
      const endValue = endProps[key];
      viewport[key] = lerp6(startValue, endValue, t);
    }
    return viewport;
  }
  const s = t * S;
  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
  const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
  const scaleIncrement = 1 / w;
  const newZoom = startZoom + scaleToZoom(scaleIncrement);
  const newCenterWorld = scale([], uDelta, u);
  add(newCenterWorld, newCenterWorld, startCenterXY);
  const newCenter = worldToLngLat(newCenterWorld);
  return {
    longitude: newCenter[0],
    latitude: newCenter[1],
    zoom: newZoom
  };
}
function getFlyToDuration(startProps, endProps, options) {
  const opts = {
    ...DEFAULT_OPTS,
    ...options
  };
  const {
    screenSpeed,
    speed,
    maxDuration
  } = opts;
  const {
    S,
    rho
  } = getFlyToTransitionParams(startProps, endProps, opts);
  const length5 = 1e3 * S;
  let duration;
  if (Number.isFinite(screenSpeed)) {
    duration = length5 / (screenSpeed / rho);
  } else {
    duration = length5 / speed;
  }
  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;
}
function getFlyToTransitionParams(startProps, endProps, opts) {
  opts = Object.assign({}, DEFAULT_OPTS, opts);
  const rho = opts.curve;
  const startZoom = startProps.zoom;
  const startCenter = [startProps.longitude, startProps.latitude];
  const startScale = zoomToScale(startZoom);
  const endZoom = endProps.zoom;
  const endCenter = [endProps.longitude, endProps.latitude];
  const scale6 = zoomToScale(endZoom - startZoom);
  const startCenterXY = lngLatToWorld(startCenter);
  const endCenterXY = lngLatToWorld(endCenter);
  const uDelta = sub([], endCenterXY, startCenterXY);
  const w0 = Math.max(startProps.width, startProps.height);
  const w1 = w0 / scale6;
  const u1 = length(uDelta) * startScale;
  const _u1 = Math.max(u1, EPSILON3);
  const rho2 = rho * rho;
  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
  const S = (r1 - r0) / rho;
  return {
    startZoom,
    startCenterXY,
    uDelta,
    w0,
    u1,
    S,
    rho,
    rho2,
    r0,
    r1
  };
}
var EPSILON3, VIEWPORT_TRANSITION_PROPS, DEFAULT_OPTS;
var init_fly_to_viewport = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js"() {
    init_math_utils2();
    init_web_mercator_utils();
    init_vec2();
    EPSILON3 = 0.01;
    VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
    DEFAULT_OPTS = {
      curve: 1.414,
      speed: 1.2
    };
  }
});

// node_modules/@math.gl/web-mercator/dist/esm/index.js
var init_esm16 = __esm({
  "node_modules/@math.gl/web-mercator/dist/esm/index.js"() {
    init_web_mercator_viewport();
    init_web_mercator_viewport();
    init_get_bounds();
    init_fit_bounds();
    init_normalize_viewport_props();
    init_fly_to_viewport();
    init_web_mercator_utils();
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js
function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
  var coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);
  if (Number.isFinite(z)) {
    return coord;
  }
  return [coord[0], coord[1], 0];
}
function getViewportCenterPosition(_ref) {
  var viewport = _ref.viewport, center = _ref.center;
  return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
}
function getViewProjectionMatrices(_ref2) {
  var viewport = _ref2.viewport, shadowMatrices = _ref2.shadowMatrices;
  var projectionMatrices = [];
  var pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  var farZ = viewport.isGeospatial ? void 0 : 1;
  var corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(function(pixel) {
    return screenToCommonSpace(pixel, pixelUnprojectionMatrix);
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    var _loop = function _loop2() {
      var shadowMatrix = _step.value;
      var viewMatrix2 = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
      var positions = corners.map(function(corner) {
        return viewMatrix2.transform(corner);
      });
      var projectionMatrix = new Matrix4().ortho({
        left: Math.min.apply(Math, _toConsumableArray(positions.map(function(position) {
          return position[0];
        }))),
        right: Math.max.apply(Math, _toConsumableArray(positions.map(function(position) {
          return position[0];
        }))),
        bottom: Math.min.apply(Math, _toConsumableArray(positions.map(function(position) {
          return position[1];
        }))),
        top: Math.max.apply(Math, _toConsumableArray(positions.map(function(position) {
          return position[1];
        }))),
        near: Math.min.apply(Math, _toConsumableArray(positions.map(function(position) {
          return -position[2];
        }))),
        far: Math.max.apply(Math, _toConsumableArray(positions.map(function(position) {
          return -position[2];
        })))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    };
    for (var _iterator = shadowMatrices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return projectionMatrices;
}
function createShadowUniforms() {
  var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var uniforms3 = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  var center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  var projectCenters = [];
  var viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();
  for (var i = 0; i < opts.shadowMatrices.length; i++) {
    var viewProjectionMatrix = viewProjectionMatrices[i];
    var viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
    if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }
  for (var _i = 0; _i < viewProjectionMatrices.length; _i++) {
    uniforms3["shadow_uViewProjectionMatrices[".concat(_i, "]")] = viewProjectionMatrices[_i];
    uniforms3["shadow_uProjectCenters[".concat(_i, "]")] = projectCenters[_i];
    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms3["shadow_uShadowMap".concat(_i)] = opts.shadowMaps[_i];
    } else {
      uniforms3["shadow_uShadowMap".concat(_i)] = opts.dummyShadowMap;
    }
  }
  return uniforms3;
}
var vs7, fs5, getMemoizedViewportCenterPosition, getMemoizedViewProjectionMatrices, DEFAULT_SHADOW_COLOR, VECTOR_TO_POINT_MATRIX2, shadow_default;
var init_shadow = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js"() {
    init_toConsumableArray();
    init_slicedToArray();
    init_constants2();
    init_project2();
    init_esm15();
    init_memoize();
    init_esm16();
    vs7 = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
    fs5 = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
    getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
    getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
    DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
    VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
    shadow_default = {
      name: "shadow",
      dependencies: [project_default],
      vs: vs7,
      fs: fs5,
      inject: {
        "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
        "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
      },
      getUniforms: function getUniforms8() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0) {
          var shadowUniforms = {};
          var _opts$shadowEnabled = opts.shadowEnabled, shadowEnabled = _opts$shadowEnabled === void 0 ? true : _opts$shadowEnabled;
          if (shadowEnabled && opts.shadowMatrices && opts.shadowMatrices.length > 0) {
            Object.assign(shadowUniforms, createShadowUniforms(opts, context));
          } else {
            Object.assign(shadowUniforms, {
              shadow_uDrawShadowMap: false,
              shadow_uUseShadowMap: false
            });
          }
          return shadowUniforms;
        }
        return {};
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js
var picking_default;
var init_picking2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js"() {
    init_esm14();
    picking_default = Object.assign({
      inject: {
        "vs:DECKGL_FILTER_COLOR": "\n    picking_setPickingColor(geometry.pickingColor);\n    // for picking depth values\n    picking_setPickingAttribute(geometry.position.z);\n    ",
        "fs:DECKGL_FILTER_COLOR": {
          order: 99,
          injection: "\n    // use highlight color if this fragment belongs to the selected object.\n    color = picking_filterHighlightColor(color);\n\n    // use picking color if rendering to picking FBO.\n    color = picking_filterPickingColor(color);\n      "
        }
      }
    }, picking);
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/index.js
function createProgramManager(gl) {
  var programManager = ProgramManager.getDefaultProgramManager(gl);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = DEFAULT_MODULES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var shaderModule = _step.value;
      programManager.addDefaultModule(shaderModule);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = void 0;
  try {
    for (var _iterator2 = SHADER_HOOKS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var shaderHook = _step2.value;
      programManager.addShaderHook(shaderHook);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
  return programManager;
}
var DEFAULT_MODULES, SHADER_HOOKS;
var init_shaderlib = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/index.js"() {
    init_esm14();
    init_esm14();
    init_geometry2();
    init_project2();
    init_project32();
    init_shadow();
    init_picking2();
    DEFAULT_MODULES = [geometry_default, project_default];
    SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var init_setPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js
var DEFAULT_LIGHT_COLOR, DEFAULT_LIGHT_INTENSITY, idCount, AmbientLight;
var init_ambient_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js"() {
    init_classCallCheck();
    DEFAULT_LIGHT_COLOR = [255, 255, 255];
    DEFAULT_LIGHT_INTENSITY = 1;
    idCount = 0;
    AmbientLight = function AmbientLight2() {
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, AmbientLight2);
      var _props$color = props.color, color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR : _props$color;
      var _props$intensity = props.intensity, intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY : _props$intensity;
      this.id = props.id || "ambient-".concat(idCount++);
      this.color = color;
      this.intensity = intensity;
      this.type = "ambient";
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js
var DEFAULT_LIGHT_COLOR2, DEFAULT_LIGHT_INTENSITY2, DEFAULT_LIGHT_DIRECTION2, idCount2, DirectionalLight;
var init_directional_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm15();
    DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
    DEFAULT_LIGHT_INTENSITY2 = 1;
    DEFAULT_LIGHT_DIRECTION2 = [0, 0, -1];
    idCount2 = 0;
    DirectionalLight = function() {
      function DirectionalLight2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, DirectionalLight2);
        var _props$color = props.color, color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR2 : _props$color;
        var _props$intensity = props.intensity, intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY2 : _props$intensity;
        var _props$direction = props.direction, direction = _props$direction === void 0 ? DEFAULT_LIGHT_DIRECTION2 : _props$direction;
        var _props$_shadow = props._shadow, _shadow = _props$_shadow === void 0 ? false : _props$_shadow;
        this.id = props.id || "directional-".concat(idCount2++);
        this.color = color;
        this.intensity = intensity;
        this.type = "directional";
        this.direction = new Vector3(direction).normalize().toArray();
        this.shadow = _shadow;
      }
      _createClass(DirectionalLight2, [{
        key: "getProjectedLight",
        value: function getProjectedLight() {
          return this;
        }
      }]);
      return DirectionalLight2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/effect.js
var Effect;
var init_effect = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/effect.js"() {
    init_classCallCheck();
    init_createClass();
    Effect = function() {
      function Effect2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Effect2);
        var _props$id = props.id, id = _props$id === void 0 ? "effect" : _props$id;
        this.id = id;
        this.props = {};
        Object.assign(this.props, props);
      }
      _createClass(Effect2, [{
        key: "preRender",
        value: function preRender() {
        }
      }, {
        key: "getModuleParameters",
        value: function getModuleParameters() {
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
        }
      }]);
      return Effect2;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
var init_superPropBase = __esm({
  "node_modules/@babel/runtime/helpers/esm/superPropBase.js"() {
    init_getPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var init_get = __esm({
  "node_modules/@babel/runtime/helpers/esm/get.js"() {
    init_superPropBase();
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/pass.js
var Pass;
var init_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/pass.js"() {
    init_classCallCheck();
    init_createClass();
    Pass = function() {
      function Pass2(gl) {
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Pass2);
        var _props$id = props.id, id = _props$id === void 0 ? "pass" : _props$id;
        this.id = id;
        this.gl = gl;
        this.props = {};
        Object.assign(this.props, props);
      }
      _createClass(Pass2, [{
        key: "setProps",
        value: function setProps(props) {
          Object.assign(this.props, props);
        }
      }, {
        key: "render",
        value: function render() {
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
        }
      }]);
      return Pass2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js
function layerIndexResolver() {
  var startIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var layerIndices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var resolvers = {};
  return function(layer, isDrawn) {
    var indexOverride = layer.props._offset;
    var layerId = layer.id;
    var parentId = layer.parent && layer.parent.id;
    var index;
    if (parentId in resolvers) {
      var resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }
    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }
    layerIndices[layerId] = index;
    return index;
  };
}
function getGLViewport(gl, _ref2) {
  var viewport = _ref2.viewport;
  var height = gl.canvas ? gl.canvas.clientHeight || gl.canvas.height : 100;
  var dimensions = viewport;
  var pixelRatio = cssToDeviceRatio(gl);
  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}
function clearGLCanvas(gl) {
  var width = gl.drawingBufferWidth;
  var height = gl.drawingBufferHeight;
  setParameters(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}
var LayersPass;
var init_layers_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_pass();
    init_esm14();
    init_log2();
    LayersPass = function(_Pass) {
      _inherits(LayersPass2, _Pass);
      function LayersPass2() {
        _classCallCheck(this, LayersPass2);
        return _possibleConstructorReturn(this, _getPrototypeOf(LayersPass2).apply(this, arguments));
      }
      _createClass(LayersPass2, [{
        key: "render",
        value: function render(props) {
          var gl = this.gl;
          setParameters(gl, {
            framebuffer: props.target
          });
          return this._drawLayers(props);
        }
      }, {
        key: "_drawLayers",
        value: function _drawLayers(props) {
          var viewports = props.viewports, views = props.views, onViewportActive = props.onViewportActive, _props$clearCanvas = props.clearCanvas, clearCanvas = _props$clearCanvas === void 0 ? true : _props$clearCanvas;
          var gl = this.gl;
          if (clearCanvas) {
            clearGLCanvas(gl);
          }
          var renderStats = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = viewports[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var viewportOrDescriptor = _step.value;
              var viewport = viewportOrDescriptor.viewport || viewportOrDescriptor;
              var view = views && views[viewport.id];
              onViewportActive(viewport);
              props.view = view;
              var subViewports = viewport.subViewports || [viewport];
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = subViewports[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var subViewport = _step2.value;
                  props.viewport = subViewport;
                  var stats = this._drawLayersInViewport(gl, props);
                  renderStats.push(stats);
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return renderStats;
        }
      }, {
        key: "_drawLayersInViewport",
        value: function _drawLayersInViewport(gl, _ref) {
          var layers = _ref.layers, layerFilter = _ref.layerFilter, onError = _ref.onError, viewport = _ref.viewport, view = _ref.view, _ref$pass = _ref.pass, pass = _ref$pass === void 0 ? "unknown" : _ref$pass, effects = _ref.effects, moduleParameters = _ref.moduleParameters;
          var glViewport = getGLViewport(gl, {
            viewport
          });
          if (view && view.props.clear) {
            var clearOpts = view.props.clear === true ? {
              color: true,
              depth: true
            } : view.props.clear;
            withParameters(gl, {
              scissorTest: true,
              scissor: glViewport
            }, function() {
              return clear(gl, clearOpts);
            });
          }
          var renderStatus = {
            totalCount: layers.length,
            visibleCount: 0,
            compositeCount: 0,
            pickableCount: 0
          };
          setParameters(gl, {
            viewport: glViewport
          });
          var indexResolver = layerIndexResolver();
          for (var layerIndex = 0; layerIndex < layers.length; layerIndex++) {
            var layer = layers[layerIndex];
            var shouldDrawLayer = this._shouldDrawLayer(layer, viewport, pass, layerFilter);
            var layerRenderIndex = indexResolver(layer, shouldDrawLayer);
            if (shouldDrawLayer && layer.props.pickable) {
              renderStatus.pickableCount++;
            }
            if (layer.isComposite) {
              renderStatus.compositeCount++;
            } else if (shouldDrawLayer) {
              renderStatus.visibleCount++;
              var _moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
              var layerParameters = this.getLayerParameters(layer, layerIndex);
              _moduleParameters.viewport = viewport;
              try {
                layer.drawLayer({
                  moduleParameters: _moduleParameters,
                  uniforms: {
                    layerIndex: layerRenderIndex
                  },
                  parameters: layerParameters
                });
              } catch (err) {
                if (onError) {
                  onError(err, layer);
                } else {
                  log_default.error("error during drawing of ".concat(layer), err)();
                }
              }
            }
          }
          return renderStatus;
        }
      }, {
        key: "shouldDrawLayer",
        value: function shouldDrawLayer(layer) {
          return true;
        }
      }, {
        key: "getModuleParameters",
        value: function getModuleParameters(layer, effects) {
          return null;
        }
      }, {
        key: "getLayerParameters",
        value: function getLayerParameters(layer, layerIndex) {
          return layer.props.parameters;
        }
      }, {
        key: "_shouldDrawLayer",
        value: function _shouldDrawLayer(layer, viewport, pass, layerFilter) {
          var shouldDrawLayer = this.shouldDrawLayer(layer) && layer.props.visible;
          if (shouldDrawLayer && layerFilter) {
            shouldDrawLayer = layerFilter({
              layer,
              viewport,
              isPicking: pass.startsWith("picking"),
              renderPass: pass
            });
          }
          if (shouldDrawLayer) {
            layer.activateViewport(viewport);
          }
          return shouldDrawLayer;
        }
      }, {
        key: "_getModuleParameters",
        value: function _getModuleParameters(layer, effects, pass, overrides) {
          var moduleParameters = Object.assign(Object.create(layer.props), {
            autoWrapLongitude: layer.wrapLongitude,
            viewport: layer.context.viewport,
            mousePosition: layer.context.mousePosition,
            pickingActive: 0,
            devicePixelRatio: cssToDeviceRatio(this.gl)
          });
          if (effects) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = void 0;
            try {
              for (var _iterator3 = effects[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var effect = _step3.value;
                Object.assign(moduleParameters, effect.getModuleParameters(layer));
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
          return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
        }
      }]);
      return LayersPass2;
    }(Pass);
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js
function ownKeys9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var ShadowPass;
var init_shadow_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_layers_pass();
    init_esm14();
    ShadowPass = function(_LayersPass) {
      _inherits(ShadowPass2, _LayersPass);
      function ShadowPass2(gl, props) {
        var _parameters, _attachments;
        var _this;
        _classCallCheck(this, ShadowPass2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(ShadowPass2).call(this, gl, props));
        _this.shadowMap = new Texture2D(gl, {
          width: 1,
          height: 1,
          parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9729), _defineProperty(_parameters, 10240, 9729), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters)
        });
        _this.depthBuffer = new Renderbuffer(gl, {
          format: 33189,
          width: 1,
          height: 1
        });
        _this.fbo = new Framebuffer(gl, {
          id: "shadowmap",
          width: 1,
          height: 1,
          attachments: (_attachments = {}, _defineProperty(_attachments, 36064, _this.shadowMap), _defineProperty(_attachments, 36096, _this.depthBuffer), _attachments)
        });
        return _this;
      }
      _createClass(ShadowPass2, [{
        key: "render",
        value: function render(params) {
          var _this2 = this;
          var target = this.fbo;
          withParameters(this.gl, {
            depthRange: [0, 1],
            depthTest: true,
            blend: false,
            clearColor: [1, 1, 1, 1]
          }, function() {
            var viewport = params.viewports[0];
            var pixelRatio = cssToDeviceRatio(_this2.gl);
            var width = viewport.width * pixelRatio;
            var height = viewport.height * pixelRatio;
            if (width !== target.width || height !== target.height) {
              target.resize({
                width,
                height
              });
            }
            _get(_getPrototypeOf(ShadowPass2.prototype), "render", _this2).call(_this2, _objectSpread9({}, params, {
              target,
              pass: "shadow"
            }));
          });
        }
      }, {
        key: "shouldDrawLayer",
        value: function shouldDrawLayer(layer) {
          return layer.props.shadowEnabled !== false;
        }
      }, {
        key: "getModuleParameters",
        value: function getModuleParameters() {
          return {
            drawToShadowMap: true
          };
        }
      }, {
        key: "delete",
        value: function _delete() {
          if (this.fbo) {
            this.fbo["delete"]();
            this.fbo = null;
          }
          if (this.shadowMap) {
            this.shadowMap["delete"]();
            this.shadowMap = null;
          }
          if (this.depthBuffer) {
            this.depthBuffer["delete"]();
            this.depthBuffer = null;
          }
        }
      }]);
      return ShadowPass2;
    }(LayersPass);
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js
var DEFAULT_AMBIENT_LIGHT_PROPS, DEFAULT_DIRECTIONAL_LIGHT_PROPS, DEFAULT_SHADOW_COLOR2, LightingEffect;
var init_lighting_effect = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm14();
    init_ambient_light();
    init_directional_light();
    init_effect();
    init_esm15();
    init_shadow_pass();
    init_shadow();
    DEFAULT_AMBIENT_LIGHT_PROPS = {
      color: [255, 255, 255],
      intensity: 1
    };
    DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
      color: [255, 255, 255],
      intensity: 1,
      direction: [-1, 3, -1]
    }, {
      color: [255, 255, 255],
      intensity: 0.9,
      direction: [1, -8, -2.5]
    }];
    DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
    LightingEffect = function(_Effect) {
      _inherits(LightingEffect2, _Effect);
      function LightingEffect2(props) {
        var _this;
        _classCallCheck(this, LightingEffect2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(LightingEffect2).call(this, props));
        _this.ambientLight = null;
        _this.directionalLights = [];
        _this.pointLights = [];
        _this.shadowColor = DEFAULT_SHADOW_COLOR2;
        _this.shadowPasses = [];
        _this.shadowMaps = [];
        _this.dummyShadowMap = null;
        _this.shadow = false;
        _this.programManager = null;
        for (var key in props) {
          var lightSource = props[key];
          switch (lightSource.type) {
            case "ambient":
              _this.ambientLight = lightSource;
              break;
            case "directional":
              _this.directionalLights.push(lightSource);
              break;
            case "point":
              _this.pointLights.push(lightSource);
              break;
            default:
          }
        }
        _this._applyDefaultLights();
        _this.shadow = _this.directionalLights.some(function(light) {
          return light.shadow;
        });
        return _this;
      }
      _createClass(LightingEffect2, [{
        key: "preRender",
        value: function preRender(gl, _ref) {
          var layers = _ref.layers, layerFilter = _ref.layerFilter, viewports = _ref.viewports, onViewportActive = _ref.onViewportActive, views = _ref.views;
          if (!this.shadow)
            return;
          this.shadowMatrices = this._createLightMatrix();
          if (this.shadowPasses.length === 0) {
            this._createShadowPasses(gl);
          }
          if (!this.programManager) {
            this.programManager = ProgramManager.getDefaultProgramManager(gl);
            if (shadow_default) {
              this.programManager.addDefaultModule(shadow_default);
            }
          }
          if (!this.dummyShadowMap) {
            this.dummyShadowMap = new Texture2D(gl, {
              width: 1,
              height: 1
            });
          }
          for (var i = 0; i < this.shadowPasses.length; i++) {
            var shadowPass = this.shadowPasses[i];
            shadowPass.render({
              layers,
              layerFilter,
              viewports,
              onViewportActive,
              views,
              moduleParameters: {
                shadowLightId: i,
                dummyShadowMap: this.dummyShadowMap,
                shadowMatrices: this.shadowMatrices
              }
            });
          }
        }
      }, {
        key: "getModuleParameters",
        value: function getModuleParameters(layer) {
          var parameters = this.shadow ? {
            shadowMaps: this.shadowMaps,
            dummyShadowMap: this.dummyShadowMap,
            shadowColor: this.shadowColor,
            shadowMatrices: this.shadowMatrices
          } : {};
          parameters.lightSources = {
            ambientLight: this.ambientLight,
            directionalLights: this.directionalLights.map(function(directionalLight) {
              return directionalLight.getProjectedLight({
                layer
              });
            }),
            pointLights: this.pointLights.map(function(pointLight) {
              return pointLight.getProjectedLight({
                layer
              });
            })
          };
          return parameters;
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.shadowPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var shadowPass = _step.value;
              shadowPass["delete"]();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          this.shadowPasses.length = 0;
          this.shadowMaps.length = 0;
          if (this.dummyShadowMap) {
            this.dummyShadowMap["delete"]();
            this.dummyShadowMap = null;
          }
          if (this.shadow && this.programManager) {
            this.programManager.removeDefaultModule(shadow_default);
            this.programManager = null;
          }
        }
      }, {
        key: "_createLightMatrix",
        value: function _createLightMatrix() {
          var lightMatrices = [];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = this.directionalLights[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var light = _step2.value;
              var viewMatrix2 = new Matrix4().lookAt({
                eye: new Vector3(light.direction).negate()
              });
              lightMatrices.push(viewMatrix2);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          return lightMatrices;
        }
      }, {
        key: "_createShadowPasses",
        value: function _createShadowPasses(gl) {
          for (var i = 0; i < this.directionalLights.length; i++) {
            var shadowPass = new ShadowPass(gl);
            this.shadowPasses[i] = shadowPass;
            this.shadowMaps[i] = shadowPass.shadowMap;
          }
        }
      }, {
        key: "_applyDefaultLights",
        value: function _applyDefaultLights() {
          var ambientLight = this.ambientLight, pointLights = this.pointLights, directionalLights = this.directionalLights;
          if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
            this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
            this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
          }
        }
      }]);
      return LightingEffect2;
    }(Effect);
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js
var TypedArrayManager, typed_array_manager_default;
var init_typed_array_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js"() {
    init_classCallCheck();
    init_createClass();
    TypedArrayManager = function() {
      function TypedArrayManager2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$overAlloc = _ref.overAlloc, overAlloc = _ref$overAlloc === void 0 ? 2 : _ref$overAlloc, _ref$poolSize = _ref.poolSize, poolSize = _ref$poolSize === void 0 ? 100 : _ref$poolSize;
        _classCallCheck(this, TypedArrayManager2);
        this.overAlloc = overAlloc;
        this.poolSize = poolSize;
        this._pool = [];
      }
      _createClass(TypedArrayManager2, [{
        key: "allocate",
        value: function allocate(typedArray, count4, _ref2) {
          var _ref2$size = _ref2.size, size = _ref2$size === void 0 ? 1 : _ref2$size, type = _ref2.type, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? 0 : _ref2$padding, _ref2$copy = _ref2.copy, copy2 = _ref2$copy === void 0 ? false : _ref2$copy, _ref2$initialize = _ref2.initialize, initialize = _ref2$initialize === void 0 ? false : _ref2$initialize;
          var Type = type || typedArray && typedArray.constructor || Float32Array;
          var newSize = count4 * size + padding;
          if (ArrayBuffer.isView(typedArray)) {
            if (newSize <= typedArray.length) {
              return typedArray;
            }
            if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
              return new Type(typedArray.buffer, 0, newSize);
            }
          }
          var newArray = this._allocate(Type, newSize, initialize);
          if (typedArray && copy2) {
            newArray.set(typedArray);
          } else if (!initialize) {
            newArray.fill(0, 0, 4);
          }
          this._release(typedArray);
          return newArray;
        }
      }, {
        key: "release",
        value: function release(typedArray) {
          this._release(typedArray);
        }
      }, {
        key: "_allocate",
        value: function _allocate(Type, size, initialize) {
          size = Math.max(Math.ceil(size * this.overAlloc), 1);
          var pool = this._pool;
          var byteLength = Type.BYTES_PER_ELEMENT * size;
          var i = pool.findIndex(function(b) {
            return b.byteLength >= byteLength;
          });
          if (i >= 0) {
            var array = new Type(pool.splice(i, 1)[0], 0, size);
            if (initialize) {
              array.fill(0);
            }
            return array;
          }
          return new Type(size);
        }
      }, {
        key: "_release",
        value: function _release(typedArray) {
          if (!ArrayBuffer.isView(typedArray)) {
            return;
          }
          var pool = this._pool;
          var buffer = typedArray.buffer;
          var byteLength = buffer.byteLength;
          var i = pool.findIndex(function(b) {
            return b.byteLength >= byteLength;
          });
          if (i < 0) {
            pool.push(buffer);
          } else if (i > 0 || pool.length < this.poolSize) {
            pool.splice(i, 0, buffer);
          }
          if (pool.length > this.poolSize) {
            pool.shift();
          }
        }
      }]);
      return TypedArrayManager2;
    }();
    typed_array_manager_default = new TypedArrayManager();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/math-utils.js
function createMat42() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod2(value4, divisor) {
  var modulus = value4 % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function extractCameraVectors(_ref) {
  var viewMatrix2 = _ref.viewMatrix, viewMatrixInverse = _ref.viewMatrixInverse;
  return {
    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],
    direction: [-viewMatrix2[2], -viewMatrix2[6], -viewMatrix2[10]],
    up: [viewMatrix2[1], viewMatrix2[5], viewMatrix2[9]],
    right: [viewMatrix2[0], viewMatrix2[4], viewMatrix2[8]]
  };
}
function getFrustumPlanes(_ref2) {
  var aspect = _ref2.aspect, near = _ref2.near, far = _ref2.far, fovyRadians = _ref2.fovyRadians, position = _ref2.position, direction = _ref2.direction, up = _ref2.up, right = _ref2.right;
  cameraDirection.copy(direction);
  var nearFarScale = 1 / cameraDirection.len();
  cameraDirection.normalize();
  cameraPosition.copy(position);
  cameraUp.copy(up);
  var widthScale = 1 / cameraUp.len();
  cameraUp.normalize();
  cameraRight.copy(right).normalize();
  var nearHeight = 2 * Math.tan(fovyRadians / 2) * near * widthScale;
  var nearWidth = nearHeight * aspect;
  nearCenter.copy(cameraDirection).scale(near * nearFarScale).add(cameraPosition);
  farCenter.copy(cameraDirection).scale(far * nearFarScale).add(cameraPosition);
  var normal = cameraDirection.clone().negate();
  var distance2 = normal.dot(nearCenter);
  var planes = {
    near: {
      distance: distance2,
      normal
    },
    far: {
      distance: cameraDirection.dot(farCenter),
      normal: cameraDirection.clone()
    }
  };
  a.copy(cameraRight).scale(nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new Vector3(a).cross(cameraUp);
  distance2 = cameraPosition.dot(normal);
  planes.right = {
    normal,
    distance: distance2
  };
  a.copy(cameraRight).scale(-nearWidth * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new Vector3(cameraUp).cross(a);
  distance2 = cameraPosition.dot(normal);
  planes.left = {
    normal,
    distance: distance2
  };
  a.copy(cameraUp).scale(nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new Vector3(cameraRight).cross(a);
  distance2 = cameraPosition.dot(normal);
  planes.top = {
    normal,
    distance: distance2
  };
  a.copy(cameraUp).scale(-nearHeight * 0.5).add(nearCenter).subtract(cameraPosition).normalize();
  normal = new Vector3(a).cross(cameraRight);
  distance2 = cameraPosition.dot(normal);
  planes.bottom = {
    normal,
    distance: distance2
  };
  return planes;
}
function fp64LowPart2(x) {
  return x - Math.fround(x);
}
function toDoublePrecisionArray(typedArray, _ref3) {
  var _ref3$size = _ref3.size, size = _ref3$size === void 0 ? 1 : _ref3$size, _ref3$startIndex = _ref3.startIndex, startIndex = _ref3$startIndex === void 0 ? 0 : _ref3$startIndex, endIndex = _ref3.endIndex;
  if (!Number.isFinite(endIndex)) {
    endIndex = typedArray.length;
  }
  var count4 = (endIndex - startIndex) / size;
  scratchArray = typed_array_manager_default.allocate(scratchArray, count4, {
    type: Float32Array,
    size: size * 2
  });
  var sourceIndex = startIndex;
  var targetIndex = 0;
  while (sourceIndex < endIndex) {
    for (var j = 0; j < size; j++) {
      var value4 = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value4;
      scratchArray[targetIndex + j + size] = fp64LowPart2(value4);
    }
    targetIndex += size * 2;
  }
  return scratchArray.subarray(0, count4 * size * 2);
}
var cameraPosition, cameraDirection, cameraUp, cameraRight, nearCenter, farCenter, a, scratchArray;
var init_math_utils3 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/math-utils.js"() {
    init_typed_array_manager();
    init_esm15();
    cameraPosition = new Vector3();
    cameraDirection = new Vector3();
    cameraUp = new Vector3();
    cameraRight = new Vector3();
    nearCenter = new Vector3();
    farCenter = new Vector3();
    a = new Vector3();
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/viewport.js
var DEGREES_TO_RADIANS4, IDENTITY2, ZERO_VECTOR2, DEFAULT_ZOOM, DEFAULT_DISTANCE_SCALES, Viewport;
var init_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/viewport.js"() {
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_log2();
    init_math_utils3();
    init_esm15();
    init_mat4();
    init_esm16();
    init_constants2();
    DEGREES_TO_RADIANS4 = Math.PI / 180;
    IDENTITY2 = createMat42();
    ZERO_VECTOR2 = [0, 0, 0];
    DEFAULT_ZOOM = 0;
    DEFAULT_DISTANCE_SCALES = {
      unitsPerMeter: [1, 1, 1],
      metersPerUnit: [1, 1, 1]
    };
    Viewport = function() {
      function Viewport2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Viewport2);
        var _opts$id = opts.id, id = _opts$id === void 0 ? null : _opts$id, _opts$x = opts.x, x = _opts$x === void 0 ? 0 : _opts$x, _opts$y = opts.y, y = _opts$y === void 0 ? 0 : _opts$y, _opts$width = opts.width, width = _opts$width === void 0 ? 1 : _opts$width, _opts$height = opts.height, height = _opts$height === void 0 ? 1 : _opts$height;
        this.id = id || this.constructor.displayName || "viewport";
        this.x = x;
        this.y = y;
        this.width = width || 1;
        this.height = height || 1;
        this._frustumPlanes = {};
        this._initViewMatrix(opts);
        this._initProjectionMatrix(opts);
        this._initPixelMatrices();
        this.equals = this.equals.bind(this);
        this.project = this.project.bind(this);
        this.unproject = this.unproject.bind(this);
        this.projectPosition = this.projectPosition.bind(this);
        this.unprojectPosition = this.unprojectPosition.bind(this);
        this.projectFlat = this.projectFlat.bind(this);
        this.unprojectFlat = this.unprojectFlat.bind(this);
      }
      _createClass(Viewport2, [{
        key: "equals",
        value: function equals4(viewport) {
          if (!(viewport instanceof Viewport2)) {
            return false;
          }
          if (this === viewport) {
            return true;
          }
          return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
        }
      }, {
        key: "project",
        value: function project2(xyz) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$topLeft = _ref.topLeft, topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;
          var worldPosition = this.projectPosition(xyz);
          var coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
          var _coord = _slicedToArray(coord, 2), x = _coord[0], y = _coord[1];
          var y2 = topLeft ? y : this.height - y;
          return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
        }
      }, {
        key: "unproject",
        value: function unproject(xyz) {
          var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$topLeft = _ref2.topLeft, topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft, targetZ = _ref2.targetZ;
          var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
          var y2 = topLeft ? y : this.height - y;
          var targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
          var coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
          var _this$unprojectPositi = this.unprojectPosition(coord), _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3), X = _this$unprojectPositi2[0], Y = _this$unprojectPositi2[1], Z = _this$unprojectPositi2[2];
          if (Number.isFinite(z)) {
            return [X, Y, Z];
          }
          return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
        }
      }, {
        key: "projectPosition",
        value: function projectPosition2(xyz) {
          var _this$projectFlat = this.projectFlat(xyz), _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2), X = _this$projectFlat2[0], Y = _this$projectFlat2[1];
          var Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
          return [X, Y, Z];
        }
      }, {
        key: "unprojectPosition",
        value: function unprojectPosition(xyz) {
          var _this$unprojectFlat = this.unprojectFlat(xyz), _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2), X = _this$unprojectFlat2[0], Y = _this$unprojectFlat2[1];
          var Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
          return [X, Y, Z];
        }
      }, {
        key: "projectFlat",
        value: function projectFlat(xyz) {
          if (this.isGeospatial) {
            return lngLatToWorld(xyz);
          }
          return xyz;
        }
      }, {
        key: "unprojectFlat",
        value: function unprojectFlat(xyz) {
          if (this.isGeospatial) {
            return worldToLngLat(xyz);
          }
          return xyz;
        }
      }, {
        key: "getBounds",
        value: function getBounds2() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var unprojectOption = {
            targetZ: options.z || 0
          };
          var topLeft = this.unproject([0, 0], unprojectOption);
          var topRight = this.unproject([this.width, 0], unprojectOption);
          var bottomLeft = this.unproject([0, this.height], unprojectOption);
          var bottomRight = this.unproject([this.width, this.height], unprojectOption);
          return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
        }
      }, {
        key: "getDistanceScales",
        value: function getDistanceScales3() {
          var coordinateOrigin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          if (coordinateOrigin) {
            return getDistanceScales({
              longitude: coordinateOrigin[0],
              latitude: coordinateOrigin[1],
              highPrecision: true
            });
          }
          return this.distanceScales;
        }
      }, {
        key: "containsPixel",
        value: function containsPixel(_ref3) {
          var x = _ref3.x, y = _ref3.y, _ref3$width = _ref3.width, width = _ref3$width === void 0 ? 1 : _ref3$width, _ref3$height = _ref3.height, height = _ref3$height === void 0 ? 1 : _ref3$height;
          return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
        }
      }, {
        key: "getFrustumPlanes",
        value: function getFrustumPlanes2() {
          if (this._frustumPlanes.near) {
            return this._frustumPlanes;
          }
          var _this$projectionProps = this.projectionProps, near = _this$projectionProps.near, far = _this$projectionProps.far, fovyRadians = _this$projectionProps.fovyRadians, aspect = _this$projectionProps.aspect;
          Object.assign(this._frustumPlanes, getFrustumPlanes({
            aspect,
            near,
            far,
            fovyRadians,
            position: this.cameraPosition,
            direction: this.cameraDirection,
            up: this.cameraUp,
            right: this.cameraRight
          }));
          return this._frustumPlanes;
        }
      }, {
        key: "getCameraPosition",
        value: function getCameraPosition() {
          return this.cameraPosition;
        }
      }, {
        key: "getCameraDirection",
        value: function getCameraDirection() {
          return this.cameraDirection;
        }
      }, {
        key: "getCameraUp",
        value: function getCameraUp() {
          return this.cameraUp;
        }
      }, {
        key: "_createProjectionMatrix",
        value: function _createProjectionMatrix(_ref4) {
          var orthographic = _ref4.orthographic, fovyRadians = _ref4.fovyRadians, aspect = _ref4.aspect, focalDistance = _ref4.focalDistance, near = _ref4.near, far = _ref4.far;
          return orthographic ? new Matrix4().orthographic({
            fovy: fovyRadians,
            aspect,
            focalDistance,
            near,
            far
          }) : new Matrix4().perspective({
            fovy: fovyRadians,
            aspect,
            near,
            far
          });
        }
      }, {
        key: "_initViewMatrix",
        value: function _initViewMatrix(opts) {
          var _opts$viewMatrix = opts.viewMatrix, viewMatrix2 = _opts$viewMatrix === void 0 ? IDENTITY2 : _opts$viewMatrix, _opts$longitude = opts.longitude, longitude = _opts$longitude === void 0 ? null : _opts$longitude, _opts$latitude = opts.latitude, latitude = _opts$latitude === void 0 ? null : _opts$latitude, _opts$zoom = opts.zoom, zoom = _opts$zoom === void 0 ? null : _opts$zoom, _opts$position = opts.position, position = _opts$position === void 0 ? null : _opts$position, _opts$modelMatrix = opts.modelMatrix, modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix, _opts$focalDistance = opts.focalDistance, focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance, _opts$distanceScales = opts.distanceScales, distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales;
          this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
          this.zoom = zoom;
          if (!Number.isFinite(this.zoom)) {
            this.zoom = this.isGeospatial ? getMeterZoom({
              latitude
            }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
          }
          var scale6 = Math.pow(2, this.zoom);
          this.scale = scale6;
          this.distanceScales = this.isGeospatial ? getDistanceScales({
            latitude,
            longitude
          }) : distanceScales || DEFAULT_DISTANCE_SCALES;
          this.focalDistance = focalDistance;
          this.distanceScales.metersPerUnit = new Vector3(this.distanceScales.metersPerUnit);
          this.distanceScales.unitsPerMeter = new Vector3(this.distanceScales.unitsPerMeter);
          this.position = ZERO_VECTOR2;
          this.meterOffset = ZERO_VECTOR2;
          if (position) {
            this.position = position;
            this.modelMatrix = modelMatrix;
            this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
          }
          if (this.isGeospatial) {
            this.longitude = longitude;
            this.latitude = latitude;
            this.center = this._getCenterInWorld({
              longitude,
              latitude
            });
          } else {
            this.center = position ? this.projectPosition(position) : [0, 0, 0];
          }
          this.viewMatrixUncentered = viewMatrix2;
          this.viewMatrix = new Matrix4().multiplyRight(this.viewMatrixUncentered).translate(new Vector3(this.center || ZERO_VECTOR2).negate());
        }
      }, {
        key: "_getCenterInWorld",
        value: function _getCenterInWorld(_ref5) {
          var longitude = _ref5.longitude, latitude = _ref5.latitude;
          var meterOffset = this.meterOffset, distanceScales = this.distanceScales;
          var center = new Vector3(this.projectPosition([longitude, latitude, 0]));
          if (meterOffset) {
            var commonPosition = new Vector3(meterOffset).scale(distanceScales.unitsPerMeter);
            center.add(commonPosition);
          }
          return center;
        }
      }, {
        key: "_initProjectionMatrix",
        value: function _initProjectionMatrix(opts) {
          var _opts$projectionMatri = opts.projectionMatrix, projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri, _opts$orthographic = opts.orthographic, orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic, fovyRadians = opts.fovyRadians, _opts$fovy = opts.fovy, fovy = _opts$fovy === void 0 ? 75 : _opts$fovy, _opts$near = opts.near, near = _opts$near === void 0 ? 0.1 : _opts$near, _opts$far = opts.far, far = _opts$far === void 0 ? 1e3 : _opts$far, _opts$focalDistance2 = opts.focalDistance, focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2;
          this.projectionProps = {
            orthographic,
            fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
            aspect: this.width / this.height,
            focalDistance,
            near,
            far
          };
          this.projectionMatrix = projectionMatrix || this._createProjectionMatrix(this.projectionProps);
        }
      }, {
        key: "_initPixelMatrices",
        value: function _initPixelMatrices() {
          var vpm = createMat42();
          multiply3(vpm, vpm, this.projectionMatrix);
          multiply3(vpm, vpm, this.viewMatrix);
          this.viewProjectionMatrix = vpm;
          this.viewMatrixInverse = invert2([], this.viewMatrix) || this.viewMatrix;
          var _extractCameraVectors = extractCameraVectors({
            viewMatrix: this.viewMatrix,
            viewMatrixInverse: this.viewMatrixInverse
          }), eye = _extractCameraVectors.eye, direction = _extractCameraVectors.direction, up = _extractCameraVectors.up, right = _extractCameraVectors.right;
          this.cameraPosition = eye;
          this.cameraDirection = direction;
          this.cameraUp = up;
          this.cameraRight = right;
          var viewportMatrix = createMat42();
          var pixelProjectionMatrix = createMat42();
          scale3(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
          translate2(viewportMatrix, viewportMatrix, [1, -1, 0]);
          multiply3(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
          this.pixelProjectionMatrix = pixelProjectionMatrix;
          this.viewportMatrix = viewportMatrix;
          this.pixelUnprojectionMatrix = invert2(createMat42(), this.pixelProjectionMatrix);
          if (!this.pixelUnprojectionMatrix) {
            log_default.warn("Pixel project matrix not invertible")();
          }
        }
      }, {
        key: "metersPerPixel",
        get: function get2() {
          return this.distanceScales.metersPerUnit[2] / this.scale;
        }
      }, {
        key: "projectionMode",
        get: function get2() {
          if (this.isGeospatial) {
            return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
          }
          return PROJECTION_MODE.IDENTITY;
        }
      }]);
      return Viewport2;
    }();
    Viewport.displayName = "Viewport";
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js
function ownKeys10(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread10(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys10(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys10(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var WebMercatorViewport2;
var init_web_mercator_viewport2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_assertThisInitialized();
    init_inherits();
    init_viewport();
    init_esm16();
    init_vec2();
    init_esm15();
    WebMercatorViewport2 = function(_Viewport) {
      _inherits(WebMercatorViewport3, _Viewport);
      function WebMercatorViewport3() {
        var _this;
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, WebMercatorViewport3);
        var _opts$latitude = opts.latitude, latitude = _opts$latitude === void 0 ? 0 : _opts$latitude, _opts$longitude = opts.longitude, longitude = _opts$longitude === void 0 ? 0 : _opts$longitude, _opts$zoom = opts.zoom, zoom = _opts$zoom === void 0 ? 11 : _opts$zoom, _opts$pitch = opts.pitch, pitch = _opts$pitch === void 0 ? 0 : _opts$pitch, _opts$bearing = opts.bearing, bearing = _opts$bearing === void 0 ? 0 : _opts$bearing, _opts$nearZMultiplier = opts.nearZMultiplier, nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier, _opts$farZMultiplier = opts.farZMultiplier, farZMultiplier = _opts$farZMultiplier === void 0 ? 1.01 : _opts$farZMultiplier, _opts$orthographic = opts.orthographic, orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic, _opts$repeat = opts.repeat, repeat = _opts$repeat === void 0 ? false : _opts$repeat, _opts$worldOffset = opts.worldOffset, worldOffset = _opts$worldOffset === void 0 ? 0 : _opts$worldOffset;
        var width = opts.width, height = opts.height, _opts$altitude = opts.altitude, altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;
        var scale6 = Math.pow(2, zoom);
        width = width || 1;
        height = height || 1;
        altitude = Math.max(0.75, altitude);
        var _getProjectionParamet = getProjectionParameters({
          width,
          height,
          pitch,
          altitude,
          nearZMultiplier,
          farZMultiplier
        }), fov = _getProjectionParamet.fov, aspect = _getProjectionParamet.aspect, focalDistance = _getProjectionParamet.focalDistance, near = _getProjectionParamet.near, far = _getProjectionParamet.far;
        var viewMatrixUncentered = getViewMatrix({
          height,
          pitch,
          bearing,
          scale: scale6,
          altitude
        });
        if (worldOffset) {
          var viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
          viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
        }
        var viewportOpts = Object.assign({}, opts, {
          width,
          height,
          viewMatrix: viewMatrixUncentered,
          longitude,
          latitude,
          zoom,
          orthographic,
          fovyRadians: fov,
          aspect,
          focalDistance: orthographic ? focalDistance : 1,
          near,
          far
        });
        _this = _possibleConstructorReturn(this, _getPrototypeOf(WebMercatorViewport3).call(this, viewportOpts));
        _this.latitude = latitude;
        _this.longitude = longitude;
        _this.zoom = zoom;
        _this.pitch = pitch;
        _this.bearing = bearing;
        _this.altitude = altitude;
        _this.orthographic = orthographic;
        _this._subViewports = repeat ? [] : null;
        Object.freeze(_assertThisInitialized(_this));
        return _this;
      }
      _createClass(WebMercatorViewport3, [{
        key: "addMetersToLngLat",
        value: function addMetersToLngLat2(lngLatZ, xyz) {
          return addMetersToLngLat(lngLatZ, xyz);
        }
      }, {
        key: "getMapCenterByLngLatPosition",
        value: function getMapCenterByLngLatPosition(_ref) {
          var lngLat = _ref.lngLat, pos = _ref.pos;
          var fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
          var toLocation = this.projectFlat(lngLat);
          var translate3 = add([], toLocation, negate([], fromLocation));
          var newCenter = add([], this.center, translate3);
          return this.unprojectFlat(newCenter);
        }
      }, {
        key: "getBounds",
        value: function getBounds2() {
          var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var corners = getBounds(this, options.z || 0);
          return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
        }
      }, {
        key: "fitBounds",
        value: function fitBounds2(bounds) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var width = this.width, height = this.height;
          var _fitBounds2 = fitBounds(Object.assign({
            width,
            height,
            bounds
          }, options)), longitude = _fitBounds2.longitude, latitude = _fitBounds2.latitude, zoom = _fitBounds2.zoom;
          return new WebMercatorViewport3({
            width,
            height,
            longitude,
            latitude,
            zoom
          });
        }
      }, {
        key: "subViewports",
        get: function get2() {
          if (this._subViewports && !this._subViewports.length) {
            var bounds = this.getBounds();
            var minOffset = Math.floor((bounds[0] + 180) / 360);
            var maxOffset = Math.ceil((bounds[2] - 180) / 360);
            for (var x = minOffset; x <= maxOffset; x++) {
              var offsetViewport = x ? new WebMercatorViewport3(_objectSpread10({}, this, {
                worldOffset: x
              })) : this;
              this._subViewports.push(offsetViewport);
            }
          }
          return this._subViewports;
        }
      }]);
      return WebMercatorViewport3;
    }(Viewport);
    WebMercatorViewport2.displayName = "WebMercatorViewport";
  }
});

// node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js
function lngLatZToWorldPosition(lngLatZ, viewport) {
  var offsetMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var p = viewport.projectPosition(lngLatZ);
  if (offsetMode && viewport instanceof WebMercatorViewport2) {
    var _lngLatZ = _slicedToArray(lngLatZ, 3), longitude = _lngLatZ[0], latitude = _lngLatZ[1], _lngLatZ$ = _lngLatZ[2], z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;
    var distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }
  return p;
}
function normalizeParameters(opts) {
  var normalizedParams = Object.assign({}, opts);
  var coordinateSystem = opts.coordinateSystem;
  var viewport = opts.viewport, coordinateOrigin = opts.coordinateOrigin, fromCoordinateSystem = opts.fromCoordinateSystem, fromCoordinateOrigin = opts.fromCoordinateOrigin;
  if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
  }
  if (fromCoordinateSystem === void 0) {
    normalizedParams.fromCoordinateSystem = coordinateSystem;
  }
  if (fromCoordinateOrigin === void 0) {
    normalizedParams.fromCoordinateOrigin = coordinateOrigin;
  }
  normalizedParams.coordinateSystem = coordinateSystem;
  return normalizedParams;
}
function getWorldPosition(position, _ref) {
  var viewport = _ref.viewport, modelMatrix = _ref.modelMatrix, coordinateSystem = _ref.coordinateSystem, coordinateOrigin = _ref.coordinateOrigin, offsetMode = _ref.offsetMode;
  var _position = _slicedToArray(position, 3), x = _position[0], y = _position[1], z = _position[2];
  if (modelMatrix) {
    var _vec4$transformMat = transformMat43([], [x, y, z, 1], modelMatrix);
    var _vec4$transformMat2 = _slicedToArray(_vec4$transformMat, 3);
    x = _vec4$transformMat2[0];
    y = _vec4$transformMat2[1];
    z = _vec4$transformMat2[2];
  }
  switch (coordinateSystem) {
    case COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);
    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
    case COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);
    case COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}
function projectPosition(position, params) {
  var _normalizeParameters = normalizeParameters(params), viewport = _normalizeParameters.viewport, coordinateSystem = _normalizeParameters.coordinateSystem, coordinateOrigin = _normalizeParameters.coordinateOrigin, modelMatrix = _normalizeParameters.modelMatrix, fromCoordinateSystem = _normalizeParameters.fromCoordinateSystem, fromCoordinateOrigin = _normalizeParameters.fromCoordinateOrigin;
  var _getOffsetOrigin = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin), geospatialOrigin = _getOffsetOrigin.geospatialOrigin, shaderCoordinateOrigin = _getOffsetOrigin.shaderCoordinateOrigin, offsetMode = _getOffsetOrigin.offsetMode;
  var worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });
  if (offsetMode) {
    var positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    sub2(worldPosition, worldPosition, positionCommonSpace);
  }
  return worldPosition;
}
var init_project_functions = __esm({
  "node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js"() {
    init_slicedToArray();
    init_constants2();
    init_viewport_uniforms();
    init_web_mercator_viewport2();
    init_vec4();
    init_vec3();
    init_esm16();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js
function ownKeys11(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread11(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys11(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys11(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var ShaderAttribute;
var init_shader_attribute = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    ShaderAttribute = function() {
      function ShaderAttribute2(dataColumn, opts) {
        _classCallCheck(this, ShaderAttribute2);
        this.opts = opts;
        this.source = dataColumn;
      }
      _createClass(ShaderAttribute2, [{
        key: "getValue",
        value: function getValue2() {
          var buffer = this.source.getBuffer();
          var accessor = this.getAccessor();
          if (buffer) {
            return [buffer, accessor];
          }
          var value4 = this.source.value;
          var size = accessor.size;
          var constantValue = value4;
          if (value4 && value4.length !== size) {
            constantValue = new Float32Array(size);
            var index = accessor.elementOffset || 0;
            for (var i = 0; i < size; ++i) {
              constantValue[i] = value4[index + i];
            }
          }
          return constantValue;
        }
      }, {
        key: "getAccessor",
        value: function getAccessor() {
          return _objectSpread11({}, this.source.getAccessor(), {}, this.opts);
        }
      }, {
        key: "value",
        get: function get2() {
          return this.source.value;
        }
      }]);
      return ShaderAttribute2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js
function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Unknown GL type");
  }
}
var init_gl_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js
function ownKeys12(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread12(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys12(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}
function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  }
  var stride = getStride(baseAccessor);
  var vertexOffset = "vertexOffset" in shaderAttributeOptions ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  var elementOffset = shaderAttributeOptions.elementOffset || 0;
  var offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return _objectSpread12({}, shaderAttributeOptions, {
    offset,
    stride
  });
}
function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  var resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: _objectSpread12({}, resolvedOptions, {
      offset: resolvedOptions.offset + baseAccessor.size * 4
    })
  };
}
var DataColumn;
var init_data_column = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    init_esm14();
    init_shader_attribute();
    init_gl_utils();
    init_typed_array_manager();
    init_math_utils3();
    init_log2();
    DataColumn = function() {
      function DataColumn2(gl, opts) {
        _classCallCheck(this, DataColumn2);
        this.gl = gl;
        this.id = opts.id;
        this.size = opts.size;
        var logicalType = opts.logicalType || opts.type;
        var doublePrecision = logicalType === 5130;
        var defaultValue = opts.defaultValue;
        defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
        opts.defaultValue = defaultValue;
        var bufferType = logicalType;
        if (doublePrecision) {
          bufferType = 5126;
        } else if (!bufferType && opts.isIndexed) {
          bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
        } else if (!bufferType) {
          bufferType = 5126;
        }
        opts.logicalType = logicalType;
        opts.type = bufferType;
        var defaultType = glArrayFromType(logicalType || bufferType || 5126);
        this.shaderAttributes = {};
        this.doublePrecision = doublePrecision;
        if (doublePrecision && opts.fp64 === false) {
          defaultType = Float32Array;
        }
        opts.bytesPerElement = defaultType.BYTES_PER_ELEMENT;
        this.defaultType = defaultType;
        this.value = null;
        this.settings = opts;
        this.state = {
          externalBuffer: null,
          bufferAccessor: opts,
          allocatedValue: null,
          constant: false
        };
        this._buffer = null;
        this.setData(opts);
      }
      _createClass(DataColumn2, [{
        key: "delete",
        value: function _delete() {
          if (this._buffer) {
            this._buffer["delete"]();
            this._buffer = null;
          }
          typed_array_manager_default.release(this.state.allocatedValue);
        }
      }, {
        key: "getShaderAttributes",
        value: function getShaderAttributes(id, options) {
          if (this.doublePrecision) {
            var shaderAttributes = {};
            var isBuffer64Bit = this.value instanceof Float64Array;
            var doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
            shaderAttributes[id] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
            shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
            return shaderAttributes;
          }
          if (options) {
            var shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
            return _defineProperty({}, id, new ShaderAttribute(this, shaderAttributeDef));
          }
          return _defineProperty({}, id, this);
        }
      }, {
        key: "getBuffer",
        value: function getBuffer() {
          if (this.state.constant) {
            return null;
          }
          return this.state.externalBuffer || this._buffer;
        }
      }, {
        key: "getValue",
        value: function getValue2() {
          if (this.state.constant) {
            return this.value;
          }
          return [this.getBuffer(), this.getAccessor()];
        }
      }, {
        key: "getAccessor",
        value: function getAccessor() {
          return this.state.bufferAccessor;
        }
      }, {
        key: "setData",
        value: function setData(opts) {
          var state = this.state;
          if (ArrayBuffer.isView(opts)) {
            opts = {
              value: opts
            };
          } else if (opts instanceof Buffer) {
            opts = {
              buffer: opts
            };
          }
          var accessor = _objectSpread12({}, this.settings, {}, opts);
          state.bufferAccessor = accessor;
          if (opts.constant) {
            var value4 = opts.value;
            value4 = this._normalizeValue(value4, [], 0);
            if (this.settings.normalized) {
              value4 = this._normalizeConstant(value4);
            }
            var hasChanged = !state.constant || !this._areValuesEqual(value4, this.value);
            if (!hasChanged) {
              return false;
            }
            state.externalBuffer = null;
            state.constant = true;
            this.value = value4;
          } else if (opts.buffer) {
            var buffer = opts.buffer;
            state.externalBuffer = buffer;
            state.constant = false;
            this.value = opts.value;
            var isBuffer64Bit = opts.value instanceof Float64Array;
            accessor.type = opts.type || buffer.accessor.type;
            accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
            accessor.stride = getStride(accessor);
          } else if (opts.value) {
            this._checkExternalBuffer(opts);
            var _value = opts.value;
            state.externalBuffer = null;
            state.constant = false;
            this.value = _value;
            accessor.bytesPerElement = _value.BYTES_PER_ELEMENT;
            accessor.stride = getStride(accessor);
            var _buffer = this.buffer, byteOffset = this.byteOffset;
            if (this.doublePrecision && _value instanceof Float64Array) {
              _value = toDoublePrecisionArray(_value, accessor);
            }
            if (_buffer.byteLength < _value.byteLength + byteOffset) {
              _buffer.reallocate((_value.byteLength + byteOffset) * 2);
            }
            _buffer.setAccessor(null);
            _buffer.subData({
              data: _value,
              offset: byteOffset
            });
            accessor.type = opts.type || _buffer.accessor.type;
          }
          return true;
        }
      }, {
        key: "updateSubBuffer",
        value: function updateSubBuffer() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var value4 = this.value;
          var _opts$startOffset = opts.startOffset, startOffset = _opts$startOffset === void 0 ? 0 : _opts$startOffset, endOffset = opts.endOffset;
          this.buffer.subData({
            data: this.doublePrecision && value4 instanceof Float64Array ? toDoublePrecisionArray(value4, {
              size: this.size,
              startIndex: startOffset,
              endIndex: endOffset
            }) : value4.subarray(startOffset, endOffset),
            offset: startOffset * value4.BYTES_PER_ELEMENT + this.byteOffset
          });
        }
      }, {
        key: "allocate",
        value: function allocate(_ref3) {
          var numInstances = _ref3.numInstances, _ref3$copy = _ref3.copy, copy2 = _ref3$copy === void 0 ? false : _ref3$copy;
          var state = this.state;
          var oldValue = state.allocatedValue;
          var value4 = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
            size: this.size,
            type: this.defaultType,
            copy: copy2
          });
          this.value = value4;
          var buffer = this.buffer, byteOffset = this.byteOffset;
          if (buffer.byteLength < value4.byteLength + byteOffset) {
            buffer.reallocate(value4.byteLength + byteOffset);
            if (copy2 && oldValue) {
              buffer.subData({
                data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
                offset: byteOffset
              });
            }
          }
          state.allocatedValue = value4;
          state.constant = false;
          state.externalBuffer = null;
          state.bufferAccessor = this.settings;
          return true;
        }
      }, {
        key: "_checkExternalBuffer",
        value: function _checkExternalBuffer(opts) {
          var value4 = opts.value;
          if (!opts.constant && value4) {
            var ArrayType = this.defaultType;
            var illegalArrayType = false;
            if (this.doublePrecision) {
              illegalArrayType = value4.BYTES_PER_ELEMENT < 4;
            }
            if (illegalArrayType) {
              throw new Error("Attribute ".concat(this.id, " does not support ").concat(value4.constructor.name));
            }
            if (!(value4 instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
              log_default.warn("Attribute ".concat(this.id, " is normalized"))();
            }
          }
        }
      }, {
        key: "_normalizeConstant",
        value: function _normalizeConstant(value4) {
          switch (this.settings.type) {
            case 5120:
              return new Float32Array(value4).map(function(x) {
                return (x + 128) / 255 * 2 - 1;
              });
            case 5122:
              return new Float32Array(value4).map(function(x) {
                return (x + 32768) / 65535 * 2 - 1;
              });
            case 5121:
              return new Float32Array(value4).map(function(x) {
                return x / 255;
              });
            case 5123:
              return new Float32Array(value4).map(function(x) {
                return x / 65535;
              });
            default:
              return value4;
          }
        }
      }, {
        key: "_normalizeValue",
        value: function _normalizeValue(value4, out, start) {
          var _this$settings = this.settings, defaultValue = _this$settings.defaultValue, size = _this$settings.size;
          if (Number.isFinite(value4)) {
            out[start] = value4;
            return out;
          }
          if (!value4) {
            out[start] = defaultValue[0];
            return out;
          }
          switch (size) {
            case 4:
              out[start + 3] = Number.isFinite(value4[3]) ? value4[3] : defaultValue[3];
            case 3:
              out[start + 2] = Number.isFinite(value4[2]) ? value4[2] : defaultValue[2];
            case 2:
              out[start + 1] = Number.isFinite(value4[1]) ? value4[1] : defaultValue[1];
            case 1:
              out[start + 0] = Number.isFinite(value4[0]) ? value4[0] : defaultValue[0];
              break;
            default:
              var i = size;
              while (--i >= 0) {
                out[start + i] = Number.isFinite(value4[i]) ? value4[i] : defaultValue[i];
              }
          }
          return out;
        }
      }, {
        key: "_areValuesEqual",
        value: function _areValuesEqual(value1, value22) {
          if (!value1 || !value22) {
            return false;
          }
          var size = this.size;
          for (var i = 0; i < size; i++) {
            if (value1[i] !== value22[i]) {
              return false;
            }
          }
          return true;
        }
      }, {
        key: "buffer",
        get: function get2() {
          if (!this._buffer) {
            var _this$settings2 = this.settings, isIndexed = _this$settings2.isIndexed, type = _this$settings2.type;
            this._buffer = new Buffer(this.gl, {
              id: this.id,
              target: isIndexed ? 34963 : 34962,
              accessor: {
                type
              }
            });
          }
          return this._buffer;
        }
      }, {
        key: "byteOffset",
        get: function get2() {
          var accessor = this.getAccessor();
          if (accessor.vertexOffset) {
            return accessor.vertexOffset * getStride(accessor);
          }
          return 0;
        }
      }]);
      return DataColumn2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js
function createIterable(data) {
  var startRow = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var endRow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Infinity;
  var iterable = EMPTY_ARRAY;
  var objectInfo = {
    index: -1,
    data,
    target: []
  };
  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === "function") {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }
  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }
  return {
    iterable,
    objectInfo
  };
}
function isAsyncIterable3(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, _ref) {
  var size = _ref.size, stride = _ref.stride, offset = _ref.offset, startIndices = _ref.startIndices, nested = _ref.nested;
  var bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  var elementStride = stride ? stride / bytesPerElement : size;
  var elementOffset = offset ? offset / bytesPerElement : 0;
  var vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return function(_, _ref2) {
    var index = _ref2.index, target = _ref2.target;
    if (!startIndices) {
      var sourceIndex = index * elementStride + elementOffset;
      for (var j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }
      return target;
    }
    var startIndex = startIndices[index];
    var endIndex = startIndices[index + 1] || vertexCount;
    var result;
    if (nested) {
      result = new Array(endIndex - startIndex);
      for (var i = startIndex; i < endIndex; i++) {
        var _sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);
        for (var _j = 0; _j < size; _j++) {
          target[_j] = typedArray[_sourceIndex + _j];
        }
        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      var targetIndex = 0;
      for (var _i = startIndex; _i < endIndex; _i++) {
        var _sourceIndex2 = _i * elementStride + elementOffset;
        for (var _j2 = 0; _j2 < size; _j2++) {
          result[targetIndex++] = typedArray[_sourceIndex2 + _j2];
        }
      }
    }
    return result;
  };
}
var EMPTY_ARRAY, placeholderArray;
var init_iterable_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js"() {
    EMPTY_ARRAY = [];
    placeholderArray = [];
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/flatten.js
function flatten(array) {
  var filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    return true;
  };
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }
  return flattenArray(array, filter, []);
}
function flattenArray(array, filter, result) {
  var index = -1;
  while (++index < array.length) {
    var value4 = array[index];
    if (Array.isArray(value4)) {
      flattenArray(value4, filter, result);
    } else if (filter(value4)) {
      result.push(value4);
    }
  }
  return result;
}
function fillArray2(_ref) {
  var target = _ref.target, source = _ref.source, _ref$start = _ref.start, start = _ref$start === void 0 ? 0 : _ref$start, _ref$count = _ref.count, count4 = _ref$count === void 0 ? 1 : _ref$count;
  var length5 = source.length;
  var total = count4 * length5;
  var copied = 0;
  for (var i = start; copied < length5; copied++) {
    target[i++] = source[copied];
  }
  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }
  return target;
}
var init_flatten = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/flatten.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/range.js
function add5(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }
  if (range[0] < 0) {
    range[0] = 0;
  }
  if (range[0] >= range[1]) {
    return rangeList;
  }
  var newRangeList = [];
  var len2 = rangeList.length;
  var insertPosition = 0;
  for (var i = 0; i < len2; i++) {
    var range0 = rangeList[i];
    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }
  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}
var EMPTY, FULL;
var init_range = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/range.js"() {
    EMPTY = [];
    FULL = [[0, Infinity]];
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/array-utils.js
function padArrayChunk(_ref) {
  var source = _ref.source, target = _ref.target, _ref$start = _ref.start, start = _ref$start === void 0 ? 0 : _ref$start, end = _ref.end, getData = _ref.getData;
  end = end || target.length;
  var sourceLength = source.length;
  var targetLength = end - start;
  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }
  target.set(source, start);
  if (!getData) {
    return;
  }
  var i = sourceLength;
  while (i < targetLength) {
    var datum = getData(i, source);
    for (var j = 0; j < datum.length; j++) {
      target[start + i] = datum[j];
      i++;
    }
  }
}
function padArray(_ref2) {
  var source = _ref2.source, target = _ref2.target, size = _ref2.size, getData = _ref2.getData, sourceStartIndices = _ref2.sourceStartIndices, targetStartIndices = _ref2.targetStartIndices;
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      getData
    });
    return target;
  }
  var sourceIndex = 0;
  var targetIndex = 0;
  var getChunkData = getData && function(i2, chunk) {
    return getData(i2 + targetIndex, chunk);
  };
  var n = Math.min(sourceStartIndices.length, targetStartIndices.length);
  for (var i = 1; i < n; i++) {
    var nextSourceIndex = sourceStartIndices[i] * size;
    var nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }
  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      getData: getChunkData
    });
  }
  return target;
}
var init_array_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/array-utils.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }
  if (Number.isFinite(userSettings)) {
    userSettings = {
      duration: userSettings
    };
  }
  userSettings.type = userSettings.type || "interpolation";
  return Object.assign({}, DEFAULT_TRANSITION_SETTINGS[userSettings.type], layerSettings, userSettings);
}
function getSourceBufferAttribute(gl, attribute) {
  var buffer = attribute.getBuffer();
  if (buffer) {
    return [attribute.getBuffer(), {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }
  return attribute.value;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error('No defined attribute type for size "'.concat(size, '"'));
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  var doublePrecision = attribute.doublePrecision, settings = attribute.settings, value4 = attribute.value, size = attribute.size;
  var multiplier = doublePrecision ? 2 : 1;
  return (settings.noAlloc ? value4.length : numInstances * size) * multiplier;
}
function padBuffer(_ref) {
  var buffer = _ref.buffer, numInstances = _ref.numInstances, attribute = _ref.attribute, fromLength = _ref.fromLength, fromStartIndices = _ref.fromStartIndices, _ref$getData = _ref.getData, getData = _ref$getData === void 0 ? function(x) {
    return x;
  } : _ref$getData;
  var precisionMultiplier = attribute.doublePrecision ? 2 : 1;
  var size = attribute.size * precisionMultiplier;
  var byteOffset = attribute.byteOffset;
  var toStartIndices = attribute.startIndices;
  var hasStartIndices = fromStartIndices && toStartIndices;
  var toLength = getAttributeBufferLength(attribute, numInstances);
  var isConstant = attribute.state.constant;
  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }
  var toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });
  if (attribute.settings.normalized && !isConstant) {
    var getter = getData;
    getData = function getData2(value4, chunk) {
      return attribute._normalizeConstant(getter(value4, chunk));
    };
  }
  var getMissingData = isConstant ? function(i, chunk) {
    return getData(toData, chunk);
  } : function(i, chunk) {
    return getData(toData.subarray(i, i + size), chunk);
  };
  var source = buffer.getData({
    length: fromLength
  });
  var data = new Float32Array(toLength);
  padArray({
    source,
    target: data,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });
  if (buffer.byteLength < data.byteLength + byteOffset) {
    buffer.reallocate(data.byteLength + byteOffset);
  }
  buffer.subData({
    data,
    offset: byteOffset
  });
}
var DEFAULT_TRANSITION_SETTINGS;
var init_attribute_transition_utils = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js"() {
    init_array_utils();
    DEFAULT_TRANSITION_SETTINGS = {
      interpolation: {
        duration: 0,
        easing: function easing(t) {
          return t;
        }
      },
      spring: {
        stiffness: 0.05,
        damping: 0.5
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js
var Attribute;
var init_attribute = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js"() {
    init_defineProperty();
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_data_column();
    init_assert10();
    init_iterable_utils();
    init_flatten();
    init_range();
    init_attribute_transition_utils();
    Attribute = function(_DataColumn) {
      _inherits(Attribute2, _DataColumn);
      function Attribute2(gl) {
        var _this;
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Attribute2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Attribute2).call(this, gl, opts));
        var _opts$transition = opts.transition, transition = _opts$transition === void 0 ? false : _opts$transition, _opts$noAlloc = opts.noAlloc, noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc, _opts$update = opts.update, update = _opts$update === void 0 ? null : _opts$update, _opts$accessor = opts.accessor, accessor = _opts$accessor === void 0 ? null : _opts$accessor, _opts$transform = opts.transform, transform2 = _opts$transform === void 0 ? null : _opts$transform, _opts$startIndices = opts.startIndices, startIndices = _opts$startIndices === void 0 ? null : _opts$startIndices;
        Object.assign(_this.settings, {
          transition,
          noAlloc,
          update: update || accessor && _this._autoUpdater,
          accessor,
          transform: transform2
        });
        Object.assign(_this.state, {
          lastExternalBuffer: null,
          binaryValue: null,
          binaryAccessor: null,
          needsUpdate: true,
          needsRedraw: false,
          updateRanges: FULL,
          startIndices
        });
        Object.seal(_this.settings);
        Object.seal(_this.state);
        _this._validateAttributeUpdaters();
        return _this;
      }
      _createClass(Attribute2, [{
        key: "needsUpdate",
        value: function needsUpdate() {
          return this.state.needsUpdate;
        }
      }, {
        key: "needsRedraw",
        value: function needsRedraw() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$clearChangedFlag = _ref.clearChangedFlags, clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;
          var needsRedraw2 = this.state.needsRedraw;
          this.state.needsRedraw = needsRedraw2 && !clearChangedFlags;
          return needsRedraw2;
        }
      }, {
        key: "getUpdateTriggers",
        value: function getUpdateTriggers() {
          var accessor = this.settings.accessor;
          return [this.id].concat(typeof accessor !== "function" && accessor || []);
        }
      }, {
        key: "supportsTransition",
        value: function supportsTransition() {
          return Boolean(this.settings.transition);
        }
      }, {
        key: "getTransitionSetting",
        value: function getTransitionSetting(opts) {
          var accessor = this.settings.accessor;
          var layerSettings = this.settings.transition;
          if (!this.supportsTransition()) {
            return null;
          }
          var userSettings = Array.isArray(accessor) ? opts[accessor.find(function(a2) {
            return opts[a2];
          })] : opts[accessor];
          return normalizeTransitionSettings(userSettings, layerSettings);
        }
      }, {
        key: "setNeedsUpdate",
        value: function setNeedsUpdate() {
          var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
          var dataRange = arguments.length > 1 ? arguments[1] : void 0;
          this.state.needsUpdate = this.state.needsUpdate || reason;
          this.setNeedsRedraw(reason);
          if (dataRange) {
            var _dataRange$startRow = dataRange.startRow, startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow, _dataRange$endRow = dataRange.endRow, endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
            this.state.updateRanges = add5(this.state.updateRanges, [startRow, endRow]);
          } else {
            this.state.updateRanges = FULL;
          }
        }
      }, {
        key: "clearNeedsUpdate",
        value: function clearNeedsUpdate() {
          this.state.needsUpdate = false;
          this.state.updateRanges = EMPTY;
        }
      }, {
        key: "setNeedsRedraw",
        value: function setNeedsRedraw() {
          var reason = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
          this.state.needsRedraw = this.state.needsRedraw || reason;
        }
      }, {
        key: "update",
        value: function update(opts) {
          this.setData(opts);
        }
      }, {
        key: "allocate",
        value: function allocate(numInstances) {
          var state = this.state, settings = this.settings;
          if (settings.noAlloc) {
            return false;
          }
          if (settings.update) {
            assert10(Number.isFinite(numInstances));
            _get(_getPrototypeOf(Attribute2.prototype), "allocate", this).call(this, {
              numInstances,
              copy: state.updateRanges !== FULL
            });
            return true;
          }
          return false;
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(_ref2) {
          var numInstances = _ref2.numInstances, data = _ref2.data, props = _ref2.props, context = _ref2.context;
          if (!this.needsUpdate()) {
            return false;
          }
          var updateRanges = this.state.updateRanges, _this$settings = this.settings, update = _this$settings.update, noAlloc = _this$settings.noAlloc;
          var updated = true;
          if (update) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = updateRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _step$value = _slicedToArray(_step.value, 2), _startRow = _step$value[0], _endRow = _step$value[1];
                update.call(context, this, {
                  data,
                  startRow: _startRow,
                  endRow: _endRow,
                  props,
                  numInstances
                });
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            if (!this.value) {
            } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
              this.setData({
                value: this.value,
                constant: this.constant
              });
            } else {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = updateRanges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var _step2$value = _slicedToArray(_step2.value, 2), startRow = _step2$value[0], endRow = _step2$value[1];
                  var startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
                  var endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
                  _get(_getPrototypeOf(Attribute2.prototype), "updateSubBuffer", this).call(this, {
                    startOffset,
                    endOffset
                  });
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
            this._checkAttributeArray();
          } else {
            updated = false;
          }
          this.clearNeedsUpdate();
          this.setNeedsRedraw();
          return updated;
        }
      }, {
        key: "setConstantValue",
        value: function setConstantValue(value4) {
          if (value4 === void 0 || typeof value4 === "function") {
            return false;
          }
          var hasChanged = this.setData({
            constant: true,
            value: value4
          });
          if (hasChanged) {
            this.setNeedsRedraw();
          }
          this.clearNeedsUpdate();
          return true;
        }
      }, {
        key: "setExternalBuffer",
        value: function setExternalBuffer(buffer) {
          var state = this.state;
          if (!buffer) {
            state.lastExternalBuffer = null;
            return false;
          }
          this.clearNeedsUpdate();
          if (state.lastExternalBuffer === buffer) {
            return true;
          }
          state.lastExternalBuffer = buffer;
          this.setNeedsRedraw();
          this.setData(buffer);
          return true;
        }
      }, {
        key: "setBinaryValue",
        value: function setBinaryValue(buffer) {
          var startIndices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var state = this.state, settings = this.settings;
          if (!buffer) {
            state.binaryValue = null;
            state.binaryAccessor = null;
            return false;
          }
          if (settings.noAlloc) {
            return false;
          }
          if (state.binaryValue === buffer) {
            this.clearNeedsUpdate();
            return true;
          }
          state.binaryValue = buffer;
          this.setNeedsRedraw();
          if (ArrayBuffer.isView(buffer)) {
            buffer = {
              value: buffer
            };
          }
          var needsUpdate = settings.transform || startIndices !== this.startIndices;
          if (needsUpdate) {
            assert10(ArrayBuffer.isView(buffer.value), "invalid ".concat(settings.accessor));
            var needsNormalize = buffer.size && buffer.size !== this.size;
            state.binaryAccessor = getAccessorFromBuffer(buffer.value, {
              size: buffer.size || this.size,
              stride: buffer.stride,
              offset: buffer.offset,
              startIndices,
              nested: needsNormalize
            });
            return false;
          }
          this.clearNeedsUpdate();
          this.setData(buffer);
          return true;
        }
      }, {
        key: "getVertexOffset",
        value: function getVertexOffset(row) {
          var startIndices = this.startIndices;
          var vertexIndex = startIndices ? startIndices[row] : row;
          return vertexIndex * this.size;
        }
      }, {
        key: "getShaderAttributes",
        value: function getShaderAttributes() {
          var shaderAttributeDefs = this.settings.shaderAttributes || _defineProperty({}, this.id, null);
          var shaderAttributes = {};
          for (var shaderAttributeName in shaderAttributeDefs) {
            Object.assign(shaderAttributes, _get(_getPrototypeOf(Attribute2.prototype), "getShaderAttributes", this).call(this, shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
          }
          return shaderAttributes;
        }
      }, {
        key: "_autoUpdater",
        value: function _autoUpdater(attribute, _ref4) {
          var data = _ref4.data, startRow = _ref4.startRow, endRow = _ref4.endRow, props = _ref4.props, numInstances = _ref4.numInstances;
          var settings = attribute.settings, state = attribute.state, value4 = attribute.value, size = attribute.size, startIndices = attribute.startIndices;
          var accessor = settings.accessor, transform2 = settings.transform;
          var accessorFunc = state.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
          assert10(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
          var i = attribute.getVertexOffset(startRow);
          var _createIterable = createIterable(data, startRow, endRow), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = iterable[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var object = _step3.value;
              objectInfo.index++;
              var objectValue = accessorFunc(object, objectInfo);
              if (transform2) {
                objectValue = transform2.call(this, objectValue);
              }
              if (startIndices) {
                var numVertices = (startIndices[objectInfo.index + 1] || numInstances) - startIndices[objectInfo.index];
                if (objectValue && Array.isArray(objectValue[0])) {
                  var startIndex = i;
                  var _iteratorNormalCompletion4 = true;
                  var _didIteratorError4 = false;
                  var _iteratorError4 = void 0;
                  try {
                    for (var _iterator4 = objectValue[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                      var item = _step4.value;
                      attribute._normalizeValue(item, value4, startIndex);
                      startIndex += size;
                    }
                  } catch (err) {
                    _didIteratorError4 = true;
                    _iteratorError4 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                        _iterator4["return"]();
                      }
                    } finally {
                      if (_didIteratorError4) {
                        throw _iteratorError4;
                      }
                    }
                  }
                } else if (objectValue && objectValue.length > size) {
                  value4.set(objectValue, i);
                } else {
                  attribute._normalizeValue(objectValue, objectInfo.target, 0);
                  fillArray2({
                    target: value4,
                    source: objectInfo.target,
                    start: i,
                    count: numVertices
                  });
                }
                i += numVertices * size;
              } else {
                attribute._normalizeValue(objectValue, value4, i);
                i += size;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          attribute.constant = false;
        }
      }, {
        key: "_validateAttributeUpdaters",
        value: function _validateAttributeUpdaters() {
          var settings = this.settings;
          var hasUpdater = settings.noAlloc || typeof settings.update === "function";
          if (!hasUpdater) {
            throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
          }
        }
      }, {
        key: "_checkAttributeArray",
        value: function _checkAttributeArray() {
          var value4 = this.value;
          var limit = Math.min(4, this.size);
          if (value4 && value4.length >= limit) {
            var valid = true;
            switch (limit) {
              case 4:
                valid = valid && Number.isFinite(value4[3]);
              case 3:
                valid = valid && Number.isFinite(value4[2]);
              case 2:
                valid = valid && Number.isFinite(value4[1]);
              case 1:
                valid = valid && Number.isFinite(value4[0]);
                break;
              default:
                valid = false;
            }
            if (!valid) {
              throw new Error("Illegal attribute generated for ".concat(this.id));
            }
          }
        }
      }, {
        key: "startIndices",
        get: function get2() {
          return this.state.startIndices;
        },
        set: function set2(layout) {
          this.state.startIndices = layout;
        }
      }]);
      return Attribute2;
    }(DataColumn);
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/transition.js
function noop2() {
}
var DEFAULT_SETTINGS2, Transition;
var init_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/transition.js"() {
    init_classCallCheck();
    init_createClass();
    DEFAULT_SETTINGS2 = {
      onStart: noop2,
      onUpdate: noop2,
      onInterrupt: noop2,
      onEnd: noop2
    };
    Transition = function() {
      function Transition2(timeline) {
        _classCallCheck(this, Transition2);
        this._inProgress = false;
        this._handle = null;
        this.timeline = timeline;
        this.settings = {};
      }
      _createClass(Transition2, [{
        key: "start",
        value: function start(props) {
          this.cancel();
          this.settings = Object.assign({}, DEFAULT_SETTINGS2, props);
          this._inProgress = true;
          this.settings.onStart(this);
        }
      }, {
        key: "end",
        value: function end() {
          if (this._inProgress) {
            this.timeline.removeChannel(this._handle);
            this._handle = null;
            this._inProgress = false;
            this.settings.onEnd(this);
          }
        }
      }, {
        key: "cancel",
        value: function cancel() {
          if (this._inProgress) {
            this.settings.onInterrupt(this);
            this.timeline.removeChannel(this._handle);
            this._handle = null;
            this._inProgress = false;
          }
        }
      }, {
        key: "update",
        value: function update() {
          if (!this._inProgress) {
            return false;
          }
          if (this._handle === null) {
            var timeline = this.timeline, settings = this.settings;
            this._handle = timeline.addChannel({
              delay: timeline.getTime(),
              duration: settings.duration
            });
          }
          this.time = this.timeline.getTime(this._handle);
          this._onUpdate();
          this.settings.onUpdate(this);
          if (this.timeline.isFinished(this._handle)) {
            this.end();
          }
          return true;
        }
      }, {
        key: "_onUpdate",
        value: function _onUpdate() {
        }
      }, {
        key: "inProgress",
        get: function get2() {
          return this._inProgress;
        }
      }]);
      return Transition2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js
function ownKeys13(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread13(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys13(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys13(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function getTransform(gl, attribute) {
  var attributeType = getAttributeTypeFromSize(attribute.size);
  return new Transform(gl, {
    vs: vs8,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vCurrent"]
  });
}
var GPUInterpolationTransition, vs8;
var init_gpu_interpolation_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm14();
    init_attribute();
    init_attribute_transition_utils();
    init_transition();
    GPUInterpolationTransition = function() {
      function GPUInterpolationTransition2(_ref) {
        var gl = _ref.gl, attribute = _ref.attribute, timeline = _ref.timeline;
        _classCallCheck(this, GPUInterpolationTransition2);
        this.gl = gl;
        this.type = "interpolation";
        this.transition = new Transition(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new Attribute(gl, attribute.settings);
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.transform = getTransform(gl, attribute);
        var bufferOpts = {
          byteLength: 0,
          usage: 35050
        };
        this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];
      }
      _createClass(GPUInterpolationTransition2, [{
        key: "start",
        value: function start(transitionSettings, numInstances) {
          if (transitionSettings.duration <= 0) {
            this.transition.cancel();
            return;
          }
          var gl = this.gl, buffers = this.buffers, attribute = this.attribute;
          cycleBuffers(buffers);
          var padBufferOpts = {
            numInstances,
            attribute,
            fromLength: this.currentLength,
            fromStartIndices: this.currentStartIndices,
            getData: transitionSettings.enter
          };
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = buffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var buffer = _step.value;
              padBuffer(_objectSpread13({
                buffer
              }, padBufferOpts));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          this.currentStartIndices = attribute.startIndices;
          this.currentLength = getAttributeBufferLength(attribute, numInstances);
          this.attributeInTransition.update({
            buffer: buffers[1],
            value: attribute.value
          });
          this.transition.start(transitionSettings);
          this.transform.update({
            elementCount: Math.floor(this.currentLength / attribute.size),
            sourceBuffers: {
              aFrom: buffers[0],
              aTo: getSourceBufferAttribute(gl, attribute)
            },
            feedbackBuffers: {
              vCurrent: buffers[1]
            }
          });
        }
      }, {
        key: "update",
        value: function update() {
          var updated = this.transition.update();
          if (updated) {
            var _this$transition = this.transition, time = _this$transition.time, _this$transition$sett = _this$transition.settings, duration = _this$transition$sett.duration, easing2 = _this$transition$sett.easing;
            var t = easing2(time / duration);
            this.transform.run({
              uniforms: {
                time: t
              }
            });
          }
          return updated;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.transition.cancel();
          this.transform["delete"]();
          while (this.buffers.length) {
            this.buffers.pop()["delete"]();
          }
        }
      }, {
        key: "inProgress",
        get: function get2() {
          return this.transition.inProgress;
        }
      }]);
      return GPUInterpolationTransition2;
    }();
    vs8 = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js
function ownKeys14(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread14(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys14(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys14(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function getTransform2(gl, attribute, framebuffer) {
  var attributeType = getAttributeTypeFromSize(attribute.size);
  return new Transform(gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ["vNext"]
  });
}
function getTexture(gl) {
  return new Texture2D(gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function getFramebuffer2(gl, texture) {
  return new Framebuffer(gl, {
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    attachments: _defineProperty({}, 36064, texture)
  });
}
var GPUSpringTransition;
var init_gpu_spring_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm14();
    init_attribute_transition_utils();
    init_attribute();
    init_transition();
    GPUSpringTransition = function() {
      function GPUSpringTransition2(_ref) {
        var gl = _ref.gl, attribute = _ref.attribute, timeline = _ref.timeline;
        _classCallCheck(this, GPUSpringTransition2);
        this.gl = gl;
        this.type = "spring";
        this.transition = new Transition(timeline);
        this.attribute = attribute;
        this.attributeInTransition = new Attribute(gl, Object.assign({}, attribute.settings, {
          normalized: false
        }));
        this.currentStartIndices = attribute.startIndices;
        this.currentLength = 0;
        this.texture = getTexture(gl);
        this.framebuffer = getFramebuffer2(gl, this.texture);
        this.transform = getTransform2(gl, attribute, this.framebuffer);
        var bufferOpts = {
          byteLength: 0,
          usage: 35050
        };
        this.buffers = [new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts), new Buffer(gl, bufferOpts)];
      }
      _createClass(GPUSpringTransition2, [{
        key: "start",
        value: function start(transitionSettings, numInstances) {
          var gl = this.gl, buffers = this.buffers, attribute = this.attribute;
          var padBufferOpts = {
            numInstances,
            attribute,
            fromLength: this.currentLength,
            fromStartIndices: this.currentStartIndices,
            getData: transitionSettings.enter
          };
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = buffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var buffer = _step.value;
              padBuffer(_objectSpread14({
                buffer
              }, padBufferOpts));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          this.currentStartIndices = attribute.startIndices;
          this.currentLength = getAttributeBufferLength(attribute, numInstances);
          this.attributeInTransition.update({
            buffer: buffers[1],
            value: attribute.value
          });
          this.transition.start(transitionSettings);
          this.transform.update({
            elementCount: Math.floor(this.currentLength / attribute.size),
            sourceBuffers: {
              aTo: getSourceBufferAttribute(gl, attribute)
            }
          });
        }
      }, {
        key: "update",
        value: function update() {
          var buffers = this.buffers, transform2 = this.transform, framebuffer = this.framebuffer, transition = this.transition;
          var updated = transition.update();
          if (!updated) {
            return false;
          }
          transform2.update({
            sourceBuffers: {
              aPrev: buffers[0],
              aCur: buffers[1]
            },
            feedbackBuffers: {
              vNext: buffers[2]
            }
          });
          transform2.run({
            framebuffer,
            discard: false,
            clearRenderTarget: true,
            uniforms: {
              stiffness: transition.settings.stiffness,
              damping: transition.settings.damping
            },
            parameters: {
              depthTest: false,
              blend: true,
              viewport: [0, 0, 1, 1],
              blendFunc: [1, 1],
              blendEquation: [32776, 32776]
            }
          });
          cycleBuffers(buffers);
          this.attributeInTransition.update({
            buffer: buffers[1],
            value: this.attribute.value
          });
          var isTransitioning = readPixelsToArray(framebuffer)[0] > 0;
          if (!isTransitioning) {
            transition.end();
          }
          return true;
        }
      }, {
        key: "cancel",
        value: function cancel() {
          this.transition.cancel();
          this.transform["delete"]();
          while (this.buffers.length) {
            this.buffers.pop()["delete"]();
          }
          this.texture["delete"]();
          this.texture = null;
          this.framebuffer["delete"]();
          this.framebuffer = null;
        }
      }, {
        key: "inProgress",
        get: function get2() {
          return this.transition.inProgress;
        }
      }]);
      return GPUSpringTransition2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js
var TRANSITION_TYPES, AttributeTransitionManager;
var init_attribute_transition_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm14();
    init_gpu_interpolation_transition();
    init_gpu_spring_transition();
    init_log2();
    TRANSITION_TYPES = {
      interpolation: GPUInterpolationTransition,
      spring: GPUSpringTransition
    };
    AttributeTransitionManager = function() {
      function AttributeTransitionManager2(gl, _ref) {
        var id = _ref.id, timeline = _ref.timeline;
        _classCallCheck(this, AttributeTransitionManager2);
        this.id = id;
        this.gl = gl;
        this.timeline = timeline;
        this.transitions = {};
        this.needsRedraw = false;
        this.numInstances = 1;
        if (Transform.isSupported(gl)) {
          this.isSupported = true;
        } else if (gl) {
          log_default.warn("WebGL2 not supported by this browser. Transition animation is disabled.")();
        }
      }
      _createClass(AttributeTransitionManager2, [{
        key: "finalize",
        value: function finalize() {
          for (var attributeName in this.transitions) {
            this._removeTransition(attributeName);
          }
        }
      }, {
        key: "update",
        value: function update(_ref2) {
          var attributes = _ref2.attributes, _ref2$transitions = _ref2.transitions, transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions, numInstances = _ref2.numInstances;
          this.numInstances = numInstances || 1;
          if (!this.isSupported) {
            return;
          }
          for (var attributeName in attributes) {
            var attribute = attributes[attributeName];
            var settings = attribute.getTransitionSetting(transitions);
            if (!settings)
              continue;
            this._updateAttribute(attributeName, attribute, settings);
          }
          for (var _attributeName in this.transitions) {
            var _attribute = attributes[_attributeName];
            if (!_attribute || !_attribute.getTransitionSetting(transitions)) {
              this._removeTransition(_attributeName);
            }
          }
        }
      }, {
        key: "hasAttribute",
        value: function hasAttribute(attributeName) {
          var transition = this.transitions[attributeName];
          return transition && transition.inProgress;
        }
      }, {
        key: "getAttributes",
        value: function getAttributes() {
          var animatedAttributes = {};
          for (var attributeName in this.transitions) {
            var transition = this.transitions[attributeName];
            if (transition.inProgress) {
              animatedAttributes[attributeName] = transition.attributeInTransition;
            }
          }
          return animatedAttributes;
        }
      }, {
        key: "run",
        value: function run() {
          if (!this.isSupported || this.numInstances === 0) {
            return false;
          }
          for (var attributeName in this.transitions) {
            var updated = this.transitions[attributeName].update();
            if (updated) {
              this.needsRedraw = true;
            }
          }
          var needsRedraw = this.needsRedraw;
          this.needsRedraw = false;
          return needsRedraw;
        }
      }, {
        key: "_removeTransition",
        value: function _removeTransition(attributeName) {
          this.transitions[attributeName].cancel();
          delete this.transitions[attributeName];
        }
      }, {
        key: "_updateAttribute",
        value: function _updateAttribute(attributeName, attribute, settings) {
          var transition = this.transitions[attributeName];
          var isNew = !transition || transition.type !== settings.type;
          if (isNew) {
            if (transition) {
              this._removeTransition(attributeName);
            }
            var TransitionType = TRANSITION_TYPES[settings.type];
            if (TransitionType) {
              this.transitions[attributeName] = new TransitionType({
                attribute,
                timeline: this.timeline,
                gl: this.gl
              });
            } else {
              log_default.error("unsupported transition type '".concat(settings.type, "'"))();
              isNew = false;
            }
          }
          if (isNew || attribute.needsRedraw()) {
            this.needsRedraw = true;
            this.transitions[attributeName].start(settings, this.numInstances);
          }
        }
      }]);
      return AttributeTransitionManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js
var TRACE_INVALIDATE, TRACE_UPDATE_START, TRACE_UPDATE_END, TRACE_ATTRIBUTE_UPDATE_START, TRACE_ATTRIBUTE_ALLOCATE, TRACE_ATTRIBUTE_UPDATE_END, AttributeManager;
var init_attribute_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_attribute();
    init_log2();
    init_debug();
    init_attribute_transition_manager();
    TRACE_INVALIDATE = "attributeManager.invalidate";
    TRACE_UPDATE_START = "attributeManager.updateStart";
    TRACE_UPDATE_END = "attributeManager.updateEnd";
    TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
    TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
    TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
    AttributeManager = function() {
      function AttributeManager2(gl) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$id = _ref.id, id = _ref$id === void 0 ? "attribute-manager" : _ref$id, stats = _ref.stats, timeline = _ref.timeline;
        _classCallCheck(this, AttributeManager2);
        this.id = id;
        this.gl = gl;
        this.attributes = {};
        this.updateTriggers = {};
        this.accessors = {};
        this.needsRedraw = true;
        this.userData = {};
        this.stats = stats;
        this.attributeTransitionManager = new AttributeTransitionManager(gl, {
          id: "".concat(id, "-transitions"),
          timeline
        });
        Object.seal(this);
      }
      _createClass(AttributeManager2, [{
        key: "finalize",
        value: function finalize() {
          for (var attributeName in this.attributes) {
            this.attributes[attributeName]["delete"]();
          }
          this.attributeTransitionManager.finalize();
        }
      }, {
        key: "getNeedsRedraw",
        value: function getNeedsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          var redraw = this.needsRedraw;
          this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
          return redraw && this.id;
        }
      }, {
        key: "setNeedsRedraw",
        value: function setNeedsRedraw() {
          var redraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          this.needsRedraw = true;
          return this;
        }
      }, {
        key: "add",
        value: function add6(attributes, updaters) {
          this._add(attributes, updaters);
        }
      }, {
        key: "addInstanced",
        value: function addInstanced(attributes, updaters) {
          this._add(attributes, updaters, {
            instanced: 1
          });
        }
      }, {
        key: "remove",
        value: function remove(attributeNameArray) {
          for (var i = 0; i < attributeNameArray.length; i++) {
            var name = attributeNameArray[i];
            if (this.attributes[name] !== void 0) {
              this.attributes[name]["delete"]();
              delete this.attributes[name];
            }
          }
        }
      }, {
        key: "invalidate",
        value: function invalidate(triggerName, dataRange) {
          var invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
          debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
        }
      }, {
        key: "invalidateAll",
        value: function invalidateAll(dataRange) {
          for (var attributeName in this.attributes) {
            this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
          }
          debug(TRACE_INVALIDATE, this, "all");
        }
      }, {
        key: "update",
        value: function update() {
          var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, data = _ref2.data, numInstances = _ref2.numInstances, _ref2$startIndices = _ref2.startIndices, startIndices = _ref2$startIndices === void 0 ? null : _ref2$startIndices, transitions = _ref2.transitions, _ref2$props = _ref2.props, props = _ref2$props === void 0 ? {} : _ref2$props, _ref2$buffers = _ref2.buffers, buffers = _ref2$buffers === void 0 ? {} : _ref2$buffers, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? {} : _ref2$context;
          var updated = false;
          debug(TRACE_UPDATE_START, this);
          if (this.stats) {
            this.stats.get("Update Attributes").timeStart();
          }
          for (var attributeName in this.attributes) {
            var attribute = this.attributes[attributeName];
            var accessorName = attribute.settings.accessor;
            attribute.startIndices = startIndices;
            if (props[attributeName]) {
              log_default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
            }
            if (attribute.setExternalBuffer(buffers[attributeName])) {
            } else if (attribute.setBinaryValue(buffers[accessorName], data.startIndices)) {
            } else if (!buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
            } else if (attribute.needsUpdate()) {
              updated = true;
              this._updateAttribute({
                attribute,
                numInstances,
                data,
                props,
                context
              });
            }
            this.needsRedraw |= attribute.needsRedraw();
          }
          if (updated) {
            debug(TRACE_UPDATE_END, this, numInstances);
          }
          if (this.stats) {
            this.stats.get("Update Attributes").timeEnd();
          }
          this.attributeTransitionManager.update({
            attributes: this.attributes,
            numInstances,
            transitions
          });
        }
      }, {
        key: "updateTransition",
        value: function updateTransition() {
          var attributeTransitionManager = this.attributeTransitionManager;
          var transitionUpdated = attributeTransitionManager.run();
          this.needsRedraw = this.needsRedraw || transitionUpdated;
          return transitionUpdated;
        }
      }, {
        key: "getAttributes",
        value: function getAttributes() {
          return this.attributes;
        }
      }, {
        key: "getChangedAttributes",
        value: function getChangedAttributes() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearChangedFlags: false
          };
          var attributes = this.attributes, attributeTransitionManager = this.attributeTransitionManager;
          var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());
          for (var attributeName in attributes) {
            var attribute = attributes[attributeName];
            if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
              changedAttributes[attributeName] = attribute;
            }
          }
          return changedAttributes;
        }
      }, {
        key: "getShaderAttributes",
        value: function getShaderAttributes(attributes) {
          var excludeAttributes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!attributes) {
            attributes = this.getAttributes();
          }
          var shaderAttributes = {};
          for (var attributeName in attributes) {
            if (!excludeAttributes[attributeName]) {
              Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
            }
          }
          return shaderAttributes;
        }
      }, {
        key: "getAccessors",
        value: function getAccessors() {
          return this.updateTriggers;
        }
      }, {
        key: "_add",
        value: function _add(attributes, updaters) {
          var extraProps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (updaters) {
            log_default.warn("AttributeManager.add({updaters}) - updater map no longer supported")();
          }
          var newAttributes = {};
          for (var attributeName in attributes) {
            var attribute = attributes[attributeName];
            var newAttribute = this._createAttribute(attributeName, attribute, extraProps);
            newAttributes[attributeName] = newAttribute;
          }
          Object.assign(this.attributes, newAttributes);
          this._mapUpdateTriggersToAttributes();
        }
      }, {
        key: "_createAttribute",
        value: function _createAttribute(name, attribute, extraProps) {
          var props = {
            id: name,
            constant: attribute.constant || false,
            isIndexed: attribute.isIndexed || attribute.elements,
            size: attribute.elements && 1 || attribute.size,
            value: attribute.value || null,
            divisor: attribute.instanced || extraProps.instanced ? 1 : attribute.divisor
          };
          return new Attribute(this.gl, Object.assign({}, attribute, props));
        }
      }, {
        key: "_mapUpdateTriggersToAttributes",
        value: function _mapUpdateTriggersToAttributes() {
          var _this = this;
          var triggers = {};
          var _loop = function _loop2(attributeName2) {
            var attribute = _this.attributes[attributeName2];
            attribute.getUpdateTriggers().forEach(function(triggerName) {
              if (!triggers[triggerName]) {
                triggers[triggerName] = [];
              }
              triggers[triggerName].push(attributeName2);
            });
          };
          for (var attributeName in this.attributes) {
            _loop(attributeName);
          }
          this.updateTriggers = triggers;
        }
      }, {
        key: "_invalidateTrigger",
        value: function _invalidateTrigger(triggerName, dataRange) {
          var attributes = this.attributes, updateTriggers = this.updateTriggers;
          var invalidatedAttributes = updateTriggers[triggerName];
          if (invalidatedAttributes) {
            invalidatedAttributes.forEach(function(name) {
              var attribute = attributes[name];
              if (attribute) {
                attribute.setNeedsUpdate(attribute.id, dataRange);
              }
            });
          }
          return invalidatedAttributes;
        }
      }, {
        key: "_updateAttribute",
        value: function _updateAttribute(opts) {
          var attribute = opts.attribute, numInstances = opts.numInstances;
          debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
          if (attribute.allocate(numInstances)) {
            debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
          }
          var updated = attribute.updateBuffer(opts);
          if (updated) {
            this.needsRedraw = true;
            debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
          }
        }
      }]);
      return AttributeManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js
var CPUInterpolationTransition;
var init_cpu_interpolation_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm15();
    init_transition();
    CPUInterpolationTransition = function(_Transition) {
      _inherits(CPUInterpolationTransition2, _Transition);
      function CPUInterpolationTransition2() {
        _classCallCheck(this, CPUInterpolationTransition2);
        return _possibleConstructorReturn(this, _getPrototypeOf(CPUInterpolationTransition2).apply(this, arguments));
      }
      _createClass(CPUInterpolationTransition2, [{
        key: "_onUpdate",
        value: function _onUpdate() {
          var time = this.time, _this$settings = this.settings, fromValue = _this$settings.fromValue, toValue = _this$settings.toValue, duration = _this$settings.duration, easing2 = _this$settings.easing;
          var t = easing2(time / duration);
          this._value = lerp(fromValue, toValue, t);
        }
      }, {
        key: "value",
        get: function get2() {
          return this._value;
        }
      }]);
      return CPUInterpolationTransition2;
    }(Transition);
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js
function updateSpringElement(prev, cur, dest, damping, stiffness) {
  var velocity = cur - prev;
  var delta = dest - cur;
  var spring = delta * stiffness;
  var damper = -velocity * damping;
  return spring + damper + velocity + cur;
}
function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    var next = [];
    for (var i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }
    return next;
  }
  return updateSpringElement(prev, cur, dest, damping, stiffness);
}
function distance(value1, value22) {
  if (Array.isArray(value1)) {
    var distanceSquare = 0;
    for (var i = 0; i < value1.length; i++) {
      var d = value1[i] - value22[i];
      distanceSquare += d * d;
    }
    return Math.sqrt(distanceSquare);
  }
  return Math.abs(value1 - value22);
}
var EPSILON4, CPUSpringTransition;
var init_cpu_spring_transition = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_transition();
    EPSILON4 = 1e-5;
    CPUSpringTransition = function(_Transition) {
      _inherits(CPUSpringTransition2, _Transition);
      function CPUSpringTransition2() {
        _classCallCheck(this, CPUSpringTransition2);
        return _possibleConstructorReturn(this, _getPrototypeOf(CPUSpringTransition2).apply(this, arguments));
      }
      _createClass(CPUSpringTransition2, [{
        key: "_onUpdate",
        value: function _onUpdate() {
          var _this$settings = this.settings, fromValue = _this$settings.fromValue, toValue = _this$settings.toValue, damping = _this$settings.damping, stiffness = _this$settings.stiffness;
          var _this$_prevValue = this._prevValue, _prevValue = _this$_prevValue === void 0 ? fromValue : _this$_prevValue, _this$_currValue = this._currValue, _currValue = _this$_currValue === void 0 ? fromValue : _this$_currValue;
          var nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
          var delta = distance(nextValue, toValue);
          var velocity = distance(nextValue, _currValue);
          if (delta < EPSILON4 && velocity < EPSILON4) {
            nextValue = toValue;
            this.end();
          }
          this._prevValue = _currValue;
          this._currValue = nextValue;
        }
      }, {
        key: "value",
        get: function get2() {
          return this._currValue;
        }
      }]);
      return CPUSpringTransition2;
    }(Transition);
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js
function ownKeys15(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread15(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys15(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys15(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var TRANSITION_TYPES2, UniformTransitionManager;
var init_uniform_transition_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js"() {
    init_slicedToArray();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_attribute_transition_utils();
    init_cpu_interpolation_transition();
    init_cpu_spring_transition();
    init_log2();
    TRANSITION_TYPES2 = {
      interpolation: CPUInterpolationTransition,
      spring: CPUSpringTransition
    };
    UniformTransitionManager = function() {
      function UniformTransitionManager2(timeline) {
        _classCallCheck(this, UniformTransitionManager2);
        this.transitions = /* @__PURE__ */ new Map();
        this.timeline = timeline;
      }
      _createClass(UniformTransitionManager2, [{
        key: "add",
        value: function add6(key, fromValue, toValue, settings) {
          var transitions = this.transitions;
          if (transitions.has(key)) {
            var _transition = transitions.get(key);
            fromValue = _transition.value;
            this.remove(key);
          }
          settings = normalizeTransitionSettings(settings);
          if (!settings) {
            return;
          }
          var TransitionType = TRANSITION_TYPES2[settings.type];
          if (!TransitionType) {
            log_default.error("unsupported transition type '".concat(settings.type, "'"))();
            return;
          }
          var transition = new TransitionType(this.timeline);
          transition.start(_objectSpread15({}, settings, {
            fromValue,
            toValue
          }));
          transitions.set(key, transition);
        }
      }, {
        key: "remove",
        value: function remove(key) {
          var transitions = this.transitions;
          if (transitions.has(key)) {
            transitions.get(key).cancel();
            transitions["delete"](key);
          }
        }
      }, {
        key: "update",
        value: function update() {
          var propsInTransition = {};
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.transitions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], transition = _step$value[1];
              transition.update();
              propsInTransition[key] = transition.value;
              if (!transition.inProgress) {
                this.remove(key);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return propsInTransition;
        }
      }, {
        key: "clear",
        value: function clear2() {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = this.transitions.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var key = _step2.value;
              this.remove(key);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }, {
        key: "active",
        get: function get2() {
          return this.transitions.size > 0;
        }
      }]);
      return UniformTransitionManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js
var LIFECYCLE, PROP_SYMBOLS;
var init_constants3 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js"() {
    LIFECYCLE = {
      NO_STATE: "Awaiting state",
      MATCHED: "Matched. State transferred from previous layer",
      INITIALIZED: "Initialized",
      AWAITING_GC: "Discarded. Awaiting garbage collection",
      AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
      FINALIZED: "Finalized! Awaiting garbage collection"
    };
    PROP_SYMBOLS = {
      COMPONENT: Symbol["for"]("component"),
      ASYNC_DEFAULTS: Symbol["for"]("asyncPropDefaults"),
      ASYNC_ORIGINAL: Symbol["for"]("asyncPropOriginal"),
      ASYNC_RESOLVED: Symbol["for"]("asyncPropResolved")
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/props.js
function validateProps(props) {
  var propTypes = getPropTypes(props);
  for (var propName in propTypes) {
    var propType = propTypes[propName];
    var validate7 = propType.validate;
    if (validate7 && !validate7(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}
function diffProps(props, oldProps) {
  var propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: getPropTypes(props),
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  var dataChangedReason = diffDataProps(props, oldProps);
  var updateTriggersChangedReason = false;
  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }
  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}
function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return null;
  }
  var result = {};
  var propTypes = getPropTypes(props);
  for (var key in props.transitions) {
    var propType = propTypes[key];
    var type = propType && propType.type;
    var isTransitionable = type === "number" || type === "color" || type === "array";
    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
    }
  }
  return result;
}
function compareProps() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, newProps = _ref.newProps, oldProps = _ref.oldProps, _ref$ignoreProps = _ref.ignoreProps, ignoreProps = _ref$ignoreProps === void 0 ? {} : _ref$ignoreProps, _ref$propTypes = _ref.propTypes, propTypes = _ref$propTypes === void 0 ? {} : _ref$propTypes, _ref$triggerName = _ref.triggerName, triggerName = _ref$triggerName === void 0 ? "props" : _ref$triggerName;
  if (oldProps === newProps) {
    return null;
  }
  if (_typeof(newProps) !== "object" || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  if (_typeof(oldProps) !== "object" || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }
  for (var _i = 0, _Object$keys = Object.keys(newProps); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }
      var changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);
      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }
  for (var _i2 = 0, _Object$keys2 = Object.keys(oldProps); _i2 < _Object$keys2.length; _i2++) {
    var _key = _Object$keys2[_i2];
    if (!(_key in ignoreProps)) {
      if (!(_key in newProps)) {
        return "".concat(triggerName, ".").concat(_key, " dropped");
      }
      if (!Object.hasOwnProperty.call(newProps, _key)) {
        var _changed = comparePropValues(newProps[_key], oldProps[_key], propTypes[_key]);
        if (_changed) {
          return "".concat(triggerName, ".").concat(_key, " ").concat(_changed);
        }
      }
    }
  }
  return null;
}
function comparePropValues(newProp, oldProp, propType) {
  var equal6 = propType && propType.equal;
  if (equal6 && !equal6(newProp, oldProp, propType)) {
    return "changed deeply";
  }
  if (!equal6) {
    equal6 = newProp && oldProp && newProp.equals;
    if (equal6 && !equal6.call(newProp, oldProp)) {
      return "changed deeply";
    }
  }
  if (!equal6 && oldProp !== newProp) {
    return "changed shallowly";
  }
  return null;
}
function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  var dataChanged = null;
  var dataComparator = props.dataComparator, _dataDiff = props._dataDiff;
  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = "Data comparator detected a change";
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = "A new data container was supplied";
  }
  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }
  return dataChanged;
}
function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  if ("all" in props.updateTriggers) {
    var diffReason = diffUpdateTrigger(props, oldProps, "all");
    if (diffReason) {
      return {
        all: true
      };
    }
  }
  var triggerChanged = {};
  var reason = false;
  for (var triggerName in props.updateTriggers) {
    if (triggerName !== "all") {
      var _diffReason = diffUpdateTrigger(props, oldProps, triggerName);
      if (_diffReason) {
        triggerChanged[triggerName] = true;
        reason = triggerChanged;
      }
    }
  }
  return reason;
}
function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return "oldProps is null, initial diff";
  }
  var oldExtensions = oldProps.extensions;
  var extensions = props.extensions;
  if (extensions === oldExtensions) {
    return false;
  }
  if (extensions.length !== oldExtensions.length) {
    return true;
  }
  for (var i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }
  return false;
}
function diffUpdateTrigger(props, oldProps, triggerName) {
  var newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
  var oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
  var diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}
function getPropTypes(props) {
  var layer = props[COMPONENT];
  var LayerType = layer && layer.constructor;
  return LayerType ? LayerType._propTypes : {};
}
var COMPONENT;
var init_props = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/props.js"() {
    init_typeof();
    init_constants3();
    COMPONENT = PROP_SYMBOLS.COMPONENT;
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/count.js
function count3(container) {
  if (!isObject3(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }
  if (typeof container.count === "function") {
    return container.count();
  }
  if (Number.isFinite(container.size)) {
    return container.size;
  }
  if (Number.isFinite(container.length)) {
    return container.length;
  }
  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }
  throw new Error(ERR_NOT_CONTAINER);
}
function isPlainObject(value4) {
  return value4 !== null && _typeof(value4) === "object" && value4.constructor === Object;
}
function isObject3(value4) {
  return value4 !== null && _typeof(value4) === "object";
}
var ERR_NOT_OBJECT, ERR_NOT_CONTAINER;
var init_count = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/count.js"() {
    init_typeof();
    ERR_NOT_OBJECT = "count(): argument not an object";
    ERR_NOT_CONTAINER = "count(): argument not a container";
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/shader.js
function ownKeys16(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread16(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys16(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys16(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }
  var result = Object.assign({}, target, source);
  if ("defines" in source) {
    result.defines = Object.assign({}, target.defines, source.defines);
  }
  if ("modules" in source) {
    result.modules = (target.modules || []).concat(source.modules);
    if (source.modules.some(function(module) {
      return module.name === "project64";
    })) {
      var index = result.modules.findIndex(function(module) {
        return module.name === "project32";
      });
      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }
  if ("inject" in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      var mergedInjection = _objectSpread16({}, target.inject);
      for (var key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
      }
      result.inject = mergedInjection;
    }
  }
  return result;
}
var init_shader2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/shader.js"() {
    init_defineProperty();
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js
function arrayEqual(array12, array2) {
  if (array12 === array2) {
    return true;
  }
  if (!isArray3(array12) || !isArray3(array2)) {
    return false;
  }
  var len2 = array12.length;
  if (len2 !== array2.length) {
    return false;
  }
  for (var i = 0; i < len2; i++) {
    if (array12[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function parsePropTypes2(propDefs) {
  var propTypes = {};
  var defaultProps4 = {};
  var deprecatedProps = {};
  for (var _i = 0, _Object$entries = Object.entries(propDefs); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), propName = _Object$entries$_i[0], propDef = _Object$entries$_i[1];
    if (propDef && propDef.deprecatedFor) {
      deprecatedProps[propName] = Array.isArray(propDef.deprecatedFor) ? propDef.deprecatedFor : [propDef.deprecatedFor];
    } else {
      var propType = parsePropType2(propName, propDef);
      propTypes[propName] = propType;
      defaultProps4[propName] = propType.value;
    }
  }
  return {
    propTypes,
    defaultProps: defaultProps4,
    deprecatedProps
  };
}
function parsePropType2(name, propDef) {
  switch (getTypeOf2(propDef)) {
    case "object":
      return normalizePropDefinition(name, propDef);
    case "array":
      return normalizePropDefinition(name, {
        type: "array",
        value: propDef,
        compare: false
      });
    case "boolean":
      return normalizePropDefinition(name, {
        type: "boolean",
        value: propDef
      });
    case "number":
      return normalizePropDefinition(name, {
        type: "number",
        value: propDef
      });
    case "function":
      return normalizePropDefinition(name, {
        type: "function",
        value: propDef,
        compare: true
      });
    default:
      return {
        name,
        type: "unknown",
        value: propDef
      };
  }
}
function normalizePropDefinition(name, propDef) {
  if (!("type" in propDef)) {
    if (!("value" in propDef)) {
      return {
        name,
        type: "object",
        value: propDef
      };
    }
    return Object.assign({
      name,
      type: getTypeOf2(propDef.value)
    }, propDef);
  }
  return Object.assign({
    name
  }, TYPE_DEFINITIONS2[propDef.type], propDef);
}
function isArray3(value4) {
  return Array.isArray(value4) || ArrayBuffer.isView(value4);
}
function getTypeOf2(value4) {
  if (isArray3(value4)) {
    return "array";
  }
  if (value4 === null) {
    return "null";
  }
  return _typeof(value4);
}
var TYPE_DEFINITIONS2;
var init_prop_types2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js"() {
    init_typeof();
    init_slicedToArray();
    TYPE_DEFINITIONS2 = {
      "boolean": {
        validate: function validate(value4, propType) {
          return true;
        },
        equal: function equal(value1, value22, propType) {
          return Boolean(value1) === Boolean(value22);
        }
      },
      number: {
        validate: function validate2(value4, propType) {
          return Number.isFinite(value4) && (!("max" in propType) || value4 <= propType.max) && (!("min" in propType) || value4 >= propType.min);
        }
      },
      color: {
        validate: function validate3(value4, propType) {
          return propType.optional && !value4 || isArray3(value4) && (value4.length === 3 || value4.length === 4);
        },
        equal: function equal2(value1, value22, propType) {
          return arrayEqual(value1, value22);
        }
      },
      accessor: {
        validate: function validate4(value4, propType) {
          var valueType = getTypeOf2(value4);
          return valueType === "function" || valueType === getTypeOf2(propType.value);
        },
        equal: function equal3(value1, value22, propType) {
          if (typeof value22 === "function") {
            return true;
          }
          return arrayEqual(value1, value22);
        }
      },
      array: {
        validate: function validate5(value4, propType) {
          return propType.optional && !value4 || isArray3(value4);
        },
        equal: function equal4(value1, value22, propType) {
          return propType.compare ? arrayEqual(value1, value22) : value1 === value22;
        }
      },
      "function": {
        validate: function validate6(value4, propType) {
          return propType.optional && !value4 || typeof value4 === "function";
        },
        equal: function equal5(value1, value22, propType) {
          return !propType.compare || value1 === value22;
        }
      }
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js
function createProps() {
  var component = this;
  var propsPrototype = getPropsPrototype(component.constructor);
  var propsInstance = Object.create(propsPrototype);
  propsInstance[COMPONENT2] = component;
  propsInstance[ASYNC_ORIGINAL] = {};
  propsInstance[ASYNC_RESOLVED] = {};
  for (var i = 0; i < arguments.length; ++i) {
    var props = arguments[i];
    for (var key in props) {
      propsInstance[key] = props[key];
    }
  }
  Object.freeze(propsInstance);
  return propsInstance;
}
function getPropsPrototype(componentClass) {
  var defaultProps4 = getOwnProperty(componentClass, "_mergedDefaultProps");
  if (!defaultProps4) {
    createPropsPrototypeAndTypes(componentClass);
    return componentClass._mergedDefaultProps;
  }
  return defaultProps4;
}
function createPropsPrototypeAndTypes(componentClass) {
  var parent = componentClass.prototype;
  if (!parent) {
    return;
  }
  var parentClass = Object.getPrototypeOf(componentClass);
  var parentDefaultProps = getPropsPrototype(parentClass);
  var componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
  var componentPropDefs = parsePropTypes2(componentDefaultProps);
  var defaultProps4 = createPropsPrototype(componentPropDefs.defaultProps, parentDefaultProps, componentClass);
  var propTypes = Object.assign({}, parentClass._propTypes, componentPropDefs.propTypes);
  addAsyncPropsToPropPrototype(defaultProps4, propTypes);
  var deprecatedProps = Object.assign({}, parentClass._deprecatedProps, componentPropDefs.deprecatedProps);
  addDeprecatedPropsToPropPrototype(defaultProps4, deprecatedProps);
  componentClass._mergedDefaultProps = defaultProps4;
  componentClass._propTypes = propTypes;
  componentClass._deprecatedProps = deprecatedProps;
}
function createPropsPrototype(props, parentProps, componentClass) {
  var defaultProps4 = /* @__PURE__ */ Object.create(null);
  Object.assign(defaultProps4, parentProps, props);
  var id = getComponentName(componentClass);
  delete props.id;
  Object.defineProperties(defaultProps4, {
    id: {
      writable: true,
      value: id
    }
  });
  return defaultProps4;
}
function addDeprecatedPropsToPropPrototype(defaultProps4, deprecatedProps) {
  var _loop = function _loop2(propName2) {
    Object.defineProperty(defaultProps4, propName2, {
      enumerable: false,
      set: function set2(newValue) {
        var nameStr = "".concat(this.id, ": ").concat(propName2);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = deprecatedProps[propName2][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var newPropName = _step.value;
            if (!hasOwnProperty(this, newPropName)) {
              this[newPropName] = newValue;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        log_default.deprecated(nameStr, deprecatedProps[propName2].join("/"))();
      }
    });
  };
  for (var propName in deprecatedProps) {
    _loop(propName);
  }
}
function addAsyncPropsToPropPrototype(defaultProps4, propTypes) {
  var defaultValues = {};
  var descriptors = {};
  for (var propName in propTypes) {
    var propType = propTypes[propName];
    var name = propType.name, value4 = propType.value;
    if (propType.async) {
      defaultValues[name] = value4;
      descriptors[name] = getDescriptorForAsyncProp(name, value4);
    }
  }
  defaultProps4[ASYNC_DEFAULTS] = defaultValues;
  defaultProps4[ASYNC_ORIGINAL] = {};
  Object.defineProperties(defaultProps4, descriptors);
}
function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,
    set: function set2(newValue) {
      if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable3(newValue)) {
        this[ASYNC_ORIGINAL][name] = newValue;
      } else {
        this[ASYNC_RESOLVED][name] = newValue;
      }
    },
    get: function get2() {
      if (this[ASYNC_RESOLVED]) {
        if (name in this[ASYNC_RESOLVED]) {
          var value4 = this[ASYNC_RESOLVED][name];
          return value4 || this[ASYNC_DEFAULTS][name];
        }
        if (name in this[ASYNC_ORIGINAL]) {
          var state = this[COMPONENT2] && this[COMPONENT2].internalState;
          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[ASYNC_DEFAULTS][name];
          }
        }
      }
      return this[ASYNC_DEFAULTS][name];
    }
  };
}
function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}
function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}
function getComponentName(componentClass) {
  var componentName = getOwnProperty(componentClass, "layerName") || getOwnProperty(componentClass, "componentName");
  if (!componentName) {
    log_default.once(0, "".concat(componentClass.name, ".componentName not specified"))();
  }
  return componentName || componentClass.name;
}
var COMPONENT2, ASYNC_ORIGINAL, ASYNC_RESOLVED, ASYNC_DEFAULTS;
var init_create_props = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js"() {
    init_log2();
    init_iterable_utils();
    init_prop_types2();
    init_constants3();
    COMPONENT2 = PROP_SYMBOLS.COMPONENT;
    ASYNC_ORIGINAL = PROP_SYMBOLS.ASYNC_ORIGINAL;
    ASYNC_RESOLVED = PROP_SYMBOLS.ASYNC_RESOLVED;
    ASYNC_DEFAULTS = PROP_SYMBOLS.ASYNC_DEFAULTS;
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js
var import_regenerator46, ASYNC_ORIGINAL2, ASYNC_RESOLVED2, ASYNC_DEFAULTS2, EMPTY_PROPS, ComponentState;
var init_component_state = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js"() {
    import_regenerator46 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_asyncIterator();
    init_log2();
    init_iterable_utils();
    init_constants3();
    ASYNC_ORIGINAL2 = PROP_SYMBOLS.ASYNC_ORIGINAL;
    ASYNC_RESOLVED2 = PROP_SYMBOLS.ASYNC_RESOLVED;
    ASYNC_DEFAULTS2 = PROP_SYMBOLS.ASYNC_DEFAULTS;
    EMPTY_PROPS = Object.freeze({});
    ComponentState = function() {
      function ComponentState2() {
        var component = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        _classCallCheck(this, ComponentState2);
        this.component = component;
        this.asyncProps = {};
        this.onAsyncPropUpdated = function() {
        };
        this.oldProps = EMPTY_PROPS;
        this.oldAsyncProps = null;
      }
      _createClass(ComponentState2, [{
        key: "getOldProps",
        value: function getOldProps() {
          return this.oldAsyncProps || this.oldProps;
        }
      }, {
        key: "resetOldProps",
        value: function resetOldProps() {
          this.oldAsyncProps = null;
          this.oldProps = this.component.props;
        }
      }, {
        key: "freezeAsyncOldProps",
        value: function freezeAsyncOldProps() {
          if (!this.oldAsyncProps) {
            this.oldProps = this.oldProps || this.component.props;
            this.oldAsyncProps = Object.create(this.oldProps);
            for (var propName in this.asyncProps) {
              Object.defineProperty(this.oldAsyncProps, propName, {
                enumerable: true,
                value: this.oldProps[propName]
              });
            }
          }
        }
      }, {
        key: "hasAsyncProp",
        value: function hasAsyncProp(propName) {
          return propName in this.asyncProps;
        }
      }, {
        key: "getAsyncProp",
        value: function getAsyncProp(propName) {
          var asyncProp = this.asyncProps[propName];
          return asyncProp && asyncProp.resolvedValue;
        }
      }, {
        key: "isAsyncPropLoading",
        value: function isAsyncPropLoading(propName) {
          if (propName) {
            var asyncProp = this.asyncProps[propName];
            return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
          }
          for (var key in this.asyncProps) {
            if (this.isAsyncPropLoading(key)) {
              return true;
            }
          }
          return false;
        }
      }, {
        key: "reloadAsyncProp",
        value: function reloadAsyncProp(propName, value4) {
          this._watchPromise(propName, Promise.resolve(value4));
        }
      }, {
        key: "setAsyncProps",
        value: function setAsyncProps(props) {
          var resolvedValues = props[ASYNC_RESOLVED2] || {};
          var originalValues = props[ASYNC_ORIGINAL2] || props;
          var defaultValues = props[ASYNC_DEFAULTS2] || {};
          for (var propName in resolvedValues) {
            var value4 = resolvedValues[propName];
            this._createAsyncPropData(propName, value4, defaultValues[propName]);
            this._updateAsyncProp(propName, value4);
          }
          for (var _propName in originalValues) {
            var _value2 = originalValues[_propName];
            this._createAsyncPropData(_propName, _value2, defaultValues[_propName]);
            this._updateAsyncProp(_propName, _value2);
          }
        }
      }, {
        key: "_updateAsyncProp",
        value: function _updateAsyncProp(propName, value4) {
          if (!this._didAsyncInputValueChange(propName, value4)) {
            return;
          }
          if (typeof value4 === "string") {
            var fetch2 = this.layer && this.layer.props.fetch;
            var url = value4;
            if (fetch2) {
              value4 = fetch2(url, {
                propName,
                layer: this.layer
              });
            }
          }
          if (value4 instanceof Promise) {
            this._watchPromise(propName, value4);
            return;
          }
          if (isAsyncIterable3(value4)) {
            this._resolveAsyncIterable(propName, value4);
            return;
          }
          this._setPropValue(propName, value4);
        }
      }, {
        key: "_didAsyncInputValueChange",
        value: function _didAsyncInputValueChange(propName, value4) {
          var asyncProp = this.asyncProps[propName];
          if (value4 === asyncProp.lastValue) {
            return false;
          }
          asyncProp.lastValue = value4;
          return true;
        }
      }, {
        key: "_setPropValue",
        value: function _setPropValue(propName, value4) {
          var asyncProp = this.asyncProps[propName];
          asyncProp.value = value4;
          asyncProp.resolvedValue = value4;
          asyncProp.pendingLoadCount++;
          asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
        }
      }, {
        key: "_setAsyncPropValue",
        value: function _setAsyncPropValue(propName, value4, loadCount) {
          var asyncProp = this.asyncProps[propName];
          if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value4 !== void 0) {
            this.freezeAsyncOldProps();
            asyncProp.resolvedValue = value4;
            asyncProp.resolvedLoadCount = loadCount;
            this.onAsyncPropUpdated(propName, value4);
          }
        }
      }, {
        key: "_watchPromise",
        value: function _watchPromise(propName, promise) {
          var _this = this;
          var asyncProp = this.asyncProps[propName];
          asyncProp.pendingLoadCount++;
          var loadCount = asyncProp.pendingLoadCount;
          promise.then(function(data) {
            data = _this._postProcessValue(propName, data);
            _this._setAsyncPropValue(propName, data, loadCount);
            var onDataLoad = _this.layer && _this.layer.props.onDataLoad;
            if (propName === "data" && onDataLoad) {
              onDataLoad(data, {
                propName,
                layer: _this.layer
              });
            }
          })["catch"](function(error2) {
            return log_default.error(error2)();
          });
        }
      }, {
        key: "_resolveAsyncIterable",
        value: function() {
          var _resolveAsyncIterable2 = _asyncToGenerator(import_regenerator46.default.mark(function _callee(propName, iterable) {
            var asyncProp, loadCount, data, count4, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, onDataLoad;
            return import_regenerator46.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (propName !== "data") {
                      this._setPropValue(propName, iterable);
                    }
                    asyncProp = this.asyncProps[propName];
                    asyncProp.pendingLoadCount++;
                    loadCount = asyncProp.pendingLoadCount;
                    data = [];
                    count4 = 0;
                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _context.prev = 8;
                    _iterator = _asyncIterator(iterable);
                  case 10:
                    _context.next = 12;
                    return _iterator.next();
                  case 12:
                    _step = _context.sent;
                    _iteratorNormalCompletion = _step.done;
                    _context.next = 16;
                    return _step.value;
                  case 16:
                    _value = _context.sent;
                    if (_iteratorNormalCompletion) {
                      _context.next = 26;
                      break;
                    }
                    chunk = _value;
                    data = this._postProcessValue(propName, chunk, data);
                    Object.defineProperty(data, "__diff", {
                      enumerable: false,
                      value: [{
                        startRow: count4,
                        endRow: data.length
                      }]
                    });
                    count4 = data.length;
                    this._setAsyncPropValue(propName, data, loadCount);
                  case 23:
                    _iteratorNormalCompletion = true;
                    _context.next = 10;
                    break;
                  case 26:
                    _context.next = 32;
                    break;
                  case 28:
                    _context.prev = 28;
                    _context.t0 = _context["catch"](8);
                    _didIteratorError = true;
                    _iteratorError = _context.t0;
                  case 32:
                    _context.prev = 32;
                    _context.prev = 33;
                    if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
                      _context.next = 37;
                      break;
                    }
                    _context.next = 37;
                    return _iterator["return"]();
                  case 37:
                    _context.prev = 37;
                    if (!_didIteratorError) {
                      _context.next = 40;
                      break;
                    }
                    throw _iteratorError;
                  case 40:
                    return _context.finish(37);
                  case 41:
                    return _context.finish(32);
                  case 42:
                    onDataLoad = this.layer && this.layer.props.onDataLoad;
                    if (onDataLoad) {
                      onDataLoad(data, {
                        propName,
                        layer: this.layer
                      });
                    }
                  case 44:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[8, 28, 32, 42], [33, , 37, 41]]);
          }));
          function _resolveAsyncIterable(_x, _x2) {
            return _resolveAsyncIterable2.apply(this, arguments);
          }
          return _resolveAsyncIterable;
        }()
      }, {
        key: "_postProcessValue",
        value: function _postProcessValue(propName, value4, previousValue) {
          var _ref = this.component ? this.component.props : {}, dataTransform = _ref.dataTransform;
          if (propName !== "data") {
            return value4;
          }
          if (dataTransform) {
            return dataTransform(value4, previousValue);
          }
          return previousValue ? previousValue.concat(value4) : value4;
        }
      }, {
        key: "_createAsyncPropData",
        value: function _createAsyncPropData(propName, value4, defaultValue) {
          var asyncProp = this.asyncProps[propName];
          if (!asyncProp) {
            this.asyncProps[propName] = {
              lastValue: null,
              resolvedValue: defaultValue,
              pendingLoadCount: 0,
              resolvedLoadCount: 0
            };
          }
        }
      }]);
      return ComponentState2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lifecycle/component.js
var ASYNC_ORIGINAL3, ASYNC_RESOLVED3, ASYNC_DEFAULTS3, defaultProps, counter, Component;
var init_component = __esm({
  "node_modules/@deck.gl/core/dist/esm/lifecycle/component.js"() {
    init_classCallCheck();
    init_createClass();
    init_constants3();
    init_create_props();
    init_constants3();
    init_component_state();
    ASYNC_ORIGINAL3 = PROP_SYMBOLS.ASYNC_ORIGINAL;
    ASYNC_RESOLVED3 = PROP_SYMBOLS.ASYNC_RESOLVED;
    ASYNC_DEFAULTS3 = PROP_SYMBOLS.ASYNC_DEFAULTS;
    defaultProps = {};
    counter = 0;
    Component = function() {
      function Component2() {
        _classCallCheck(this, Component2);
        this.props = createProps.apply(this, arguments);
        this.id = this.props.id;
        this.count = counter++;
        this.lifecycle = LIFECYCLE.NO_STATE;
        this.parent = null;
        this.context = null;
        this.state = null;
        this.internalState = null;
        Object.seal(this);
      }
      _createClass(Component2, [{
        key: "clone",
        value: function clone3(newProps) {
          var props = this.props;
          var asyncProps = {};
          for (var key in props[ASYNC_DEFAULTS3]) {
            if (key in props[ASYNC_RESOLVED3]) {
              asyncProps[key] = props[ASYNC_RESOLVED3][key];
            } else if (key in props[ASYNC_ORIGINAL3]) {
              asyncProps[key] = props[ASYNC_ORIGINAL3][key];
            }
          }
          return new this.constructor(Object.assign({}, props, asyncProps, newProps));
        }
      }, {
        key: "_initState",
        value: function _initState() {
          this.internalState = new ComponentState({});
        }
      }, {
        key: "stats",
        get: function get2() {
          return this.internalState.stats;
        }
      }]);
      return Component2;
    }();
    Component.componentName = "Component";
    Component.defaultProps = defaultProps;
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer-state.js
var LayerState;
var init_layer_state = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer-state.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_component_state();
    LayerState = function(_ComponentState) {
      _inherits(LayerState2, _ComponentState);
      function LayerState2(_ref) {
        var _this;
        var attributeManager = _ref.attributeManager, layer = _ref.layer;
        _classCallCheck(this, LayerState2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(LayerState2).call(this, layer));
        _this.attributeManager = attributeManager;
        _this.model = null;
        _this.needsRedraw = true;
        _this.subLayers = null;
        return _this;
      }
      _createClass(LayerState2, [{
        key: "layer",
        get: function get2() {
          return this.component;
        },
        set: function set2(layer) {
          this.component = layer;
        }
      }]);
      return LayerState2;
    }(ComponentState);
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer.js
var TRACE_CHANGE_FLAG, TRACE_INITIALIZE, TRACE_UPDATE, TRACE_FINALIZE, TRACE_MATCHED, EMPTY_ARRAY2, areViewportsEqual, pickingColorCache, defaultProps2, Layer;
var init_layer = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer.js"() {
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_constants2();
    init_attribute_manager();
    init_uniform_transition_manager();
    init_props();
    init_count();
    init_log2();
    init_debug();
    init_esm14();
    init_assert10();
    init_memoize();
    init_shader2();
    init_project_functions();
    init_typed_array_manager();
    init_component();
    init_layer_state();
    init_esm16();
    init_esm3();
    TRACE_CHANGE_FLAG = "layer.changeFlag";
    TRACE_INITIALIZE = "layer.initialize";
    TRACE_UPDATE = "layer.update";
    TRACE_FINALIZE = "layer.finalize";
    TRACE_MATCHED = "layer.matched";
    EMPTY_ARRAY2 = Object.freeze([]);
    areViewportsEqual = memoize(function(_ref) {
      var oldViewport = _ref.oldViewport, viewport = _ref.viewport;
      return oldViewport.equals(viewport);
    });
    pickingColorCache = new Uint8ClampedArray(0);
    defaultProps2 = {
      data: {
        type: "data",
        value: EMPTY_ARRAY2,
        async: true
      },
      dataComparator: null,
      _dataDiff: {
        type: "function",
        value: function value(data) {
          return data && data.__diff;
        },
        compare: false,
        optional: true
      },
      dataTransform: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      onDataLoad: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      fetch: {
        type: "function",
        value: function value2(url, _ref2) {
          var propName = _ref2.propName, layer = _ref2.layer;
          var resourceManager = layer.context.resourceManager;
          var loadOptions = layer.getLoadOptions();
          var inResourceManager = resourceManager.contains(url);
          if (!inResourceManager && !loadOptions) {
            resourceManager.add({
              resourceId: url,
              data: url,
              persistent: false
            });
            inResourceManager = true;
          }
          if (inResourceManager) {
            return resourceManager.subscribe({
              resourceId: url,
              onChange: function onChange(data) {
                return layer.internalState.reloadAsyncProp(propName, data);
              },
              consumerId: layer.id,
              requestId: propName
            });
          }
          return load(url, loadOptions);
        },
        compare: false
      },
      updateTriggers: {},
      visible: true,
      pickable: false,
      opacity: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
      },
      onHover: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      onClick: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      onDragStart: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      onDrag: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      onDragEnd: {
        type: "function",
        value: null,
        compare: false,
        optional: true
      },
      coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
      coordinateOrigin: {
        type: "array",
        value: [0, 0, 0],
        compare: true
      },
      modelMatrix: {
        type: "array",
        value: null,
        compare: true,
        optional: true
      },
      wrapLongitude: false,
      positionFormat: "XYZ",
      colorFormat: "RGBA",
      parameters: {},
      uniforms: {},
      extensions: [],
      getPolygonOffset: {
        type: "function",
        value: function value3(_ref3) {
          var layerIndex = _ref3.layerIndex;
          return [0, -layerIndex * 100];
        },
        compare: false
      },
      highlightedObjectIndex: null,
      autoHighlight: false,
      highlightColor: {
        type: "accessor",
        value: [0, 0, 128, 128]
      }
    };
    Layer = function(_Component) {
      _inherits(Layer2, _Component);
      function Layer2() {
        _classCallCheck(this, Layer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(Layer2).apply(this, arguments));
      }
      _createClass(Layer2, [{
        key: "toString",
        value: function toString() {
          var className = this.constructor.layerName || this.constructor.name;
          return "".concat(className, "({id: '").concat(this.props.id, "'})");
        }
      }, {
        key: "setState",
        value: function setState(updateObject) {
          this.setChangeFlags({
            stateChanged: true
          });
          Object.assign(this.state, updateObject);
          this.setNeedsRedraw();
        }
      }, {
        key: "setNeedsRedraw",
        value: function setNeedsRedraw() {
          var redraw = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (this.internalState) {
            this.internalState.needsRedraw = redraw;
          }
        }
      }, {
        key: "setNeedsUpdate",
        value: function setNeedsUpdate() {
          this.context.layerManager.setNeedsUpdate(String(this));
          this.internalState.needsUpdate = true;
        }
      }, {
        key: "getNeedsRedraw",
        value: function getNeedsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          return this._getNeedsRedraw(opts);
        }
      }, {
        key: "needsUpdate",
        value: function needsUpdate() {
          return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
        }
      }, {
        key: "hasUniformTransition",
        value: function hasUniformTransition() {
          return this.internalState.uniformTransitions.active;
        }
      }, {
        key: "isPickable",
        value: function isPickable() {
          return this.props.pickable && this.props.visible;
        }
      }, {
        key: "getModels",
        value: function getModels() {
          return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
        }
      }, {
        key: "getAttributeManager",
        value: function getAttributeManager() {
          return this.internalState && this.internalState.attributeManager;
        }
      }, {
        key: "getCurrentLayer",
        value: function getCurrentLayer() {
          return this.internalState && this.internalState.layer;
        }
      }, {
        key: "getLoadOptions",
        value: function getLoadOptions() {
          return this.props.loadOptions;
        }
      }, {
        key: "project",
        value: function project2(xyz) {
          var viewport = this.context.viewport;
          var worldPosition = getWorldPosition(xyz, {
            viewport,
            modelMatrix: this.props.modelMatrix,
            coordinateOrigin: this.props.coordinateOrigin,
            coordinateSystem: this.props.coordinateSystem
          });
          var _worldToPixels = worldToPixels(worldPosition, viewport.pixelProjectionMatrix), _worldToPixels2 = _slicedToArray(_worldToPixels, 3), x = _worldToPixels2[0], y = _worldToPixels2[1], z = _worldToPixels2[2];
          return xyz.length === 2 ? [x, y] : [x, y, z];
        }
      }, {
        key: "unproject",
        value: function unproject(xy) {
          var viewport = this.context.viewport;
          return viewport.unproject(xy);
        }
      }, {
        key: "projectPosition",
        value: function projectPosition2(xyz) {
          return projectPosition(xyz, {
            viewport: this.context.viewport,
            modelMatrix: this.props.modelMatrix,
            coordinateOrigin: this.props.coordinateOrigin,
            coordinateSystem: this.props.coordinateSystem
          });
        }
      }, {
        key: "use64bitPositions",
        value: function use64bitPositions() {
          var coordinateSystem = this.props.coordinateSystem;
          return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
        }
      }, {
        key: "onHover",
        value: function onHover(info, pickingEvent) {
          if (this.props.onHover) {
            return this.props.onHover(info, pickingEvent);
          }
          return false;
        }
      }, {
        key: "onClick",
        value: function onClick(info, pickingEvent) {
          if (this.props.onClick) {
            return this.props.onClick(info, pickingEvent);
          }
          return false;
        }
      }, {
        key: "nullPickingColor",
        value: function nullPickingColor() {
          return [0, 0, 0];
        }
      }, {
        key: "encodePickingColor",
        value: function encodePickingColor(i) {
          var target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          target[0] = i + 1 & 255;
          target[1] = i + 1 >> 8 & 255;
          target[2] = i + 1 >> 8 >> 8 & 255;
          return target;
        }
      }, {
        key: "decodePickingColor",
        value: function decodePickingColor(color) {
          assert10(color instanceof Uint8Array);
          var _color = _slicedToArray(color, 3), i1 = _color[0], i2 = _color[1], i3 = _color[2];
          var index = i1 + i2 * 256 + i3 * 65536 - 1;
          return index;
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          throw new Error("Layer ".concat(this, " has not defined initializeState"));
        }
      }, {
        key: "getShaders",
        value: function getShaders(shaders) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.props.extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var extension = _step.value;
              shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return shaders;
        }
      }, {
        key: "shouldUpdateState",
        value: function shouldUpdateState(_ref4) {
          var oldProps = _ref4.oldProps, props = _ref4.props, context = _ref4.context, changeFlags = _ref4.changeFlags;
          return changeFlags.propsOrDataChanged;
        }
      }, {
        key: "updateState",
        value: function updateState(_ref5) {
          var oldProps = _ref5.oldProps, props = _ref5.props, context = _ref5.context, changeFlags = _ref5.changeFlags;
          var attributeManager = this.getAttributeManager();
          if (changeFlags.dataChanged && attributeManager) {
            var dataChanged = changeFlags.dataChanged;
            if (Array.isArray(dataChanged)) {
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = dataChanged[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var dataRange = _step2.value;
                  attributeManager.invalidateAll(dataRange);
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            } else {
              attributeManager.invalidateAll();
            }
          }
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var model = _step3.value;
              model["delete"]();
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          var attributeManager = this.getAttributeManager();
          if (attributeManager) {
            attributeManager.finalize();
          }
          this.context.resourceManager.unsubscribe({
            consumerId: this.id
          });
          this.internalState.uniformTransitions.clear();
        }
      }, {
        key: "draw",
        value: function draw(opts) {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = void 0;
          try {
            for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var model = _step4.value;
              model.draw(opts);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref6) {
          var info = _ref6.info, mode = _ref6.mode;
          var index = info.index;
          if (index >= 0) {
            if (Array.isArray(this.props.data)) {
              info.object = this.props.data[index];
            }
          }
          return info;
        }
      }, {
        key: "activateViewport",
        value: function activateViewport(viewport) {
          var oldViewport = this.internalState.viewport;
          this.internalState.viewport = viewport;
          if (!oldViewport || !areViewportsEqual({
            oldViewport,
            viewport
          })) {
            this.setChangeFlags({
              viewportChanged: true
            });
            this._update();
          }
        }
      }, {
        key: "invalidateAttribute",
        value: function invalidateAttribute() {
          var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
          var diffReason = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          var attributeManager = this.getAttributeManager();
          if (!attributeManager) {
            return;
          }
          if (name === "all") {
            attributeManager.invalidateAll();
          } else {
            attributeManager.invalidate(name);
          }
        }
      }, {
        key: "updateAttributes",
        value: function updateAttributes(changedAttributes) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = void 0;
          try {
            for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var model = _step5.value;
              this._setModelAttributes(model, changedAttributes);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      }, {
        key: "_updateAttributes",
        value: function _updateAttributes(props) {
          var attributeManager = this.getAttributeManager();
          if (!attributeManager) {
            return;
          }
          var numInstances = this.getNumInstances(props);
          var startIndices = this.getStartIndices(props);
          attributeManager.update({
            data: props.data,
            numInstances,
            startIndices,
            props,
            transitions: props.transitions,
            buffers: props.data.attributes,
            context: this,
            ignoreUnknownAttributes: true
          });
          var changedAttributes = attributeManager.getChangedAttributes({
            clearChangedFlags: true
          });
          this.updateAttributes(changedAttributes);
        }
      }, {
        key: "_updateAttributeTransition",
        value: function _updateAttributeTransition() {
          var attributeManager = this.getAttributeManager();
          if (attributeManager) {
            attributeManager.updateTransition();
          }
        }
      }, {
        key: "_updateUniformTransition",
        value: function _updateUniformTransition() {
          var uniformTransitions = this.internalState.uniformTransitions;
          if (uniformTransitions.active) {
            var propsInTransition = uniformTransitions.update();
            var props = Object.create(this.props);
            for (var key in propsInTransition) {
              Object.defineProperty(props, key, {
                value: propsInTransition[key]
              });
            }
            return props;
          }
          return this.props;
        }
      }, {
        key: "calculateInstancePickingColors",
        value: function calculateInstancePickingColors(attribute, _ref7) {
          var numInstances = _ref7.numInstances;
          var cacheSize = pickingColorCache.length / 3;
          if (cacheSize < numInstances) {
            pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
              size: 3,
              copy: true
            });
            var newCacheSize = pickingColorCache.length / 3;
            var pickingColor = [];
            assert10(newCacheSize < 16777215, "index out of picking color range");
            for (var i = cacheSize; i < newCacheSize; i++) {
              this.encodePickingColor(i, pickingColor);
              pickingColorCache[i * 3 + 0] = pickingColor[0];
              pickingColorCache[i * 3 + 1] = pickingColor[1];
              pickingColorCache[i * 3 + 2] = pickingColor[2];
            }
          }
          attribute.value = pickingColorCache.subarray(0, numInstances * 3);
        }
      }, {
        key: "_setModelAttributes",
        value: function _setModelAttributes(model, changedAttributes) {
          var attributeManager = this.getAttributeManager();
          var excludeAttributes = model.userData.excludeAttributes || {};
          var shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
          model.setAttributes(shaderAttributes);
        }
      }, {
        key: "clearPickingColor",
        value: function clearPickingColor(color) {
          var _this$getAttributeMan = this.getAttributeManager().attributes, pickingColors = _this$getAttributeMan.pickingColors, instancePickingColors = _this$getAttributeMan.instancePickingColors;
          var colors = pickingColors || instancePickingColors;
          var i = this.decodePickingColor(color);
          var start = colors.getVertexOffset(i);
          var end = colors.getVertexOffset(i + 1);
          colors.buffer.subData({
            data: new Uint8Array(end - start),
            offset: start
          });
        }
      }, {
        key: "restorePickingColors",
        value: function restorePickingColors() {
          var _this$getAttributeMan2 = this.getAttributeManager().attributes, pickingColors = _this$getAttributeMan2.pickingColors, instancePickingColors = _this$getAttributeMan2.instancePickingColors;
          var colors = pickingColors || instancePickingColors;
          colors.updateSubBuffer({
            startOffset: 0
          });
        }
      }, {
        key: "getNumInstances",
        value: function getNumInstances(props) {
          props = props || this.props;
          if (props.numInstances !== void 0) {
            return props.numInstances;
          }
          if (this.state && this.state.numInstances !== void 0) {
            return this.state.numInstances;
          }
          return count3(props.data);
        }
      }, {
        key: "getStartIndices",
        value: function getStartIndices(props) {
          props = props || this.props;
          if (props.startIndices !== void 0) {
            return props.startIndices;
          }
          if (this.state && this.state.startIndices) {
            return this.state.startIndices;
          }
          return null;
        }
      }, {
        key: "_initialize",
        value: function _initialize() {
          debug(TRACE_INITIALIZE, this);
          this._initState();
          this.initializeState(this.context);
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = void 0;
          try {
            for (var _iterator6 = this.props.extensions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var extension = _step6.value;
              extension.initializeState.call(this, this.context, extension);
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
          this.setChangeFlags({
            dataChanged: true,
            propsChanged: true,
            viewportChanged: true,
            extensionsChanged: true
          });
          this._updateState();
        }
      }, {
        key: "_update",
        value: function _update() {
          var stateNeedsUpdate = this.needsUpdate();
          debug(TRACE_UPDATE, this, stateNeedsUpdate);
          if (stateNeedsUpdate) {
            this._updateState();
          }
        }
      }, {
        key: "_updateState",
        value: function _updateState() {
          var currentProps = this.props;
          var currentViewport = this.context.viewport;
          var propsInTransition = this._updateUniformTransition();
          this.internalState.propsInTransition = propsInTransition;
          this.context.viewport = this.internalState.viewport || currentViewport;
          this.props = propsInTransition;
          var updateParams = this._getUpdateParams();
          if (this.context.gl) {
            this.updateState(updateParams);
          } else {
            try {
              this.updateState(updateParams);
            } catch (error2) {
            }
          }
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = void 0;
          try {
            for (var _iterator7 = this.props.extensions[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var extension = _step7.value;
              extension.updateState.call(this, updateParams, extension);
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
          this._updateModules(updateParams);
          if (this.isComposite) {
            this._renderLayers(updateParams);
          } else {
            this.setNeedsRedraw();
            this._updateAttributes(this.props);
            if (this.state.model) {
              this.state.model.setInstanceCount(this.getNumInstances());
            }
          }
          this.context.viewport = currentViewport;
          this.props = currentProps;
          this.clearChangeFlags();
          this.internalState.needsUpdate = false;
          this.internalState.resetOldProps();
        }
      }, {
        key: "_finalize",
        value: function _finalize() {
          debug(TRACE_FINALIZE, this);
          assert10(this.internalState && this.state);
          this.finalizeState(this.context);
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = void 0;
          try {
            for (var _iterator8 = this.props.extensions[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var extension = _step8.value;
              extension.finalizeState.call(this, extension);
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
                _iterator8["return"]();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        }
      }, {
        key: "drawLayer",
        value: function drawLayer(_ref8) {
          var _this = this;
          var _ref8$moduleParameter = _ref8.moduleParameters, moduleParameters = _ref8$moduleParameter === void 0 ? null : _ref8$moduleParameter, _ref8$uniforms = _ref8.uniforms, uniforms3 = _ref8$uniforms === void 0 ? {} : _ref8$uniforms, _ref8$parameters = _ref8.parameters, parameters = _ref8$parameters === void 0 ? {} : _ref8$parameters;
          this._updateAttributeTransition();
          var currentProps = this.props;
          this.props = this.internalState.propsInTransition || currentProps;
          var opacity = this.props.opacity;
          uniforms3.opacity = Math.pow(opacity, 1 / 2.2);
          if (moduleParameters) {
            this.setModuleParameters(moduleParameters);
          }
          var getPolygonOffset = this.props.getPolygonOffset;
          var offsets = getPolygonOffset && getPolygonOffset(uniforms3) || [0, 0];
          setParameters(this.context.gl, {
            polygonOffset: offsets
          });
          withParameters(this.context.gl, parameters, function() {
            var opts = {
              moduleParameters,
              uniforms: uniforms3,
              parameters,
              context: _this.context
            };
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = void 0;
            try {
              for (var _iterator9 = _this.props.extensions[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var extension = _step9.value;
                extension.draw.call(_this, opts, extension);
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                  _iterator9["return"]();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }
            _this.draw(opts);
          });
          this.props = currentProps;
        }
      }, {
        key: "getChangeFlags",
        value: function getChangeFlags() {
          return this.internalState.changeFlags;
        }
      }, {
        key: "setChangeFlags",
        value: function setChangeFlags(flags) {
          var changeFlags = this.internalState.changeFlags;
          for (var key in changeFlags) {
            if (flags[key] && !changeFlags[key]) {
              changeFlags[key] = flags[key];
              debug(TRACE_CHANGE_FLAG, this, key, flags);
            }
          }
          var propsOrDataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged;
          changeFlags.propsOrDataChanged = propsOrDataChanged;
          changeFlags.somethingChanged = propsOrDataChanged || flags.viewportChanged || flags.stateChanged;
        }
      }, {
        key: "clearChangeFlags",
        value: function clearChangeFlags() {
          this.internalState.changeFlags = {
            dataChanged: false,
            propsChanged: false,
            updateTriggersChanged: false,
            viewportChanged: false,
            stateChanged: false,
            extensionsChanged: false,
            propsOrDataChanged: false,
            somethingChanged: false
          };
        }
      }, {
        key: "diffProps",
        value: function diffProps2(newProps, oldProps) {
          var changeFlags = diffProps(newProps, oldProps);
          if (changeFlags.updateTriggersChanged) {
            for (var key in changeFlags.updateTriggersChanged) {
              if (changeFlags.updateTriggersChanged[key]) {
                this.invalidateAttribute(key);
              }
            }
          }
          if (changeFlags.transitionsChanged) {
            for (var _key in changeFlags.transitionsChanged) {
              this.internalState.uniformTransitions.add(_key, oldProps[_key], newProps[_key], newProps.transitions[_key]);
            }
          }
          return this.setChangeFlags(changeFlags);
        }
      }, {
        key: "validateProps",
        value: function validateProps2() {
          validateProps(this.props);
        }
      }, {
        key: "setModuleParameters",
        value: function setModuleParameters(moduleParameters) {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = void 0;
          try {
            for (var _iterator10 = this.getModels()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var model = _step10.value;
              model.updateModuleSettings(moduleParameters);
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                _iterator10["return"]();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }
        }
      }, {
        key: "_updateModules",
        value: function _updateModules(_ref9) {
          var props = _ref9.props, oldProps = _ref9.oldProps;
          var autoHighlight = props.autoHighlight, highlightedObjectIndex = props.highlightedObjectIndex, highlightColor = props.highlightColor;
          if (oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
            var parameters = {};
            if (!autoHighlight) {
              parameters.pickingSelectedColor = null;
            }
            if (Array.isArray(highlightColor)) {
              parameters.pickingHighlightColor = highlightColor;
            }
            if (Number.isInteger(highlightedObjectIndex)) {
              parameters.pickingSelectedColor = highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
            }
            this.setModuleParameters(parameters);
          }
        }
      }, {
        key: "_getUpdateParams",
        value: function _getUpdateParams() {
          return {
            props: this.props,
            oldProps: this.internalState.getOldProps(),
            context: this.context,
            changeFlags: this.internalState.changeFlags
          };
        }
      }, {
        key: "_getNeedsRedraw",
        value: function _getNeedsRedraw(opts) {
          if (!this.internalState) {
            return false;
          }
          var redraw = false;
          redraw = redraw || this.internalState.needsRedraw && this.id;
          this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
          var attributeManager = this.getAttributeManager();
          var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw(opts);
          redraw = redraw || attributeManagerNeedsRedraw;
          return redraw;
        }
      }, {
        key: "_getAttributeManager",
        value: function _getAttributeManager() {
          return new AttributeManager(this.context.gl, {
            id: this.props.id,
            stats: this.context.stats,
            timeline: this.context.timeline
          });
        }
      }, {
        key: "_initState",
        value: function _initState() {
          assert10(!this.internalState && !this.state);
          assert10(isFinite(this.props.coordinateSystem), "".concat(this.id, ": invalid coordinateSystem"));
          var attributeManager = this._getAttributeManager();
          if (attributeManager) {
            attributeManager.addInstanced({
              instancePickingColors: {
                type: 5121,
                size: 3,
                noAlloc: true,
                update: this.calculateInstancePickingColors
              }
            });
          }
          this.internalState = new LayerState({
            attributeManager,
            layer: this
          });
          this.clearChangeFlags();
          this.state = {};
          Object.defineProperty(this.state, "attributeManager", {
            get: function get2() {
              log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()");
              return attributeManager;
            }
          });
          this.internalState.layer = this;
          this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
          this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
          this.internalState.setAsyncProps(this.props);
        }
      }, {
        key: "_transferState",
        value: function _transferState(oldLayer) {
          debug(TRACE_MATCHED, this, this === oldLayer);
          var state = oldLayer.state, internalState = oldLayer.internalState;
          assert10(state && internalState);
          if (this === oldLayer) {
            return;
          }
          this.internalState = internalState;
          this.internalState.layer = this;
          this.state = state;
          this.internalState.setAsyncProps(this.props);
          this.diffProps(this.props, this.internalState.getOldProps());
        }
      }, {
        key: "_onAsyncPropUpdated",
        value: function _onAsyncPropUpdated() {
          this.diffProps(this.props, this.internalState.getOldProps());
          this.setNeedsUpdate();
        }
      }, {
        key: "isLoaded",
        get: function get2() {
          return this.internalState && !this.internalState.isAsyncPropLoading();
        }
      }, {
        key: "wrapLongitude",
        get: function get2() {
          return this.props.wrapLongitude;
        }
      }]);
      return Layer2;
    }(Component);
    Layer.layerName = "Layer";
    Layer.defaultProps = defaultProps2;
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js
var Resource2;
var init_resource2 = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm3();
    Resource2 = function() {
      function Resource3(id, data, context) {
        _classCallCheck(this, Resource3);
        this.id = id;
        this.context = context;
        this._loadCount = 0;
        this._subscribers = /* @__PURE__ */ new Set();
        this.setData(data);
      }
      _createClass(Resource3, [{
        key: "subscribe",
        value: function subscribe(consumer) {
          this._subscribers.add(consumer);
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe(consumer) {
          this._subscribers["delete"](consumer);
        }
      }, {
        key: "inUse",
        value: function inUse() {
          return this._subscribers.size > 0;
        }
      }, {
        key: "delete",
        value: function _delete() {
        }
      }, {
        key: "getData",
        value: function getData() {
          var _this = this;
          return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(function() {
            return _this.getData();
          });
        }
      }, {
        key: "setData",
        value: function setData(data, forceUpdate) {
          var _this2 = this;
          if (data === this._data && !forceUpdate) {
            return;
          }
          this._data = data;
          var loadCount = ++this._loadCount;
          var loader = data;
          if (typeof data === "string") {
            loader = load(data);
          }
          if (loader instanceof Promise) {
            this.isLoaded = false;
            this._loader = loader.then(function(result) {
              if (_this2._loadCount === loadCount) {
                _this2.isLoaded = true;
                _this2._error = null;
                _this2._content = result;
              }
            })["catch"](function(error2) {
              if (_this2._loadCount === loadCount) {
                _this2.isLoaded = true;
                _this2._error = error2 || true;
              }
            });
          } else {
            this.isLoaded = true;
            this._error = null;
            this._content = data;
          }
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this._subscribers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var subscriber = _step.value;
              subscriber.onChange(this.getData());
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }]);
      return Resource3;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js
var ResourceManager;
var init_resource_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_resource2();
    ResourceManager = function() {
      function ResourceManager2(_ref) {
        var gl = _ref.gl, protocol = _ref.protocol;
        _classCallCheck(this, ResourceManager2);
        this.protocol = protocol || "resource://";
        this._context = {
          gl,
          resourceManager: this
        };
        this._resources = {};
        this._consumers = {};
        this._pruneRequest = null;
      }
      _createClass(ResourceManager2, [{
        key: "contains",
        value: function contains(resourceId) {
          if (resourceId.startsWith(this.protocol)) {
            return true;
          }
          return resourceId in this._resources;
        }
      }, {
        key: "add",
        value: function add6(_ref2) {
          var resourceId = _ref2.resourceId, data = _ref2.data, _ref2$forceUpdate = _ref2.forceUpdate, forceUpdate = _ref2$forceUpdate === void 0 ? false : _ref2$forceUpdate, _ref2$persistent = _ref2.persistent, persistent = _ref2$persistent === void 0 ? true : _ref2$persistent;
          var res = this._resources[resourceId];
          if (res) {
            res.setData(data, forceUpdate);
          } else {
            res = new Resource2(resourceId, data, this._context);
            this._resources[resourceId] = res;
          }
          res.persistent = persistent;
        }
      }, {
        key: "remove",
        value: function remove(resourceId) {
          var res = this._resources[resourceId];
          if (res) {
            res["delete"]();
            delete this._resources[resourceId];
          }
        }
      }, {
        key: "unsubscribe",
        value: function unsubscribe(_ref3) {
          var consumerId = _ref3.consumerId;
          var consumer = this._consumers[consumerId];
          if (consumer) {
            for (var requestId in consumer) {
              var request = consumer[requestId];
              if (request.resource) {
                request.resource.unsubscribe(request);
              }
            }
            delete this._consumers[consumerId];
            this.prune();
          }
        }
      }, {
        key: "subscribe",
        value: function subscribe(_ref4) {
          var resourceId = _ref4.resourceId, onChange = _ref4.onChange, consumerId = _ref4.consumerId, _ref4$requestId = _ref4.requestId, requestId = _ref4$requestId === void 0 ? "default" : _ref4$requestId;
          var resources = this._resources, protocol = this.protocol;
          if (resourceId.startsWith(protocol)) {
            resourceId = resourceId.replace(protocol, "");
            if (!resources[resourceId]) {
              this.add({
                resourceId,
                data: null,
                persistent: false
              });
            }
          }
          var res = resources[resourceId];
          this._track(consumerId, requestId, res, onChange);
          if (res) {
            return res.getData();
          }
          return void 0;
        }
      }, {
        key: "prune",
        value: function prune() {
          var _this = this;
          if (!this._pruneRequest) {
            this._pruneRequest = setTimeout(function() {
              return _this._prune();
            }, 0);
          }
        }
      }, {
        key: "finalize",
        value: function finalize() {
          for (var key in this._resources) {
            this._resources[key]["delete"]();
          }
        }
      }, {
        key: "_track",
        value: function _track(consumerId, requestId, resource, onChange) {
          var consumers = this._consumers;
          var consumer = consumers[consumerId] = consumers[consumerId] || {};
          var request = consumer[requestId] || {};
          if (request.resource) {
            request.resource.unsubscribe(request);
            request.resource = null;
            this.prune();
          }
          if (resource) {
            consumer[requestId] = request;
            request.onChange = onChange;
            request.resource = resource;
            resource.subscribe(request);
          }
        }
      }, {
        key: "_prune",
        value: function _prune() {
          this._pruneRequest = null;
          for (var _i = 0, _Object$keys = Object.keys(this._resources); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            var res = this._resources[key];
            if (!res.persistent && !res.inUse()) {
              res["delete"]();
              delete this._resources[key];
            }
          }
        }
      }]);
      return ResourceManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js
var TRACE_SET_LAYERS, TRACE_ACTIVATE_VIEWPORT, INITIAL_CONTEXT, layerName, LayerManager;
var init_layer_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm14();
    init_layer();
    init_constants3();
    init_log2();
    init_debug();
    init_flatten();
    init_esm8();
    init_resource_manager();
    init_viewport();
    init_shaderlib();
    TRACE_SET_LAYERS = "layerManager.setLayers";
    TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
    INITIAL_CONTEXT = Object.seal({
      layerManager: null,
      resourceManager: null,
      deck: null,
      gl: null,
      stats: null,
      shaderCache: null,
      pickingFBO: null,
      mousePosition: null,
      userData: {}
    });
    layerName = function layerName2(layer) {
      return layer instanceof Layer ? "".concat(layer) : !layer ? "null" : "invalid";
    };
    LayerManager = function() {
      function LayerManager2(gl) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, deck = _ref.deck, stats = _ref.stats, viewport = _ref.viewport, timeline = _ref.timeline;
        _classCallCheck(this, LayerManager2);
        this.lastRenderedLayers = [];
        this.layers = [];
        this.resourceManager = new ResourceManager({
          gl,
          protocol: "deck://"
        });
        this.context = Object.assign({}, INITIAL_CONTEXT, {
          layerManager: this,
          gl,
          deck,
          programManager: gl && createProgramManager(gl),
          stats: stats || new Stats({
            id: "deck.gl"
          }),
          viewport: viewport || new Viewport({
            id: "DEFAULT-INITIAL-VIEWPORT"
          }),
          timeline: timeline || new Timeline(),
          resourceManager: this.resourceManager
        });
        this._needsRedraw = "Initial render";
        this._needsUpdate = false;
        this._debug = false;
        this._onError = null;
        this.activateViewport = this.activateViewport.bind(this);
        Object.seal(this);
      }
      _createClass(LayerManager2, [{
        key: "finalize",
        value: function finalize() {
          this.resourceManager.finalize();
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.layers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var layer = _step.value;
              this._finalizeLayer(layer);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }, {
        key: "needsRedraw",
        value: function needsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          var redraw = this._needsRedraw;
          if (opts.clearRedrawFlags) {
            this._needsRedraw = false;
          }
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var layer = _step2.value;
              var layerNeedsRedraw = layer.getNeedsRedraw(opts);
              redraw = redraw || layerNeedsRedraw;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          return redraw;
        }
      }, {
        key: "needsUpdate",
        value: function needsUpdate() {
          return this._needsUpdate;
        }
      }, {
        key: "setNeedsRedraw",
        value: function setNeedsRedraw(reason) {
          this._needsRedraw = this._needsRedraw || reason;
        }
      }, {
        key: "setNeedsUpdate",
        value: function setNeedsUpdate(reason) {
          this._needsUpdate = this._needsUpdate || reason;
        }
      }, {
        key: "getLayers",
        value: function getLayers() {
          var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$layerIds = _ref2.layerIds, layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
          return layerIds ? this.layers.filter(function(layer) {
            return layerIds.find(function(layerId) {
              return layer.id.indexOf(layerId) === 0;
            });
          }) : this.layers;
        }
      }, {
        key: "setProps",
        value: function setProps(props) {
          if ("debug" in props) {
            this._debug = props.debug;
          }
          if ("userData" in props) {
            this.context.userData = props.userData;
          }
          if ("layers" in props) {
            this.setLayers(props.layers);
          }
          if ("onError" in props) {
            this._onError = props.onError;
          }
        }
      }, {
        key: "setLayers",
        value: function setLayers(newLayers) {
          var forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var shouldUpdate = forceUpdate || newLayers !== this.lastRenderedLayers;
          debug(TRACE_SET_LAYERS, this, shouldUpdate, newLayers);
          if (!shouldUpdate) {
            return this;
          }
          this.lastRenderedLayers = newLayers;
          newLayers = flatten(newLayers, Boolean);
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = newLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var layer = _step3.value;
              layer.context = this.context;
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          this._updateLayers(this.layers, newLayers);
          return this;
        }
      }, {
        key: "updateLayers",
        value: function updateLayers() {
          var reason = this.needsUpdate();
          if (reason) {
            this.setNeedsRedraw("updating layers: ".concat(reason));
            var forceUpdate = true;
            this.setLayers(this.lastRenderedLayers, forceUpdate);
          }
        }
      }, {
        key: "activateViewport",
        value: function activateViewport(viewport) {
          debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
          if (viewport) {
            this.context.viewport = viewport;
          }
          return this;
        }
      }, {
        key: "_handleError",
        value: function _handleError(stage, error2, layer) {
          if (this._onError) {
            this._onError(error2, layer);
          } else {
            log_default.error("error during ".concat(stage, " of ").concat(layerName(layer)), error2)();
          }
        }
      }, {
        key: "_updateLayers",
        value: function _updateLayers(oldLayers, newLayers) {
          var oldLayerMap = {};
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = void 0;
          try {
            for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var oldLayer = _step4.value;
              if (oldLayerMap[oldLayer.id]) {
                log_default.warn("Multiple old layers with same id ".concat(layerName(oldLayer)))();
              } else {
                oldLayerMap[oldLayer.id] = oldLayer;
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
          var generatedLayers = [];
          this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
          this._finalizeOldLayers(oldLayerMap);
          var needsUpdate = false;
          for (var _i = 0, _generatedLayers = generatedLayers; _i < _generatedLayers.length; _i++) {
            var layer = _generatedLayers[_i];
            if (layer.hasUniformTransition()) {
              needsUpdate = true;
              break;
            }
          }
          this._needsUpdate = needsUpdate;
          this.layers = generatedLayers;
        }
      }, {
        key: "_updateSublayersRecursively",
        value: function _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = void 0;
          try {
            for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var newLayer = _step5.value;
              newLayer.context = this.context;
              var oldLayer = oldLayerMap[newLayer.id];
              if (oldLayer === null) {
                log_default.warn("Multiple new layers with same id ".concat(layerName(newLayer)))();
              }
              oldLayerMap[newLayer.id] = null;
              var sublayers = null;
              try {
                if (this._debug && oldLayer !== newLayer) {
                  newLayer.validateProps();
                }
                if (!oldLayer) {
                  this._initializeLayer(newLayer);
                } else {
                  this._transferLayerState(oldLayer, newLayer);
                  this._updateLayer(newLayer);
                }
                generatedLayers.push(newLayer);
                sublayers = newLayer.isComposite && newLayer.getSubLayers();
              } catch (err) {
                this._handleError("matching", err, newLayer);
              }
              if (sublayers) {
                this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      }, {
        key: "_finalizeOldLayers",
        value: function _finalizeOldLayers(oldLayerMap) {
          for (var layerId in oldLayerMap) {
            var layer = oldLayerMap[layerId];
            if (layer) {
              this._finalizeLayer(layer);
            }
          }
        }
      }, {
        key: "_initializeLayer",
        value: function _initializeLayer(layer) {
          try {
            layer._initialize();
            layer.lifecycle = LIFECYCLE.INITIALIZED;
          } catch (err) {
            this._handleError("initialization", err, layer);
          }
        }
      }, {
        key: "_transferLayerState",
        value: function _transferLayerState(oldLayer, newLayer) {
          newLayer._transferState(oldLayer);
          newLayer.lifecycle = LIFECYCLE.MATCHED;
          if (newLayer !== oldLayer) {
            oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
          }
        }
      }, {
        key: "_updateLayer",
        value: function _updateLayer(layer) {
          try {
            layer._update();
          } catch (err) {
            this._handleError("update", err, layer);
          }
        }
      }, {
        key: "_finalizeLayer",
        value: function _finalizeLayer(layer) {
          this._needsRedraw = this._needsRedraw || "finalized ".concat(layerName(layer));
          layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
          try {
            layer._finalize();
            layer.lifecycle = LIFECYCLE.FINALIZED;
          } catch (err) {
            this._handleError("finalization", err, layer);
          }
        }
      }]);
      return LayerManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js
function deepEqual(a2, b) {
  if (a2 === b) {
    return true;
  }
  if (!a2 || !b) {
    return false;
  }
  for (var key in a2) {
    var aValue = a2[key];
    var bValue = b[key];
    var equals4 = aValue === bValue || Array.isArray(aValue) && Array.isArray(bValue) && deepEqual(aValue, bValue);
    if (!equals4) {
      return false;
    }
  }
  return true;
}
var init_deep_equal = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/view-manager.js
function ownKeys17(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread17(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys17(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys17(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var ViewManager;
var init_view_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/view-manager.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_assert10();
    init_deep_equal();
    init_log2();
    init_flatten();
    ViewManager = function() {
      function ViewManager2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, ViewManager2);
        this.views = [];
        this.width = 100;
        this.height = 100;
        this.viewState = {};
        this.controllers = {};
        this.timeline = props.timeline;
        this._viewports = [];
        this._viewportMap = {};
        this._isUpdating = false;
        this._needsRedraw = "Initial render";
        this._needsUpdate = true;
        this._eventManager = props.eventManager;
        this._eventCallbacks = {
          onViewStateChange: props.onViewStateChange,
          onInteractiveStateChange: props.onInteractiveStateChange
        };
        Object.seal(this);
        this.setProps(props);
      }
      _createClass(ViewManager2, [{
        key: "finalize",
        value: function finalize() {
          for (var key in this.controllers) {
            if (this.controllers[key]) {
              this.controllers[key].finalize();
            }
          }
          this.controllers = {};
        }
      }, {
        key: "needsRedraw",
        value: function needsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          var redraw = this._needsRedraw;
          if (opts.clearRedrawFlags) {
            this._needsRedraw = false;
          }
          return redraw;
        }
      }, {
        key: "setNeedsUpdate",
        value: function setNeedsUpdate(reason) {
          this._needsUpdate = this._needsUpdate || reason;
          this._needsRedraw = this._needsRedraw || reason;
        }
      }, {
        key: "updateViewStates",
        value: function updateViewStates() {
          for (var viewId in this.controllers) {
            var controller = this.controllers[viewId];
            if (controller) {
              controller.updateTransition();
            }
          }
        }
      }, {
        key: "getViewports",
        value: function getViewports(rect) {
          if (rect) {
            return this._viewports.filter(function(viewport) {
              return viewport.containsPixel(rect);
            });
          }
          return this._viewports;
        }
      }, {
        key: "getViews",
        value: function getViews() {
          var viewMap = {};
          this.views.forEach(function(view) {
            viewMap[view.id] = view;
          });
          return viewMap;
        }
      }, {
        key: "getView",
        value: function getView(viewOrViewId) {
          return typeof viewOrViewId === "string" ? this.views.find(function(view) {
            return view.id === viewOrViewId;
          }) : viewOrViewId;
        }
      }, {
        key: "getViewState",
        value: function getViewState(viewId) {
          var view = this.getView(viewId);
          var viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
          return view ? view.filterViewState(viewState) : viewState;
        }
      }, {
        key: "getViewport",
        value: function getViewport(viewId) {
          return this._viewportMap[viewId];
        }
      }, {
        key: "unproject",
        value: function unproject(xyz, opts) {
          var viewports = this.getViewports();
          var pixel = {
            x: xyz[0],
            y: xyz[1]
          };
          for (var i = viewports.length - 1; i >= 0; --i) {
            var viewport = viewports[i];
            if (viewport.containsPixel(pixel)) {
              var p = xyz.slice();
              p[0] -= viewport.x;
              p[1] -= viewport.y;
              return viewport.unproject(p, opts);
            }
          }
          return null;
        }
      }, {
        key: "setProps",
        value: function setProps(props) {
          if ("views" in props) {
            this._setViews(props.views);
          }
          if ("viewState" in props) {
            this._setViewState(props.viewState);
          }
          if ("width" in props || "height" in props) {
            this._setSize(props.width, props.height);
          }
          if (!this._isUpdating) {
            this._update();
          }
        }
      }, {
        key: "_update",
        value: function _update() {
          this._isUpdating = true;
          if (this._needsUpdate) {
            this._needsUpdate = false;
            this._rebuildViewports();
          }
          if (this._needsUpdate) {
            this._needsUpdate = false;
            this._rebuildViewports();
          }
          this._isUpdating = false;
        }
      }, {
        key: "_setSize",
        value: function _setSize(width, height) {
          assert10(Number.isFinite(width) && Number.isFinite(height));
          if (width !== this.width || height !== this.height) {
            this.width = width;
            this.height = height;
            this.setNeedsUpdate("Size changed");
          }
        }
      }, {
        key: "_setViews",
        value: function _setViews(views) {
          views = flatten(views, Boolean);
          var viewsChanged = this._diffViews(views, this.views);
          if (viewsChanged) {
            this.setNeedsUpdate("views changed");
          }
          this.views = views;
        }
      }, {
        key: "_setViewState",
        value: function _setViewState(viewState) {
          if (viewState) {
            var viewStateChanged = !deepEqual(viewState, this.viewState);
            if (viewStateChanged) {
              this.setNeedsUpdate("viewState changed");
            }
            this.viewState = viewState;
          } else {
            log_default.warn("missing `viewState` or `initialViewState`")();
          }
        }
      }, {
        key: "_onViewStateChange",
        value: function _onViewStateChange(viewId, event) {
          event.viewId = viewId;
          this._eventCallbacks.onViewStateChange(event);
        }
      }, {
        key: "_createController",
        value: function _createController(view, props) {
          var Controller2 = props.type;
          var controller = new Controller2(_objectSpread17({
            timeline: this.timeline,
            eventManager: this._eventManager,
            onViewStateChange: this._onViewStateChange.bind(this, props.id),
            onStateChange: this._eventCallbacks.onInteractiveStateChange,
            makeViewport: view._getViewport.bind(view)
          }, props));
          return controller;
        }
      }, {
        key: "_updateController",
        value: function _updateController(view, viewState, viewport, controller) {
          var controllerProps = view.controller;
          if (controllerProps) {
            controllerProps = _objectSpread17({}, viewState, {}, view.props, {}, controllerProps, {
              id: view.id,
              x: viewport.x,
              y: viewport.y,
              width: viewport.width,
              height: viewport.height
            });
            if (controller) {
              controller.setProps(controllerProps);
            } else {
              controller = this._createController(view, controllerProps);
            }
            return controller;
          }
          return null;
        }
      }, {
        key: "_rebuildViewports",
        value: function _rebuildViewports() {
          var width = this.width, height = this.height, views = this.views;
          var oldControllers = this.controllers;
          this._viewports = [];
          this.controllers = {};
          for (var i = views.length; i--; ) {
            var view = views[i];
            var viewState = this.getViewState(view);
            var viewport = view.makeViewport({
              width,
              height,
              viewState
            });
            this.controllers[view.id] = this._updateController(view, viewState, viewport, oldControllers[view.id]);
            this._viewports.unshift(viewport);
          }
          for (var id in oldControllers) {
            if (oldControllers[id] && !this.controllers[id]) {
              oldControllers[id].finalize();
            }
          }
          this._buildViewportMap();
        }
      }, {
        key: "_buildViewportMap",
        value: function _buildViewportMap() {
          var _this = this;
          this._viewportMap = {};
          this._viewports.forEach(function(viewport) {
            if (viewport.id) {
              _this._viewportMap[viewport.id] = _this._viewportMap[viewport.id] || viewport;
            }
          });
        }
      }, {
        key: "_diffViews",
        value: function _diffViews(newViews, oldViews) {
          if (newViews.length !== oldViews.length) {
            return true;
          }
          return newViews.some(function(_, i) {
            return !newViews[i].equals(oldViews[i]);
          });
        }
      }]);
      return ViewManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/positions.js
function parsePosition(value4) {
  switch (_typeof(value4)) {
    case "number":
      return {
        position: value4,
        relative: false
      };
    case "string":
      var match = value4.match(PERCENT_OR_PIXELS_REGEX);
      if (match && match.length >= 3) {
        var relative = match[2] === "%";
        var position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(value4));
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}
var PERCENT_OR_PIXELS_REGEX;
var init_positions = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/positions.js"() {
    init_typeof();
    PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  }
});

// node_modules/@deck.gl/core/dist/esm/views/view.js
function ownKeys18(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread18(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys18(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys18(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var View;
var init_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/view.js"() {
    init_typeof();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_viewport();
    init_positions();
    init_deep_equal();
    init_assert10();
    View = function() {
      function View2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, View2);
        var _props$id = props.id, id = _props$id === void 0 ? null : _props$id, _props$x = props.x, x = _props$x === void 0 ? 0 : _props$x, _props$y = props.y, y = _props$y === void 0 ? 0 : _props$y, _props$width = props.width, width = _props$width === void 0 ? "100%" : _props$width, _props$height = props.height, height = _props$height === void 0 ? "100%" : _props$height, _props$projectionMatr = props.projectionMatrix, projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr, _props$fovy = props.fovy, fovy = _props$fovy === void 0 ? 50 : _props$fovy, _props$near = props.near, near = _props$near === void 0 ? 0.1 : _props$near, _props$far = props.far, far = _props$far === void 0 ? 1e3 : _props$far, _props$modelMatrix = props.modelMatrix, modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix, _props$viewportInstan = props.viewportInstance, viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan, _props$type = props.type, type = _props$type === void 0 ? Viewport : _props$type;
        assert10(!viewportInstance || viewportInstance instanceof Viewport);
        this.viewportInstance = viewportInstance;
        this.id = id || this.constructor.displayName || "view";
        this.type = type;
        this.props = Object.assign({}, props, {
          id: this.id,
          projectionMatrix,
          fovy,
          near,
          far,
          modelMatrix
        });
        this._parseDimensions({
          x,
          y,
          width,
          height
        });
        this.equals = this.equals.bind(this);
        Object.seal(this);
      }
      _createClass(View2, [{
        key: "equals",
        value: function equals4(view) {
          if (this === view) {
            return true;
          }
          if (this.viewportInstance) {
            return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
          }
          var viewChanged = deepEqual(this.props, view.props);
          return viewChanged;
        }
      }, {
        key: "makeViewport",
        value: function makeViewport(_ref) {
          var width = _ref.width, height = _ref.height, viewState = _ref.viewState;
          if (this.viewportInstance) {
            return this.viewportInstance;
          }
          viewState = this.filterViewState(viewState);
          var viewportDimensions = this.getDimensions({
            width,
            height
          });
          var props = _objectSpread18({}, viewState, {}, this.props, {}, viewportDimensions);
          return this._getViewport(props);
        }
      }, {
        key: "getViewStateId",
        value: function getViewStateId() {
          switch (_typeof(this.props.viewState)) {
            case "string":
              return this.props.viewState;
            case "object":
              return this.props.viewState && this.props.viewState.id;
            default:
              return this.id;
          }
        }
      }, {
        key: "filterViewState",
        value: function filterViewState(viewState) {
          if (this.props.viewState && _typeof(this.props.viewState) === "object") {
            if (!this.props.viewState.id) {
              return this.props.viewState;
            }
            var newViewState = Object.assign({}, viewState);
            for (var key in this.props.viewState) {
              if (key !== "id") {
                newViewState[key] = this.props.viewState[key];
              }
            }
            return newViewState;
          }
          return viewState;
        }
      }, {
        key: "getDimensions",
        value: function getDimensions(_ref2) {
          var width = _ref2.width, height = _ref2.height;
          return {
            x: getPosition(this._x, width),
            y: getPosition(this._y, height),
            width: getPosition(this._width, width),
            height: getPosition(this._height, height)
          };
        }
      }, {
        key: "_getControllerProps",
        value: function _getControllerProps(defaultOpts) {
          var opts = this.props.controller;
          if (!opts) {
            return null;
          }
          if (opts === true) {
            return defaultOpts;
          }
          if (typeof opts === "function") {
            opts = {
              type: opts
            };
          }
          return Object.assign({}, defaultOpts, opts);
        }
      }, {
        key: "_getViewport",
        value: function _getViewport(props) {
          var ViewportType = this.type;
          return new ViewportType(props);
        }
      }, {
        key: "_parseDimensions",
        value: function _parseDimensions(_ref3) {
          var x = _ref3.x, y = _ref3.y, width = _ref3.width, height = _ref3.height;
          this._x = parsePosition(x);
          this._y = parsePosition(y);
          this._width = parsePosition(width);
          this._height = parsePosition(height);
        }
      }]);
      return View2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js
var TransitionInterpolator;
var init_transition_interpolator = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm15();
    init_assert10();
    TransitionInterpolator = function() {
      function TransitionInterpolator2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, TransitionInterpolator2);
        if (Array.isArray(opts)) {
          opts = {
            compare: opts,
            extract: opts,
            required: opts
          };
        }
        var _opts = opts, compare = _opts.compare, extract = _opts.extract, required = _opts.required;
        this._propsToCompare = compare;
        this._propsToExtract = extract;
        this._requiredProps = required;
      }
      _createClass(TransitionInterpolator2, [{
        key: "arePropsEqual",
        value: function arePropsEqual(currentProps, nextProps) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = (this._propsToCompare || Object.keys(nextProps))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var key = _step.value;
              if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
                return false;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return true;
        }
      }, {
        key: "initializeProps",
        value: function initializeProps(startProps, endProps) {
          var result;
          if (this._propsToExtract) {
            var startViewStateProps = {};
            var endViewStateProps = {};
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = this._propsToExtract[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var key = _step2.value;
                startViewStateProps[key] = startProps[key];
                endViewStateProps[key] = endProps[key];
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            result = {
              start: startViewStateProps,
              end: endViewStateProps
            };
          } else {
            result = {
              start: startProps,
              end: endProps
            };
          }
          this._checkRequiredProps(result.start);
          this._checkRequiredProps(result.end);
          return result;
        }
      }, {
        key: "interpolateProps",
        value: function interpolateProps(startProps, endProps, t) {
          return endProps;
        }
      }, {
        key: "getDuration",
        value: function getDuration(startProps, endProps) {
          return endProps.transitionDuration;
        }
      }, {
        key: "_checkRequiredProps",
        value: function _checkRequiredProps(props) {
          if (!this._requiredProps) {
            return;
          }
          this._requiredProps.forEach(function(propName) {
            var value4 = props[propName];
            assert10(Number.isFinite(value4) || Array.isArray(value4), "".concat(propName, " is required for transition"));
          });
        }
      }]);
      return TransitionInterpolator2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js
var DEFAULT_PROPS3, DEFAULT_REQUIRED_PROPS, LinearInterpolator;
var init_linear_interpolator = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_transition_interpolator();
    init_esm15();
    DEFAULT_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
    DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
    LinearInterpolator = function(_TransitionInterpolat) {
      _inherits(LinearInterpolator2, _TransitionInterpolat);
      function LinearInterpolator2(transitionProps) {
        _classCallCheck(this, LinearInterpolator2);
        return _possibleConstructorReturn(this, _getPrototypeOf(LinearInterpolator2).call(this, transitionProps || {
          compare: DEFAULT_PROPS3,
          extract: DEFAULT_PROPS3,
          required: DEFAULT_REQUIRED_PROPS
        }));
      }
      _createClass(LinearInterpolator2, [{
        key: "interpolateProps",
        value: function interpolateProps(startProps, endProps, t) {
          var viewport = {};
          for (var key in endProps) {
            viewport[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);
          }
          return viewport;
        }
      }]);
      return LinearInterpolator2;
    }(TransitionInterpolator);
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js
var noop3, TRANSITION_EVENTS, DEFAULT_PROPS4, TransitionManager;
var init_transition_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_linear_interpolator();
    init_transition();
    noop3 = function noop4() {
    };
    TRANSITION_EVENTS = {
      BREAK: 1,
      SNAP_TO_END: 2,
      IGNORE: 3
    };
    DEFAULT_PROPS4 = {
      transitionDuration: 0,
      transitionEasing: function transitionEasing(t) {
        return t;
      },
      transitionInterpolator: new LinearInterpolator(),
      transitionInterruption: TRANSITION_EVENTS.BREAK,
      onTransitionStart: noop3,
      onTransitionInterrupt: noop3,
      onTransitionEnd: noop3
    };
    TransitionManager = function() {
      function TransitionManager2(ControllerState) {
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, TransitionManager2);
        this.ControllerState = ControllerState;
        this.props = Object.assign({}, DEFAULT_PROPS4, props);
        this.propsInTransition = null;
        this.transition = new Transition(props.timeline);
        this.onViewStateChange = props.onViewStateChange;
        this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
      }
      _createClass(TransitionManager2, [{
        key: "finalize",
        value: function finalize() {
          this.transition.cancel();
        }
      }, {
        key: "getViewportInTransition",
        value: function getViewportInTransition() {
          return this.propsInTransition;
        }
      }, {
        key: "processViewStateChange",
        value: function processViewStateChange(nextProps) {
          var transitionTriggered = false;
          var currentProps = this.props;
          nextProps = Object.assign({}, DEFAULT_PROPS4, nextProps);
          this.props = nextProps;
          if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
            return transitionTriggered;
          }
          if (this._isTransitionEnabled(nextProps)) {
            var _this$transition$sett = this.transition.settings, interruption = _this$transition$sett.interruption, endProps = _this$transition$sett.endProps;
            var startProps = Object.assign({}, currentProps, interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps);
            this._triggerTransition(startProps, nextProps);
            transitionTriggered = true;
          } else {
            this.transition.cancel();
          }
          return transitionTriggered;
        }
      }, {
        key: "updateTransition",
        value: function updateTransition() {
          this.transition.update();
        }
      }, {
        key: "_isTransitionEnabled",
        value: function _isTransitionEnabled(props) {
          var transitionDuration = props.transitionDuration, transitionInterpolator = props.transitionInterpolator;
          return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
        }
      }, {
        key: "_isUpdateDueToCurrentTransition",
        value: function _isUpdateDueToCurrentTransition(props) {
          if (this.transition.inProgress) {
            return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
          }
          return false;
        }
      }, {
        key: "_shouldIgnoreViewportChange",
        value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
          if (this.transition.inProgress) {
            return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
          } else if (this._isTransitionEnabled(nextProps)) {
            return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
          }
          return true;
        }
      }, {
        key: "_triggerTransition",
        value: function _triggerTransition(startProps, endProps) {
          var startViewstate = new this.ControllerState(startProps);
          var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
          var transitionInterpolator = endProps.transitionInterpolator;
          var duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
          if (duration === 0) {
            return;
          }
          var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);
          this.propsInTransition = {};
          this.duration = duration;
          this.transition.start({
            duration,
            easing: endProps.transitionEasing,
            interpolator: endProps.transitionInterpolator,
            interruption: endProps.transitionInterruption,
            startProps: initialProps.start,
            endProps: initialProps.end,
            onStart: endProps.onTransitionStart,
            onUpdate: this._onTransitionUpdate,
            onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
            onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
          });
          this.updateTransition();
        }
      }, {
        key: "_onTransitionEnd",
        value: function _onTransitionEnd(callback) {
          var _this = this;
          return function(transition) {
            _this.propsInTransition = null;
            callback(transition);
          };
        }
      }, {
        key: "_onTransitionUpdate",
        value: function _onTransitionUpdate(transition) {
          var time = transition.time, _transition$settings = transition.settings, interpolator = _transition$settings.interpolator, startProps = _transition$settings.startProps, endProps = _transition$settings.endProps, duration = _transition$settings.duration, easing2 = _transition$settings.easing;
          var t = easing2(time / duration);
          var viewport = interpolator.interpolateProps(startProps, endProps, t);
          this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();
          if (this.onViewStateChange) {
            this.onViewStateChange({
              viewState: this.propsInTransition,
              interactionState: {
                inTransition: true
              },
              oldViewState: this.props
            });
          }
        }
      }]);
      return TransitionManager2;
    }();
    TransitionManager.defaultProps = DEFAULT_PROPS4;
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/controller.js
function ownKeys19(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread19(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys19(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys19(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var NO_TRANSITION_PROPS, ZOOM_ACCEL, EVENT_TYPES, Controller;
var init_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/controller.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_transition_manager();
    init_assert10();
    NO_TRANSITION_PROPS = {
      transitionDuration: 0
    };
    ZOOM_ACCEL = 0.01;
    EVENT_TYPES = {
      WHEEL: ["wheel"],
      PAN: ["panstart", "panmove", "panend"],
      PINCH: ["pinchstart", "pinchmove", "pinchend"],
      DOUBLE_TAP: ["doubletap"],
      KEYBOARD: ["keydown"]
    };
    Controller = function() {
      function Controller2(ControllerState) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Controller2);
        assert10(ControllerState);
        this.ControllerState = ControllerState;
        this.controllerState = null;
        this.controllerStateProps = null;
        this.eventManager = null;
        this.transitionManager = new TransitionManager(ControllerState, options);
        this._events = null;
        this._state = {
          isDragging: false
        };
        this._customEvents = [];
        this.onViewStateChange = null;
        this.onStateChange = null;
        this.invertPan = false;
        this.handleEvent = this.handleEvent.bind(this);
        this.setProps(options);
      }
      _createClass(Controller2, [{
        key: "finalize",
        value: function finalize() {
          for (var eventName in this._events) {
            if (this._events[eventName]) {
              this.eventManager.off(eventName, this.handleEvent);
            }
          }
          this.transitionManager.finalize();
        }
      }, {
        key: "handleEvent",
        value: function handleEvent(event) {
          var ControllerState = this.ControllerState;
          this.controllerState = new ControllerState(_objectSpread19({
            makeViewport: this.makeViewport
          }, this.controllerStateProps, {}, this._state));
          switch (event.type) {
            case "panstart":
              return this._onPanStart(event);
            case "panmove":
              return this._onPan(event);
            case "panend":
              return this._onPanEnd(event);
            case "pinchstart":
              return this._onPinchStart(event);
            case "pinchmove":
              return this._onPinch(event);
            case "pinchend":
              return this._onPinchEnd(event);
            case "doubletap":
              return this._onDoubleTap(event);
            case "wheel":
              return this._onWheel(event);
            case "keydown":
              return this._onKeyDown(event);
            default:
              return false;
          }
        }
      }, {
        key: "getCenter",
        value: function getCenter(event) {
          var _this$controllerState = this.controllerStateProps, x = _this$controllerState.x, y = _this$controllerState.y;
          var offsetCenter = event.offsetCenter;
          return [offsetCenter.x - x, offsetCenter.y - y];
        }
      }, {
        key: "isPointInBounds",
        value: function isPointInBounds(pos, event) {
          var _this$controllerState2 = this.controllerStateProps, width = _this$controllerState2.width, height = _this$controllerState2.height;
          if (event && event.handled) {
            return false;
          }
          var inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;
          if (inside && event) {
            event.stopPropagation();
          }
          return inside;
        }
      }, {
        key: "isFunctionKeyPressed",
        value: function isFunctionKeyPressed(event) {
          var srcEvent = event.srcEvent;
          return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
        }
      }, {
        key: "isDragging",
        value: function isDragging() {
          return this._state.isDragging;
        }
      }, {
        key: "setProps",
        value: function setProps(props) {
          if ("onViewStateChange" in props) {
            this.onViewStateChange = props.onViewStateChange;
          }
          if ("onStateChange" in props) {
            this.onStateChange = props.onStateChange;
          }
          if ("makeViewport" in props) {
            this.makeViewport = props.makeViewport;
          }
          this.controllerStateProps = props;
          if ("eventManager" in props && this.eventManager !== props.eventManager) {
            this.eventManager = props.eventManager;
            this._events = {};
            this.toggleEvents(this._customEvents, true);
          }
          this.transitionManager.processViewStateChange(this.controllerStateProps);
          var _props$scrollZoom = props.scrollZoom, scrollZoom = _props$scrollZoom === void 0 ? true : _props$scrollZoom, _props$dragPan = props.dragPan, dragPan = _props$dragPan === void 0 ? true : _props$dragPan, _props$dragRotate = props.dragRotate, dragRotate = _props$dragRotate === void 0 ? true : _props$dragRotate, _props$doubleClickZoo = props.doubleClickZoom, doubleClickZoom = _props$doubleClickZoo === void 0 ? true : _props$doubleClickZoo, _props$touchZoom = props.touchZoom, touchZoom = _props$touchZoom === void 0 ? true : _props$touchZoom, _props$touchRotate = props.touchRotate, touchRotate = _props$touchRotate === void 0 ? false : _props$touchRotate, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard;
          var isInteractive = Boolean(this.onViewStateChange);
          this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
          this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
          this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
          this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
          this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
          this.scrollZoom = scrollZoom;
          this.dragPan = dragPan;
          this.dragRotate = dragRotate;
          this.doubleClickZoom = doubleClickZoom;
          this.touchZoom = touchZoom;
          this.touchRotate = touchRotate;
          this.keyboard = keyboard;
        }
      }, {
        key: "updateTransition",
        value: function updateTransition() {
          this.transitionManager.updateTransition();
        }
      }, {
        key: "toggleEvents",
        value: function toggleEvents(eventNames, enabled) {
          var _this = this;
          if (this.eventManager) {
            eventNames.forEach(function(eventName) {
              if (_this._events[eventName] !== enabled) {
                _this._events[eventName] = enabled;
                if (enabled) {
                  _this.eventManager.on(eventName, _this.handleEvent);
                } else {
                  _this.eventManager.off(eventName, _this.handleEvent);
                }
              }
            });
          }
        }
      }, {
        key: "updateViewport",
        value: function updateViewport(newControllerState) {
          var extraProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var interactionState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var viewState = Object.assign({}, newControllerState.getViewportProps(), extraProps);
          var changed = this.controllerState !== newControllerState;
          if (changed) {
            var oldViewState = this.controllerState ? this.controllerState.getViewportProps() : null;
            if (this.onViewStateChange) {
              this.onViewStateChange({
                viewState,
                interactionState,
                oldViewState
              });
            }
          }
          Object.assign(this._state, newControllerState.getInteractiveState(), interactionState);
          if (this.onStateChange) {
            this.onStateChange(this._state);
          }
        }
      }, {
        key: "_onPanStart",
        value: function _onPanStart(event) {
          var pos = this.getCenter(event);
          if (!this.isPointInBounds(pos, event)) {
            return false;
          }
          var newControllerState = this.controllerState.panStart({
            pos
          }).rotateStart({
            pos
          });
          this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
            isDragging: true
          });
          return true;
        }
      }, {
        key: "_onPan",
        value: function _onPan(event) {
          if (!this.isDragging()) {
            return false;
          }
          var alternateMode = this.isFunctionKeyPressed(event) || event.rightButton;
          alternateMode = this.invertPan ? !alternateMode : alternateMode;
          return alternateMode ? this._onPanMove(event) : this._onPanRotate(event);
        }
      }, {
        key: "_onPanEnd",
        value: function _onPanEnd(event) {
          var newControllerState = this.controllerState.panEnd().rotateEnd();
          this.updateViewport(newControllerState, null, {
            isDragging: false,
            isPanning: false,
            isRotating: false
          });
          return true;
        }
      }, {
        key: "_onPanMove",
        value: function _onPanMove(event) {
          if (!this.dragPan) {
            return false;
          }
          var pos = this.getCenter(event);
          var newControllerState = this.controllerState.pan({
            pos
          });
          this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
            isDragging: true,
            isPanning: true
          });
          return true;
        }
      }, {
        key: "_onPanRotate",
        value: function _onPanRotate(event) {
          if (!this.dragRotate) {
            return false;
          }
          var deltaX = event.deltaX, deltaY = event.deltaY;
          var _this$controllerState3 = this.controllerState.getViewportProps(), width = _this$controllerState3.width, height = _this$controllerState3.height;
          var deltaScaleX = deltaX / width;
          var deltaScaleY = deltaY / height;
          var newControllerState = this.controllerState.rotate({
            deltaScaleX,
            deltaScaleY
          });
          this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
            isDragging: true,
            isRotating: true
          });
          return true;
        }
      }, {
        key: "_onWheel",
        value: function _onWheel(event) {
          if (!this.scrollZoom) {
            return false;
          }
          event.preventDefault();
          var pos = this.getCenter(event);
          if (!this.isPointInBounds(pos, event)) {
            return false;
          }
          var delta = event.delta;
          var scale6 = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));
          if (delta < 0 && scale6 !== 0) {
            scale6 = 1 / scale6;
          }
          var newControllerState = this.controllerState.zoom({
            pos,
            scale: scale6
          });
          this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
            isZooming: true,
            isPanning: true
          });
          return true;
        }
      }, {
        key: "_onPinchStart",
        value: function _onPinchStart(event) {
          var pos = this.getCenter(event);
          if (!this.isPointInBounds(pos, event)) {
            return false;
          }
          var newControllerState = this.controllerState.zoomStart({
            pos
          }).rotateStart({
            pos
          });
          this._state.startPinchRotation = event.rotation;
          this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
            isDragging: true
          });
          return true;
        }
      }, {
        key: "_onPinch",
        value: function _onPinch(event) {
          if (!this.touchZoom && !this.touchRotate) {
            return false;
          }
          if (!this.isDragging()) {
            return false;
          }
          var newControllerState = this.controllerState;
          if (this.touchZoom) {
            var scale6 = event.scale;
            var pos = this.getCenter(event);
            newControllerState = newControllerState.zoom({
              pos,
              scale: scale6
            });
          }
          if (this.touchRotate) {
            var rotation = event.rotation;
            var startPinchRotation = this._state.startPinchRotation;
            newControllerState = newControllerState.rotate({
              deltaScaleX: -(rotation - startPinchRotation) / 180
            });
          }
          this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
            isDragging: true,
            isPanning: this.touchZoom,
            isZooming: this.touchZoom,
            isRotating: this.touchRotate
          });
          return true;
        }
      }, {
        key: "_onPinchEnd",
        value: function _onPinchEnd(event) {
          var newControllerState = this.controllerState.zoomEnd().rotateEnd();
          this._state.startPinchRotation = 0;
          this.updateViewport(newControllerState, null, {
            isDragging: false,
            isPanning: false,
            isZooming: false,
            isRotating: false
          });
          return true;
        }
      }, {
        key: "_onDoubleTap",
        value: function _onDoubleTap(event) {
          if (!this.doubleClickZoom) {
            return false;
          }
          var pos = this.getCenter(event);
          if (!this.isPointInBounds(pos, event)) {
            return false;
          }
          var isZoomOut = this.isFunctionKeyPressed(event);
          var newControllerState = this.controllerState.zoom({
            pos,
            scale: isZoomOut ? 0.5 : 2
          });
          this.updateViewport(newControllerState, this._getTransitionProps(), {
            isZooming: true,
            isPanning: true
          });
          return true;
        }
      }, {
        key: "_onKeyDown",
        value: function _onKeyDown(event) {
          if (!this.keyboard) {
            return false;
          }
          var funcKey = this.isFunctionKeyPressed(event);
          var controllerState = this.controllerState;
          var newControllerState;
          var interactionState = {};
          switch (event.srcEvent.keyCode) {
            case 189:
              newControllerState = funcKey ? controllerState.zoomOut().zoomOut() : controllerState.zoomOut();
              interactionState.isZooming = true;
              break;
            case 187:
              newControllerState = funcKey ? controllerState.zoomIn().zoomIn() : controllerState.zoomIn();
              interactionState.isZooming = true;
              break;
            case 37:
              if (funcKey) {
                newControllerState = controllerState.rotateLeft();
                interactionState.isRotating = true;
              } else {
                newControllerState = controllerState.moveLeft();
                interactionState.isPanning = true;
              }
              break;
            case 39:
              if (funcKey) {
                newControllerState = controllerState.rotateRight();
                interactionState.isRotating = true;
              } else {
                newControllerState = controllerState.moveRight();
                interactionState.isPanning = true;
              }
              break;
            case 38:
              if (funcKey) {
                newControllerState = controllerState.rotateUp();
                interactionState.isRotating = true;
              } else {
                newControllerState = controllerState.moveUp();
                interactionState.isPanning = true;
              }
              break;
            case 40:
              if (funcKey) {
                newControllerState = controllerState.rotateDown();
                interactionState.isRotating = true;
              } else {
                newControllerState = controllerState.moveDown();
                interactionState.isPanning = true;
              }
              break;
            default:
              return false;
          }
          this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
          return true;
        }
      }, {
        key: "_getTransitionProps",
        value: function _getTransitionProps() {
          return NO_TRANSITION_PROPS;
        }
      }, {
        key: "events",
        set: function set2(customEvents) {
          this.toggleEvents(this._customEvents, false);
          this.toggleEvents(customEvents, true);
          this._customEvents = customEvents;
          this.setProps(this.controllerStateProps);
        }
      }]);
      return Controller2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/view-state.js
var ViewState;
var init_view_state = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/view-state.js"() {
    init_classCallCheck();
    init_createClass();
    init_assert10();
    ViewState = function() {
      function ViewState2(opts) {
        _classCallCheck(this, ViewState2);
        assert10(Number.isFinite(opts.width), "`width` must be supplied");
        assert10(Number.isFinite(opts.height), "`height` must be supplied");
        this._viewportProps = this._applyConstraints(opts);
      }
      _createClass(ViewState2, [{
        key: "getViewportProps",
        value: function getViewportProps() {
          return this._viewportProps;
        }
      }, {
        key: "shortestPathFrom",
        value: function shortestPathFrom(viewState) {
          return this._viewportProps;
        }
      }, {
        key: "_applyConstraints",
        value: function _applyConstraints(props) {
          return props;
        }
      }]);
      return ViewState2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js
function ownKeys20(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread20(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys20(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys20(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var PITCH_MOUSE_THRESHOLD, PITCH_ACCEL, LINEAR_TRANSITION_PROPS, NO_TRANSITION_PROPS2, MAPBOX_LIMITS, DEFAULT_STATE, MapState, MapController;
var init_map_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js"() {
    init_defineProperty();
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm15();
    init_controller();
    init_view_state();
    init_esm16();
    init_assert10();
    init_linear_interpolator();
    init_transition_manager();
    PITCH_MOUSE_THRESHOLD = 5;
    PITCH_ACCEL = 1.2;
    LINEAR_TRANSITION_PROPS = {
      transitionDuration: 300,
      transitionEasing: function transitionEasing2(t) {
        return t;
      },
      transitionInterpolator: new LinearInterpolator(),
      transitionInterruption: TRANSITION_EVENTS.BREAK
    };
    NO_TRANSITION_PROPS2 = {
      transitionDuration: 0
    };
    MAPBOX_LIMITS = {
      minZoom: 0,
      maxZoom: 20,
      minPitch: 0,
      maxPitch: 60
    };
    DEFAULT_STATE = {
      pitch: 0,
      bearing: 0,
      altitude: 1.5
    };
    MapState = function(_ViewState) {
      _inherits(MapState2, _ViewState);
      function MapState2() {
        var _this;
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, makeViewport = _ref.makeViewport, width = _ref.width, height = _ref.height, latitude = _ref.latitude, longitude = _ref.longitude, zoom = _ref.zoom, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom, _ref$minZoom = _ref.minZoom, minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom, _ref$maxPitch = _ref.maxPitch, maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch, _ref$minPitch = _ref.minPitch, minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch, startPanLngLat = _ref.startPanLngLat, startZoomLngLat = _ref.startZoomLngLat, startBearing = _ref.startBearing, startPitch = _ref.startPitch, startZoom = _ref.startZoom;
        _classCallCheck(this, MapState2);
        assert10(Number.isFinite(longitude), "`longitude` must be supplied");
        assert10(Number.isFinite(latitude), "`latitude` must be supplied");
        assert10(Number.isFinite(zoom), "`zoom` must be supplied");
        _this = _possibleConstructorReturn(this, _getPrototypeOf(MapState2).call(this, {
          width,
          height,
          latitude,
          longitude,
          zoom,
          bearing,
          pitch,
          altitude,
          maxZoom,
          minZoom,
          maxPitch,
          minPitch
        }));
        _this._interactiveState = {
          startPanLngLat,
          startZoomLngLat,
          startBearing,
          startPitch,
          startZoom
        };
        _this.makeViewport = makeViewport;
        return _this;
      }
      _createClass(MapState2, [{
        key: "getViewportProps",
        value: function getViewportProps() {
          return this._viewportProps;
        }
      }, {
        key: "getInteractiveState",
        value: function getInteractiveState() {
          return this._interactiveState;
        }
      }, {
        key: "panStart",
        value: function panStart(_ref2) {
          var pos = _ref2.pos;
          return this._getUpdatedState({
            startPanLngLat: this._unproject(pos)
          });
        }
      }, {
        key: "pan",
        value: function pan(_ref3) {
          var pos = _ref3.pos, startPos = _ref3.startPos;
          var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);
          if (!startPanLngLat) {
            return this;
          }
          var _this$_calculateNewLn = this._calculateNewLngLat({
            startPanLngLat,
            pos
          }), _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2), longitude = _this$_calculateNewLn2[0], latitude = _this$_calculateNewLn2[1];
          return this._getUpdatedState({
            longitude,
            latitude
          });
        }
      }, {
        key: "panEnd",
        value: function panEnd() {
          return this._getUpdatedState({
            startPanLngLat: null
          });
        }
      }, {
        key: "rotateStart",
        value: function rotateStart(_ref4) {
          var pos = _ref4.pos;
          return this._getUpdatedState({
            startBearing: this._viewportProps.bearing,
            startPitch: this._viewportProps.pitch
          });
        }
      }, {
        key: "rotate",
        value: function rotate3(_ref5) {
          var _ref5$deltaScaleX = _ref5.deltaScaleX, deltaScaleX = _ref5$deltaScaleX === void 0 ? 0 : _ref5$deltaScaleX, _ref5$deltaScaleY = _ref5.deltaScaleY, deltaScaleY = _ref5$deltaScaleY === void 0 ? 0 : _ref5$deltaScaleY;
          var _this$_interactiveSta = this._interactiveState, startBearing = _this$_interactiveSta.startBearing, startPitch = _this$_interactiveSta.startPitch;
          if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
            return this;
          }
          var _this$_calculateNewPi = this._calculateNewPitchAndBearing({
            deltaScaleX,
            deltaScaleY,
            startBearing,
            startPitch
          }), pitch = _this$_calculateNewPi.pitch, bearing = _this$_calculateNewPi.bearing;
          return this._getUpdatedState({
            bearing,
            pitch
          });
        }
      }, {
        key: "rotateEnd",
        value: function rotateEnd() {
          return this._getUpdatedState({
            startBearing: null,
            startPitch: null
          });
        }
      }, {
        key: "zoomStart",
        value: function zoomStart(_ref6) {
          var pos = _ref6.pos;
          return this._getUpdatedState({
            startZoomLngLat: this._unproject(pos),
            startZoom: this._viewportProps.zoom
          });
        }
      }, {
        key: "zoom",
        value: function zoom(_ref7) {
          var pos = _ref7.pos, startPos = _ref7.startPos, scale6 = _ref7.scale;
          var _this$_interactiveSta2 = this._interactiveState, startZoom = _this$_interactiveSta2.startZoom, startZoomLngLat = _this$_interactiveSta2.startZoomLngLat;
          if (!Number.isFinite(startZoom)) {
            startZoom = this._viewportProps.zoom;
            startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
          }
          var zoom2 = this._calculateNewZoom({
            scale: scale6,
            startZoom
          });
          var zoomedViewport = this.makeViewport(_objectSpread20({}, this._viewportProps, {
            zoom: zoom2
          }));
          var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({
            lngLat: startZoomLngLat,
            pos
          }), _zoomedViewport$getMa2 = _slicedToArray(_zoomedViewport$getMa, 2), longitude = _zoomedViewport$getMa2[0], latitude = _zoomedViewport$getMa2[1];
          return this._getUpdatedState({
            zoom: zoom2,
            longitude,
            latitude
          });
        }
      }, {
        key: "zoomEnd",
        value: function zoomEnd() {
          return this._getUpdatedState({
            startZoomLngLat: null,
            startZoom: null
          });
        }
      }, {
        key: "zoomIn",
        value: function zoomIn() {
          return this._zoomFromCenter(2);
        }
      }, {
        key: "zoomOut",
        value: function zoomOut() {
          return this._zoomFromCenter(0.5);
        }
      }, {
        key: "moveLeft",
        value: function moveLeft() {
          return this._panFromCenter([100, 0]);
        }
      }, {
        key: "moveRight",
        value: function moveRight() {
          return this._panFromCenter([-100, 0]);
        }
      }, {
        key: "moveUp",
        value: function moveUp() {
          return this._panFromCenter([0, 100]);
        }
      }, {
        key: "moveDown",
        value: function moveDown() {
          return this._panFromCenter([0, -100]);
        }
      }, {
        key: "rotateLeft",
        value: function rotateLeft() {
          return this._getUpdatedState({
            bearing: this._viewportProps.bearing - 15
          });
        }
      }, {
        key: "rotateRight",
        value: function rotateRight() {
          return this._getUpdatedState({
            bearing: this._viewportProps.bearing + 15
          });
        }
      }, {
        key: "rotateUp",
        value: function rotateUp() {
          return this._getUpdatedState({
            pitch: this._viewportProps.pitch + 10
          });
        }
      }, {
        key: "rotateDown",
        value: function rotateDown() {
          return this._getUpdatedState({
            pitch: this._viewportProps.pitch - 10
          });
        }
      }, {
        key: "shortestPathFrom",
        value: function shortestPathFrom(viewState) {
          var fromProps = viewState.getViewportProps();
          var props = Object.assign({}, this._viewportProps);
          var bearing = props.bearing, longitude = props.longitude;
          if (Math.abs(bearing - fromProps.bearing) > 180) {
            props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
          }
          if (Math.abs(longitude - fromProps.longitude) > 180) {
            props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
          }
          return props;
        }
      }, {
        key: "_zoomFromCenter",
        value: function _zoomFromCenter(scale6) {
          var _this$_viewportProps = this._viewportProps, width = _this$_viewportProps.width, height = _this$_viewportProps.height;
          return this.zoom({
            pos: [width / 2, height / 2],
            scale: scale6
          });
        }
      }, {
        key: "_panFromCenter",
        value: function _panFromCenter(offset) {
          var _this$_viewportProps2 = this._viewportProps, width = _this$_viewportProps2.width, height = _this$_viewportProps2.height;
          return this.pan({
            startPos: [width / 2, height / 2],
            pos: [width / 2 + offset[0], height / 2 + offset[1]]
          });
        }
      }, {
        key: "_getUpdatedState",
        value: function _getUpdatedState(newProps) {
          return new this.constructor(_objectSpread20({
            makeViewport: this.makeViewport
          }, this._viewportProps, {}, this._interactiveState, {}, newProps));
        }
      }, {
        key: "_applyConstraints",
        value: function _applyConstraints(props) {
          var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom;
          props.zoom = clamp(zoom, minZoom, maxZoom);
          var maxPitch = props.maxPitch, minPitch = props.minPitch, pitch = props.pitch;
          props.pitch = clamp(pitch, minPitch, maxPitch);
          Object.assign(props, normalizeViewportProps(props));
          return props;
        }
      }, {
        key: "_unproject",
        value: function _unproject(pos) {
          var viewport = this.makeViewport(this._viewportProps);
          return pos && viewport.unproject(pos);
        }
      }, {
        key: "_calculateNewLngLat",
        value: function _calculateNewLngLat(_ref8) {
          var startPanLngLat = _ref8.startPanLngLat, pos = _ref8.pos;
          var viewport = this.makeViewport(this._viewportProps);
          return viewport.getMapCenterByLngLatPosition({
            lngLat: startPanLngLat,
            pos
          });
        }
      }, {
        key: "_calculateNewZoom",
        value: function _calculateNewZoom(_ref9) {
          var scale6 = _ref9.scale, startZoom = _ref9.startZoom;
          var _this$_viewportProps3 = this._viewportProps, maxZoom = _this$_viewportProps3.maxZoom, minZoom = _this$_viewportProps3.minZoom;
          var zoom = startZoom + Math.log2(scale6);
          return clamp(zoom, minZoom, maxZoom);
        }
      }, {
        key: "_calculateNewPitchAndBearing",
        value: function _calculateNewPitchAndBearing(_ref10) {
          var deltaScaleX = _ref10.deltaScaleX, deltaScaleY = _ref10.deltaScaleY, startBearing = _ref10.startBearing, startPitch = _ref10.startPitch;
          deltaScaleY = clamp(deltaScaleY, -1, 1);
          var _this$_viewportProps4 = this._viewportProps, minPitch = _this$_viewportProps4.minPitch, maxPitch = _this$_viewportProps4.maxPitch;
          var bearing = startBearing + 180 * deltaScaleX;
          var pitch = startPitch;
          if (deltaScaleY > 0) {
            pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
          } else if (deltaScaleY < 0) {
            pitch = startPitch - deltaScaleY * (minPitch - startPitch);
          }
          return {
            pitch,
            bearing
          };
        }
      }]);
      return MapState2;
    }(ViewState);
    MapController = function(_Controller) {
      _inherits(MapController2, _Controller);
      function MapController2(props) {
        var _this2;
        _classCallCheck(this, MapController2);
        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MapController2).call(this, MapState, props));
        _this2.invertPan = true;
        return _this2;
      }
      _createClass(MapController2, [{
        key: "_getTransitionProps",
        value: function _getTransitionProps() {
          return LINEAR_TRANSITION_PROPS;
        }
      }, {
        key: "_onPanRotate",
        value: function _onPanRotate(event) {
          if (!this.dragRotate) {
            return false;
          }
          var deltaX = event.deltaX, deltaY = event.deltaY;
          var _this$getCenter = this.getCenter(event), _this$getCenter2 = _slicedToArray(_this$getCenter, 2), centerY = _this$getCenter2[1];
          var startY = centerY - deltaY;
          var _this$controllerState = this.controllerState.getViewportProps(), width = _this$controllerState.width, height = _this$controllerState.height;
          var deltaScaleX = deltaX / width;
          var deltaScaleY = 0;
          if (deltaY > 0) {
            if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
              deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
            }
          } else if (deltaY < 0) {
            if (startY > PITCH_MOUSE_THRESHOLD) {
              deltaScaleY = 1 - centerY / startY;
            }
          }
          deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
          var newControllerState = this.controllerState.rotate({
            deltaScaleX,
            deltaScaleY
          });
          return this.updateViewport(newControllerState, NO_TRANSITION_PROPS2, {
            isDragging: true,
            isRotating: true
          });
        }
      }]);
      return MapController2;
    }(Controller);
  }
});

// node_modules/@deck.gl/core/dist/esm/views/map-view.js
var MapView;
var init_map_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/map-view.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_view();
    init_web_mercator_viewport2();
    init_map_controller();
    MapView = function(_View) {
      _inherits(MapView2, _View);
      function MapView2(props) {
        _classCallCheck(this, MapView2);
        return _possibleConstructorReturn(this, _getPrototypeOf(MapView2).call(this, Object.assign({}, props, {
          type: WebMercatorViewport2
        })));
      }
      _createClass(MapView2, [{
        key: "controller",
        get: function get2() {
          return this._getControllerProps({
            type: MapController
          });
        }
      }]);
      return MapView2;
    }(View);
    MapView.displayName = "MapView";
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js
var DEFAULT_LIGHTING_EFFECT, EffectManager;
var init_effect_manager = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_deep_equal();
    init_lighting_effect();
    DEFAULT_LIGHTING_EFFECT = new LightingEffect();
    EffectManager = function() {
      function EffectManager2() {
        _classCallCheck(this, EffectManager2);
        this.effects = [];
        this._internalEffects = [];
        this._needsRedraw = "Initial render";
        this.setEffects();
      }
      _createClass(EffectManager2, [{
        key: "setProps",
        value: function setProps(props) {
          if ("effects" in props) {
            if (props.effects.length !== this.effects.length || !deepEqual(props.effects, this.effects)) {
              this.setEffects(props.effects);
              this._needsRedraw = "effects changed";
            }
          }
        }
      }, {
        key: "needsRedraw",
        value: function needsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          var redraw = this._needsRedraw;
          if (opts.clearRedrawFlags) {
            this._needsRedraw = false;
          }
          return redraw;
        }
      }, {
        key: "getEffects",
        value: function getEffects() {
          return this._internalEffects;
        }
      }, {
        key: "finalize",
        value: function finalize() {
          this.cleanup();
        }
      }, {
        key: "setEffects",
        value: function setEffects() {
          var effects = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.cleanup();
          this.effects = effects;
          this._createInternalEffects();
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = this.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var effect = _step.value;
              effect.cleanup();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = this._internalEffects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _effect = _step2.value;
              _effect.cleanup();
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          this.effects.length = 0;
          this._internalEffects.length = 0;
        }
      }, {
        key: "_createInternalEffects",
        value: function _createInternalEffects() {
          this._internalEffects = this.effects.slice();
          if (!this.effects.some(function(effect) {
            return effect instanceof LightingEffect;
          })) {
            this._internalEffects.push(DEFAULT_LIGHTING_EFFECT);
          }
        }
      }]);
      return EffectManager2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js
var DrawLayersPass;
var init_draw_layers_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js"() {
    init_classCallCheck();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_layers_pass();
    DrawLayersPass = function(_LayersPass) {
      _inherits(DrawLayersPass2, _LayersPass);
      function DrawLayersPass2() {
        _classCallCheck(this, DrawLayersPass2);
        return _possibleConstructorReturn(this, _getPrototypeOf(DrawLayersPass2).apply(this, arguments));
      }
      return DrawLayersPass2;
    }(LayersPass);
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js
function ownKeys21(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread21(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys21(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys21(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var PICKING_PARAMETERS, PickLayersPass;
var init_pick_layers_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_layers_pass();
    init_esm14();
    PICKING_PARAMETERS = {
      blendFunc: [1, 0, 32771, 0],
      blendEquation: 32774
    };
    PickLayersPass = function(_LayersPass) {
      _inherits(PickLayersPass2, _LayersPass);
      function PickLayersPass2() {
        _classCallCheck(this, PickLayersPass2);
        return _possibleConstructorReturn(this, _getPrototypeOf(PickLayersPass2).apply(this, arguments));
      }
      _createClass(PickLayersPass2, [{
        key: "render",
        value: function render(props) {
          if (props.pickingFBO) {
            this._drawPickingBuffer(props);
          } else {
            _get(_getPrototypeOf(PickLayersPass2.prototype), "render", this).call(this, props);
          }
        }
      }, {
        key: "_drawPickingBuffer",
        value: function _drawPickingBuffer(_ref) {
          var _this = this;
          var layers = _ref.layers, layerFilter = _ref.layerFilter, viewports = _ref.viewports, onViewportActive = _ref.onViewportActive, pickingFBO = _ref.pickingFBO, _ref$deviceRect = _ref.deviceRect, x = _ref$deviceRect.x, y = _ref$deviceRect.y, width = _ref$deviceRect.width, height = _ref$deviceRect.height, _ref$pass = _ref.pass, pass = _ref$pass === void 0 ? "picking" : _ref$pass, redrawReason = _ref.redrawReason, pickZ = _ref.pickZ;
          var gl = this.gl;
          this.pickZ = pickZ;
          return withParameters(gl, _objectSpread21({
            scissorTest: true,
            scissor: [x, y, width, height],
            clearColor: [0, 0, 0, 0],
            depthMask: true,
            depthTest: true,
            depthRange: [0, 1],
            colorMask: [true, true, true, true]
          }, PICKING_PARAMETERS, {
            blend: !pickZ
          }), function() {
            _get(_getPrototypeOf(PickLayersPass2.prototype), "render", _this).call(_this, {
              target: pickingFBO,
              layers,
              layerFilter,
              viewports,
              onViewportActive,
              pass,
              redrawReason
            });
          });
        }
      }, {
        key: "shouldDrawLayer",
        value: function shouldDrawLayer(layer) {
          return layer.props.pickable;
        }
      }, {
        key: "getModuleParameters",
        value: function getModuleParameters() {
          return {
            pickingActive: 1,
            pickingAttribute: this.pickZ,
            lightSources: {}
          };
        }
      }, {
        key: "getLayerParameters",
        value: function getLayerParameters(layer, layerIndex) {
          var pickParameters = this.pickZ ? {
            blend: false
          } : _objectSpread21({}, PICKING_PARAMETERS, {
            blend: true,
            blendColor: [0, 0, 0, (layerIndex + 1) / 255]
          });
          return Object.assign({}, layer.props.parameters, pickParameters);
        }
      }]);
      return PickLayersPass2;
    }(LayersPass);
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js
function ownKeys22(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys22(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys22(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var TRACE_RENDER_LAYERS, DeckRenderer;
var init_deck_renderer = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_debug();
    init_draw_layers_pass();
    init_pick_layers_pass();
    init_esm14();
    TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
    DeckRenderer = function() {
      function DeckRenderer2(gl) {
        _classCallCheck(this, DeckRenderer2);
        this.gl = gl;
        this.layerFilter = null;
        this.drawPickingColors = false;
        this.drawLayersPass = new DrawLayersPass(gl);
        this.pickLayersPass = new PickLayersPass(gl);
        this.renderCount = 0;
        this._needsRedraw = "Initial render";
        this.renderBuffers = [];
        this.lastPostProcessEffect = null;
        this._onError = null;
      }
      _createClass(DeckRenderer2, [{
        key: "setProps",
        value: function setProps(props) {
          if ("layerFilter" in props && this.layerFilter !== props.layerFilter) {
            this.layerFilter = props.layerFilter;
            this._needsRedraw = "layerFilter changed";
          }
          if ("drawPickingColors" in props && this.drawPickingColors !== props.drawPickingColors) {
            this.drawPickingColors = props.drawPickingColors;
            this._needsRedraw = "drawPickingColors changed";
          }
          if ("onError" in props) {
            this._onError = props.onError;
          }
        }
      }, {
        key: "renderLayers",
        value: function renderLayers(opts) {
          var layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
          opts.layerFilter = this.layerFilter;
          opts.onError = this._onError;
          opts.effects = opts.effects || [];
          opts.target = opts.target || Framebuffer.getDefaultFramebuffer(this.gl);
          this._preRender(opts.effects, opts);
          var outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : opts.target;
          var renderStats = layerPass.render(_objectSpread22({}, opts, {
            target: outputBuffer
          }));
          this._postRender(opts.effects, opts);
          this.renderCount++;
          debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
        }
      }, {
        key: "needsRedraw",
        value: function needsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          var redraw = this._needsRedraw;
          if (opts.clearRedrawFlags) {
            this._needsRedraw = false;
          }
          return redraw;
        }
      }, {
        key: "finalize",
        value: function finalize() {
          var renderBuffers = this.renderBuffers;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = renderBuffers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var buffer = _step.value;
              buffer["delete"]();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          renderBuffers.length = 0;
        }
      }, {
        key: "_preRender",
        value: function _preRender(effects, opts) {
          var lastPostProcessEffect = null;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var effect = _step2.value;
              effect.preRender(this.gl, opts);
              if (effect.postRender) {
                lastPostProcessEffect = effect;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          if (lastPostProcessEffect) {
            this._resizeRenderBuffers();
          }
          this.lastPostProcessEffect = lastPostProcessEffect;
        }
      }, {
        key: "_resizeRenderBuffers",
        value: function _resizeRenderBuffers() {
          var renderBuffers = this.renderBuffers;
          if (renderBuffers.length === 0) {
            renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
          }
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = renderBuffers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var buffer = _step3.value;
              buffer.resize();
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
      }, {
        key: "_postRender",
        value: function _postRender(effects, opts) {
          var renderBuffers = this.renderBuffers;
          var params = {
            inputBuffer: renderBuffers[0],
            swapBuffer: renderBuffers[1],
            target: null
          };
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = void 0;
          try {
            for (var _iterator4 = effects[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var effect = _step4.value;
              if (effect.postRender) {
                if (effect === this.lastPostProcessEffect) {
                  params.target = opts.target;
                  effect.postRender(this.gl, params);
                  break;
                }
                var buffer = effect.postRender(this.gl, params);
                params.inputBuffer = buffer;
                params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      }]);
      return DeckRenderer2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js
function getClosestObject(_ref) {
  var pickedColors = _ref.pickedColors, layers = _ref.layers, deviceX = _ref.deviceX, deviceY = _ref.deviceY, deviceRadius = _ref.deviceRadius, deviceRect = _ref.deviceRect;
  if (pickedColors) {
    var x = deviceRect.x, y = deviceRect.y, width = deviceRect.width, height = deviceRect.height;
    var minSquareDistanceToCenter = deviceRadius * deviceRadius;
    var closestPixelIndex = -1;
    var i = 0;
    for (var row = 0; row < height; row++) {
      var dy = row + y - deviceY;
      var dy2 = dy * dy;
      if (dy2 > minSquareDistanceToCenter) {
        i += 4 * width;
      } else {
        for (var col = 0; col < width; col++) {
          var pickedLayerIndex = pickedColors[i + 3] - 1;
          if (pickedLayerIndex >= 0) {
            var dx = col + x - deviceX;
            var d2 = dx * dx + dy2;
            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i;
            }
          }
          i += 4;
        }
      }
    }
    if (closestPixelIndex >= 0) {
      var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;
      var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      var pickedLayer = layers[_pickedLayerIndex];
      if (pickedLayer) {
        var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
        var _dy = Math.floor(closestPixelIndex / 4 / width);
        var _dx = closestPixelIndex / 4 - _dy * width;
        return {
          pickedColor,
          pickedLayer,
          pickedObjectIndex,
          pickedX: x + _dx,
          pickedY: y + _dy
        };
      }
      log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
  }
  return NO_PICKED_OBJECT;
}
function getUniqueObjects(_ref2) {
  var pickedColors = _ref2.pickedColors, layers = _ref2.layers;
  var uniqueColors = /* @__PURE__ */ new Map();
  if (pickedColors) {
    for (var i = 0; i < pickedColors.length; i += 4) {
      var pickedLayerIndex = pickedColors[i + 3] - 1;
      if (pickedLayerIndex >= 0) {
        var pickedColor = pickedColors.slice(i, i + 4);
        var colorKey = pickedColor.join(",");
        if (!uniqueColors.has(colorKey)) {
          var pickedLayer = layers[pickedLayerIndex];
          if (pickedLayer) {
            uniqueColors.set(colorKey, {
              pickedColor,
              pickedLayer,
              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
            });
          } else {
            log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
          }
        }
      }
    }
  }
  return Array.from(uniqueColors.values());
}
var NO_PICKED_OBJECT;
var init_query_object = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js"() {
    init_log2();
    NO_PICKED_OBJECT = {
      pickedColor: null,
      pickedLayer: null,
      pickedObjectIndex: -1
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js
function processPickInfo(_ref) {
  var pickInfo = _ref.pickInfo, lastPickedInfo = _ref.lastPickedInfo, mode = _ref.mode, layers = _ref.layers, viewports = _ref.viewports, x = _ref.x, y = _ref.y, z = _ref.z, pixelRatio = _ref.pixelRatio;
  var pickedColor = pickInfo.pickedColor, pickedLayer = pickInfo.pickedLayer, pickedObjectIndex = pickInfo.pickedObjectIndex;
  var affectedLayers = pickedLayer ? [pickedLayer] : [];
  if (mode === "hover") {
    var lastPickedObjectIndex = lastPickedInfo.index;
    var lastPickedLayerId = lastPickedInfo.layerId;
    var pickedLayerId = pickedLayer && pickedLayer.props.id;
    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        var lastPickedLayer = layers.find(function(layer) {
          return layer.props.id === lastPickedLayerId;
        });
        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }
      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }
  var viewport = getViewportFromCoordinates({
    viewports
  });
  var coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y], {
    targetZ: z
  });
  var baseInfo = {
    color: null,
    layer: null,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    lngLat: coordinate,
    devicePixel: [pickInfo.pickedX, pickInfo.pickedY],
    pixelRatio
  };
  var infos = /* @__PURE__ */ new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(function(layer) {
    var info = Object.assign({}, baseInfo);
    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }
    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });
    if (layer === pickedLayer && mode === "hover") {
      lastPickedInfo.info = info;
    }
    if (info) {
      infos.set(info.layer.id, info);
    }
    if (mode === "hover" && layer.props.autoHighlight) {
      var pickingModuleParameters = {
        pickingSelectedColor: pickedLayer === layer ? pickedColor : null
      };
      var highlightColor = layer.props.highlightColor;
      if (pickedLayer === layer && typeof highlightColor === "function") {
        pickingModuleParameters.pickingHighlightColor = highlightColor(info);
      }
      layer.setModuleParameters(pickingModuleParameters);
      layer.setNeedsRedraw();
    }
  });
  return infos;
}
function getLayerPickingInfo(_ref2) {
  var layer = _ref2.layer, info = _ref2.info, mode = _ref2.mode;
  while (layer && info) {
    var sourceLayer = info.layer || layer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }
  return info;
}
function getViewportFromCoordinates(_ref3) {
  var viewports = _ref3.viewports;
  var viewport = viewports[0];
  return viewport;
}
var init_pick_info = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js"() {
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js
var DeckPicker;
var init_deck_picker = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm14();
    init_assert10();
    init_log2();
    init_pick_layers_pass();
    init_query_object();
    init_pick_info();
    DeckPicker = function() {
      function DeckPicker2(gl) {
        _classCallCheck(this, DeckPicker2);
        this.gl = gl;
        this.pickingFBO = null;
        this.pickLayersPass = new PickLayersPass(gl);
        this.layerFilter = null;
        this.lastPickedInfo = {
          index: -1,
          layerId: null,
          info: null
        };
        this._onError = null;
      }
      _createClass(DeckPicker2, [{
        key: "setProps",
        value: function setProps(props) {
          if ("layerFilter" in props) {
            this.layerFilter = props.layerFilter;
          }
          if ("onError" in props) {
            this._onError = props.onError;
          }
        }
      }, {
        key: "finalize",
        value: function finalize() {
          if (this.pickingFBO) {
            this.pickingFBO["delete"]();
          }
          if (this.depthFBO) {
            this.depthFBO.color["delete"]();
            this.depthFBO["delete"]();
          }
        }
      }, {
        key: "pickObject",
        value: function pickObject(opts) {
          return this._pickClosestObject(opts);
        }
      }, {
        key: "pickObjects",
        value: function pickObjects(opts) {
          return this._pickVisibleObjects(opts);
        }
      }, {
        key: "getLastPickedObject",
        value: function getLastPickedObject(_ref) {
          var x = _ref.x, y = _ref.y, layers = _ref.layers, viewports = _ref.viewports;
          var lastPickedInfo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
          var lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
          var layer = lastPickedLayerId ? layers.find(function(l) {
            return l.id === lastPickedLayerId;
          }) : null;
          var coordinate = viewports[0] && viewports[0].unproject([x, y]);
          var info = {
            x,
            y,
            coordinate,
            lngLat: coordinate,
            layer
          };
          if (layer) {
            return Object.assign({}, lastPickedInfo, info);
          }
          return Object.assign(info, {
            color: null,
            object: null,
            index: -1
          });
        }
      }, {
        key: "_resizeBuffer",
        value: function _resizeBuffer() {
          var gl = this.gl;
          if (!this.pickingFBO) {
            this.pickingFBO = new Framebuffer(gl);
            if (Framebuffer.isSupported(gl, {
              colorBufferFloat: true
            })) {
              this.depthFBO = new Framebuffer(gl);
              this.depthFBO.attach(_defineProperty({}, 36064, new Texture2D(gl, {
                format: isWebGL2(gl) ? 34836 : 6408,
                type: 5126
              })));
            }
          }
          this.pickingFBO.resize({
            width: gl.canvas.width,
            height: gl.canvas.height
          });
          if (this.depthFBO) {
            this.depthFBO.resize({
              width: gl.canvas.width,
              height: gl.canvas.height
            });
          }
          return this.pickingFBO;
        }
      }, {
        key: "_getPickable",
        value: function _getPickable(layers) {
          var pickableLayers = layers.filter(function(layer) {
            return layer.isPickable() && !layer.isComposite;
          });
          if (pickableLayers.length > 255) {
            log_default.warn("Too many pickable layers, only picking the first 255")();
            return pickableLayers.slice(0, 255);
          }
          return pickableLayers;
        }
      }, {
        key: "_pickClosestObject",
        value: function _pickClosestObject(_ref2) {
          var layers = _ref2.layers, viewports = _ref2.viewports, x = _ref2.x, y = _ref2.y, _ref2$radius = _ref2.radius, radius = _ref2$radius === void 0 ? 0 : _ref2$radius, _ref2$depth = _ref2.depth, depth = _ref2$depth === void 0 ? 1 : _ref2$depth, _ref2$mode = _ref2.mode, mode = _ref2$mode === void 0 ? "query" : _ref2$mode, unproject3D = _ref2.unproject3D, onViewportActive = _ref2.onViewportActive;
          layers = this._getPickable(layers);
          this._resizeBuffer();
          var pixelRatio = cssToDeviceRatio(this.gl);
          var devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);
          var devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
          var deviceRadius = Math.round(radius * pixelRatio);
          var _this$pickingFBO = this.pickingFBO, width = _this$pickingFBO.width, height = _this$pickingFBO.height;
          var deviceRect = this._getPickingRect({
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceWidth: width,
            deviceHeight: height
          });
          var infos;
          var result = [];
          var affectedLayers = {};
          for (var i = 0; i < depth; i++) {
            var pickedColors = deviceRect && this._drawAndSample({
              layers,
              viewports,
              onViewportActive,
              deviceRect,
              pass: "picking:".concat(mode),
              redrawReason: mode
            });
            var pickInfo = getClosestObject({
              pickedColors,
              layers,
              deviceX: devicePixel[0],
              deviceY: devicePixel[1],
              deviceRadius,
              deviceRect
            });
            var z = void 0;
            if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
              var zValues = this._drawAndSample({
                layers: [pickInfo.pickedLayer],
                viewports,
                onViewportActive,
                deviceRect: {
                  x: pickInfo.pickedX,
                  y: pickInfo.pickedY,
                  width: 1,
                  height: 1
                },
                pass: "picking:".concat(mode),
                redrawReason: "pick-z",
                pickZ: true
              });
              z = zValues[0] * viewports[0].distanceScales.metersPerUnit[2] + viewports[0].position[2];
            }
            if (pickInfo.pickedColor && i + 1 < depth) {
              var layerId = pickInfo.pickedColor[3] - 1;
              affectedLayers[layerId] = true;
              layers[layerId].clearPickingColor(pickInfo.pickedColor);
            }
            infos = processPickInfo({
              pickInfo,
              lastPickedInfo: this.lastPickedInfo,
              mode,
              layers,
              viewports,
              x,
              y,
              z,
              pixelRatio
            });
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = infos.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var info = _step.value;
                if (info.layer) {
                  result.push(info);
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            if (!pickInfo.pickedColor) {
              break;
            }
          }
          for (var _layerId in affectedLayers) {
            layers[_layerId].restorePickingColors();
          }
          return {
            result,
            emptyInfo: infos && infos.get(null)
          };
        }
      }, {
        key: "_pickVisibleObjects",
        value: function _pickVisibleObjects(_ref3) {
          var layers = _ref3.layers, viewports = _ref3.viewports, x = _ref3.x, y = _ref3.y, _ref3$width = _ref3.width, width = _ref3$width === void 0 ? 1 : _ref3$width, _ref3$height = _ref3.height, height = _ref3$height === void 0 ? 1 : _ref3$height, _ref3$mode = _ref3.mode, mode = _ref3$mode === void 0 ? "query" : _ref3$mode, onViewportActive = _ref3.onViewportActive;
          layers = this._getPickable(layers);
          this._resizeBuffer();
          var pixelRatio = cssToDeviceRatio(this.gl);
          var leftTop = cssToDevicePixels(this.gl, [x, y], true);
          var deviceLeft = leftTop.x;
          var deviceTop = leftTop.y + leftTop.height;
          var rightBottom = cssToDevicePixels(this.gl, [x + width, y + height], true);
          var deviceRight = rightBottom.x + rightBottom.width;
          var deviceBottom = rightBottom.y;
          var deviceRect = {
            x: deviceLeft,
            y: deviceBottom,
            width: deviceRight - deviceLeft,
            height: deviceTop - deviceBottom
          };
          var pickedColors = this._drawAndSample({
            layers,
            viewports,
            onViewportActive,
            deviceRect,
            pass: "picking:".concat(mode),
            redrawReason: mode
          });
          var pickInfos = getUniqueObjects({
            pickedColors,
            layers
          });
          var uniqueInfos = /* @__PURE__ */ new Map();
          pickInfos.forEach(function(pickInfo) {
            var info = {
              color: pickInfo.pickedColor,
              layer: null,
              index: pickInfo.pickedObjectIndex,
              picked: true,
              x,
              y,
              width,
              height,
              pixelRatio
            };
            info = getLayerPickingInfo({
              layer: pickInfo.pickedLayer,
              info,
              mode
            });
            if (!uniqueInfos.has(info.object)) {
              uniqueInfos.set(info.object, info);
            }
          });
          return Array.from(uniqueInfos.values());
        }
      }, {
        key: "_drawAndSample",
        value: function _drawAndSample(_ref4) {
          var layers = _ref4.layers, viewports = _ref4.viewports, onViewportActive = _ref4.onViewportActive, deviceRect = _ref4.deviceRect, pass = _ref4.pass, redrawReason = _ref4.redrawReason, pickZ = _ref4.pickZ;
          assert10(deviceRect.width > 0 && deviceRect.height > 0);
          if (layers.length < 1) {
            return null;
          }
          var pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
          this.pickLayersPass.render({
            layers,
            layerFilter: this.layerFilter,
            onError: this._onError,
            viewports,
            onViewportActive,
            pickingFBO,
            deviceRect,
            pass,
            redrawReason,
            pickZ
          });
          var x = deviceRect.x, y = deviceRect.y, width = deviceRect.width, height = deviceRect.height;
          var pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
          readPixelsToArray(pickingFBO, {
            sourceX: x,
            sourceY: y,
            sourceWidth: width,
            sourceHeight: height,
            target: pickedColors
          });
          return pickedColors;
        }
      }, {
        key: "_getPickingRect",
        value: function _getPickingRect(_ref5) {
          var deviceX = _ref5.deviceX, deviceY = _ref5.deviceY, deviceRadius = _ref5.deviceRadius, deviceWidth = _ref5.deviceWidth, deviceHeight = _ref5.deviceHeight;
          var x = Math.max(0, deviceX - deviceRadius);
          var y = Math.max(0, deviceY - deviceRadius);
          var width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
          var height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
          if (width <= 0 || height <= 0) {
            return null;
          }
          return {
            x,
            y,
            width,
            height
          };
        }
      }]);
      return DeckPicker2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/tooltip.js
var defaultStyle, Tooltip;
var init_tooltip = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/tooltip.js"() {
    init_classCallCheck();
    init_createClass();
    defaultStyle = {
      zIndex: 1,
      position: "absolute",
      pointerEvents: "none",
      color: "#a0a7b4",
      backgroundColor: "#29323c",
      padding: "10px",
      top: 0,
      left: 0,
      display: "none"
    };
    Tooltip = function() {
      function Tooltip2(canvas) {
        _classCallCheck(this, Tooltip2);
        var canvasParent = canvas.parentElement;
        if (canvasParent) {
          this.el = document.createElement("div");
          this.el.className = "deck-tooltip";
          Object.assign(this.el.style, defaultStyle);
          canvasParent.appendChild(this.el);
        }
      }
      _createClass(Tooltip2, [{
        key: "setTooltip",
        value: function setTooltip(displayInfo, x, y) {
          var el = this.el;
          if (typeof displayInfo === "string") {
            el.innerText = displayInfo;
          } else if (!displayInfo) {
            el.style.display = "none";
            return;
          } else {
            if ("text" in displayInfo) {
              el.innerText = displayInfo.text;
            }
            if ("html" in displayInfo) {
              el.innerHTML = displayInfo.html;
            }
            if ("className" in displayInfo) {
              el.className = displayInfo.className;
            }
            Object.assign(el.style, displayInfo.style);
          }
          el.style.display = "block";
          el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
        }
      }, {
        key: "remove",
        value: function remove() {
          if (this.el) {
            this.el.remove();
          }
        }
      }]);
      return Tooltip2;
    }();
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    (function(window3, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round2 = Math.round;
      var abs = Math.abs;
      var now = Date.now;
      function setTimeoutContext(fn, timeout, context) {
        return setTimeout(bindFn(fn, context), timeout);
      }
      function invokeArrayArg(arg, fn, context) {
        if (Array.isArray(arg)) {
          each(arg, context[fn], context);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
        return function() {
          var e2 = new Error("get-stack-trace");
          var stack = e2 && e2.stack ? e2.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log3 = window3.console && (window3.console.warn || window3.console.log);
          if (log3) {
            log3.call(window3.console, deprecationMessage, stack);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend = deprecate(function extend2(dest, src, merge2) {
        var keys = Object.keys(src);
        var i = 0;
        while (i < keys.length) {
          if (!merge2 || merge2 && dest[keys[i]] === undefined2) {
            dest[keys[i]] = src[keys[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context) {
        return function boundFn() {
          return fn.apply(context, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent(node9, parent) {
        while (node9) {
          if (node9 == parent) {
            return true;
          }
          node9 = node9.parentNode;
        }
        return false;
      }
      function inStr(str, find) {
        return str.indexOf(find) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray(src, find, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray(values, val) < 0) {
            results.push(src[i]);
          }
          values[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a2, b) {
              return a2[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element) {
        var doc = element.ownerDocument || element;
        return doc.defaultView || doc.parentWindow || window3;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window3;
      var SUPPORT_POINTER_EVENTS = prefixed(window3, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START2 = 1;
      var INPUT_MOVE2 = 2;
      var INPUT_END2 = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input2(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input2.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput2;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput2;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset.x);
        input.deltaY = prevDelta.y + (center.y - offset.y);
      }
      function computeIntervalInputData(session, input) {
        var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
          var deltaX = input.deltaX - last.deltaX;
          var deltaY = input.deltaY - last.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last.velocity;
          velocityX = last.velocityX;
          velocityY = last.velocityY;
          direction = last.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round2(input.pointers[i].clientX),
            clientY: round2(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round2(pointers[0].clientX),
            y: round2(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round2(x / pointersLength),
          y: round2(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs(x) >= abs(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP2 = {
        mousedown: INPUT_START2,
        mousemove: INPUT_MOVE2,
        mouseup: INPUT_END2
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput2() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input2.apply(this, arguments);
      }
      inherit(MouseInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP2[ev.type];
          if (eventType & INPUT_START2 && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE2 && ev.which !== 1) {
            eventType = INPUT_END2;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END2) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START2,
        pointermove: INPUT_MOVE2,
        pointerup: INPUT_END2,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window3.MSPointerEvent && !window3.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput2() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input2.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput2, Input2, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input2.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input2, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START2) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END2 | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START2,
        touchmove: INPUT_MOVE2,
        touchend: INPUT_END2,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input2.apply(this, arguments);
      }
      inherit(TouchInput, Input2, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent(touch.target, target);
        });
        if (type === INPUT_START2) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input2.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput2(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input2, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START2) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value4) {
        this.manager = manager;
        this.set(value4);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value4) {
          if (value4 == TOUCH_ACTION_COMPUTE) {
            value4 = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value4]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value4;
          }
          this.actions = value4.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window3.CSS && window3.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window3.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options) {
        this.options = assign({}, this.defaults, options || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options) {
          assign(this.options, options);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END2) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options = this.options;
          var hasMoved = true;
          var distance2 = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance2 = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance2 = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance2 > options.threshold && direction & options.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTime = input.deltaTime > options.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START2) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options.time, this);
          } else if (input.eventType & INPUT_END2) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END2) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END2;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options = this.options;
          var validPointers = input.pointers.length === options.pointers;
          var validMovement = input.distance < options.threshold;
          var validTouchTime = input.deltaTime < options.time;
          this.reset();
          if (input.eventType & INPUT_START2 && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END2) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer(element, options) {
        options = options || {};
        options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
        return new Manager3(element, options);
      }
      Hammer.VERSION = "2.0.7";
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager3(element, options) {
        this.options = assign({}, Hammer.defaults, options || {});
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager3.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options) {
          assign(this.options, options);
          if (options.touchAction) {
            this.touchAction.update();
          }
          if (options.inputTarget) {
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events, handler) {
          if (events === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add6) {
        var element = manager.element;
        if (!element.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value4, name) {
          prop = prefixed(element.style, name);
          if (add6) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value4;
          } else {
            element.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add6) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START: INPUT_START2,
        INPUT_MOVE: INPUT_MOVE2,
        INPUT_END: INPUT_END2,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager: Manager3,
        Input: Input2,
        TouchAction,
        TouchInput,
        MouseInput: MouseInput2,
        PointerEventInput: PointerEventInput2,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each,
        merge,
        extend,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window3 !== "undefined" ? window3 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
      } else {
        window3[exportName] = Hammer;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
function some(array, predict) {
  for (let i = 0; i < array.length; i++) {
    if (predict(array[i])) {
      return true;
    }
  }
  return false;
}
function enhancePointerEventInput(PointerEventInput2) {
  const oldHandler = PointerEventInput2.prototype.handler;
  PointerEventInput2.prototype.handler = function handler(ev) {
    const store = this.store;
    if (ev.button > 0 && ev.type === "pointerdown") {
      if (!some(store, (e2) => e2.pointerId === ev.pointerId)) {
        store.push(ev);
      }
    }
    oldHandler.call(this, ev);
  };
}
function enhanceMouseInput(MouseInput2) {
  MouseInput2.prototype.handler = function handler(ev) {
    let eventType = MOUSE_INPUT_MAP[ev.type];
    if (eventType & INPUT_START && ev.button >= 0) {
      this.pressed = true;
    }
    if (eventType & INPUT_MOVE && ev.which === 0) {
      eventType = INPUT_END;
    }
    if (!this.pressed) {
      return;
    }
    if (eventType & INPUT_END) {
      this.pressed = false;
    }
    this.callback(this.manager, eventType, {
      pointers: [ev],
      changedPointers: [ev],
      pointerType: "mouse",
      srcEvent: ev
    });
  };
}
var INPUT_START, INPUT_MOVE, INPUT_END, MOUSE_INPUT_MAP;
var init_hammer_overrides = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js"() {
    INPUT_START = 1;
    INPUT_MOVE = 2;
    INPUT_END = 4;
    MOUSE_INPUT_MAP = {
      mousedown: INPUT_START,
      mousemove: INPUT_MOVE,
      mouseup: INPUT_END
    };
  }
});

// node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
var hammerjs, Manager2, hammer_browser_default;
var init_hammer_browser = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js"() {
    hammerjs = __toESM(require_hammer());
    init_hammer_overrides();
    enhancePointerEventInput(hammerjs.PointerEventInput);
    enhanceMouseInput(hammerjs.MouseInput);
    Manager2 = hammerjs.Manager;
    hammer_browser_default = hammerjs;
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/input.js
var Input;
var init_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/input.js"() {
    Input = class {
      constructor(element, callback, options) {
        this.element = element;
        this.callback = callback;
        this.options = { enable: true, ...options };
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/constants.js
var RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP, BASIC_EVENT_ALIASES, INPUT_EVENT_TYPES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES;
var init_constants4 = __esm({
  "node_modules/mjolnir.js/dist/esm/constants.js"() {
    init_hammer_browser();
    RECOGNIZERS = hammer_browser_default ? [
      [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
      [hammer_browser_default.Rotate, { enable: false }],
      [hammer_browser_default.Pinch, { enable: false }],
      [hammer_browser_default.Swipe, { enable: false }],
      [hammer_browser_default.Pan, { threshold: 0, enable: false }],
      [hammer_browser_default.Press, { enable: false }],
      [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
      // TODO - rename to 'tap' and 'singletap' in the next major release
      [hammer_browser_default.Tap, { event: "anytap", enable: false }],
      [hammer_browser_default.Tap, { enable: false }]
    ] : null;
    RECOGNIZER_COMPATIBLE_MAP = {
      tripan: ["rotate", "pinch", "pan"],
      rotate: ["pinch"],
      pinch: ["pan"],
      pan: ["press", "doubletap", "anytap", "tap"],
      doubletap: ["anytap"],
      anytap: ["tap"]
    };
    RECOGNIZER_FALLBACK_MAP = {
      doubletap: ["tap"]
    };
    BASIC_EVENT_ALIASES = {
      pointerdown: "pointerdown",
      pointermove: "pointermove",
      pointerup: "pointerup",
      touchstart: "pointerdown",
      touchmove: "pointermove",
      touchend: "pointerup",
      mousedown: "pointerdown",
      mousemove: "pointermove",
      mouseup: "pointerup"
    };
    INPUT_EVENT_TYPES = {
      KEY_EVENTS: ["keydown", "keyup"],
      MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
      WHEEL_EVENTS: [
        // Chrome, Safari
        "wheel",
        // IE
        "mousewheel"
      ]
    };
    EVENT_RECOGNIZER_MAP = {
      tap: "tap",
      anytap: "anytap",
      doubletap: "doubletap",
      press: "press",
      pinch: "pinch",
      pinchin: "pinch",
      pinchout: "pinch",
      pinchstart: "pinch",
      pinchmove: "pinch",
      pinchend: "pinch",
      pinchcancel: "pinch",
      rotate: "rotate",
      rotatestart: "rotate",
      rotatemove: "rotate",
      rotateend: "rotate",
      rotatecancel: "rotate",
      tripan: "tripan",
      tripanstart: "tripan",
      tripanmove: "tripan",
      tripanup: "tripan",
      tripandown: "tripan",
      tripanleft: "tripan",
      tripanright: "tripan",
      tripanend: "tripan",
      tripancancel: "tripan",
      pan: "pan",
      panstart: "pan",
      panmove: "pan",
      panup: "pan",
      pandown: "pan",
      panleft: "pan",
      panright: "pan",
      panend: "pan",
      pancancel: "pan",
      swipe: "swipe",
      swipeleft: "swipe",
      swiperight: "swipe",
      swipeup: "swipe",
      swipedown: "swipe"
    };
    GESTURE_EVENT_ALIASES = {
      click: "tap",
      anyclick: "anytap",
      dblclick: "doubletap",
      mousedown: "pointerdown",
      mousemove: "pointermove",
      mouseup: "pointerup",
      mouseover: "pointerover",
      mouseout: "pointerout",
      mouseleave: "pointerleave"
    };
  }
});

// node_modules/mjolnir.js/dist/esm/utils/globals.js
var userAgent, window_5, passiveSupported;
var init_globals6 = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/globals.js"() {
    userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
    window_5 = typeof window !== "undefined" ? window : global;
    passiveSupported = false;
    try {
      const options = {
        // This function will be called when the browser
        // attempts to access the passive property.
        get passive() {
          passiveSupported = true;
          return true;
        }
      };
      window_5.addEventListener("test", null, options);
      window_5.removeEventListener("test", null);
    } catch (err) {
      passiveSupported = false;
    }
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
var firefox, WHEEL_EVENTS, EVENT_TYPE, WHEEL_DELTA_MAGIC_SCALER, WHEEL_DELTA_PER_LINE, SHIFT_MULTIPLIER, WheelInput;
var init_wheel_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js"() {
    init_input();
    init_constants4();
    init_globals6();
    firefox = userAgent.indexOf("firefox") !== -1;
    ({ WHEEL_EVENTS } = INPUT_EVENT_TYPES);
    EVENT_TYPE = "wheel";
    WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
    WHEEL_DELTA_PER_LINE = 40;
    SHIFT_MULTIPLIER = 0.25;
    WheelInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          if (!this.options.enable) {
            return;
          }
          let value4 = event.deltaY;
          if (window_5.WheelEvent) {
            if (firefox && event.deltaMode === window_5.WheelEvent.DOM_DELTA_PIXEL) {
              value4 /= window_5.devicePixelRatio;
            }
            if (event.deltaMode === window_5.WheelEvent.DOM_DELTA_LINE) {
              value4 *= WHEEL_DELTA_PER_LINE;
            }
          }
          if (value4 !== 0 && value4 % WHEEL_DELTA_MAGIC_SCALER === 0) {
            value4 = Math.floor(value4 / WHEEL_DELTA_MAGIC_SCALER);
          }
          if (event.shiftKey && value4) {
            value4 = value4 * SHIFT_MULTIPLIER;
          }
          this.callback({
            type: EVENT_TYPE,
            center: {
              x: event.clientX,
              y: event.clientY
            },
            delta: -value4,
            srcEvent: event,
            pointerType: "mouse",
            target: event.target
          });
        };
        this.events = (this.options.events || []).concat(WHEEL_EVENTS);
        this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
      }
      destroy() {
        this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE) {
          this.options.enable = enabled;
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/move-input.js
var MOUSE_EVENTS, MOVE_EVENT_TYPE, OVER_EVENT_TYPE, OUT_EVENT_TYPE, ENTER_EVENT_TYPE, LEAVE_EVENT_TYPE, MoveInput;
var init_move_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/move-input.js"() {
    init_input();
    init_constants4();
    ({ MOUSE_EVENTS } = INPUT_EVENT_TYPES);
    MOVE_EVENT_TYPE = "pointermove";
    OVER_EVENT_TYPE = "pointerover";
    OUT_EVENT_TYPE = "pointerout";
    ENTER_EVENT_TYPE = "pointerenter";
    LEAVE_EVENT_TYPE = "pointerleave";
    MoveInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          this.handleOverEvent(event);
          this.handleOutEvent(event);
          this.handleEnterEvent(event);
          this.handleLeaveEvent(event);
          this.handleMoveEvent(event);
        };
        this.pressed = false;
        const { enable: enable2 } = this.options;
        this.enableMoveEvent = enable2;
        this.enableLeaveEvent = enable2;
        this.enableEnterEvent = enable2;
        this.enableOutEvent = enable2;
        this.enableOverEvent = enable2;
        this.events = (this.options.events || []).concat(MOUSE_EVENTS);
        this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
      }
      destroy() {
        this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === MOVE_EVENT_TYPE) {
          this.enableMoveEvent = enabled;
        }
        if (eventType === OVER_EVENT_TYPE) {
          this.enableOverEvent = enabled;
        }
        if (eventType === OUT_EVENT_TYPE) {
          this.enableOutEvent = enabled;
        }
        if (eventType === ENTER_EVENT_TYPE) {
          this.enableEnterEvent = enabled;
        }
        if (eventType === LEAVE_EVENT_TYPE) {
          this.enableLeaveEvent = enabled;
        }
      }
      handleOverEvent(event) {
        if (this.enableOverEvent) {
          if (event.type === "mouseover") {
            this._emit(OVER_EVENT_TYPE, event);
          }
        }
      }
      handleOutEvent(event) {
        if (this.enableOutEvent) {
          if (event.type === "mouseout") {
            this._emit(OUT_EVENT_TYPE, event);
          }
        }
      }
      handleEnterEvent(event) {
        if (this.enableEnterEvent) {
          if (event.type === "mouseenter") {
            this._emit(ENTER_EVENT_TYPE, event);
          }
        }
      }
      handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
          if (event.type === "mouseleave") {
            this._emit(LEAVE_EVENT_TYPE, event);
          }
        }
      }
      handleMoveEvent(event) {
        if (this.enableMoveEvent) {
          switch (event.type) {
            case "mousedown":
              if (event.button >= 0) {
                this.pressed = true;
              }
              break;
            case "mousemove":
              if (event.which === 0) {
                this.pressed = false;
              }
              if (!this.pressed) {
                this._emit(MOVE_EVENT_TYPE, event);
              }
              break;
            case "mouseup":
              this.pressed = false;
              break;
            default:
          }
        }
      }
      _emit(type, event) {
        this.callback({
          type,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/key-input.js
var KEY_EVENTS, DOWN_EVENT_TYPE, UP_EVENT_TYPE, KeyInput;
var init_key_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/key-input.js"() {
    init_input();
    init_constants4();
    ({ KEY_EVENTS } = INPUT_EVENT_TYPES);
    DOWN_EVENT_TYPE = "keydown";
    UP_EVENT_TYPE = "keyup";
    KeyInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          const targetElement = event.target || event.srcElement;
          if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
            return;
          }
          if (this.enableDownEvent && event.type === "keydown") {
            this.callback({
              type: DOWN_EVENT_TYPE,
              srcEvent: event,
              key: event.key,
              target: event.target
            });
          }
          if (this.enableUpEvent && event.type === "keyup") {
            this.callback({
              type: UP_EVENT_TYPE,
              srcEvent: event,
              key: event.key,
              target: event.target
            });
          }
        };
        this.enableDownEvent = this.options.enable;
        this.enableUpEvent = this.options.enable;
        this.events = (this.options.events || []).concat(KEY_EVENTS);
        element.tabIndex = this.options.tabIndex || 0;
        element.style.outline = "none";
        this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
      }
      destroy() {
        this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === DOWN_EVENT_TYPE) {
          this.enableDownEvent = enabled;
        }
        if (eventType === UP_EVENT_TYPE) {
          this.enableUpEvent = enabled;
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
var EVENT_TYPE2, ContextmenuInput;
var init_contextmenu_input = __esm({
  "node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js"() {
    init_input();
    EVENT_TYPE2 = "contextmenu";
    ContextmenuInput = class extends Input {
      constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
          if (!this.options.enable) {
            return;
          }
          this.callback({
            type: EVENT_TYPE2,
            center: {
              x: event.clientX,
              y: event.clientY
            },
            srcEvent: event,
            pointerType: "mouse",
            target: event.target
          });
        };
        element.addEventListener("contextmenu", this.handleEvent);
      }
      destroy() {
        this.element.removeEventListener("contextmenu", this.handleEvent);
      }
      /**
       * Enable this input (begin processing events)
       * if the specified event type is among those handled by this input.
       */
      enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE2) {
          this.options.enable = enabled;
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/utils/event-utils.js
function whichButtons(event) {
  const eventType = MOUSE_EVENTS2[event.srcEvent.type];
  if (!eventType) {
    return null;
  }
  const { buttons, button, which } = event.srcEvent;
  let leftButton = false;
  let middleButton = false;
  let rightButton = false;
  if (
    // button is up, need to find out which one was pressed before
    eventType === UP_EVENT || // moving but does not support `buttons` API
    eventType === MOVE_EVENT && !Number.isFinite(buttons)
  ) {
    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
  } else if (eventType === MOVE_EVENT) {
    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
  } else if (eventType === DOWN_EVENT) {
    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
  }
  return { leftButton, middleButton, rightButton };
}
function getOffsetPosition(event, rootElement) {
  const center = event.center;
  if (!center) {
    return null;
  }
  const rect = rootElement.getBoundingClientRect();
  const scaleX2 = rect.width / rootElement.offsetWidth || 1;
  const scaleY2 = rect.height / rootElement.offsetHeight || 1;
  const offsetCenter = {
    x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
    y: (center.y - rect.top - rootElement.clientTop) / scaleY2
  };
  return { center, offsetCenter };
}
var DOWN_EVENT, MOVE_EVENT, UP_EVENT, MOUSE_EVENTS2, MOUSE_EVENT_WHICH_LEFT, MOUSE_EVENT_WHICH_MIDDLE, MOUSE_EVENT_WHICH_RIGHT, MOUSE_EVENT_BUTTON_LEFT, MOUSE_EVENT_BUTTON_MIDDLE, MOUSE_EVENT_BUTTON_RIGHT, MOUSE_EVENT_BUTTONS_LEFT_MASK, MOUSE_EVENT_BUTTONS_RIGHT_MASK, MOUSE_EVENT_BUTTONS_MIDDLE_MASK;
var init_event_utils = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/event-utils.js"() {
    DOWN_EVENT = 1;
    MOVE_EVENT = 2;
    UP_EVENT = 4;
    MOUSE_EVENTS2 = {
      pointerdown: DOWN_EVENT,
      pointermove: MOVE_EVENT,
      pointerup: UP_EVENT,
      mousedown: DOWN_EVENT,
      mousemove: MOVE_EVENT,
      mouseup: UP_EVENT
    };
    MOUSE_EVENT_WHICH_LEFT = 1;
    MOUSE_EVENT_WHICH_MIDDLE = 2;
    MOUSE_EVENT_WHICH_RIGHT = 3;
    MOUSE_EVENT_BUTTON_LEFT = 0;
    MOUSE_EVENT_BUTTON_MIDDLE = 1;
    MOUSE_EVENT_BUTTON_RIGHT = 2;
    MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
    MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
    MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  }
});

// node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
var DEFAULT_OPTIONS2, EventRegistrar;
var init_event_registrar = __esm({
  "node_modules/mjolnir.js/dist/esm/utils/event-registrar.js"() {
    init_event_utils();
    DEFAULT_OPTIONS2 = {
      srcElement: "root",
      priority: 0
    };
    EventRegistrar = class {
      constructor(eventManager) {
        this.handleEvent = (event) => {
          if (this.isEmpty()) {
            return;
          }
          const mjolnirEvent = this._normalizeEvent(event);
          let target = event.srcEvent.target;
          while (target && target !== mjolnirEvent.rootElement) {
            this._emit(mjolnirEvent, target);
            if (mjolnirEvent.handled) {
              return;
            }
            target = target.parentNode;
          }
          this._emit(mjolnirEvent, "root");
        };
        this.eventManager = eventManager;
        this.handlers = [];
        this.handlersByElement = /* @__PURE__ */ new Map();
        this._active = false;
      }
      // Returns true if there are no non-passive handlers
      isEmpty() {
        return !this._active;
      }
      add(type, handler, options, once = false, passive = false) {
        const { handlers, handlersByElement } = this;
        let opts = DEFAULT_OPTIONS2;
        if (typeof options === "string" || options && options.addEventListener) {
          opts = { ...DEFAULT_OPTIONS2, srcElement: options };
        } else if (options) {
          opts = { ...DEFAULT_OPTIONS2, ...options };
        }
        let entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
          entries = [];
          handlersByElement.set(opts.srcElement, entries);
        }
        const entry = {
          type,
          handler,
          srcElement: opts.srcElement,
          priority: opts.priority
        };
        if (once) {
          entry.once = true;
        }
        if (passive) {
          entry.passive = true;
        }
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        let insertPosition = entries.length - 1;
        while (insertPosition >= 0) {
          if (entries[insertPosition].priority >= entry.priority) {
            break;
          }
          insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
      }
      remove(type, handler) {
        const { handlers, handlersByElement } = this;
        for (let i = handlers.length - 1; i >= 0; i--) {
          const entry = handlers[i];
          if (entry.type === type && entry.handler === handler) {
            handlers.splice(i, 1);
            const entries = handlersByElement.get(entry.srcElement);
            entries.splice(entries.indexOf(entry), 1);
            if (entries.length === 0) {
              handlersByElement.delete(entry.srcElement);
            }
          }
        }
        this._active = handlers.some((entry) => !entry.passive);
      }
      /**
       * Invoke handlers on a particular element
       */
      _emit(event, srcElement) {
        const entries = this.handlersByElement.get(srcElement);
        if (entries) {
          let immediatePropagationStopped = false;
          const stopPropagation = () => {
            event.handled = true;
          };
          const stopImmediatePropagation = () => {
            event.handled = true;
            immediatePropagationStopped = true;
          };
          const entriesToRemove = [];
          for (let i = 0; i < entries.length; i++) {
            const { type, handler, once } = entries[i];
            handler({
              ...event,
              // @ts-ignore
              type,
              stopPropagation,
              stopImmediatePropagation
            });
            if (once) {
              entriesToRemove.push(entries[i]);
            }
            if (immediatePropagationStopped) {
              break;
            }
          }
          for (let i = 0; i < entriesToRemove.length; i++) {
            const { type, handler } = entriesToRemove[i];
            this.remove(type, handler);
          }
        }
      }
      /**
       * Normalizes hammerjs and custom events to have predictable fields.
       */
      _normalizeEvent(event) {
        const rootElement = this.eventManager.getElement();
        return {
          ...event,
          ...whichButtons(event),
          ...getOffsetPosition(event, rootElement),
          preventDefault: () => {
            event.srcEvent.preventDefault();
          },
          stopImmediatePropagation: null,
          stopPropagation: null,
          handled: false,
          rootElement
        };
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/event-manager.js
var DEFAULT_OPTIONS3, EventManager;
var init_event_manager = __esm({
  "node_modules/mjolnir.js/dist/esm/event-manager.js"() {
    init_hammer_browser();
    init_wheel_input();
    init_move_input();
    init_key_input();
    init_contextmenu_input();
    init_event_registrar();
    init_constants4();
    DEFAULT_OPTIONS3 = {
      // event handlers
      events: null,
      // custom recognizers
      recognizers: null,
      recognizerOptions: {},
      // Manager class
      Manager: Manager2,
      // allow browser default touch action
      // https://github.com/uber/react-map-gl/issues/506
      touchAction: "none",
      tabIndex: 0
    };
    EventManager = class {
      constructor(element = null, options) {
        this._onBasicInput = (event) => {
          const { srcEvent } = event;
          const alias = BASIC_EVENT_ALIASES[srcEvent.type];
          if (alias) {
            this.manager.emit(alias, event);
          }
        };
        this._onOtherEvent = (event) => {
          this.manager.emit(event.type, event);
        };
        this.options = { ...DEFAULT_OPTIONS3, ...options };
        this.events = /* @__PURE__ */ new Map();
        this.setElement(element);
        const { events } = this.options;
        if (events) {
          this.on(events);
        }
      }
      getElement() {
        return this.element;
      }
      setElement(element) {
        if (this.element) {
          this.destroy();
        }
        this.element = element;
        if (!element) {
          return;
        }
        const { options } = this;
        const ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
          touchAction: options.touchAction,
          recognizers: options.recognizers || RECOGNIZERS
        }).on("hammer.input", this._onBasicInput);
        if (!options.recognizers) {
          Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name) => {
            const recognizer = this.manager.get(name);
            if (recognizer) {
              RECOGNIZER_COMPATIBLE_MAP[name].forEach((otherName) => {
                recognizer.recognizeWith(otherName);
              });
            }
          });
        }
        for (const recognizerName in options.recognizerOptions) {
          const recognizer = this.manager.get(recognizerName);
          if (recognizer) {
            const recognizerOption = options.recognizerOptions[recognizerName];
            delete recognizerOption.enable;
            recognizer.set(recognizerOption);
          }
        }
        this.wheelInput = new WheelInput(element, this._onOtherEvent, {
          enable: false
        });
        this.moveInput = new MoveInput(element, this._onOtherEvent, {
          enable: false
        });
        this.keyInput = new KeyInput(element, this._onOtherEvent, {
          enable: false,
          tabIndex: options.tabIndex
        });
        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
          enable: false
        });
        for (const [eventAlias, eventRegistrar] of this.events) {
          if (!eventRegistrar.isEmpty()) {
            this._toggleRecognizer(eventRegistrar.recognizerName, true);
            this.manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
      }
      // Tear down internal event management implementations.
      destroy() {
        if (this.element) {
          this.wheelInput.destroy();
          this.moveInput.destroy();
          this.keyInput.destroy();
          this.contextmenuInput.destroy();
          this.manager.destroy();
          this.wheelInput = null;
          this.moveInput = null;
          this.keyInput = null;
          this.contextmenuInput = null;
          this.manager = null;
          this.element = null;
        }
      }
      /** Register an event handler function to be called on `event` */
      on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
      }
      once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
      }
      watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
      }
      off(event, handler) {
        this._removeEventHandler(event, handler);
      }
      /*
       * Enable/disable recognizer for the given event
       */
      _toggleRecognizer(name, enabled) {
        const { manager } = this;
        if (!manager) {
          return;
        }
        const recognizer = manager.get(name);
        if (recognizer && recognizer.options.enable !== enabled) {
          recognizer.set({ enable: enabled });
          const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
          if (fallbackRecognizers && !this.options.recognizers) {
            fallbackRecognizers.forEach((otherName) => {
              const otherRecognizer = manager.get(otherName);
              if (enabled) {
                otherRecognizer.requireFailure(name);
                recognizer.dropRequireFailure(otherName);
              } else {
                otherRecognizer.dropRequireFailure(name);
              }
            });
          }
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
      }
      /**
       * Process the event registration for a single event + handler.
       */
      _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== "string") {
          opts = handler;
          for (const eventName in event) {
            this._addEventHandler(eventName, event[eventName], opts, once, passive);
          }
          return;
        }
        const { manager, events } = this;
        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        let eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
          eventRegistrar = new EventRegistrar(this);
          events.set(eventAlias, eventRegistrar);
          eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
          if (manager) {
            manager.on(eventAlias, eventRegistrar.handleEvent);
          }
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
        }
      }
      /**
       * Process the event deregistration for a single event + handler.
       */
      _removeEventHandler(event, handler) {
        if (typeof event !== "string") {
          for (const eventName in event) {
            this._removeEventHandler(eventName, event[eventName]);
          }
          return;
        }
        const { events } = this;
        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        const eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
          return;
        }
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
          const { recognizerName } = eventRegistrar;
          let isRecognizerUsed = false;
          for (const eh of events.values()) {
            if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
              isRecognizerUsed = true;
              break;
            }
          }
          if (!isRecognizerUsed) {
            this._toggleRecognizer(recognizerName, false);
          }
        }
      }
    };
  }
});

// node_modules/mjolnir.js/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  EventManager: () => EventManager
});
var init_esm17 = __esm({
  "node_modules/mjolnir.js/dist/esm/index.js"() {
    init_event_manager();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/deck.js
function ownKeys23(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread23(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys23(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys23(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function noop5() {
}
function getPropTypes2(PropTypes) {
  return {
    id: PropTypes.string,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    layerFilter: PropTypes.func,
    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    viewState: PropTypes.object,
    effects: PropTypes.arrayOf(PropTypes.instanceOf(Effect)),
    controller: PropTypes.oneOfType([PropTypes.func, PropTypes.bool, PropTypes.object]),
    gl: PropTypes.object,
    glOptions: PropTypes.object,
    parameters: PropTypes.object,
    pickingRadius: PropTypes.number,
    useDevicePixels: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),
    touchAction: PropTypes.string,
    onWebGLInitialized: PropTypes.func,
    onResize: PropTypes.func,
    onViewStateChange: PropTypes.func,
    onBeforeRender: PropTypes.func,
    onAfterRender: PropTypes.func,
    onLoad: PropTypes.func,
    onError: PropTypes.func,
    debug: PropTypes.bool,
    drawPickingColors: PropTypes.bool,
    _framebuffer: PropTypes.object,
    _animate: PropTypes.bool
  };
}
var import_env15, getCursor, defaultProps3, Deck;
var init_deck = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/deck.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_layer_manager();
    init_view_manager();
    init_map_view();
    init_effect_manager();
    init_effect();
    init_deck_renderer();
    init_deck_picker();
    init_tooltip();
    init_log2();
    init_deep_equal();
    init_init3();
    import_env15 = __toESM(require_env());
    init_esm14();
    init_esm8();
    init_esm17();
    init_assert10();
    init_constants2();
    getCursor = function getCursor2(_ref) {
      var isDragging = _ref.isDragging;
      return isDragging ? "grabbing" : "grab";
    };
    defaultProps3 = {
      id: "deckgl-overlay",
      width: "100%",
      height: "100%",
      pickingRadius: 0,
      layerFilter: null,
      glOptions: {},
      gl: null,
      layers: [],
      effects: [],
      views: null,
      controller: null,
      useDevicePixels: true,
      touchAction: "none",
      _framebuffer: null,
      _animate: false,
      onWebGLInitialized: noop5,
      onResize: noop5,
      onViewStateChange: noop5,
      onBeforeRender: noop5,
      onAfterRender: noop5,
      onLoad: noop5,
      onError: null,
      _onMetrics: null,
      getCursor,
      debug: false,
      drawPickingColors: false
    };
    Deck = function() {
      function Deck2(props) {
        _classCallCheck(this, Deck2);
        props = Object.assign({}, defaultProps3, props);
        this.props = {};
        this.width = 0;
        this.height = 0;
        this.viewManager = null;
        this.layerManager = null;
        this.effectManager = null;
        this.deckRenderer = null;
        this.deckPicker = null;
        this._needsRedraw = true;
        this._pickRequest = {};
        this._lastPointerDownInfo = null;
        this.viewState = null;
        this.interactiveState = {
          isDragging: false
        };
        this._onEvent = this._onEvent.bind(this);
        this._onPointerDown = this._onPointerDown.bind(this);
        this._onPointerMove = this._onPointerMove.bind(this);
        this._pickAndCallback = this._pickAndCallback.bind(this);
        this._onRendererInitialized = this._onRendererInitialized.bind(this);
        this._onRenderFrame = this._onRenderFrame.bind(this);
        this._onViewStateChange = this._onViewStateChange.bind(this);
        this._onInteractiveStateChange = this._onInteractiveStateChange.bind(this);
        if (props.viewState && props.initialViewState) {
          log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
        }
        if ((0, import_env15.getBrowser)() === "IE") {
          log_default.warn("IE 11 support will be deprecated in v8.0")();
        }
        if (!props.gl) {
          if (typeof document !== "undefined") {
            this.canvas = this._createCanvas(props);
          }
        }
        this.animationLoop = this._createAnimationLoop(props);
        this.stats = new Stats({
          id: "deck.gl"
        });
        this.metrics = {
          fps: 0,
          setPropsTime: 0,
          updateAttributesTime: 0,
          framesRedrawn: 0,
          pickTime: 0,
          pickCount: 0,
          gpuTime: 0,
          gpuTimePerFrame: 0,
          cpuTime: 0,
          cpuTimePerFrame: 0,
          bufferMemory: 0,
          textureMemory: 0,
          renderbufferMemory: 0,
          gpuMemory: 0
        };
        this._metricsCounter = 0;
        this.setProps(props);
        this.animationLoop.start();
      }
      _createClass(Deck2, [{
        key: "finalize",
        value: function finalize() {
          this.animationLoop.stop();
          this.animationLoop = null;
          this._lastPointerDownInfo = null;
          if (this.layerManager) {
            this.layerManager.finalize();
            this.layerManager = null;
            this.viewManager.finalize();
            this.viewManager = null;
            this.effectManager.finalize();
            this.effectManager = null;
            this.deckRenderer.finalize();
            this.deckRenderer = null;
            this.deckPicker.finalize();
            this.deckPicker = null;
            this.eventManager.destroy();
            this.eventManager = null;
            this.tooltip.remove();
            this.tooltip = null;
          }
          if (!this.props.canvas && !this.props.gl && this.canvas) {
            this.canvas.parentElement.removeChild(this.canvas);
            this.canvas = null;
          }
        }
      }, {
        key: "setProps",
        value: function setProps(props) {
          this.stats.get("setProps Time").timeStart();
          if ("onLayerHover" in props) {
            log_default.removed("onLayerHover", "onHover")();
          }
          if ("onLayerClick" in props) {
            log_default.removed("onLayerClick", "onClick")();
          }
          if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState)) {
            this.viewState = props.initialViewState;
          }
          Object.assign(this.props, props);
          this._setCanvasSize(this.props);
          var resolvedProps = Object.create(this.props);
          Object.assign(resolvedProps, {
            views: this._getViews(),
            width: this.width,
            height: this.height,
            viewState: this._getViewState()
          });
          this.animationLoop.setProps(resolvedProps);
          if (this.layerManager) {
            this.viewManager.setProps(resolvedProps);
            this.layerManager.activateViewport(this.getViewports()[0]);
            this.layerManager.setProps(resolvedProps);
            this.effectManager.setProps(resolvedProps);
            this.deckRenderer.setProps(resolvedProps);
            this.deckPicker.setProps(resolvedProps);
          }
          this.stats.get("setProps Time").timeEnd();
        }
      }, {
        key: "needsRedraw",
        value: function needsRedraw() {
          var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            clearRedrawFlags: false
          };
          if (this.props._animate) {
            return "Deck._animate";
          }
          var redraw = this._needsRedraw;
          if (opts.clearRedrawFlags) {
            this._needsRedraw = false;
          }
          var viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
          var layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
          var effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
          var deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
          redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
          return redraw;
        }
      }, {
        key: "redraw",
        value: function redraw(force) {
          if (!this.layerManager) {
            return;
          }
          var redrawReason = force || this.needsRedraw({
            clearRedrawFlags: true
          });
          if (!redrawReason) {
            return;
          }
          this.stats.get("Redraw Count").incrementCount();
          if (this.props._customRender) {
            this.props._customRender(redrawReason);
          } else {
            this._drawLayers(redrawReason);
          }
        }
      }, {
        key: "getViews",
        value: function getViews() {
          return this.viewManager.views;
        }
      }, {
        key: "getViewports",
        value: function getViewports(rect) {
          return this.viewManager.getViewports(rect);
        }
      }, {
        key: "pickObject",
        value: function pickObject(opts) {
          var infos = this._pick("pickObject", "pickObject Time", opts).result;
          return infos.length ? infos[0] : null;
        }
      }, {
        key: "pickMultipleObjects",
        value: function pickMultipleObjects(opts) {
          opts.depth = opts.depth || 10;
          return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
        }
      }, {
        key: "pickObjects",
        value: function pickObjects(opts) {
          return this._pick("pickObjects", "pickObjects Time", opts);
        }
      }, {
        key: "_addResources",
        value: function _addResources(resources) {
          var forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          for (var id in resources) {
            this.layerManager.resourceManager.add({
              resourceId: id,
              data: resources[id],
              forceUpdate
            });
          }
        }
      }, {
        key: "_removeResources",
        value: function _removeResources(resourceIds) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = resourceIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var id = _step.value;
              this.layerManager.resourceManager.remove(id);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }, {
        key: "_pick",
        value: function _pick(method, statKey, opts) {
          var stats = this.stats;
          stats.get("Pick Count").incrementCount();
          stats.get(statKey).timeStart();
          var infos = this.deckPicker[method](Object.assign({
            layers: this.layerManager.getLayers(opts),
            viewports: this.getViewports(opts),
            onViewportActive: this.layerManager.activateViewport
          }, opts));
          stats.get(statKey).timeEnd();
          return infos;
        }
      }, {
        key: "_createCanvas",
        value: function _createCanvas(props) {
          var canvas = props.canvas;
          if (typeof canvas === "string") {
            canvas = document.getElementById(canvas);
            assert10(canvas);
          }
          if (!canvas) {
            canvas = document.createElement("canvas");
            var parent = props.parent || document.body;
            parent.appendChild(canvas);
          }
          var id = props.id, style = props.style;
          canvas.id = id;
          Object.assign(canvas.style, style);
          return canvas;
        }
      }, {
        key: "_setCanvasSize",
        value: function _setCanvasSize(props) {
          if (!this.canvas) {
            return;
          }
          var width = props.width, height = props.height;
          if (width || width === 0) {
            width = Number.isFinite(width) ? "".concat(width, "px") : width;
            this.canvas.style.width = width;
          }
          if (height || height === 0) {
            height = Number.isFinite(height) ? "".concat(height, "px") : height;
            this.canvas.style.position = "absolute";
            this.canvas.style.height = height;
          }
        }
      }, {
        key: "_updateCanvasSize",
        value: function _updateCanvasSize() {
          if (this._checkForCanvasSizeChange()) {
            var width = this.width, height = this.height;
            this.viewManager.setProps({
              width,
              height
            });
            this.props.onResize({
              width: this.width,
              height: this.height
            });
          }
        }
      }, {
        key: "_checkForCanvasSizeChange",
        value: function _checkForCanvasSizeChange() {
          var canvas = this.canvas;
          if (!canvas) {
            return false;
          }
          var newWidth = canvas.clientWidth || canvas.width;
          var newHeight = canvas.clientHeight || canvas.height;
          if (newWidth !== this.width || newHeight !== this.height) {
            this.width = newWidth;
            this.height = newHeight;
            return true;
          }
          return false;
        }
      }, {
        key: "_createAnimationLoop",
        value: function _createAnimationLoop(props) {
          var _this = this;
          var width = props.width, height = props.height, gl = props.gl, glOptions = props.glOptions, debug2 = props.debug, useDevicePixels = props.useDevicePixels, autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
          return new AnimationLoop({
            width,
            height,
            useDevicePixels,
            autoResizeDrawingBuffer,
            autoResizeViewport: false,
            gl,
            onCreateContext: function onCreateContext(opts) {
              return createGLContext(Object.assign({}, glOptions, opts, {
                canvas: _this.canvas,
                debug: debug2
              }));
            },
            onInitialize: this._onRendererInitialized,
            onRender: this._onRenderFrame,
            onBeforeRender: props.onBeforeRender,
            onAfterRender: props.onAfterRender
          });
        }
      }, {
        key: "_getViewState",
        value: function _getViewState() {
          return this.props.viewState || this.viewState;
        }
      }, {
        key: "_getViews",
        value: function _getViews() {
          var views = this.props.views || [new MapView({
            id: "default-view"
          })];
          views = Array.isArray(views) ? views : [views];
          if (views.length && this.props.controller) {
            views[0].props.controller = this.props.controller;
          }
          return views;
        }
      }, {
        key: "_onPointerMove",
        value: function _onPointerMove(event) {
          var _pickRequest = this._pickRequest;
          if (event.type === "pointerleave") {
            _pickRequest.x = -1;
            _pickRequest.y = -1;
            _pickRequest.radius = 0;
          } else if (event.leftButton || event.rightButton) {
            return;
          } else {
            var pos = event.offsetCenter;
            if (!pos) {
              return;
            }
            _pickRequest.x = pos.x;
            _pickRequest.y = pos.y;
            _pickRequest.radius = this.props.pickingRadius;
          }
          if (this.layerManager) {
            this.layerManager.context.mousePosition = {
              x: _pickRequest.x,
              y: _pickRequest.y
            };
          }
          _pickRequest.event = event;
          _pickRequest.mode = "hover";
        }
      }, {
        key: "_pickAndCallback",
        value: function _pickAndCallback() {
          var _pickRequest = this._pickRequest;
          if (_pickRequest.event) {
            var _this$_pick = this._pick("pickObject", "pickObject Time", _pickRequest), result = _this$_pick.result, emptyInfo = _this$_pick.emptyInfo;
            var pickedInfo = emptyInfo;
            var handled = false;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = result[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var info = _step2.value;
                pickedInfo = info;
                handled = info.layer.onHover(info, _pickRequest.event);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            if (!handled && this.props.onHover) {
              this.props.onHover(pickedInfo, _pickRequest.event);
            }
            if (this.props.getTooltip) {
              var displayInfo = this.props.getTooltip(pickedInfo);
              this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
            }
            _pickRequest.event = null;
          }
        }
      }, {
        key: "_updateCursor",
        value: function _updateCursor() {
          var container = this.props.parent || this.canvas;
          if (container) {
            container.style.cursor = this.props.getCursor(this.interactiveState);
          }
        }
      }, {
        key: "_setGLContext",
        value: function _setGLContext(gl) {
          if (this.layerManager) {
            return;
          }
          if (!this.canvas) {
            this.canvas = gl.canvas;
            instrumentGLContext(gl, {
              enable: true,
              copyState: true
            });
          }
          this.tooltip = new Tooltip(this.canvas);
          setParameters(gl, {
            blend: true,
            blendFunc: [770, 771, 1, 771],
            polygonOffsetFill: true,
            depthTest: true,
            depthFunc: 515
          });
          this.props.onWebGLInitialized(gl);
          var timeline = new Timeline();
          timeline.play();
          this.animationLoop.attachTimeline(timeline);
          this.eventManager = new EventManager(this.props.parent || gl.canvas, {
            touchAction: this.props.touchAction,
            events: {
              pointerdown: this._onPointerDown,
              pointermove: this._onPointerMove,
              pointerleave: this._onPointerMove
            }
          });
          for (var eventType in EVENTS) {
            this.eventManager.on(eventType, this._onEvent);
          }
          this.viewManager = new ViewManager({
            timeline,
            eventManager: this.eventManager,
            onViewStateChange: this._onViewStateChange,
            onInteractiveStateChange: this._onInteractiveStateChange,
            views: this._getViews(),
            viewState: this._getViewState(),
            width: this.width,
            height: this.height
          });
          var viewport = this.viewManager.getViewports()[0];
          this.layerManager = new LayerManager(gl, {
            deck: this,
            stats: this.stats,
            viewport,
            timeline
          });
          this.effectManager = new EffectManager();
          this.deckRenderer = new DeckRenderer(gl);
          this.deckPicker = new DeckPicker(gl);
          this.setProps(this.props);
          this._updateCanvasSize();
          this.props.onLoad();
        }
      }, {
        key: "_drawLayers",
        value: function _drawLayers(redrawReason, renderOptions) {
          var gl = this.layerManager.context.gl;
          setParameters(gl, this.props.parameters);
          this.props.onBeforeRender({
            gl
          });
          this.deckRenderer.renderLayers(Object.assign({
            target: this.props._framebuffer,
            layers: this.layerManager.getLayers(),
            viewports: this.viewManager.getViewports(),
            onViewportActive: this.layerManager.activateViewport,
            views: this.viewManager.getViews(),
            pass: "screen",
            redrawReason,
            effects: this.effectManager.getEffects()
          }, renderOptions));
          this.props.onAfterRender({
            gl
          });
        }
      }, {
        key: "_onRendererInitialized",
        value: function _onRendererInitialized(_ref2) {
          var gl = _ref2.gl;
          this._setGLContext(gl);
        }
      }, {
        key: "_onRenderFrame",
        value: function _onRenderFrame(animationProps) {
          this._getFrameStats();
          if (this._metricsCounter++ % 60 === 0) {
            this._getMetrics();
            this.stats.reset();
            log_default.table(4, this.metrics)();
            if (this.props._onMetrics) {
              this.props._onMetrics(this.metrics);
            }
          }
          this._updateCanvasSize();
          this._updateCursor();
          this.layerManager.updateLayers();
          this._pickAndCallback();
          this.redraw(false);
          if (this.viewManager) {
            this.viewManager.updateViewStates();
          }
        }
      }, {
        key: "_onViewStateChange",
        value: function _onViewStateChange(params) {
          var viewState = this.props.onViewStateChange(params) || params.viewState;
          if (this.viewState) {
            this.viewState = _objectSpread23({}, this.viewState, _defineProperty({}, params.viewId, viewState));
            if (!this.props.viewState) {
              this.viewManager.setProps({
                viewState: this.viewState
              });
            }
          }
        }
      }, {
        key: "_onInteractiveStateChange",
        value: function _onInteractiveStateChange(_ref3) {
          var _ref3$isDragging = _ref3.isDragging, isDragging = _ref3$isDragging === void 0 ? false : _ref3$isDragging;
          if (isDragging !== this.interactiveState.isDragging) {
            this.interactiveState.isDragging = isDragging;
          }
        }
      }, {
        key: "_onEvent",
        value: function _onEvent(event) {
          var eventOptions = EVENTS[event.type];
          var pos = event.offsetCenter;
          if (!eventOptions || !pos) {
            return;
          }
          var layers = this.layerManager.getLayers();
          var info = this.deckPicker.getLastPickedObject({
            x: pos.x,
            y: pos.y,
            layers,
            viewports: this.getViewports(pos)
          }, this._lastPointerDownInfo);
          var layer = info.layer;
          var layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
          var rootHandler = this.props[eventOptions.handler];
          var handled = false;
          if (layerHandler) {
            handled = layerHandler.call(layer, info, event);
          }
          if (!handled && rootHandler) {
            rootHandler(info, event);
          }
        }
      }, {
        key: "_onPointerDown",
        value: function _onPointerDown(event) {
          var pos = event.offsetCenter;
          this._lastPointerDownInfo = this.pickObject({
            x: pos.x,
            y: pos.y,
            radius: this.props.pickingRadius
          });
        }
      }, {
        key: "_getFrameStats",
        value: function _getFrameStats() {
          var stats = this.stats;
          stats.get("frameRate").timeEnd();
          stats.get("frameRate").timeStart();
          var animationLoopStats = this.animationLoop.stats;
          stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
          stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
        }
      }, {
        key: "_getMetrics",
        value: function _getMetrics() {
          var metrics = this.metrics, stats = this.stats;
          metrics.fps = stats.get("frameRate").getHz();
          metrics.setPropsTime = stats.get("setProps Time").time;
          metrics.updateAttributesTime = stats.get("Update Attributes").time;
          metrics.framesRedrawn = stats.get("Redraw Count").count;
          metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
          metrics.pickCount = stats.get("Pick Count").count;
          metrics.gpuTime = stats.get("GPU Time").time;
          metrics.cpuTime = stats.get("CPU Time").time;
          metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
          metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
          var memoryStats = lumaStats.get("Memory Usage");
          metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
          metrics.textureMemory = memoryStats.get("Texture Memory").count;
          metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
          metrics.gpuMemory = memoryStats.get("GPU Memory").count;
        }
      }]);
      return Deck2;
    }();
    Deck.getPropTypes = getPropTypes2;
    Deck.defaultProps = defaultProps3;
    Deck.VERSION = init_default2.VERSION;
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js
var TRACE_RENDER_LAYERS2, CompositeLayer;
var init_composite_layer = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_layer();
    init_debug();
    init_flatten();
    TRACE_RENDER_LAYERS2 = "compositeLayer.renderLayers";
    CompositeLayer = function(_Layer) {
      _inherits(CompositeLayer2, _Layer);
      function CompositeLayer2() {
        _classCallCheck(this, CompositeLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(CompositeLayer2).apply(this, arguments));
      }
      _createClass(CompositeLayer2, [{
        key: "getSubLayers",
        value: function getSubLayers() {
          return this.internalState && this.internalState.subLayers || [];
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
        }
      }, {
        key: "setState",
        value: function setState(updateObject) {
          _get(_getPrototypeOf(CompositeLayer2.prototype), "setState", this).call(this, updateObject);
          this.setNeedsUpdate();
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref) {
          var info = _ref.info;
          var object = info.object;
          var isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;
          if (!isDataWrapped) {
            return info;
          }
          return Object.assign(info, {
            object: object.__source.object,
            index: object.__source.index
          });
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          return null;
        }
      }, {
        key: "shouldRenderSubLayer",
        value: function shouldRenderSubLayer(id, data) {
          var overridingProps = this.props._subLayerProps;
          return data && data.length || overridingProps && overridingProps[id];
        }
      }, {
        key: "getSubLayerClass",
        value: function getSubLayerClass(id, DefaultLayerClass) {
          var overridingProps = this.props._subLayerProps;
          return overridingProps && overridingProps[id] && overridingProps[id].type || DefaultLayerClass;
        }
      }, {
        key: "getSubLayerRow",
        value: function getSubLayerRow(row, sourceObject, sourceObjectIndex) {
          row.__source = {
            parent: this,
            object: sourceObject,
            index: sourceObjectIndex
          };
          return row;
        }
      }, {
        key: "getSubLayerAccessor",
        value: function getSubLayerAccessor(accessor) {
          if (typeof accessor === "function") {
            var objectInfo = {
              data: this.props.data,
              target: []
            };
            return function(x, i) {
              if (x.__source) {
                objectInfo.index = x.__source.index;
                return accessor(x.__source.object, objectInfo);
              }
              return accessor(x, i);
            };
          }
          return accessor;
        }
      }, {
        key: "getSubLayerProps",
        value: function getSubLayerProps() {
          var sublayerProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _this$props = this.props, opacity = _this$props.opacity, pickable = _this$props.pickable, visible = _this$props.visible, parameters = _this$props.parameters, getPolygonOffset = _this$props.getPolygonOffset, highlightedObjectIndex = _this$props.highlightedObjectIndex, autoHighlight = _this$props.autoHighlight, highlightColor = _this$props.highlightColor, coordinateSystem = _this$props.coordinateSystem, coordinateOrigin = _this$props.coordinateOrigin, wrapLongitude = _this$props.wrapLongitude, positionFormat = _this$props.positionFormat, modelMatrix = _this$props.modelMatrix, extensions = _this$props.extensions, overridingProps = _this$props._subLayerProps;
          var newProps = {
            opacity,
            pickable,
            visible,
            parameters,
            getPolygonOffset,
            highlightedObjectIndex,
            autoHighlight,
            highlightColor,
            coordinateSystem,
            coordinateOrigin,
            wrapLongitude,
            positionFormat,
            modelMatrix,
            extensions
          };
          var overridingSublayerProps = overridingProps && overridingProps[sublayerProps.id];
          var overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
          var sublayerId = sublayerProps.id || "sublayer";
          if (overridingSublayerProps) {
            var propTypes = this.constructor._propTypes;
            for (var key in overridingSublayerProps) {
              var propType = propTypes[key];
              if (propType && propType.type === "accessor") {
                overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
              }
            }
          }
          Object.assign(newProps, sublayerProps, overridingSublayerProps, {
            id: "".concat(this.props.id, "-").concat(sublayerId),
            updateTriggers: Object.assign({
              all: this.props.updateTriggers.all
            }, sublayerProps.updateTriggers, overridingSublayerTriggers)
          });
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var extension = _step.value;
              var passThroughProps = extension.getSubLayerProps.call(this, extension);
              if (passThroughProps) {
                Object.assign(newProps, passThroughProps, {
                  updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
                });
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return newProps;
        }
      }, {
        key: "_getAttributeManager",
        value: function _getAttributeManager() {
          return null;
        }
      }, {
        key: "_renderLayers",
        value: function _renderLayers() {
          var subLayers = this.internalState.subLayers;
          var shouldUpdate = !subLayers || this.needsUpdate();
          if (shouldUpdate) {
            subLayers = this.renderLayers();
            subLayers = flatten(subLayers, Boolean);
            this.internalState.subLayers = subLayers;
          }
          debug(TRACE_RENDER_LAYERS2, this, shouldUpdate, subLayers);
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = subLayers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var layer = _step2.value;
              layer.parent = this;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }, {
        key: "isComposite",
        get: function get2() {
          return true;
        }
      }, {
        key: "isLoaded",
        get: function get2() {
          return _get(_getPrototypeOf(CompositeLayer2.prototype), "isLoaded", this) && this.getSubLayers().every(function(layer) {
            return layer.isLoaded;
          });
        }
      }]);
      return CompositeLayer2;
    }(Layer);
    CompositeLayer.layerName = "CompositeLayer";
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js
var LayerExtension;
var init_layer_extension = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js"() {
    init_classCallCheck();
    init_createClass();
    init_deep_equal();
    LayerExtension = function() {
      function LayerExtension2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, LayerExtension2);
        this.opts = opts;
      }
      _createClass(LayerExtension2, [{
        key: "equals",
        value: function equals4(extension) {
          if (this === extension) {
            return true;
          }
          return this.constructor === extension.constructor && deepEqual(this.opts, extension.opts);
        }
      }, {
        key: "getShaders",
        value: function getShaders(extension) {
          return null;
        }
      }, {
        key: "getSubLayerProps",
        value: function getSubLayerProps(extension) {
          var _extension$constructo = extension.constructor.defaultProps, defaultProps4 = _extension$constructo === void 0 ? {} : _extension$constructo;
          var newProps = {
            updateTriggers: {}
          };
          for (var key in defaultProps4) {
            if (key in this.props) {
              var propDef = defaultProps4[key];
              var propValue = this.props[key];
              newProps[key] = propValue;
              if (propDef && propDef.type === "accessor") {
                newProps.updateTriggers[key] = this.props.updateTriggers[key];
                if (typeof propValue === "function") {
                  newProps[key] = this.getSubLayerAccessor(propValue, true);
                }
              }
            }
          }
          return newProps;
        }
      }, {
        key: "initializeState",
        value: function initializeState(context, extension) {
        }
      }, {
        key: "updateState",
        value: function updateState(params, extension) {
        }
      }, {
        key: "draw",
        value: function draw(params, extension) {
        }
      }, {
        key: "finalizeState",
        value: function finalizeState(extension) {
        }
      }]);
      return LayerExtension2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/lib/index.js
var init_lib = __esm({
  "node_modules/@deck.gl/core/dist/esm/lib/index.js"() {
    init_constants2();
    init_deck();
    init_deck_renderer();
    init_effect();
    init_layer();
    init_composite_layer();
    init_layer_extension();
    init_attribute_manager();
    init_layer_manager();
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js
function getAttenuation(props) {
  if ("attenuation" in props) {
    return props.attenuation;
  }
  if ("intensity" in props) {
    return [0, 0, props.intensity];
  }
  return DEFAULT_ATTENUATION;
}
var DEFAULT_LIGHT_COLOR3, DEFAULT_LIGHT_INTENSITY3, DEFAULT_ATTENUATION, DEFAULT_LIGHT_POSITION, idCount3, PointLight;
var init_point_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js"() {
    init_classCallCheck();
    init_createClass();
    init_project_functions();
    init_lib();
    DEFAULT_LIGHT_COLOR3 = [255, 255, 255];
    DEFAULT_LIGHT_INTENSITY3 = 1;
    DEFAULT_ATTENUATION = [0, 0, 1];
    DEFAULT_LIGHT_POSITION = [0, 0, 1];
    idCount3 = 0;
    PointLight = function() {
      function PointLight2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, PointLight2);
        var _props$color = props.color, color = _props$color === void 0 ? DEFAULT_LIGHT_COLOR3 : _props$color;
        var _props$intensity = props.intensity, intensity = _props$intensity === void 0 ? DEFAULT_LIGHT_INTENSITY3 : _props$intensity;
        var _props$position = props.position, position = _props$position === void 0 ? DEFAULT_LIGHT_POSITION : _props$position;
        this.id = props.id || "point-".concat(idCount3++);
        this.color = color;
        this.intensity = intensity;
        this.type = "point";
        this.position = position;
        this.attenuation = getAttenuation(props);
        this.projectedLight = Object.assign({}, this);
      }
      _createClass(PointLight2, [{
        key: "getProjectedLight",
        value: function getProjectedLight(_ref) {
          var layer = _ref.layer;
          var projectedLight = this.projectedLight;
          var viewport = layer.context.viewport;
          var _layer$props = layer.props, coordinateSystem = _layer$props.coordinateSystem, coordinateOrigin = _layer$props.coordinateOrigin;
          var position = projectPosition(this.position, {
            viewport,
            coordinateSystem,
            coordinateOrigin,
            fromCoordinateSystem: viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
            fromCoordinateOrigin: [0, 0, 0]
          });
          projectedLight.color = this.color;
          projectedLight.intensity = this.intensity;
          projectedLight.position = position;
          return projectedLight;
        }
      }]);
      return PointLight2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js
var CameraLight;
var init_camera_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_point_light();
    init_viewport_uniforms();
    CameraLight = function(_PointLight) {
      _inherits(CameraLight2, _PointLight);
      function CameraLight2() {
        _classCallCheck(this, CameraLight2);
        return _possibleConstructorReturn(this, _getPrototypeOf(CameraLight2).apply(this, arguments));
      }
      _createClass(CameraLight2, [{
        key: "getProjectedLight",
        value: function getProjectedLight(_ref) {
          var layer = _ref.layer;
          var projectedLight = this.projectedLight;
          var viewport = layer.context.viewport;
          var _layer$props = layer.props, coordinateSystem = _layer$props.coordinateSystem, coordinateOrigin = _layer$props.coordinateOrigin, modelMatrix = _layer$props.modelMatrix;
          var _getUniformsFromViewp = getUniformsFromViewport({
            viewport,
            modelMatrix,
            coordinateSystem,
            coordinateOrigin
          }), project_uCameraPosition = _getUniformsFromViewp.project_uCameraPosition;
          projectedLight.color = this.color;
          projectedLight.intensity = this.intensity;
          projectedLight.position = project_uCameraPosition;
          return projectedLight;
        }
      }]);
      return CameraLight2;
    }(PointLight);
  }
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var init_objectWithoutProperties = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"() {
    init_objectWithoutPropertiesLoose();
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/suncalc.js
function getSolarPosition(timestamp, latitude, longitude) {
  var longitudeWestInRadians = DEGREES_TO_RADIANS5 * -longitude;
  var phi = DEGREES_TO_RADIANS5 * latitude;
  var d = toDays(timestamp);
  var c = getSunCoords(d);
  var H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}
function getSunlightDirection(timestamp, latitude, longitude) {
  var _getSolarPosition = getSolarPosition(timestamp, latitude, longitude), azimuth = _getSolarPosition.azimuth, altitude = _getSolarPosition.altitude;
  var azimuthN = azimuth + Math.PI;
  return [-Math.sin(azimuthN), -Math.cos(azimuthN), -Math.sin(altitude)];
}
function toJulianDay(timestamp) {
  return timestamp / DAY_IN_MS - 0.5 + JD1970;
}
function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}
function getRightAscension(eclipticLongitude, b) {
  var lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}
function getDeclination(eclipticLongitude, b) {
  var lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}
function getAzimuth(hourAngle, latitudeInRadians, declination) {
  var H = hourAngle;
  var phi = latitudeInRadians;
  var delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}
function getAltitude(hourAngle, latitudeInRadians, declination) {
  var H = hourAngle;
  var phi = latitudeInRadians;
  var delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}
function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS5 * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}
function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS5 * (M0 + M1 * days);
}
function getEclipticLongitude(meanAnomaly) {
  var M = meanAnomaly;
  var C = DEGREES_TO_RADIANS5 * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 3e-4 * Math.sin(3 * M));
  var P = DEGREES_TO_RADIANS5 * 102.9372;
  return M + C + P + Math.PI;
}
function getSunCoords(dates) {
  var M = getSolarMeanAnomaly(dates);
  var L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}
var DEGREES_TO_RADIANS5, DAY_IN_MS, JD1970, JD2000, e, M0, M1, THETA0, THETA1;
var init_suncalc = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/suncalc.js"() {
    DEGREES_TO_RADIANS5 = Math.PI / 180;
    DAY_IN_MS = 1e3 * 60 * 60 * 24;
    JD1970 = 2440588;
    JD2000 = 2451545;
    e = DEGREES_TO_RADIANS5 * 23.4397;
    M0 = 357.5291;
    M1 = 0.98560028;
    THETA0 = 280.147;
    THETA1 = 360.9856235;
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js
var SunLight;
var init_sun_light = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js"() {
    init_objectWithoutProperties();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_directional_light();
    init_suncalc();
    SunLight = function(_DirectionalLight) {
      _inherits(SunLight2, _DirectionalLight);
      function SunLight2(_ref) {
        var _this;
        var timestamp = _ref.timestamp, others = _objectWithoutProperties(_ref, ["timestamp"]);
        _classCallCheck(this, SunLight2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(SunLight2).call(this, others));
        _this.timestamp = timestamp;
        return _this;
      }
      _createClass(SunLight2, [{
        key: "getProjectedLight",
        value: function getProjectedLight(_ref2) {
          var layer = _ref2.layer;
          var _layer$context$viewpo = layer.context.viewport, latitude = _layer$context$viewpo.latitude, longitude = _layer$context$viewpo.longitude;
          this.direction = getSunlightDirection(this.timestamp, latitude, longitude);
          return this;
        }
      }]);
      return SunLight2;
    }(DirectionalLight);
  }
});

// node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js
var ScreenPass;
var init_screen_pass = __esm({
  "node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm14();
    init_pass();
    ScreenPass = function(_Pass) {
      _inherits(ScreenPass2, _Pass);
      function ScreenPass2(gl) {
        var _this;
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, ScreenPass2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(ScreenPass2).call(this, gl, props));
        var module = props.module, fs6 = props.fs, id = props.id;
        _this.model = new ClipSpace(gl, {
          id,
          fs: fs6,
          modules: [module]
        });
        return _this;
      }
      _createClass(ScreenPass2, [{
        key: "render",
        value: function render(params) {
          var _this2 = this;
          var gl = this.gl;
          withParameters(gl, {
            framebuffer: params.outputBuffer,
            clearColor: [0, 0, 0, 0]
          }, function() {
            return _this2._renderPass(gl, params);
          });
        }
      }, {
        key: "delete",
        value: function _delete() {
          this.model["delete"]();
          this.model = null;
        }
      }, {
        key: "_renderPass",
        value: function _renderPass(gl, _ref) {
          var inputBuffer = _ref.inputBuffer, outputBuffer = _ref.outputBuffer;
          clear(gl, {
            color: true
          });
          this.model.draw({
            moduleSettings: this.props.moduleSettings,
            uniforms: {
              texture: inputBuffer,
              texSize: [inputBuffer.width, inputBuffer.height]
            },
            parameters: {
              depthWrite: false,
              depthTest: false
            }
          });
        }
      }]);
      return ScreenPass2;
    }(Pass);
  }
});

// node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js
function createPasses(gl, module, id, moduleSettings) {
  if (module.filter || module.sampler) {
    var fs6 = getFragmentShaderForRenderPass(module);
    var pass = new ScreenPass(gl, {
      id,
      module,
      fs: fs6,
      moduleSettings
    });
    return [pass];
  }
  var passes = module.passes || [];
  return passes.map(function(pass2, index) {
    var fs7 = getFragmentShaderForRenderPass(module, pass2);
    var idn = "".concat(id, "-").concat(index);
    return new ScreenPass(gl, {
      id: idn,
      module,
      fs: fs7,
      moduleSettings
    });
  });
}
function getFragmentShaderForRenderPass(module) {
  var pass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : module;
  if (pass.filter) {
    var func = typeof pass.filter === "string" ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }
  if (pass.sampler) {
    var _func = typeof pass.sampler === "string" ? pass.sampler : "".concat(module.name, "_sampleColor");
    return SAMPLER_FS_TEMPLATE(_func);
  }
  return null;
}
var PostProcessEffect, FILTER_FS_TEMPLATE, SAMPLER_FS_TEMPLATE;
var init_post_process_effect = __esm({
  "node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_effect();
    init_screen_pass();
    init_esm14();
    PostProcessEffect = function(_Effect) {
      _inherits(PostProcessEffect2, _Effect);
      function PostProcessEffect2(module) {
        var _this;
        var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, PostProcessEffect2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(PostProcessEffect2).call(this, props));
        _this.id = "".concat(module.name, "-pass");
        normalizeShaderModule(module);
        _this.module = module;
        return _this;
      }
      _createClass(PostProcessEffect2, [{
        key: "postRender",
        value: function postRender(gl, params) {
          if (!this.passes) {
            this.passes = createPasses(gl, this.module, this.id, this.props);
          }
          var target = params.target;
          var inputBuffer = params.inputBuffer;
          var outputBuffer = params.swapBuffer;
          for (var index = 0; index < this.passes.length; index++) {
            if (target && index === this.passes.length - 1) {
              outputBuffer = target;
            }
            this.passes[index].render({
              inputBuffer,
              outputBuffer
            });
            var switchBuffer = outputBuffer;
            outputBuffer = inputBuffer;
            inputBuffer = switchBuffer;
          }
          return inputBuffer;
        }
      }, {
        key: "cleanup",
        value: function cleanup() {
          if (this.passes) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var pass = _step.value;
                pass["delete"]();
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            this.passes = null;
          }
        }
      }]);
      return PostProcessEffect2;
    }(Effect);
    FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE2(func) {
      return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");
    };
    SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE2(func) {
      return "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");
    };
  }
});

// node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js
function getDistanceScales2() {
  var unitsPerMeter2 = GLOBE_RADIUS / EARTH_RADIUS;
  var unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter2, unitsPerMeter2, unitsPerMeter2],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter2, 1 / unitsPerMeter2, 1 / unitsPerMeter2],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter2],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter2]
  };
}
function transformVector2(matrix, vector) {
  var result = transformMat43([], vector, matrix);
  scale4(result, result, 1 / result[3]);
  return result;
}
var DEGREES_TO_RADIANS6, RADIANS_TO_DEGREES3, EARTH_RADIUS, GLOBE_RADIUS, GlobeViewport;
var init_globe_viewport = __esm({
  "node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js"() {
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm15();
    init_viewport();
    init_constants2();
    init_vec3();
    init_vec4();
    DEGREES_TO_RADIANS6 = Math.PI / 180;
    RADIANS_TO_DEGREES3 = 180 / Math.PI;
    EARTH_RADIUS = 6370972;
    GLOBE_RADIUS = 256;
    GlobeViewport = function(_Viewport) {
      _inherits(GlobeViewport2, _Viewport);
      function GlobeViewport2() {
        var _this;
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, GlobeViewport2);
        var _opts$latitude = opts.latitude, latitude = _opts$latitude === void 0 ? 0 : _opts$latitude, _opts$longitude = opts.longitude, longitude = _opts$longitude === void 0 ? 0 : _opts$longitude, _opts$zoom = opts.zoom, zoom = _opts$zoom === void 0 ? 11 : _opts$zoom, _opts$nearZMultiplier = opts.nearZMultiplier, nearZMultiplier = _opts$nearZMultiplier === void 0 ? 0.1 : _opts$nearZMultiplier, _opts$farZMultiplier = opts.farZMultiplier, farZMultiplier = _opts$farZMultiplier === void 0 ? 1 : _opts$farZMultiplier, _opts$resolution = opts.resolution, resolution = _opts$resolution === void 0 ? 10 : _opts$resolution;
        var width = opts.width, height = opts.height, _opts$altitude = opts.altitude, altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude;
        width = width || 1;
        height = height || 1;
        altitude = Math.max(0.75, altitude);
        var viewMatrix2 = new Matrix4().lookAt({
          eye: [0, -altitude, 0],
          up: [0, 0, 1]
        });
        var scale6 = Math.pow(2, zoom);
        viewMatrix2.rotateX(latitude * DEGREES_TO_RADIANS6);
        viewMatrix2.rotateZ(-longitude * DEGREES_TO_RADIANS6);
        viewMatrix2.scale(scale6 / height);
        var halfFov = Math.atan(0.5 / altitude);
        var relativeScale = GLOBE_RADIUS * 2 * scale6 / height;
        var viewportOpts = Object.assign({}, opts, {
          width,
          height,
          viewMatrix: viewMatrix2,
          longitude,
          latitude,
          zoom,
          fovyRadians: halfFov * 2,
          aspect: width / height,
          focalDistance: altitude,
          near: nearZMultiplier,
          far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
        });
        _this = _possibleConstructorReturn(this, _getPrototypeOf(GlobeViewport2).call(this, viewportOpts));
        _this.resolution = resolution;
        _this.distanceScales = getDistanceScales2();
        return _this;
      }
      _createClass(GlobeViewport2, [{
        key: "getDistanceScales",
        value: function getDistanceScales3() {
          return this.distanceScales;
        }
      }, {
        key: "unproject",
        value: function unproject(xyz) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$topLeft = _ref.topLeft, topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft, targetZ = _ref.targetZ;
          var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
          var y2 = topLeft ? y : this.height - y;
          var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;
          var coord;
          if (Number.isFinite(z)) {
            coord = transformVector2(pixelUnprojectionMatrix, [x, y2, z, 1]);
          } else {
            var coord0 = transformVector2(pixelUnprojectionMatrix, [x, y2, -1, 1]);
            var coord1 = transformVector2(pixelUnprojectionMatrix, [x, y2, 1, 1]);
            var lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
            var lSqr = sqrLen(sub2([], coord0, coord1));
            var l0Sqr = sqrLen(coord0);
            var l1Sqr = sqrLen(coord1);
            var sSqr = (4 * l0Sqr * l1Sqr - Math.pow(lSqr - l0Sqr - l1Sqr, 2)) / 16;
            var dSqr = 4 * sSqr / lSqr;
            var r0 = Math.sqrt(l0Sqr - dSqr);
            var dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
            var t = (r0 - dr) / Math.sqrt(lSqr);
            coord = lerp3([], coord0, coord1, t);
          }
          var _this$unprojectPositi = this.unprojectPosition(coord), _this$unprojectPositi2 = _slicedToArray(_this$unprojectPositi, 3), X = _this$unprojectPositi2[0], Y = _this$unprojectPositi2[1], Z = _this$unprojectPositi2[2];
          if (Number.isFinite(z)) {
            return [X, Y, Z];
          }
          return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
        }
      }, {
        key: "projectPosition",
        value: function projectPosition2(xyz) {
          var _xyz2 = _slicedToArray(xyz, 3), lng = _xyz2[0], lat = _xyz2[1], _xyz2$ = _xyz2[2], Z = _xyz2$ === void 0 ? 0 : _xyz2$;
          var lambda = lng * DEGREES_TO_RADIANS6;
          var phi = lat * DEGREES_TO_RADIANS6;
          var cosPhi = Math.cos(phi);
          var D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
          return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
        }
      }, {
        key: "unprojectPosition",
        value: function unprojectPosition(xyz) {
          var _xyz3 = _slicedToArray(xyz, 3), x = _xyz3[0], y = _xyz3[1], z = _xyz3[2];
          var D = len(xyz);
          var phi = Math.asin(z / D);
          var lambda = Math.atan2(x, -y);
          var lng = lambda * RADIANS_TO_DEGREES3;
          var lat = phi * RADIANS_TO_DEGREES3;
          var Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
          return [lng, lat, Z];
        }
      }, {
        key: "projectFlat",
        value: function projectFlat(xyz) {
          return xyz;
        }
      }, {
        key: "unprojectFlat",
        value: function unprojectFlat(xyz) {
          return xyz;
        }
      }, {
        key: "getMapCenterByLngLatPosition",
        value: function getMapCenterByLngLatPosition(_ref2) {
          var lngLat = _ref2.lngLat, pos = _ref2.pos;
          var fromPosition = this.unproject(pos);
          return [lngLat[0] - fromPosition[0] + this.longitude, lngLat[1] - fromPosition[1] + this.latitude];
        }
      }, {
        key: "projectionMode",
        get: function get2() {
          return PROJECTION_MODE.GLOBE;
        }
      }]);
      return GlobeViewport2;
    }(Viewport);
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js
var MOVEMENT_SPEED, DEFAULT_STATE2, FirstPersonState, FirstPersonController;
var init_first_person_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_controller();
    init_view_state();
    init_math_utils3();
    init_esm15();
    MOVEMENT_SPEED = 20;
    DEFAULT_STATE2 = {
      position: [0, 0, 0],
      pitch: 0,
      bearing: 0,
      maxPitch: 90,
      minPitch: -90
    };
    FirstPersonState = function(_ViewState) {
      _inherits(FirstPersonState2, _ViewState);
      function FirstPersonState2(_ref) {
        var _this;
        var width = _ref.width, height = _ref.height, _ref$position = _ref.position, position = _ref$position === void 0 ? DEFAULT_STATE2.position : _ref$position, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? DEFAULT_STATE2.bearing : _ref$bearing, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? DEFAULT_STATE2.pitch : _ref$pitch, longitude = _ref.longitude, latitude = _ref.latitude, _ref$maxPitch = _ref.maxPitch, maxPitch = _ref$maxPitch === void 0 ? DEFAULT_STATE2.maxPitch : _ref$maxPitch, _ref$minPitch = _ref.minPitch, minPitch = _ref$minPitch === void 0 ? DEFAULT_STATE2.minPitch : _ref$minPitch, startBearing = _ref.startBearing, startPitch = _ref.startPitch, startZoomPosition = _ref.startZoomPosition, startZoom = _ref.startZoom;
        _classCallCheck(this, FirstPersonState2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(FirstPersonState2).call(this, {
          width,
          height,
          position,
          bearing,
          pitch,
          longitude,
          latitude,
          maxPitch,
          minPitch
        }));
        _this._interactiveState = {
          startBearing,
          startPitch,
          startZoomPosition,
          startZoom
        };
        return _this;
      }
      _createClass(FirstPersonState2, [{
        key: "getInteractiveState",
        value: function getInteractiveState() {
          return this._interactiveState;
        }
      }, {
        key: "getDirection",
        value: function getDirection() {
          var use2D = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var spherical = new SphericalCoordinates({
            bearing: this._viewportProps.bearing,
            pitch: use2D ? 90 : 90 + this._viewportProps.pitch
          });
          var direction = spherical.toVector3().normalize();
          return direction;
        }
      }, {
        key: "panStart",
        value: function panStart() {
          return this;
        }
      }, {
        key: "pan",
        value: function pan() {
          return this;
        }
      }, {
        key: "panEnd",
        value: function panEnd() {
          return this;
        }
      }, {
        key: "rotateStart",
        value: function rotateStart(_ref2) {
          var pos = _ref2.pos;
          return this._getUpdatedState({
            startBearing: this._viewportProps.bearing,
            startPitch: this._viewportProps.pitch
          });
        }
      }, {
        key: "rotate",
        value: function rotate3(_ref3) {
          var deltaScaleX = _ref3.deltaScaleX, deltaScaleY = _ref3.deltaScaleY;
          var _this$_interactiveSta = this._interactiveState, startBearing = _this$_interactiveSta.startBearing, startPitch = _this$_interactiveSta.startPitch;
          if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
            return this;
          }
          return this._getUpdatedState({
            bearing: startBearing - deltaScaleX * 180,
            pitch: startPitch - deltaScaleY * 90
          });
        }
      }, {
        key: "rotateEnd",
        value: function rotateEnd() {
          return this._getUpdatedState({
            startBearing: null,
            startPitch: null
          });
        }
      }, {
        key: "zoomStart",
        value: function zoomStart() {
          return this._getUpdatedState({
            startZoomPosition: this._viewportProps.position,
            startZoom: this._viewportProps.zoom
          });
        }
      }, {
        key: "zoom",
        value: function zoom(_ref4) {
          var scale6 = _ref4.scale;
          var startZoomPosition = this._interactiveState.startZoomPosition;
          if (!startZoomPosition) {
            startZoomPosition = this._viewportProps.position;
          }
          var direction = this.getDirection();
          return this._move(direction, Math.log2(scale6), startZoomPosition);
        }
      }, {
        key: "zoomEnd",
        value: function zoomEnd() {
          return this._getUpdatedState({
            startZoomPosition: null,
            startZoom: null
          });
        }
      }, {
        key: "moveLeft",
        value: function moveLeft() {
          var direction = this.getDirection(true);
          return this._move(direction.rotateZ({
            radians: Math.PI / 2
          }));
        }
      }, {
        key: "moveRight",
        value: function moveRight() {
          var direction = this.getDirection(true);
          return this._move(direction.rotateZ({
            radians: -Math.PI / 2
          }));
        }
      }, {
        key: "moveUp",
        value: function moveUp() {
          var direction = this.getDirection(true);
          return this._move(direction);
        }
      }, {
        key: "moveDown",
        value: function moveDown() {
          var direction = this.getDirection(true);
          return this._move(direction.negate());
        }
      }, {
        key: "rotateLeft",
        value: function rotateLeft() {
          return this._getUpdatedState({
            bearing: this._viewportProps.bearing - 15
          });
        }
      }, {
        key: "rotateRight",
        value: function rotateRight() {
          return this._getUpdatedState({
            bearing: this._viewportProps.bearing + 15
          });
        }
      }, {
        key: "rotateUp",
        value: function rotateUp() {
          return this._getUpdatedState({
            pitch: this._viewportProps.pitch + 10
          });
        }
      }, {
        key: "rotateDown",
        value: function rotateDown() {
          return this._getUpdatedState({
            pitch: this._viewportProps.pitch - 10
          });
        }
      }, {
        key: "zoomIn",
        value: function zoomIn() {
          return this.zoom({
            scale: 2
          });
        }
      }, {
        key: "zoomOut",
        value: function zoomOut() {
          return this.zoom({
            scale: 0.5
          });
        }
      }, {
        key: "shortestPathFrom",
        value: function shortestPathFrom(viewState) {
          var fromProps = viewState.getViewportProps();
          var props = Object.assign({}, this._viewportProps);
          var bearing = props.bearing, longitude = props.longitude;
          if (Math.abs(bearing - fromProps.bearing) > 180) {
            props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
          }
          if (Math.abs(longitude - fromProps.longitude) > 180) {
            props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
          }
          return props;
        }
      }, {
        key: "_move",
        value: function _move(direction) {
          var speed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          var fromPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._viewportProps.position;
          var delta = direction.scale(speed * MOVEMENT_SPEED);
          return this._getUpdatedState({
            position: new Vector3(fromPosition).add(delta)
          });
        }
      }, {
        key: "_getUpdatedState",
        value: function _getUpdatedState(newProps) {
          return new FirstPersonState2(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
        }
      }, {
        key: "_applyConstraints",
        value: function _applyConstraints(props) {
          var pitch = props.pitch, maxPitch = props.maxPitch, minPitch = props.minPitch, longitude = props.longitude, bearing = props.bearing;
          props.pitch = clamp(pitch, minPitch, maxPitch);
          if (longitude < -180 || longitude > 180) {
            props.longitude = mod2(longitude + 180, 360) - 180;
          }
          if (bearing < -180 || bearing > 180) {
            props.bearing = mod2(bearing + 180, 360) - 180;
          }
          return props;
        }
      }]);
      return FirstPersonState2;
    }(ViewState);
    FirstPersonController = function(_Controller) {
      _inherits(FirstPersonController2, _Controller);
      function FirstPersonController2(props) {
        _classCallCheck(this, FirstPersonController2);
        return _possibleConstructorReturn(this, _getPrototypeOf(FirstPersonController2).call(this, FirstPersonState, props));
      }
      return FirstPersonController2;
    }(Controller);
  }
});

// node_modules/@deck.gl/core/dist/esm/views/first-person-view.js
function getDirectionFromBearingAndPitch(_ref) {
  var bearing = _ref.bearing, pitch = _ref.pitch;
  var spherical = new SphericalCoordinates({
    bearing,
    pitch
  });
  var direction = spherical.toVector3().normalize();
  return direction;
}
var FirstPersonView;
var init_first_person_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/first-person-view.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_view();
    init_viewport();
    init_esm16();
    init_esm15();
    init_first_person_controller();
    FirstPersonView = function(_View) {
      _inherits(FirstPersonView2, _View);
      function FirstPersonView2() {
        _classCallCheck(this, FirstPersonView2);
        return _possibleConstructorReturn(this, _getPrototypeOf(FirstPersonView2).apply(this, arguments));
      }
      _createClass(FirstPersonView2, [{
        key: "_getViewport",
        value: function _getViewport(props) {
          var _props$modelMatrix = props.modelMatrix, modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix, _props$bearing = props.bearing, bearing = _props$bearing === void 0 ? 0 : _props$bearing, _props$pitch = props.pitch, pitch = _props$pitch === void 0 ? 0 : _props$pitch, _props$up = props.up, up = _props$up === void 0 ? [0, 0, 1] : _props$up;
          var dir = getDirectionFromBearingAndPitch({
            bearing,
            pitch: 90 + pitch
          });
          var center = modelMatrix ? modelMatrix.transformDirection(dir) : dir;
          var zoom = getMeterZoom(props);
          var scale6 = Math.pow(2, zoom);
          var viewMatrix2 = new Matrix4().lookAt({
            eye: [0, 0, 0],
            center,
            up
          }).scale(scale6);
          return new Viewport(Object.assign({}, props, {
            zoom,
            viewMatrix: viewMatrix2
          }));
        }
      }, {
        key: "controller",
        get: function get2() {
          return this._getControllerProps({
            type: FirstPersonController
          });
        }
      }]);
      return FirstPersonView2;
    }(View);
    FirstPersonView.displayName = "FirstPersonView";
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js
var MOVEMENT_SPEED2, DEFAULT_STATE3, LINEAR_TRANSITION_PROPS2, zoom2Scale, OrbitState, OrbitController;
var init_orbit_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm15();
    init_controller();
    init_view_state();
    init_linear_interpolator();
    init_transition_manager();
    init_math_utils3();
    MOVEMENT_SPEED2 = 50;
    DEFAULT_STATE3 = {
      orbitAxis: "Z",
      rotationX: 0,
      rotationOrbit: 0,
      zoom: 0,
      target: [0, 0, 0],
      minRotationX: -90,
      maxRotationX: 90,
      minZoom: -Infinity,
      maxZoom: Infinity
    };
    LINEAR_TRANSITION_PROPS2 = {
      transitionDuration: 300,
      transitionEasing: function transitionEasing3(t) {
        return t;
      },
      transitionInterpolator: new LinearInterpolator(["target", "zoom", "rotationX", "rotationOrbit"]),
      transitionInterruption: TRANSITION_EVENTS.BREAK
    };
    zoom2Scale = function zoom2Scale2(zoom) {
      return Math.pow(2, zoom);
    };
    OrbitState = function(_ViewState) {
      _inherits(OrbitState2, _ViewState);
      function OrbitState2(_ref) {
        var _this;
        var makeViewport = _ref.makeViewport, width = _ref.width, height = _ref.height, _ref$orbitAxis = _ref.orbitAxis, orbitAxis = _ref$orbitAxis === void 0 ? DEFAULT_STATE3.orbitAxis : _ref$orbitAxis, _ref$rotationX = _ref.rotationX, rotationX = _ref$rotationX === void 0 ? DEFAULT_STATE3.rotationX : _ref$rotationX, _ref$rotationOrbit = _ref.rotationOrbit, rotationOrbit = _ref$rotationOrbit === void 0 ? DEFAULT_STATE3.rotationOrbit : _ref$rotationOrbit, _ref$target = _ref.target, target = _ref$target === void 0 ? DEFAULT_STATE3.target : _ref$target, _ref$zoom = _ref.zoom, zoom = _ref$zoom === void 0 ? DEFAULT_STATE3.zoom : _ref$zoom, _ref$minRotationX = _ref.minRotationX, minRotationX = _ref$minRotationX === void 0 ? DEFAULT_STATE3.minRotationX : _ref$minRotationX, _ref$maxRotationX = _ref.maxRotationX, maxRotationX = _ref$maxRotationX === void 0 ? DEFAULT_STATE3.maxRotationX : _ref$maxRotationX, _ref$minZoom = _ref.minZoom, minZoom = _ref$minZoom === void 0 ? DEFAULT_STATE3.minZoom : _ref$minZoom, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? DEFAULT_STATE3.maxZoom : _ref$maxZoom, startPanPosition = _ref.startPanPosition, startTarget = _ref.startTarget, startRotationX = _ref.startRotationX, startRotationOrbit = _ref.startRotationOrbit, startZoomPosition = _ref.startZoomPosition, startZoom = _ref.startZoom;
        _classCallCheck(this, OrbitState2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(OrbitState2).call(this, {
          width,
          height,
          orbitAxis,
          rotationX,
          rotationOrbit,
          target,
          zoom,
          minRotationX,
          maxRotationX,
          minZoom,
          maxZoom
        }));
        _this._interactiveState = {
          startPanPosition,
          startTarget,
          startRotationX,
          startRotationOrbit,
          startZoomPosition,
          startZoom
        };
        _this.makeViewport = makeViewport;
        return _this;
      }
      _createClass(OrbitState2, [{
        key: "getViewportProps",
        value: function getViewportProps() {
          return this._viewportProps;
        }
      }, {
        key: "getInteractiveState",
        value: function getInteractiveState() {
          return this._interactiveState;
        }
      }, {
        key: "panStart",
        value: function panStart(_ref2) {
          var pos = _ref2.pos;
          var target = this._viewportProps.target;
          return this._getUpdatedState({
            startPanPosition: pos,
            startTarget: target
          });
        }
      }, {
        key: "pan",
        value: function pan(_ref3) {
          var pos = _ref3.pos, startPos = _ref3.startPos;
          var _this$_interactiveSta = this._interactiveState, startPanPosition = _this$_interactiveSta.startPanPosition, startTarget = _this$_interactiveSta.startTarget;
          var delta = new Vector2(pos).subtract(startPanPosition);
          return this._getUpdatedState({
            target: this._calculateNewTarget({
              startTarget,
              pixelOffset: delta
            })
          });
        }
      }, {
        key: "panEnd",
        value: function panEnd() {
          return this._getUpdatedState({
            startPanPosition: null,
            startTarget: null
          });
        }
      }, {
        key: "rotateStart",
        value: function rotateStart(_ref4) {
          var pos = _ref4.pos;
          return this._getUpdatedState({
            startRotationX: this._viewportProps.rotationX,
            startRotationOrbit: this._viewportProps.rotationOrbit
          });
        }
      }, {
        key: "rotate",
        value: function rotate3(_ref5) {
          var deltaScaleX = _ref5.deltaScaleX, deltaScaleY = _ref5.deltaScaleY;
          var _this$_interactiveSta2 = this._interactiveState, startRotationX = _this$_interactiveSta2.startRotationX, startRotationOrbit = _this$_interactiveSta2.startRotationOrbit;
          if (!Number.isFinite(startRotationX) || !Number.isFinite(startRotationOrbit)) {
            return this;
          }
          if (startRotationX < -90 || startRotationX > 90) {
            deltaScaleX *= -1;
          }
          return this._getUpdatedState({
            rotationX: startRotationX + deltaScaleY * 180,
            rotationOrbit: startRotationOrbit + deltaScaleX * 180,
            isRotating: true
          });
        }
      }, {
        key: "rotateEnd",
        value: function rotateEnd() {
          return this._getUpdatedState({
            startRotationX: null,
            startRotationOrbit: null
          });
        }
      }, {
        key: "shortestPathFrom",
        value: function shortestPathFrom(viewState) {
          var fromProps = viewState.getViewportProps();
          var props = Object.assign({}, this._viewportProps);
          var rotationOrbit = props.rotationOrbit;
          if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
            props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
          }
          return props;
        }
      }, {
        key: "zoomStart",
        value: function zoomStart(_ref6) {
          var pos = _ref6.pos;
          return this._getUpdatedState({
            startZoomPosition: pos,
            startTarget: this._viewportProps.target,
            startZoom: this._viewportProps.zoom
          });
        }
      }, {
        key: "zoom",
        value: function zoom(_ref7) {
          var pos = _ref7.pos, startPos = _ref7.startPos, scale6 = _ref7.scale;
          var _this$_viewportProps = this._viewportProps, zoom2 = _this$_viewportProps.zoom, width = _this$_viewportProps.width, height = _this$_viewportProps.height, target = _this$_viewportProps.target;
          var _this$_interactiveSta3 = this._interactiveState, startZoom = _this$_interactiveSta3.startZoom, startZoomPosition = _this$_interactiveSta3.startZoomPosition, startTarget = _this$_interactiveSta3.startTarget;
          if (!Number.isFinite(startZoom)) {
            startZoom = zoom2;
            startTarget = target;
            startZoomPosition = startPos || pos;
          }
          var newZoom = this._calculateNewZoom({
            scale: scale6,
            startZoom
          });
          var startScale = zoom2Scale(startZoom);
          var newScale = zoom2Scale(newZoom);
          var dX = (width / 2 - startZoomPosition[0]) * (newScale / startScale - 1);
          var dY = (height / 2 - startZoomPosition[1]) * (newScale / startScale - 1);
          return this._getUpdatedState({
            zoom: newZoom,
            target: this._calculateNewTarget({
              startTarget,
              zoom: newZoom,
              pixelOffset: [dX, dY]
            })
          });
        }
      }, {
        key: "zoomEnd",
        value: function zoomEnd() {
          return this._getUpdatedState({
            startZoomPosition: null,
            startTarget: null,
            startZoom: null
          });
        }
      }, {
        key: "zoomIn",
        value: function zoomIn() {
          return this._getUpdatedState({
            zoom: this._calculateNewZoom({
              scale: 2
            })
          });
        }
      }, {
        key: "zoomOut",
        value: function zoomOut() {
          return this._getUpdatedState({
            zoom: this._calculateNewZoom({
              scale: 0.5
            })
          });
        }
      }, {
        key: "moveLeft",
        value: function moveLeft() {
          var pixelOffset = [-MOVEMENT_SPEED2, 0];
          return this._getUpdatedState({
            target: this._calculateNewTarget({
              pixelOffset
            })
          });
        }
      }, {
        key: "moveRight",
        value: function moveRight() {
          var pixelOffset = [MOVEMENT_SPEED2, 0];
          return this._getUpdatedState({
            target: this._calculateNewTarget({
              pixelOffset
            })
          });
        }
      }, {
        key: "moveUp",
        value: function moveUp() {
          var pixelOffset = [0, -MOVEMENT_SPEED2];
          return this._getUpdatedState({
            target: this._calculateNewTarget({
              pixelOffset
            })
          });
        }
      }, {
        key: "moveDown",
        value: function moveDown() {
          var pixelOffset = [0, MOVEMENT_SPEED2];
          return this._getUpdatedState({
            target: this._calculateNewTarget({
              pixelOffset
            })
          });
        }
      }, {
        key: "rotateLeft",
        value: function rotateLeft() {
          return this._getUpdatedState({
            rotationOrbit: this._viewportProps.rotationOrbit - 15
          });
        }
      }, {
        key: "rotateRight",
        value: function rotateRight() {
          return this._getUpdatedState({
            rotationOrbit: this._viewportProps.rotationOrbit + 15
          });
        }
      }, {
        key: "rotateUp",
        value: function rotateUp() {
          return this._getUpdatedState({
            rotationX: this._viewportProps.rotationX - 10
          });
        }
      }, {
        key: "rotateDown",
        value: function rotateDown() {
          return this._getUpdatedState({
            rotationX: this._viewportProps.rotationX + 10
          });
        }
      }, {
        key: "_calculateNewZoom",
        value: function _calculateNewZoom(_ref8) {
          var scale6 = _ref8.scale, startZoom = _ref8.startZoom;
          var _this$_viewportProps2 = this._viewportProps, maxZoom = _this$_viewportProps2.maxZoom, minZoom = _this$_viewportProps2.minZoom;
          if (!Number.isFinite(startZoom)) {
            startZoom = this._viewportProps.zoom;
          }
          var zoom = startZoom + Math.log2(scale6);
          return clamp(zoom, minZoom, maxZoom);
        }
      }, {
        key: "_calculateNewTarget",
        value: function _calculateNewTarget(_ref9) {
          var startTarget = _ref9.startTarget, zoom = _ref9.zoom, pixelOffset = _ref9.pixelOffset;
          var viewportProps = Object.assign({}, this._viewportProps);
          if (Number.isFinite(zoom)) {
            viewportProps.zoom = zoom;
          }
          if (startTarget) {
            viewportProps.target = startTarget;
          }
          var viewport = this.makeViewport(viewportProps);
          var center = viewport.project(viewportProps.target);
          return viewport.unproject([center[0] - pixelOffset[0], center[1] - pixelOffset[1], center[2]]);
        }
      }, {
        key: "_getUpdatedState",
        value: function _getUpdatedState(newProps) {
          return new OrbitState2(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
        }
      }, {
        key: "_applyConstraints",
        value: function _applyConstraints(props) {
          var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom, maxRotationX = props.maxRotationX, minRotationX = props.minRotationX, rotationOrbit = props.rotationOrbit;
          props.zoom = clamp(zoom, minZoom, maxZoom);
          props.rotationX = clamp(props.rotationX, minRotationX, maxRotationX);
          if (rotationOrbit < -180 || rotationOrbit > 180) {
            props.rotationOrbit = mod2(rotationOrbit + 180, 360) - 180;
          }
          return props;
        }
      }]);
      return OrbitState2;
    }(ViewState);
    OrbitController = function(_Controller) {
      _inherits(OrbitController2, _Controller);
      function OrbitController2(props) {
        _classCallCheck(this, OrbitController2);
        return _possibleConstructorReturn(this, _getPrototypeOf(OrbitController2).call(this, OrbitState, props));
      }
      _createClass(OrbitController2, [{
        key: "_getTransitionProps",
        value: function _getTransitionProps() {
          return LINEAR_TRANSITION_PROPS2;
        }
      }]);
      return OrbitController2;
    }(Controller);
  }
});

// node_modules/@deck.gl/core/dist/esm/views/orbit-view.js
function getViewMatrix2(_ref) {
  var height = _ref.height, fovy = _ref.fovy, orbitAxis = _ref.orbitAxis, rotationX = _ref.rotationX, rotationOrbit = _ref.rotationOrbit, zoom = _ref.zoom;
  var distance2 = 0.5 / Math.tan(fovy * DEGREES_TO_RADIANS7 / 2);
  var up = orbitAxis === "Z" ? [0, 0, 1] : [0, 1, 0];
  var eye = orbitAxis === "Z" ? [0, -distance2, 0] : [0, 0, distance2];
  var viewMatrix2 = new Matrix4().lookAt({
    eye,
    up
  });
  viewMatrix2.rotateX(rotationX * DEGREES_TO_RADIANS7);
  if (orbitAxis === "Z") {
    viewMatrix2.rotateZ(rotationOrbit * DEGREES_TO_RADIANS7);
  } else {
    viewMatrix2.rotateY(rotationOrbit * DEGREES_TO_RADIANS7);
  }
  var projectionScale = Math.pow(2, zoom) / (height || 1);
  viewMatrix2.scale(projectionScale);
  return viewMatrix2;
}
var DEGREES_TO_RADIANS7, OrbitViewport, OrbitView;
var init_orbit_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/orbit-view.js"() {
    init_createClass();
    init_classCallCheck();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_view();
    init_viewport();
    init_esm15();
    init_orbit_controller();
    DEGREES_TO_RADIANS7 = Math.PI / 180;
    OrbitViewport = function(_Viewport) {
      _inherits(OrbitViewport2, _Viewport);
      function OrbitViewport2(props) {
        _classCallCheck(this, OrbitViewport2);
        var id = props.id, x = props.x, y = props.y, width = props.width, height = props.height, _props$fovy = props.fovy, fovy = _props$fovy === void 0 ? 50 : _props$fovy, near = props.near, far = props.far, _props$orbitAxis = props.orbitAxis, orbitAxis = _props$orbitAxis === void 0 ? "Z" : _props$orbitAxis, _props$target = props.target, target = _props$target === void 0 ? [0, 0, 0] : _props$target, _props$rotationX = props.rotationX, rotationX = _props$rotationX === void 0 ? 0 : _props$rotationX, _props$rotationOrbit = props.rotationOrbit, rotationOrbit = _props$rotationOrbit === void 0 ? 0 : _props$rotationOrbit, _props$zoom = props.zoom, zoom = _props$zoom === void 0 ? 0 : _props$zoom;
        return _possibleConstructorReturn(this, _getPrototypeOf(OrbitViewport2).call(this, {
          id,
          viewMatrix: getViewMatrix2({
            height,
            fovy,
            orbitAxis,
            rotationX,
            rotationOrbit,
            zoom
          }),
          fovy,
          near,
          far,
          x,
          y,
          position: target,
          width,
          height,
          zoom
        }));
      }
      return OrbitViewport2;
    }(Viewport);
    OrbitView = function(_View) {
      _inherits(OrbitView2, _View);
      function OrbitView2(props) {
        _classCallCheck(this, OrbitView2);
        return _possibleConstructorReturn(this, _getPrototypeOf(OrbitView2).call(this, Object.assign({}, props, {
          type: OrbitViewport
        })));
      }
      _createClass(OrbitView2, [{
        key: "controller",
        get: function get2() {
          return this._getControllerProps({
            type: OrbitController
          });
        }
      }]);
      return OrbitView2;
    }(View);
    OrbitView.displayName = "OrbitView";
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js
var LINEAR_TRANSITION_PROPS3, OrthographicController;
var init_orthographic_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_controller();
    init_orbit_controller();
    init_linear_interpolator();
    init_transition_manager();
    LINEAR_TRANSITION_PROPS3 = {
      transitionDuration: 300,
      transitionEasing: function transitionEasing4(t) {
        return t;
      },
      transitionInterpolator: new LinearInterpolator(["target", "zoom"]),
      transitionInterruption: TRANSITION_EVENTS.BREAK
    };
    OrthographicController = function(_Controller) {
      _inherits(OrthographicController2, _Controller);
      function OrthographicController2(props) {
        var _this;
        _classCallCheck(this, OrthographicController2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(OrthographicController2).call(this, OrbitState, props));
        _this.invertPan = true;
        return _this;
      }
      _createClass(OrthographicController2, [{
        key: "_onPanRotate",
        value: function _onPanRotate(event) {
          return false;
        }
      }, {
        key: "_getTransitionProps",
        value: function _getTransitionProps() {
          return LINEAR_TRANSITION_PROPS3;
        }
      }]);
      return OrthographicController2;
    }(Controller);
  }
});

// node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js
function getProjectionMatrix2(_ref) {
  var width = _ref.width, height = _ref.height, near = _ref.near, far = _ref.far;
  width = width || 1;
  height = height || 1;
  return new Matrix4().ortho({
    left: -width / 2,
    right: width / 2,
    bottom: height / 2,
    top: -height / 2,
    near,
    far
  });
}
var viewMatrix, OrthographicViewport, OrthographicView;
var init_orthographic_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js"() {
    init_createClass();
    init_getPrototypeOf();
    init_classCallCheck();
    init_possibleConstructorReturn();
    init_inherits();
    init_view();
    init_viewport();
    init_esm15();
    init_orthographic_controller();
    viewMatrix = new Matrix4().lookAt({
      eye: [0, 0, 1]
    });
    OrthographicViewport = function(_Viewport) {
      _inherits(OrthographicViewport2, _Viewport);
      function OrthographicViewport2(_ref2) {
        var _this;
        var id = _ref2.id, x = _ref2.x, y = _ref2.y, width = _ref2.width, height = _ref2.height, _ref2$near = _ref2.near, near = _ref2$near === void 0 ? 0.1 : _ref2$near, _ref2$far = _ref2.far, far = _ref2$far === void 0 ? 1e3 : _ref2$far, _ref2$zoom = _ref2.zoom, zoom = _ref2$zoom === void 0 ? 0 : _ref2$zoom, _ref2$target = _ref2.target, target = _ref2$target === void 0 ? [0, 0, 0] : _ref2$target;
        _classCallCheck(this, OrthographicViewport2);
        var scale6 = Math.pow(2, zoom);
        return _possibleConstructorReturn(_this, new Viewport({
          id,
          x,
          y,
          width,
          height,
          position: target,
          viewMatrix: viewMatrix.clone().scale(scale6),
          projectionMatrix: getProjectionMatrix2({
            width,
            height,
            near,
            far
          }),
          zoom
        }));
      }
      return OrthographicViewport2;
    }(Viewport);
    OrthographicView = function(_View) {
      _inherits(OrthographicView2, _View);
      function OrthographicView2(props) {
        _classCallCheck(this, OrthographicView2);
        return _possibleConstructorReturn(this, _getPrototypeOf(OrthographicView2).call(this, Object.assign({}, props, {
          type: OrthographicViewport
        })));
      }
      _createClass(OrthographicView2, [{
        key: "controller",
        get: function get2() {
          return this._getControllerProps({
            type: OrthographicController
          });
        }
      }]);
      return OrthographicView2;
    }(View);
    OrthographicView.displayName = "OrthographicView";
  }
});

// node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js
var LINEAR_TRANSITION_PROPS4, GlobeState, GlobeController;
var init_globe_controller = __esm({
  "node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js"() {
    init_get();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm15();
    init_controller();
    init_map_controller();
    init_math_utils3();
    init_linear_interpolator();
    init_transition_manager();
    LINEAR_TRANSITION_PROPS4 = {
      transitionDuration: 300,
      transitionEasing: function transitionEasing5(t) {
        return t;
      },
      transitionInterpolator: new LinearInterpolator(["longitude", "latitude", "zoom"]),
      transitionInterruption: TRANSITION_EVENTS.BREAK
    };
    GlobeState = function(_MapState) {
      _inherits(GlobeState2, _MapState);
      function GlobeState2() {
        _classCallCheck(this, GlobeState2);
        return _possibleConstructorReturn(this, _getPrototypeOf(GlobeState2).apply(this, arguments));
      }
      _createClass(GlobeState2, [{
        key: "_applyConstraints",
        value: function _applyConstraints(props) {
          var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom;
          props.zoom = clamp(zoom, minZoom, maxZoom);
          var longitude = props.longitude, latitude = props.latitude;
          if (longitude < -180 || longitude > 180) {
            props.longitude = mod2(longitude + 180, 360) - 180;
          }
          props.latitude = clamp(latitude, -89, 89);
          return props;
        }
      }]);
      return GlobeState2;
    }(MapState);
    GlobeController = function(_Controller) {
      _inherits(GlobeController2, _Controller);
      function GlobeController2(props) {
        var _this;
        _classCallCheck(this, GlobeController2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(GlobeController2).call(this, GlobeState, props));
        _this.invertPan = true;
        return _this;
      }
      _createClass(GlobeController2, [{
        key: "setProps",
        value: function setProps(props) {
          _get(_getPrototypeOf(GlobeController2.prototype), "setProps", this).call(this, props);
          this.dragRotate = false;
          this.touchRotate = false;
        }
      }, {
        key: "_getTransitionProps",
        value: function _getTransitionProps() {
          return LINEAR_TRANSITION_PROPS4;
        }
      }]);
      return GlobeController2;
    }(Controller);
  }
});

// node_modules/@deck.gl/core/dist/esm/views/globe-view.js
function ownKeys24(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread24(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys24(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys24(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var GlobeView;
var init_globe_view = __esm({
  "node_modules/@deck.gl/core/dist/esm/views/globe-view.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_view();
    init_globe_viewport();
    init_globe_controller();
    GlobeView = function(_View) {
      _inherits(GlobeView2, _View);
      function GlobeView2(props) {
        _classCallCheck(this, GlobeView2);
        return _possibleConstructorReturn(this, _getPrototypeOf(GlobeView2).call(this, _objectSpread24({}, props, {
          type: GlobeViewport
        })));
      }
      _createClass(GlobeView2, [{
        key: "controller",
        get: function get2() {
          return this._getControllerProps({
            type: GlobeController
          });
        }
      }]);
      return GlobeView2;
    }(View);
    GlobeView.displayName = "GlobeView";
  }
});

// node_modules/@deck.gl/core/dist/esm/transitions/viewport-fly-to-interpolator.js
var LINEARLY_INTERPOLATED_PROPS, DEFAULT_OPTS2, FlyToInterpolator;
var init_viewport_fly_to_interpolator = __esm({
  "node_modules/@deck.gl/core/dist/esm/transitions/viewport-fly-to-interpolator.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_transition_interpolator();
    init_esm15();
    init_esm16();
    LINEARLY_INTERPOLATED_PROPS = ["bearing", "pitch"];
    DEFAULT_OPTS2 = {
      speed: 1.2,
      curve: 1.414
    };
    FlyToInterpolator = function(_TransitionInterpolat) {
      _inherits(FlyToInterpolator2, _TransitionInterpolat);
      function FlyToInterpolator2() {
        var _this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, FlyToInterpolator2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(FlyToInterpolator2).call(this, {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch"],
          extract: ["width", "height", "longitude", "latitude", "zoom", "bearing", "pitch"],
          required: ["width", "height", "latitude", "longitude", "zoom"]
        }));
        _this.props = Object.assign({}, DEFAULT_OPTS2, props);
        return _this;
      }
      _createClass(FlyToInterpolator2, [{
        key: "interpolateProps",
        value: function interpolateProps(startProps, endProps, t) {
          var viewport = flyToViewport(startProps, endProps, t, this.props);
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = LINEARLY_INTERPOLATED_PROPS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var key = _step.value;
              viewport[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return viewport;
        }
      }, {
        key: "getDuration",
        value: function getDuration(startProps, endProps) {
          var transitionDuration = endProps.transitionDuration;
          if (transitionDuration === "auto") {
            transitionDuration = getFlyToDuration(startProps, endProps, this.props);
          }
          return transitionDuration;
        }
      }]);
      return FlyToInterpolator2;
    }(TransitionInterpolator);
  }
});

// node_modules/@deck.gl/core/dist/esm/utils/tesselator.js
var Tesselator;
var init_tesselator = __esm({
  "node_modules/@deck.gl/core/dist/esm/utils/tesselator.js"() {
    init_classCallCheck();
    init_createClass();
    init_iterable_utils();
    init_typed_array_manager();
    init_assert10();
    init_esm14();
    Tesselator = function() {
      function Tesselator2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, Tesselator2);
        var _opts$attributes = opts.attributes, attributes = _opts$attributes === void 0 ? {} : _opts$attributes;
        this.typedArrayManager = typed_array_manager_default;
        this.indexStarts = null;
        this.vertexStarts = null;
        this.vertexCount = 0;
        this.instanceCount = 0;
        this.attributes = {};
        this._attributeDefs = attributes;
        this.opts = opts;
        this.updateGeometry(opts);
        Object.seal(this);
      }
      _createClass(Tesselator2, [{
        key: "updateGeometry",
        value: function updateGeometry(opts) {
          Object.assign(this.opts, opts);
          var _this$opts = this.opts, data = _this$opts.data, _this$opts$buffers = _this$opts.buffers, buffers = _this$opts$buffers === void 0 ? {} : _this$opts$buffers, getGeometry = _this$opts.getGeometry, geometryBuffer = _this$opts.geometryBuffer, positionFormat = _this$opts.positionFormat, dataChanged = _this$opts.dataChanged, _this$opts$normalize = _this$opts.normalize, normalize4 = _this$opts$normalize === void 0 ? true : _this$opts$normalize;
          this.data = data;
          this.getGeometry = getGeometry;
          this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
          this.buffers = buffers;
          this.normalize = normalize4;
          if (geometryBuffer) {
            assert10(data.startIndices, "binary data missing startIndices");
            this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
            if (!normalize4) {
              buffers.positions = geometryBuffer;
            }
          }
          this.geometryBuffer = buffers.positions;
          if (Array.isArray(dataChanged)) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var dataRange = _step.value;
                this._rebuildGeometry(dataRange);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          } else {
            this._rebuildGeometry();
          }
        }
      }, {
        key: "updatePartialGeometry",
        value: function updatePartialGeometry(_ref) {
          var startRow = _ref.startRow, endRow = _ref.endRow;
          this._rebuildGeometry({
            startRow,
            endRow
          });
        }
      }, {
        key: "normalizeGeometry",
        value: function normalizeGeometry(geometry) {
          return geometry;
        }
      }, {
        key: "updateGeometryAttributes",
        value: function updateGeometryAttributes(geometry, startIndex, size) {
          throw new Error("Not implemented");
        }
      }, {
        key: "getGeometrySize",
        value: function getGeometrySize(geometry) {
          throw new Error("Not implemented");
        }
      }, {
        key: "getGeometryFromBuffer",
        value: function getGeometryFromBuffer(geometryBuffer) {
          var value4 = geometryBuffer.value || geometryBuffer;
          assert10(ArrayBuffer.isView(value4), "cannot read geometries");
          return getAccessorFromBuffer(value4, {
            size: this.positionSize,
            offset: geometryBuffer.offset,
            stride: geometryBuffer.stride,
            startIndices: this.data.startIndices
          });
        }
      }, {
        key: "_allocate",
        value: function _allocate(instanceCount, copy2) {
          var attributes = this.attributes, buffers = this.buffers, _attributeDefs = this._attributeDefs, typedArrayManager = this.typedArrayManager;
          for (var name in _attributeDefs) {
            if (name in buffers) {
              typedArrayManager.release(attributes[name]);
              attributes[name] = null;
            } else {
              var def = _attributeDefs[name];
              def.copy = copy2;
              attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
            }
          }
        }
      }, {
        key: "_forEachGeometry",
        value: function _forEachGeometry(visitor, startRow, endRow) {
          var data = this.data, getGeometry = this.getGeometry;
          var _createIterable = createIterable(data, startRow, endRow), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var object = _step2.value;
              objectInfo.index++;
              var geometry = getGeometry(object, objectInfo);
              visitor(geometry, objectInfo.index);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }, {
        key: "_rebuildGeometry",
        value: function _rebuildGeometry(dataRange) {
          var _this = this;
          if (!this.data || !this.getGeometry) {
            return;
          }
          var indexStarts = this.indexStarts, vertexStarts = this.vertexStarts, instanceCount = this.instanceCount;
          var data = this.data, geometryBuffer = this.geometryBuffer;
          var _ref2 = dataRange || {}, _ref2$startRow = _ref2.startRow, startRow = _ref2$startRow === void 0 ? 0 : _ref2$startRow, _ref2$endRow = _ref2.endRow, endRow = _ref2$endRow === void 0 ? Infinity : _ref2$endRow;
          var normalizedData = {};
          if (!dataRange) {
            indexStarts = [0];
            vertexStarts = [0];
          }
          if (this.normalize || !geometryBuffer) {
            this._forEachGeometry(function(geometry, dataIndex) {
              geometry = _this.normalizeGeometry(geometry);
              normalizedData[dataIndex] = geometry;
              vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + _this.getGeometrySize(geometry);
            }, startRow, endRow);
            instanceCount = vertexStarts[vertexStarts.length - 1];
          } else if (geometryBuffer.buffer instanceof Buffer) {
            var byteStride = geometryBuffer.stride || this.positionSize * 4;
            vertexStarts = data.startIndices;
            instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;
          } else {
            var bufferValue = geometryBuffer.value || geometryBuffer;
            var elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
            vertexStarts = data.startIndices;
            instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;
          }
          this._allocate(instanceCount, Boolean(dataRange));
          this.indexStarts = indexStarts;
          this.vertexStarts = vertexStarts;
          this.instanceCount = instanceCount;
          var context = {};
          this._forEachGeometry(function(geometry, dataIndex) {
            geometry = normalizedData[dataIndex] || geometry;
            context.vertexStart = vertexStarts[dataIndex];
            context.indexStart = indexStarts[dataIndex];
            var vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
            context.geometrySize = vertexEnd - vertexStarts[dataIndex];
            context.geometryIndex = dataIndex;
            _this.updateGeometryAttributes(geometry, context);
          }, startRow, endRow);
          this.vertexCount = indexStarts[indexStarts.length - 1];
        }
      }]);
      return Tesselator2;
    }();
  }
});

// node_modules/@deck.gl/core/dist/esm/index.js
var esm_exports5 = {};
__export(esm_exports5, {
  AmbientLight: () => AmbientLight,
  AttributeManager: () => AttributeManager,
  COORDINATE_SYSTEM: () => COORDINATE_SYSTEM,
  CompositeLayer: () => CompositeLayer,
  Controller: () => Controller,
  Deck: () => Deck,
  DeckRenderer: () => DeckRenderer,
  DirectionalLight: () => DirectionalLight,
  Effect: () => Effect,
  FirstPersonController: () => FirstPersonController,
  FirstPersonView: () => FirstPersonView,
  FlyToInterpolator: () => FlyToInterpolator,
  Layer: () => Layer,
  LayerExtension: () => LayerExtension,
  LayerManager: () => LayerManager,
  LightingEffect: () => LightingEffect,
  LinearInterpolator: () => LinearInterpolator,
  MapController: () => MapController,
  MapView: () => MapView,
  OrbitController: () => OrbitController,
  OrbitView: () => OrbitView,
  OrthographicController: () => OrthographicController,
  OrthographicView: () => OrthographicView,
  PointLight: () => PointLight,
  PostProcessEffect: () => PostProcessEffect,
  TRANSITION_EVENTS: () => TRANSITION_EVENTS,
  Tesselator: () => Tesselator,
  TransitionInterpolator: () => TransitionInterpolator,
  View: () => View,
  Viewport: () => Viewport,
  WebMercatorViewport: () => WebMercatorViewport2,
  _CameraLight: () => CameraLight,
  _GlobeController: () => GlobeController,
  _GlobeView: () => GlobeView,
  _GlobeViewport: () => GlobeViewport,
  _LayersPass: () => LayersPass,
  _SunLight: () => SunLight,
  _compareProps: () => compareProps,
  _count: () => count3,
  _fillArray: () => fillArray2,
  _flatten: () => flatten,
  _memoize: () => memoize,
  _mergeShaders: () => mergeShaders,
  createIterable: () => createIterable,
  fp64LowPart: () => fp64LowPart2,
  gouraudLighting: () => gouraudLighting,
  log: () => log_default,
  phongLighting: () => phongLighting,
  picking: () => picking_default,
  project: () => project_default,
  project32: () => project32_default,
  shadow: () => shadow_default
});
var init_esm18 = __esm({
  "node_modules/@deck.gl/core/dist/esm/index.js"() {
    init_init3();
    init_shaderlib();
    init_constants2();
    init_lighting_effect();
    init_ambient_light();
    init_directional_light();
    init_point_light();
    init_camera_light();
    init_sun_light();
    init_post_process_effect();
    init_layers_pass();
    init_deck();
    init_layer_manager();
    init_attribute_manager();
    init_layer();
    init_composite_layer();
    init_deck_renderer();
    init_viewport();
    init_web_mercator_viewport2();
    init_globe_viewport();
    init_shaderlib();
    init_view();
    init_map_view();
    init_first_person_view();
    init_orbit_view();
    init_orthographic_view();
    init_globe_view();
    init_controller();
    init_map_controller();
    init_globe_controller();
    init_first_person_controller();
    init_orbit_controller();
    init_orthographic_controller();
    init_effect();
    init_layer_extension();
    init_transition_manager();
    init_transition_interpolator();
    init_linear_interpolator();
    init_viewport_fly_to_interpolator();
    init_log2();
    init_iterable_utils();
    init_math_utils3();
    init_tesselator();
    init_flatten();
    init_count();
    init_memoize();
    init_shader2();
    init_props();
  }
});

export {
  require_regenerator,
  _asyncToGenerator,
  init_asyncToGenerator,
  _awaitAsyncGenerator,
  init_awaitAsyncGenerator,
  _wrapAsyncGenerator,
  init_wrapAsyncGenerator,
  _asyncIterator,
  init_asyncIterator,
  _classCallCheck,
  init_classCallCheck,
  _createClass,
  init_createClass,
  Stats,
  init_esm,
  _toConsumableArray,
  init_toConsumableArray,
  require_child_process,
  fetchFile,
  load,
  esm_exports,
  init_esm3 as init_esm2,
  log_default,
  log,
  isWebGL2,
  getParameters,
  withParameters,
  cssToDeviceRatio,
  init_esm9 as init_esm3,
  assert7 as assert,
  uid,
  Accessor,
  Buffer,
  Texture2D,
  readPixelsToBuffer,
  copyToTexture,
  FEATURES,
  hasFeature,
  hasFeatures,
  Framebuffer,
  cloneTextureFrom,
  init_esm10 as init_esm4,
  fp64arithmetic,
  fp64,
  assert9 as assert2,
  config,
  toRadians,
  toDegrees,
  degrees,
  clamp,
  lerp,
  equals,
  add,
  scale,
  length,
  negate,
  lerp2,
  sub,
  init_vec2,
  Vector2,
  length2,
  negate2,
  dot,
  init_vec3,
  Vector3,
  Matrix3,
  invert2 as invert,
  multiply3 as multiply,
  translate2 as translate,
  scale3 as scale2,
  rotateX2 as rotateX,
  rotateZ2 as rotateZ,
  getScaling,
  perspective,
  equals2,
  init_mat4,
  scale4 as scale3,
  transformMat43 as transformMat4,
  init_vec4,
  Matrix4,
  Quaternion,
  math_utils_default,
  init_esm11 as init_esm5,
  gouraudLighting,
  phongLighting,
  pbr,
  init_esm12 as init_esm6,
  Model,
  Transform,
  Geometry,
  CubeGeometry,
  init_esm13 as init_esm7,
  esm_exports3 as esm_exports2,
  init_esm14 as init_esm8,
  COORDINATE_SYSTEM,
  memoize,
  project_default,
  project32_default,
  _slicedToArray,
  init_slicedToArray,
  init_esm15 as init_esm9,
  WebMercatorViewport,
  normalizeViewportProps,
  flyToViewport,
  getFlyToDuration,
  init_esm16 as init_esm10,
  shadow_default,
  picking_default,
  _assertThisInitialized,
  init_assertThisInitialized,
  _possibleConstructorReturn,
  init_possibleConstructorReturn,
  _getPrototypeOf,
  init_getPrototypeOf,
  _setPrototypeOf,
  init_setPrototypeOf,
  _inherits,
  init_inherits,
  AmbientLight,
  DirectionalLight,
  Effect,
  _get,
  init_get,
  LayersPass,
  LightingEffect,
  fp64LowPart2 as fp64LowPart,
  Viewport,
  WebMercatorViewport2,
  createIterable,
  flatten,
  fillArray2 as fillArray,
  AttributeManager,
  compareProps,
  count3 as count,
  mergeShaders,
  Layer,
  LayerManager,
  View,
  TransitionInterpolator,
  LinearInterpolator,
  TRANSITION_EVENTS,
  Controller,
  MapController,
  MapView,
  DeckRenderer,
  EventManager,
  esm_exports4 as esm_exports3,
  init_esm17 as init_esm11,
  Deck,
  CompositeLayer,
  LayerExtension,
  PointLight,
  CameraLight,
  _objectWithoutProperties,
  init_objectWithoutProperties,
  SunLight,
  PostProcessEffect,
  GlobeViewport,
  FirstPersonController,
  FirstPersonView,
  OrbitController,
  OrbitView,
  OrthographicController,
  OrthographicView,
  GlobeController,
  GlobeView,
  FlyToInterpolator,
  Tesselator,
  esm_exports5 as esm_exports4,
  init_esm18 as init_esm12
};
/*! Bundled license information:

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@luma.gl/shadertools/dist/esm/modules/fxaa/fxaa.js:
  (**
   * ORIGINAL LICENCE
   * @license
   * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above copyright
   *    notice, this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   *  * Neither the name of NVIDIA CORPORATION nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
   * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=chunk-5T2OUC3W.js.map
