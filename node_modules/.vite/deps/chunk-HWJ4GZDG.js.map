{
  "version": 3,
  "sources": ["../../@deck.gl/extensions/src/brushing/shader-module.js", "../../@deck.gl/extensions/src/brushing/brushing.js", "../../@deck.gl/extensions/src/data-filter/shader-module.js", "../../@deck.gl/extensions/src/data-filter/data-filter.js", "../../@deck.gl/extensions/src/fp64/project64.glsl.js", "../../@deck.gl/extensions/src/fp64/project64.js", "../../@deck.gl/extensions/src/fp64/fp64.js", "../../@deck.gl/extensions/src/path-style/shaders.glsl.js", "../../@deck.gl/extensions/src/path-style/path-style.js", "../../@deck.gl/extensions/src/fill-style/shaders.glsl.js", "../../@deck.gl/extensions/src/fill-style/fill-style.js", "../../@deck.gl/extensions/src/index.js"],
  "sourcesContent": ["// Copyright (c) 2015-2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {project} from '@deck.gl/core';\n\nconst vs = `\n  uniform bool brushing_enabled;\n  uniform int brushing_target;\n  uniform vec2 brushing_mousePos;\n  uniform float brushing_radius;\n\n  #ifdef NON_INSTANCED_MODEL\n  attribute vec2 brushingTargets;\n  #else\n  attribute vec2 instanceBrushingTargets;\n  #endif\n\n  varying float brushing_isVisible;\n\n  bool brushing_isPointInRange(vec2 position) {\n    if (!brushing_enabled) {\n      return true;\n    }\n    vec2 source_commonspace = project_position(position);\n    vec2 target_commonspace = project_position(brushing_mousePos);\n    float distance = length((target_commonspace - source_commonspace) / project_uCommonUnitsPerMeter.xy);\n\n    return distance <= brushing_radius;\n  }\n\n  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {\n    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);\n  }\n\n  void brushing_setVisible(bool visible) {\n    brushing_isVisible = float(visible);\n  }\n`;\n\nconst fs = `\n  uniform bool brushing_enabled;\n  varying float brushing_isVisible;\n`;\n\nconst TARGET = {\n  source: 0,\n  target: 1,\n  custom: 2,\n  source_target: 3\n};\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': `\n    vec2 brushingTarget;\n    vec2 brushingSource;\n    if (brushing_target == 3) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n      brushingSource = geometry.worldPosition.xy;\n    } else if (brushing_target == 0) {\n      brushingTarget = geometry.worldPosition.xy;\n    } else if (brushing_target == 1) {\n      brushingTarget = geometry.worldPositionAlt.xy;\n    } else {\n      #ifdef NON_INSTANCED_MODEL\n      brushingTarget = brushingTargets;\n      #else\n      brushingTarget = instanceBrushingTargets;\n      #endif\n    }\n    bool visible;\n    if (brushing_target == 3) {\n      visible = brushing_arePointsInRange(brushingSource, brushingTarget);\n    } else {\n      visible = brushing_isPointInRange(brushingTarget);\n    }\n    brushing_setVisible(visible);\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (brushing_enabled && brushing_isVisible < 0.5) {\n      discard;\n    }\n  `\n};\n\nexport default {\n  name: 'brushing',\n  dependencies: [project],\n  vs,\n  fs,\n  inject,\n  getUniforms: opts => {\n    if (!opts || !opts.viewport) {\n      return {};\n    }\n    const {\n      brushingEnabled = true,\n      brushingRadius = 10000,\n      brushingTarget = 'source',\n      mousePosition,\n      viewport\n    } = opts;\n    return {\n      brushing_enabled: Boolean(\n        brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)\n      ),\n      brushing_radius: brushingRadius,\n      brushing_target: TARGET[brushingTarget] || 0,\n      brushing_mousePos: mousePosition\n        ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y])\n        : [0, 0]\n    };\n  }\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\nimport shaderModule from './shader-module';\n\nconst defaultProps = {\n  getBrushingTarget: {type: 'accessor', value: [0, 0]},\n\n  brushingTarget: 'source',\n  brushingEnabled: true,\n  brushingRadius: 10000\n};\n\nexport default class BrushingExtension extends LayerExtension {\n  getShaders(extension) {\n    return {\n      modules: [shaderModule]\n    };\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        brushingTargets: {\n          size: 2,\n          accessor: 'getBrushingTarget',\n          // Hack: extension's defaultProps is not merged with the layer's defaultProps,\n          // So we can't use the standard accessor when the prop is undefined\n          update: !this.props.getBrushingTarget && extension.useConstantTargetPositions,\n          shaderAttributes: {\n            brushingTargets: {\n              divisor: 0\n            },\n            instanceBrushingTargets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n\n    // Trigger redraw when mouse moves\n    // TODO - expose this in a better way\n    extension.onMouseMove = () => {\n      this.getCurrentLayer().setNeedsRedraw();\n    };\n    if (this.context.deck) {\n      this.context.deck.eventManager.on({\n        pointermove: extension.onMouseMove,\n        pointerleave: extension.onMouseMove\n      });\n    }\n  }\n\n  finalizeState(extension) {\n    // Remove event listeners\n    if (this.context.deck) {\n      this.context.deck.eventManager.off({\n        pointermove: extension.onMouseMove,\n        pointerleave: extension.onMouseMove\n      });\n    }\n  }\n\n  useConstantTargetPositions(attribute) {\n    attribute.constant = true;\n    attribute.value = new Float32Array(2);\n    return;\n  }\n}\n\nBrushingExtension.extensionName = 'BrushingExtension';\nBrushingExtension.defaultProps = defaultProps;\n", "/*\n * data filter shader module\n */\nconst vs = `\nuniform DATAFILTER_TYPE filter_min;\nuniform DATAFILTER_TYPE filter_softMin;\nuniform DATAFILTER_TYPE filter_softMax;\nuniform DATAFILTER_TYPE filter_max;\nuniform bool filter_useSoftMargin;\nuniform bool filter_enabled;\nuniform bool filter_transformSize;\n\n#ifdef NON_INSTANCED_MODEL\n  #define DATAFILTER_ATTRIB filterValues\n  #define DATAFILTER_ATTRIB_64LOW filterValues64Low\n#else\n  #define DATAFILTER_ATTRIB instanceFilterValues\n  #define DATAFILTER_ATTRIB_64LOW instanceFilterValues64Low\n#endif\n\nattribute DATAFILTER_TYPE DATAFILTER_ATTRIB;\n#ifdef DATAFILTER_DOUBLE\n  attribute DATAFILTER_TYPE DATAFILTER_ATTRIB_64LOW;\n\n  uniform DATAFILTER_TYPE filter_min64High;\n  uniform DATAFILTER_TYPE filter_max64High;\n#endif\n\nvarying float dataFilter_value;\n\nfloat dataFilter_reduceValue(float value) {\n  return value;\n}\nfloat dataFilter_reduceValue(vec2 value) {\n  return min(value.x, value.y);\n}\nfloat dataFilter_reduceValue(vec3 value) {\n  return min(min(value.x, value.y), value.z);\n}\nfloat dataFilter_reduceValue(vec4 value) {\n  return min(min(value.x, value.y), min(value.z, value.w));\n}\nvoid dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {\n  if (filter_enabled) {\n    if (filter_useSoftMargin) {\n      dataFilter_value = dataFilter_reduceValue(\n        smoothstep(filter_min, filter_softMin, valueFromMin) *\n        (1.0 - smoothstep(filter_softMax, filter_max, valueFromMax))\n      );\n    } else {\n      dataFilter_value = dataFilter_reduceValue(\n        step(filter_min, valueFromMin) * step(valueFromMax, filter_max)\n      );\n    }\n  } else {\n    dataFilter_value = 1.0;\n  }\n}\n`;\n\nconst fs = `\nuniform bool filter_transformColor;\nvarying float dataFilter_value;\n`;\n\nconst getUniforms = opts => {\n  if (!opts || !opts.extensions) {\n    return {};\n  }\n  const {\n    filterRange = [-1, 1],\n    filterEnabled = true,\n    filterTransformSize = true,\n    filterTransformColor = true\n  } = opts;\n  const filterSoftRange = opts.filterSoftRange || filterRange;\n\n  const uniforms = Number.isFinite(filterRange[0])\n    ? {\n        filter_min: filterRange[0],\n        filter_softMin: filterSoftRange[0],\n        filter_softMax: filterSoftRange[1],\n        filter_max: filterRange[1]\n      }\n    : {\n        filter_min: filterRange.map(r => r[0]),\n        filter_softMin: filterSoftRange.map(r => r[0]),\n        filter_softMax: filterSoftRange.map(r => r[1]),\n        filter_max: filterRange.map(r => r[1])\n      };\n  uniforms.filter_enabled = filterEnabled;\n  uniforms.filter_useSoftMargin = Boolean(opts.filterSoftRange);\n  uniforms.filter_transformSize = filterEnabled && filterTransformSize;\n  uniforms.filter_transformColor = filterEnabled && filterTransformColor;\n\n  return uniforms;\n};\n\nconst getUniforms64 = opts => {\n  if (!opts || !opts.extensions) {\n    return {};\n  }\n  const uniforms = getUniforms(opts);\n  if (Number.isFinite(uniforms.filter_min)) {\n    const min64High = Math.fround(uniforms.filter_min);\n    uniforms.filter_min -= min64High;\n    uniforms.filter_softMin -= min64High;\n    uniforms.filter_min64High = min64High;\n\n    const max64High = Math.fround(uniforms.filter_max);\n    uniforms.filter_max -= max64High;\n    uniforms.filter_softMax -= max64High;\n    uniforms.filter_max64High = max64High;\n  } else {\n    const min64High = uniforms.filter_min.map(Math.fround);\n    uniforms.filter_min = uniforms.filter_min.map((x, i) => x - min64High[i]);\n    uniforms.filter_softMin = uniforms.filter_softMin.map((x, i) => x - min64High[i]);\n    uniforms.filter_min64High = min64High;\n\n    const max64High = uniforms.filter_max.map(Math.fround);\n    uniforms.filter_max = uniforms.filter_max.map((x, i) => x - max64High[i]);\n    uniforms.filter_softMax = uniforms.filter_softMax.map((x, i) => x - max64High[i]);\n    uniforms.filter_max64High = max64High;\n  }\n  return uniforms;\n};\n\nconst inject = {\n  'vs:#main-start': `\n    #ifdef DATAFILTER_DOUBLE\n      dataFilter_setValue(\n        DATAFILTER_ATTRIB - filter_min64High + DATAFILTER_ATTRIB_64LOW,\n        DATAFILTER_ATTRIB - filter_max64High + DATAFILTER_ATTRIB_64LOW\n      );\n    #else\n      dataFilter_setValue(DATAFILTER_ATTRIB, DATAFILTER_ATTRIB);\n    #endif\n  `,\n\n  'vs:DECKGL_FILTER_SIZE': `\n    if (filter_transformSize) {\n      size = size * dataFilter_value;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (dataFilter_value == 0.0) discard;\n    if (filter_transformColor) {\n      color.a *= dataFilter_value;\n    }\n  `\n};\n\nexport const shaderModule = {\n  name: 'data-filter',\n  vs,\n  fs,\n  inject,\n  getUniforms\n};\n\nexport const shaderModule64 = {\n  name: 'data-filter-fp64',\n  vs,\n  fs,\n  inject,\n  getUniforms: getUniforms64\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension} from '@deck.gl/core';\nimport {shaderModule, shaderModule64} from './shader-module';\nimport GL from '@luma.gl/constants';\n\nconst defaultProps = {\n  getFilterValue: {type: 'accessor', value: 0},\n\n  filterEnabled: true,\n  filterRange: [-1, 1],\n  filterSoftRange: null,\n  filterTransformSize: true,\n  filterTransformColor: true\n};\n\nconst DATA_TYPE_FROM_SIZE = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\nexport default class DataFilterExtension extends LayerExtension {\n  constructor({filterSize = 1, fp64 = false} = {}) {\n    if (!DATA_TYPE_FROM_SIZE[filterSize]) {\n      throw new Error('filterSize out of range');\n    }\n\n    super({filterSize, fp64});\n  }\n\n  getShaders(extension) {\n    const {filterSize, fp64} = extension.opts;\n\n    return {\n      modules: [fp64 ? shaderModule64 : shaderModule],\n      defines: {\n        DATAFILTER_TYPE: DATA_TYPE_FROM_SIZE[filterSize],\n        DATAFILTER_DOUBLE: Boolean(fp64)\n      }\n    };\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (attributeManager) {\n      attributeManager.add({\n        filterValues: {\n          size: extension.opts.filterSize,\n          type: extension.opts.fp64 ? GL.DOUBLE : GL.FLOAT,\n          accessor: 'getFilterValue',\n          shaderAttributes: {\n            filterValues: {\n              divisor: 0\n            },\n            instanceFilterValues: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n  }\n}\n\nDataFilterExtension.extensionName = 'DataFilterExtension';\nDataFilterExtension.defaultProps = defaultProps;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nexport default `\\\n\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project_uViewProjectionMatrixFP64[16];\n\n// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sum_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition\n) {\n  // This is the local offset to the instance position\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_size(position.z);\n\n  // Apply web mercator projection (depends on coordinate system imn use)\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);\n\n  vec2 commonPosition64[4];\n  commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  commonPosition64[3] = vec2(1.0, 0.0);\n\n  commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_common_position_to_clipspace_fp64(commonPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64xyLow, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, commonPosition\n  );\n}\n`;\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {fp64} from '@luma.gl/shadertools';\nconst {fp64ify, fp64ifyMatrix4} = fp64;\nimport {project, _memoize as memoize} from '@deck.gl/core';\n\nimport project64Shader from './project64.glsl';\n\nexport default {\n  name: 'project64',\n  dependencies: [project, fp64],\n  vs: project64Shader,\n  getUniforms\n};\n\n// TODO - this module should calculate the 64 bit uniforms\n// It is currently done by project to minimize duplicated work\n\nconst DEFAULT_MODULE_OPTIONS = {};\nconst getMemoizedUniforms = memoize(calculateUniforms);\n\nfunction getUniforms(opts = DEFAULT_MODULE_OPTIONS) {\n  if (opts.viewport) {\n    const {viewProjectionMatrix, scale} = opts.viewport;\n    // We only need to update fp64 uniforms if fp32 projection is being updated\n    return getMemoizedUniforms({viewProjectionMatrix, scale});\n  }\n  return {};\n}\n\nfunction calculateUniforms({viewProjectionMatrix, scale}) {\n  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);\n  const scaleFP64 = fp64ify(scale);\n\n  return {\n    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,\n    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,\n    project64_uScale: scaleFP64\n  };\n}\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport project64 from './project64';\n\nexport default class Fp64Extension extends LayerExtension {\n  getShaders(opts) {\n    const {coordinateSystem} = this.props;\n    if (\n      coordinateSystem !== COORDINATE_SYSTEM.LNGLAT &&\n      coordinateSystem !== COORDINATE_SYSTEM.DEFAULT\n    ) {\n      throw new Error('fp64: coordinateSystem must be LNGLAT');\n    }\n\n    return {\n      modules: [project64]\n    };\n  }\n}\n\nFp64Extension.extensionName = 'Fp64Extension';\n", "export const dashShaders = {\n  inject: {\n    'vs:#decl': `\nattribute vec2 instanceDashArrays;\nvarying vec2 vDashArray;\n`,\n\n    'vs:#main-end': `\nvDashArray = instanceDashArrays;\n`,\n\n    'fs:#decl': `\nuniform float dashAlignMode;\nvarying vec2 vDashArray;\n\n// mod doesn't work correctly for negative numbers\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\n`,\n\n    // if given position is in the gap part of the dashed line\n    // dashArray.x: solid stroke length, relative to width\n    // dashArray.y: gap length, relative to width\n    // alignMode:\n    // 0 - no adjustment\n    // o----     ----     ----     ---- o----     -o----     ----     o\n    // 1 - stretch to fit, draw half dash at each end for nicer joints\n    // o--    ----    ----    ----    --o--      --o--     ----     --o\n    'fs:#main-start': `\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength > 0.0) {\n    unitLength = mix(\n      unitLength,\n      vPathLength / round(vPathLength / unitLength),\n      dashAlignMode\n    );\n\n    float offset = dashAlignMode * solidLength / 2.0;\n\n    if (\n      gapLength > 0.0 &&\n      vPathPosition.y >= 0.0 &&\n      vPathPosition.y <= vPathLength &&\n      mod2(vPathPosition.y + offset, unitLength) > solidLength\n    ) {\n      discard;\n    }\n  }  \n`\n  }\n};\n\nexport const offsetShaders = {\n  inject: {\n    'vs:#decl': `\nattribute float instanceOffsets;\n`,\n    'vs:DECKGL_FILTER_SIZE': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  size *= offsetWidth;\n`,\n    'vCornerOffset = offsetVec;': `\n  float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;\n  vec2 offsetCenter = -instanceOffsets * (isCap ? perp : miterVec * miterSize) * 2.0;\n  vCornerOffset = vCornerOffset * offsetWidth - offsetCenter;\n`,\n    'fs:#main-start': `\n  float isInside;\n  isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);\n  if (isInside == 0.0) {\n    discard;\n  }\n`\n  }\n};\n", "// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {LayerExtension, _mergeShaders as mergeShaders} from '@deck.gl/core';\nimport {dashShaders, offsetShaders} from './shaders.glsl';\n\nconst defaultProps = {\n  getDashArray: {type: 'accessor', value: [0, 0]},\n  getOffset: {type: 'accessor', value: 0},\n  dashJustified: false\n};\n\nexport default class PathStyleExtension extends LayerExtension {\n  constructor({dash = false, offset = false} = {}) {\n    super({dash, offset});\n  }\n\n  isEnabled(layer) {\n    return layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    // Merge shader injection\n    let result = {};\n    if (extension.opts.dash) {\n      result = mergeShaders(result, dashShaders);\n    }\n    if (extension.opts.offset) {\n      result = mergeShaders(result, offsetShaders);\n    }\n\n    return result;\n  }\n\n  initializeState(context, extension) {\n    const attributeManager = this.getAttributeManager();\n    if (!attributeManager || !extension.isEnabled(this)) {\n      // This extension only works with the PathLayer\n      return;\n    }\n\n    extension.enabled = true;\n\n    if (extension.opts.dash) {\n      attributeManager.addInstanced({\n        instanceDashArrays: {size: 2, accessor: 'getDashArray'}\n      });\n    }\n    if (extension.opts.offset) {\n      attributeManager.addInstanced({\n        instanceOffsets: {size: 1, accessor: 'getOffset'}\n      });\n    }\n  }\n\n  updateState(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const uniforms = {};\n\n    if (extension.opts.dash) {\n      uniforms.dashAlignMode = this.props.dashJustified ? 1 : 0;\n    }\n\n    this.state.model.setUniforms(uniforms);\n  }\n}\n\nPathStyleExtension.extensionName = 'PathStyleExtension';\nPathStyleExtension.defaultProps = defaultProps;\n", "import {project, COORDINATE_SYSTEM} from '@deck.gl/core';\n\n/*\n * fill pattern shader module\n */\nconst patternVs = `\n#ifdef NON_INSTANCED_MODEL\n  #define FILL_PATTERN_FRAME_ATTRIB fillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB fillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB fillPatternOffsets\n#else\n  #define FILL_PATTERN_FRAME_ATTRIB instanceFillPatternFrames\n  #define FILL_PATTERN_SCALE_ATTRIB instanceFillPatternScales\n  #define FILL_PATTERN_OFFSET_ATTRIB instanceFillPatternOffsets\n#endif\n\nattribute vec4 FILL_PATTERN_FRAME_ATTRIB;\nattribute float FILL_PATTERN_SCALE_ATTRIB;\nattribute vec2 FILL_PATTERN_OFFSET_ATTRIB;\n\nuniform bool fill_patternEnabled;\nuniform vec2 fill_patternTextureSize;\n\nvarying vec2 fill_uv;\nvarying vec4 fill_patternBounds;\nvarying vec3 fill_patternPlacement;\n`;\n\nconst patternFs = `\nuniform bool fill_patternEnabled;\nuniform bool fill_patternMask;\nuniform sampler2D fill_patternTexture;\nuniform vec2 fill_uvCoordinateOrigin;\n\nvarying vec4 fill_patternBounds;\nvarying vec3 fill_patternPlacement;\nvarying vec2 fill_uv;\n\nconst float FILL_UV_SCALE = 512.0 / 40000000.0;\n`;\n\nconst inject = {\n  'vs:DECKGL_FILTER_GL_POSITION': `\n    fill_uv = geometry.position.xy;\n  `,\n\n  'vs:DECKGL_FILTER_COLOR': `\n    if (fill_patternEnabled) {\n      fill_patternBounds = FILL_PATTERN_FRAME_ATTRIB / vec4(fill_patternTextureSize, fill_patternTextureSize);\n      fill_patternPlacement.xy = FILL_PATTERN_OFFSET_ATTRIB;\n      fill_patternPlacement.z = FILL_PATTERN_SCALE_ATTRIB * FILL_PATTERN_FRAME_ATTRIB.w;\n    }\n  `,\n\n  'fs:DECKGL_FILTER_COLOR': `\n    if (fill_patternEnabled) {\n      float scale = FILL_UV_SCALE * fill_patternPlacement.z;\n      vec2 patternUV = mod(mod(fill_uvCoordinateOrigin, scale) + fill_uv, scale) / scale;\n      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);\n\n      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;\n      texCoords.y = 1.0 - texCoords.y;\n\n      vec4 patternColor = texture2D(fill_patternTexture, texCoords);\n      if (fill_patternMask) {\n        color.a *= patternColor.a;\n      } else {\n        color.rgb = patternColor.rgb;\n      }\n    }\n  `\n};\n\nfunction getPatternUniforms(opts = {}, uniforms) {\n  if ('fillPatternTexture' in opts) {\n    const {fillPatternTexture} = opts;\n    return {\n      fill_patternTexture: fillPatternTexture,\n      fill_patternTextureSize: [fillPatternTexture.width, fillPatternTexture.height]\n    };\n  }\n  if (opts.viewport) {\n    const {viewport, fillPatternMask = true, fillPatternEnabled = true} = opts;\n    const {project_uCoordinateOrigin, project_uCoordinateSystem} = uniforms;\n\n    const coordinateOriginCommon =\n      project_uCoordinateSystem === COORDINATE_SYSTEM.CARTESIAN\n        ? project_uCoordinateOrigin\n        : viewport.projectPosition(project_uCoordinateOrigin);\n\n    return {\n      fill_uvCoordinateOrigin: coordinateOriginCommon.slice(0, 2),\n      fill_patternMask: fillPatternMask,\n      fill_patternEnabled: fillPatternEnabled\n    };\n  }\n  return {};\n}\n\nexport const patternShaders = {\n  name: 'fill-pattern',\n  vs: patternVs,\n  fs: patternFs,\n  inject,\n  dependencies: [project],\n  getUniforms: getPatternUniforms\n};\n", "import {LayerExtension} from '@deck.gl/core';\nimport {Texture2D} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport {patternShaders} from './shaders.glsl';\n\nconst defaultProps = {\n  fillPatternEnabled: true,\n  fillPatternAtlas: null,\n  fillPatternMapping: null,\n  fillPatternMask: true,\n  getFillPattern: {type: 'accessor', value: d => d.pattern},\n  getFillPatternScale: {type: 'accessor', value: 1},\n  getFillPatternOffset: {type: 'accessor', value: [0, 0]}\n};\n\nconst DEFAULT_TEXTURE_PARAMETERS = {\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR,\n  // GL.LINEAR is the default value but explicitly set it here\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  // for texture boundary artifact\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\n\nexport default class FillStyleExtension extends LayerExtension {\n  constructor({pattern = false} = {}) {\n    super({pattern});\n  }\n\n  isEnabled(layer) {\n    return layer.getAttributeManager() && !layer.state.pathTesselator;\n  }\n\n  getShaders(extension) {\n    if (!extension.isEnabled(this)) {\n      return null;\n    }\n\n    return {\n      modules: [extension.opts.pattern && patternShaders].filter(Boolean)\n    };\n  }\n\n  initializeState(context, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const attributeManager = this.getAttributeManager();\n\n    if (extension.opts.pattern) {\n      attributeManager.add({\n        fillPatternFrames: {\n          size: 4,\n          accessor: 'getFillPattern',\n          transform: extension.getPatternFrame.bind(this),\n          shaderAttributes: {\n            fillPatternFrames: {\n              divisor: 0\n            },\n            instanceFillPatternFrames: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternScales: {\n          size: 1,\n          accessor: 'getFillPatternScale',\n          defaultValue: 1,\n          shaderAttributes: {\n            fillPatternScales: {\n              divisor: 0\n            },\n            instanceFillPatternScales: {\n              divisor: 1\n            }\n          }\n        },\n        fillPatternOffsets: {\n          size: 2,\n          accessor: 'getFillPatternOffset',\n          shaderAttributes: {\n            fillPatternOffsets: {\n              divisor: 0\n            },\n            instanceFillPatternOffsets: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n    this.setState({\n      emptyTexture: new Texture2D(this.context.gl, {\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState({props, oldProps}, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    if (props.fillPatternAtlas && props.fillPatternAtlas !== oldProps.fillPatternAtlas) {\n      extension.loadPatternAtlas.call(this, props);\n    }\n    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {\n      extension.loadPatternMapping.call(this, props);\n    }\n  }\n\n  draw(params, extension) {\n    if (!extension.isEnabled(this)) {\n      return;\n    }\n\n    const {patternTexture} = this.state;\n    this.setModuleParameters({\n      fillPatternTexture: patternTexture || this.state.emptyTexture\n    });\n  }\n\n  finalizeState() {\n    const {patternTexture, emptyTexture} = this.state;\n    if (patternTexture) {\n      patternTexture.delete();\n    }\n    if (emptyTexture) {\n      emptyTexture.delete();\n    }\n  }\n\n  async loadPatternAtlas({fillPatternAtlas, fetch}) {\n    if (this.state.patternTexture) {\n      this.state.patternTexture.delete();\n    }\n    this.setState({patternTexture: null});\n    let image = fillPatternAtlas;\n    if (typeof image === 'string') {\n      image = await fetch(image, {propName: 'fillPatternAtlas', layer: this});\n    }\n    const patternTexture =\n      image instanceof Texture2D\n        ? image\n        : new Texture2D(this.context.gl, {\n            data: image,\n            parameters: DEFAULT_TEXTURE_PARAMETERS\n          });\n    this.setState({patternTexture});\n  }\n\n  async loadPatternMapping({fillPatternMapping, fetch}) {\n    this.setState({patternMapping: null});\n    let patternMapping = fillPatternMapping;\n    if (typeof patternMapping === 'string') {\n      patternMapping = await fetch(patternMapping, {\n        propName: 'fillPatternMapping',\n        layer: this\n      });\n    }\n    this.setState({patternMapping});\n    this.getAttributeManager().invalidate('getFillPattern');\n    this.setNeedsUpdate();\n  }\n\n  getPatternFrame(name) {\n    const {patternMapping} = this.state;\n    const def = patternMapping && patternMapping[name];\n    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];\n  }\n}\n\nFillStyleExtension.extensionName = 'FillStyleExtension';\nFillStyleExtension.defaultProps = defaultProps;\n", "export {default as BrushingExtension} from './brushing/brushing';\nexport {default as DataFilterExtension} from './data-filter/data-filter';\nexport {default as Fp64Extension} from './fp64/fp64';\nexport {default as PathStyleExtension} from './path-style/path-style';\nexport {default as FillStyleExtension} from './fill-style/fill-style';\n\n// Shader module\nexport {default as project64} from './fp64/project64';\n"],
  "mappings": "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",
  "names": ["vs", "fs", "TARGET", "inject", "init_esm", "source", "target", "custom", "source_target", "name", "dependencies", "project", "getUniforms", "opts", "viewport", "brushingEnabled", "brushingRadius", "brushingTarget", "mousePosition", "brushing_enabled", "Boolean", "containsPixel", "brushing_radius", "brushing_target", "brushing_mousePos", "unproject", "x", "y", "defaultProps", "BrushingExtension", "init_esm", "getBrushingTarget", "type", "value", "brushingTarget", "brushingEnabled", "brushingRadius", "extension", "modules", "shaderModule", "context", "attributeManager", "getAttributeManager", "add", "brushingTargets", "size", "accessor", "update", "props", "useConstantTargetPositions", "shaderAttributes", "divisor", "instanceBrushingTargets", "onMouseMove", "getCurrentLayer", "setNeedsRedraw", "deck", "eventManager", "on", "pointermove", "pointerleave", "off", "attribute", "constant", "Float32Array", "LayerExtension", "extensionName", "vs", "fs", "getUniforms", "getUniforms64", "inject", "shaderModule", "shaderModule64", "init_shader_module", "opts", "extensions", "filterRange", "filterEnabled", "filterTransformSize", "filterTransformColor", "filterSoftRange", "uniforms", "Number", "isFinite", "filter_min", "filter_softMin", "filter_softMax", "filter_max", "map", "r", "filter_enabled", "filter_useSoftMargin", "Boolean", "filter_transformSize", "filter_transformColor", "min64High", "Math", "fround", "filter_min64High", "max64High", "filter_max64High", "x", "i", "name", "defaultProps", "DATA_TYPE_FROM_SIZE", "DataFilterExtension", "init_esm", "init_shader_module", "getFilterValue", "type", "value", "filterEnabled", "filterRange", "filterSoftRange", "filterTransformSize", "filterTransformColor", "filterSize", "fp64", "Error", "extension", "opts", "modules", "shaderModule64", "shaderModule", "defines", "DATAFILTER_TYPE", "DATAFILTER_DOUBLE", "Boolean", "context", "attributeManager", "getAttributeManager", "add", "filterValues", "size", "accessor", "shaderAttributes", "divisor", "instanceFilterValues", "LayerExtension", "extensionName", "getUniforms", "opts", "DEFAULT_MODULE_OPTIONS", "viewport", "viewProjectionMatrix", "scale", "getMemoizedUniforms", "calculateUniforms", "glViewProjectionMatrixFP64", "fp64ifyMatrix4", "scaleFP64", "fp64ify", "project_uViewProjectionMatrixFP64", "project64_uViewProjectionMatrix", "project64_uScale", "init_esm", "fp64", "name", "dependencies", "project", "vs", "project64Shader", "memoize", "Fp64Extension", "init_esm", "opts", "coordinateSystem", "props", "COORDINATE_SYSTEM", "LNGLAT", "DEFAULT", "Error", "modules", "project64", "LayerExtension", "extensionName", "dashShaders", "offsetShaders", "inject", "defaultProps", "PathStyleExtension", "init_esm", "getDashArray", "type", "value", "getOffset", "dashJustified", "dash", "offset", "layer", "state", "pathTesselator", "extension", "isEnabled", "result", "opts", "mergeShaders", "dashShaders", "offsetShaders", "context", "attributeManager", "getAttributeManager", "enabled", "addInstanced", "instanceDashArrays", "size", "accessor", "instanceOffsets", "params", "uniforms", "dashAlignMode", "props", "model", "setUniforms", "LayerExtension", "extensionName", "getPatternUniforms", "opts", "uniforms", "fillPatternTexture", "fill_patternTexture", "fill_patternTextureSize", "width", "height", "viewport", "fillPatternMask", "fillPatternEnabled", "project_uCoordinateOrigin", "project_uCoordinateSystem", "coordinateOriginCommon", "COORDINATE_SYSTEM", "CARTESIAN", "projectPosition", "fill_uvCoordinateOrigin", "slice", "fill_patternMask", "fill_patternEnabled", "patternVs", "patternFs", "inject", "patternShaders", "init_shaders_glsl", "init_esm", "name", "vs", "fs", "dependencies", "project", "getUniforms", "defaultProps", "DEFAULT_TEXTURE_PARAMETERS", "FillStyleExtension", "init_esm", "init_shaders_glsl", "fillPatternEnabled", "fillPatternAtlas", "fillPatternMapping", "fillPatternMask", "getFillPattern", "type", "value", "d", "pattern", "getFillPatternScale", "getFillPatternOffset", "layer", "getAttributeManager", "state", "pathTesselator", "extension", "isEnabled", "modules", "opts", "patternShaders", "filter", "Boolean", "context", "attributeManager", "add", "fillPatternFrames", "size", "accessor", "transform", "getPatternFrame", "bind", "shaderAttributes", "divisor", "instanceFillPatternFrames", "fillPatternScales", "defaultValue", "instanceFillPatternScales", "fillPatternOffsets", "instanceFillPatternOffsets", "setState", "emptyTexture", "Texture2D", "gl", "data", "Uint8Array", "width", "height", "props", "oldProps", "loadPatternAtlas", "call", "loadPatternMapping", "params", "patternTexture", "setModuleParameters", "fillPatternTexture", "fetch", "image", "propName", "parameters", "patternMapping", "invalidate", "setNeedsUpdate", "name", "def", "x", "y", "LayerExtension", "extensionName", "init_esm"]
}
