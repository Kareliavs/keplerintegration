import {
  COORDINATE_SYSTEM,
  CompositeLayer,
  CubeGeometry,
  FEATURES,
  Geometry,
  Layer,
  Model,
  Stats,
  Tesselator,
  Texture2D,
  _asyncToGenerator,
  _classCallCheck,
  _createClass,
  _get,
  _getPrototypeOf,
  _inherits,
  _possibleConstructorReturn,
  _slicedToArray,
  _toConsumableArray,
  cloneTextureFrom,
  copyToTexture,
  createIterable,
  gouraudLighting,
  hasFeatures,
  init_asyncIterator,
  init_asyncToGenerator,
  init_awaitAsyncGenerator,
  init_classCallCheck,
  init_createClass,
  init_esm,
  init_esm12 as init_esm6,
  init_esm2,
  init_esm5 as init_esm3,
  init_esm8 as init_esm4,
  init_esm9 as init_esm5,
  init_get,
  init_getPrototypeOf,
  init_inherits,
  init_possibleConstructorReturn,
  init_slicedToArray,
  init_toConsumableArray,
  init_wrapAsyncGenerator,
  lerp,
  load,
  log_default,
  picking_default,
  project32_default,
  require_child_process,
  require_regenerator,
  uid
} from "./chunk-5T2OUC3W.js";
import {
  _defineProperty,
  _typeof,
  init_defineProperty,
  init_typeof
} from "./chunk-K5YS6U7Z.js";
import {
  __commonJS,
  __esm,
  __export,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js
var arc_layer_vertex_glsl_default;
var init_arc_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-vertex.glsl.js"() {
    arc_layer_vertex_glsl_default = "#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  float unitZ = dh == 0.0 ? 0.0 : deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    vec3 source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    vec3 target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n  \n    float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n    float nextSegmentRatio = getSegmentRatio(min(numSegments, segmentIndex + 1.0));\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source = project_position(instanceSourcePositions, instanceSourcePositions64Low);\n    vec3 target = project_position(instanceTargetPositions, instanceTargetPositions64Low);\n\n    float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js
var arc_layer_fragment_glsl_default;
var init_arc_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer-fragment.glsl.js"() {
    arc_layer_fragment_glsl_default = "#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js
var DEFAULT_COLOR, defaultProps, ArcLayer;
var init_arc_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/arc-layer/arc-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_arc_layer_vertex_glsl();
    init_arc_layer_fragment_glsl();
    DEFAULT_COLOR = [0, 0, 0, 255];
    defaultProps = {
      getSourcePosition: {
        type: "accessor",
        value: function value(x) {
          return x.sourcePosition;
        }
      },
      getTargetPosition: {
        type: "accessor",
        value: function value2(x) {
          return x.targetPosition;
        }
      },
      getSourceColor: {
        type: "accessor",
        value: DEFAULT_COLOR
      },
      getTargetColor: {
        type: "accessor",
        value: DEFAULT_COLOR
      },
      getWidth: {
        type: "accessor",
        value: 1
      },
      getHeight: {
        type: "accessor",
        value: 1
      },
      getTilt: {
        type: "accessor",
        value: 0
      },
      greatCircle: false,
      widthUnits: "pixels",
      widthScale: {
        type: "number",
        value: 1,
        min: 0
      },
      widthMinPixels: {
        type: "number",
        value: 0,
        min: 0
      },
      widthMaxPixels: {
        type: "number",
        value: Number.MAX_SAFE_INTEGER,
        min: 0
      }
    };
    ArcLayer = function(_Layer) {
      _inherits(ArcLayer2, _Layer);
      function ArcLayer2() {
        _classCallCheck(this, ArcLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(ArcLayer2).apply(this, arguments));
      }
      _createClass(ArcLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return _get(_getPrototypeOf(ArcLayer2.prototype), "getShaders", this).call(this, {
            vs: arc_layer_vertex_glsl_default,
            fs: arc_layer_fragment_glsl_default,
            modules: [project32_default, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var attributeManager = this.getAttributeManager();
          attributeManager.addInstanced({
            instanceSourcePositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getSourcePosition"
            },
            instanceTargetPositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getTargetPosition"
            },
            instanceSourceColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getSourceColor",
              defaultValue: DEFAULT_COLOR
            },
            instanceTargetColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getTargetColor",
              defaultValue: DEFAULT_COLOR
            },
            instanceWidths: {
              size: 1,
              transition: true,
              accessor: "getWidth",
              defaultValue: 1
            },
            instanceHeights: {
              size: 1,
              transition: true,
              accessor: "getHeight",
              defaultValue: 1
            },
            instanceTilts: {
              size: 1,
              transition: true,
              accessor: "getTilt",
              defaultValue: 0
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          _get(_getPrototypeOf(ArcLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            this.getAttributeManager().invalidateAll();
          }
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var viewport = this.context.viewport;
          var _this$props = this.props, widthUnits = _this$props.widthUnits, widthScale = _this$props.widthScale, widthMinPixels = _this$props.widthMinPixels, widthMaxPixels = _this$props.widthMaxPixels, greatCircle = _this$props.greatCircle;
          var widthMultiplier = widthUnits === "pixels" ? viewport.metersPerPixel : 1;
          this.state.model.setUniforms(uniforms).setUniforms({
            greatCircle,
            widthScale: widthScale * widthMultiplier,
            widthMinPixels,
            widthMaxPixels
          }).draw();
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          var positions = [];
          var NUM_SEGMENTS = 50;
          for (var i = 0; i < NUM_SEGMENTS; i++) {
            positions = positions.concat([i, 1, 0, i, -1, 0]);
          }
          var model = new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 5,
              attributes: {
                positions: new Float32Array(positions)
              }
            }),
            isInstanced: true
          }));
          model.setUniforms({
            numSegments: NUM_SEGMENTS
          });
          return model;
        }
      }]);
      return ArcLayer2;
    }(Layer);
    ArcLayer.layerName = "ArcLayer";
    ArcLayer.defaultProps = defaultProps;
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js
function createMesh(bounds, resolution) {
  if (!resolution) {
    return createQuad(bounds);
  }
  var maxXSpan = Math.max(Math.abs(bounds[0][0] - bounds[3][0]), Math.abs(bounds[1][0] - bounds[2][0]));
  var maxYSpan = Math.max(Math.abs(bounds[1][1] - bounds[0][1]), Math.abs(bounds[2][1] - bounds[3][1]));
  var uCount = Math.ceil(maxXSpan / resolution) + 1;
  var vCount = Math.ceil(maxYSpan / resolution) + 1;
  var vertexCount = (uCount - 1) * (vCount - 1) * 6;
  var indices = new Uint32Array(vertexCount);
  var texCoords = new Float32Array(uCount * vCount * 2);
  var positions = new Float64Array(uCount * vCount * 3);
  var vertex = 0;
  var index = 0;
  for (var u = 0; u < uCount; u++) {
    var ut = u / (uCount - 1);
    for (var v = 0; v < vCount; v++) {
      var vt = v / (vCount - 1);
      var p = interpolateQuad(bounds, ut, vt);
      positions[vertex * 3 + 0] = p[0];
      positions[vertex * 3 + 1] = p[1];
      positions[vertex * 3 + 2] = p[2] || 0;
      texCoords[vertex * 2 + 0] = ut;
      texCoords[vertex * 2 + 1] = 1 - vt;
      if (u > 0 && v > 0) {
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - vCount - 1;
        indices[index++] = vertex - 1;
        indices[index++] = vertex - vCount;
        indices[index++] = vertex - 1;
        indices[index++] = vertex;
      }
      vertex++;
    }
  }
  return {
    vertexCount,
    positions,
    indices,
    texCoords
  };
}
function createQuad(bounds) {
  var positions = new Float64Array(12);
  for (var i = 0; i < bounds.length; i++) {
    positions[i * 3 + 0] = bounds[i][0];
    positions[i * 3 + 1] = bounds[i][1];
    positions[i * 3 + 2] = bounds[i][2] || 0;
  }
  return {
    vertexCount: 6,
    positions,
    indices: DEFAULT_INDICES,
    texCoords: DEFAULT_TEX_COORDS
  };
}
function interpolateQuad(quad, ut, vt) {
  return lerp(lerp(quad[0], quad[1], vt), lerp(quad[3], quad[2], vt), ut);
}
var DEFAULT_INDICES, DEFAULT_TEX_COORDS;
var init_create_mesh = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/create-mesh.js"() {
    init_esm5();
    DEFAULT_INDICES = new Uint16Array([0, 2, 1, 0, 3, 2]);
    DEFAULT_TEX_COORDS = new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]);
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js
var bitmap_layer_vertex_default;
var init_bitmap_layer_vertex = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-vertex.js"() {
    bitmap_layer_vertex_default = "\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js
var bitmap_layer_fragment_default;
var init_bitmap_layer_fragment = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer-fragment.js"() {
    bitmap_layer_fragment_default = "\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  return mix(transparentColor, vec4(color, 1.0), alpha);\n}\n\nvoid main(void) {\n  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = vTexCoord;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js
var _DEFAULT_TEXTURE_PARA, DEFAULT_TEXTURE_PARAMETERS, defaultProps2, BitmapLayer;
var init_bitmap_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/bitmap-layer/bitmap-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_defineProperty();
    init_esm6();
    init_esm4();
    init_create_mesh();
    init_bitmap_layer_vertex();
    init_bitmap_layer_fragment();
    DEFAULT_TEXTURE_PARAMETERS = (_DEFAULT_TEXTURE_PARA = {}, _defineProperty(_DEFAULT_TEXTURE_PARA, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA, 10243, 33071), _DEFAULT_TEXTURE_PARA);
    defaultProps2 = {
      image: {
        type: "object",
        value: null,
        async: true
      },
      bounds: {
        type: "array",
        value: [1, 0, 0, 1],
        compare: true
      },
      desaturate: {
        type: "number",
        min: 0,
        max: 1,
        value: 0
      },
      transparentColor: {
        type: "color",
        value: [0, 0, 0, 0]
      },
      tintColor: {
        type: "color",
        value: [255, 255, 255]
      }
    };
    BitmapLayer = function(_Layer) {
      _inherits(BitmapLayer2, _Layer);
      function BitmapLayer2() {
        _classCallCheck(this, BitmapLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(BitmapLayer2).apply(this, arguments));
      }
      _createClass(BitmapLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return _get(_getPrototypeOf(BitmapLayer2.prototype), "getShaders", this).call(this, {
            vs: bitmap_layer_vertex_default,
            fs: bitmap_layer_fragment_default,
            modules: [project32_default, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var _this = this;
          var attributeManager = this.getAttributeManager();
          attributeManager.remove(["instancePickingColors"]);
          var noAlloc = true;
          attributeManager.add({
            indices: {
              size: 1,
              isIndexed: true,
              update: function update(attribute) {
                return attribute.value = _this.state.mesh.indices;
              },
              noAlloc
            },
            positions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              update: function update(attribute) {
                return attribute.value = _this.state.mesh.positions;
              },
              noAlloc
            },
            texCoords: {
              size: 2,
              update: function update(attribute) {
                return attribute.value = _this.state.mesh.texCoords;
              },
              noAlloc
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            this.getAttributeManager().invalidateAll();
          }
          if (props.image !== oldProps.image) {
            this.loadTexture(props.image);
          }
          var attributeManager = this.getAttributeManager();
          if (props.bounds !== oldProps.bounds) {
            var oldMesh = this.state.mesh;
            var mesh = this._createMesh();
            this.state.model.setVertexCount(mesh.vertexCount);
            for (var key in mesh) {
              if (oldMesh && oldMesh[key] !== mesh[key]) {
                attributeManager.invalidate(key);
              }
            }
            this.setState({
              mesh
            });
          }
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          _get(_getPrototypeOf(BitmapLayer2.prototype), "finalizeState", this).call(this);
          if (this.state.bitmapTexture) {
            this.state.bitmapTexture["delete"]();
          }
        }
      }, {
        key: "_createMesh",
        value: function _createMesh() {
          var bounds = this.props.bounds;
          var normalizedBounds = bounds;
          if (Number.isFinite(bounds[0])) {
            normalizedBounds = [[bounds[0], bounds[1]], [bounds[0], bounds[3]], [bounds[2], bounds[3]], [bounds[2], bounds[1]]];
          }
          return createMesh(normalizedBounds, this.context.viewport.resolution);
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          if (!gl) {
            return null;
          }
          return new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 4,
              vertexCount: 6
            }),
            isInstanced: false
          }));
        }
      }, {
        key: "draw",
        value: function draw(opts) {
          var uniforms = opts.uniforms;
          var _this$state = this.state, bitmapTexture = _this$state.bitmapTexture, model = _this$state.model;
          var _this$props = this.props, image = _this$props.image, desaturate = _this$props.desaturate, transparentColor = _this$props.transparentColor, tintColor = _this$props.tintColor;
          if (bitmapTexture && image instanceof HTMLVideoElement && image.readyState > HTMLVideoElement.HAVE_METADATA) {
            var sizeChanged = bitmapTexture.width !== image.videoWidth || bitmapTexture.height !== image.videoHeight;
            if (sizeChanged) {
              bitmapTexture.resize({
                width: image.videoWidth,
                height: image.videoHeight,
                mipmaps: true
              });
              bitmapTexture.setSubImageData({
                data: image,
                paramters: DEFAULT_TEXTURE_PARAMETERS
              });
            } else {
              bitmapTexture.setSubImageData({
                data: image
              });
            }
            bitmapTexture.generateMipmap();
          }
          if (bitmapTexture && model) {
            model.setUniforms(Object.assign({}, uniforms, {
              bitmapTexture,
              desaturate,
              transparentColor: transparentColor.map(function(x) {
                return x / 255;
              }),
              tintColor: tintColor.slice(0, 3).map(function(x) {
                return x / 255;
              })
            })).draw();
          }
        }
      }, {
        key: "loadTexture",
        value: function loadTexture(image) {
          var gl = this.context.gl;
          if (this.state.bitmapTexture) {
            this.state.bitmapTexture["delete"]();
          }
          if (image instanceof Texture2D) {
            this.setState({
              bitmapTexture: image
            });
          } else if (image instanceof HTMLVideoElement) {
            this.setState({
              bitmapTexture: new Texture2D(gl, {
                width: 1,
                height: 1,
                parameters: DEFAULT_TEXTURE_PARAMETERS,
                mipmaps: false
              })
            });
          } else if (image) {
            this.setState({
              bitmapTexture: new Texture2D(gl, {
                data: image,
                parameters: DEFAULT_TEXTURE_PARAMETERS
              })
            });
          }
        }
      }]);
      return BitmapLayer2;
    }(Layer);
    BitmapLayer.layerName = "BitmapLayer";
    BitmapLayer.defaultProps = defaultProps2;
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js
var icon_layer_vertex_glsl_default;
var init_icon_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-vertex.glsl.js"() {
    icon_layer_vertex_glsl_default = "#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js
var icon_layer_fragment_glsl_default;
var init_icon_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer-fragment.glsl.js"() {
    icon_layer_fragment_glsl_default = "#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
var init_assert = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/utils/assert.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js
var globals, self_, window_, global_, document_, isBrowser, matches, nodeVersion;
var init_globals = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/utils/globals.js"() {
    init_typeof();
    globals = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_ = globals.self || globals.window || globals.global;
    window_ = globals.window || globals.self || globals.global;
    global_ = globals.global || globals.self || globals.window;
    document_ = globals.document || {};
    isBrowser = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
    matches = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
    nodeVersion = matches && parseFloat(matches[1]) || 0;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    case "html":
      return IMAGE_SUPPORTED;
    case "ndarray":
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
var _parseImageNode, IMAGE_SUPPORTED, IMAGE_BITMAP_SUPPORTED, NODE_IMAGE_SUPPORTED, DATA_SUPPORTED;
var init_image_type = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js"() {
    init_globals();
    _parseImageNode = global_._parseImageNode;
    IMAGE_SUPPORTED = typeof Image !== "undefined";
    IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
    NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
    DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
function getImageType(image) {
  var format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      var canvas = document.createElement("canvas");
      var context = canvas.getContext("2d");
      if (context) {
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      }
    default:
      return assert(false);
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && _typeof(image) === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}
var init_parsed_image_api = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js"() {
    init_typeof();
    init_assert();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    var textDecoder = new TextDecoder();
    var xmlText = textDecoder.decode(arrayBuffer);
    var src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}
var SVG_DATA_URL_PATTERN, SVG_URL_PATTERN;
var init_svg_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js"() {
    SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
    SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
function parseToImage(_x, _x2, _x3) {
  return _parseToImage.apply(this, arguments);
}
function _parseToImage() {
  _parseToImage = _asyncToGenerator(import_regenerator.default.mark(function _callee(arrayBuffer, options, url) {
    var blobOrDataUrl, URL2, objectUrl;
    return import_regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
            URL2 = self.URL || self.webkitURL;
            objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
            _context.prev = 3;
            _context.next = 6;
            return loadToImage(objectUrl || blobOrDataUrl, options);
          case 6:
            return _context.abrupt("return", _context.sent);
          case 7:
            _context.prev = 7;
            if (objectUrl) {
              URL2.revokeObjectURL(objectUrl);
            }
            return _context.finish(7);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, , 7, 10]]);
  }));
  return _parseToImage.apply(this, arguments);
}
function loadToImage(_x4, _x5) {
  return _loadToImage.apply(this, arguments);
}
function _loadToImage() {
  _loadToImage = _asyncToGenerator(import_regenerator.default.mark(function _callee2(url, options) {
    var image;
    return import_regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            image = new Image();
            image.src = url;
            if (!(options.image && options.image.decode && image.decode)) {
              _context2.next = 6;
              break;
            }
            _context2.next = 5;
            return image.decode();
          case 5:
            return _context2.abrupt("return", image);
          case 6:
            _context2.next = 8;
            return new Promise(function(resolve, reject) {
              try {
                image.onload = function() {
                  return resolve(image);
                };
                image.onerror = function(err) {
                  return reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
                };
              } catch (error) {
                reject(error);
              }
            });
          case 8:
            return _context2.abrupt("return", _context2.sent);
          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadToImage.apply(this, arguments);
}
var import_regenerator;
var init_parse_to_image = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js"() {
    import_regenerator = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_svg_utils();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
function parseToImageBitmap(_x, _x2, _x3) {
  return _parseToImageBitmap.apply(this, arguments);
}
function _parseToImageBitmap() {
  _parseToImageBitmap = _asyncToGenerator(import_regenerator2.default.mark(function _callee(arrayBuffer, options, url) {
    var blob, image, imagebitmapOptions;
    return import_regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!isSVG(url)) {
              _context.next = 7;
              break;
            }
            _context.next = 3;
            return parseToImage(arrayBuffer, options, url);
          case 3:
            image = _context.sent;
            blob = image;
            _context.next = 8;
            break;
          case 7:
            blob = getBlob(arrayBuffer, url);
          case 8:
            imagebitmapOptions = options && options.imagebitmap;
            _context.next = 11;
            return safeCreateImageBitmap(blob, imagebitmapOptions);
          case 11:
            return _context.abrupt("return", _context.sent);
          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseToImageBitmap.apply(this, arguments);
}
function safeCreateImageBitmap(_x4) {
  return _safeCreateImageBitmap.apply(this, arguments);
}
function _safeCreateImageBitmap() {
  _safeCreateImageBitmap = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(blob) {
    var imagebitmapOptions, _args2 = arguments;
    return import_regenerator2.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            imagebitmapOptions = _args2.length > 1 && _args2[1] !== void 0 ? _args2[1] : null;
            if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
              imagebitmapOptions = null;
            }
            if (!imagebitmapOptions) {
              _context2.next = 13;
              break;
            }
            _context2.prev = 3;
            _context2.next = 6;
            return createImageBitmap(blob, imagebitmapOptions);
          case 6:
            return _context2.abrupt("return", _context2.sent);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](3);
            console.warn(_context2.t0);
            imagebitmapOptionsSupported = false;
          case 13:
            _context2.next = 15;
            return createImageBitmap(blob);
          case 15:
            return _context2.abrupt("return", _context2.sent);
          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 9]]);
  }));
  return _safeCreateImageBitmap.apply(this, arguments);
}
function isEmptyObject(object) {
  for (var key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}
var import_regenerator2, EMPTY_OBJECT, imagebitmapOptionsSupported;
var init_parse_to_image_bitmap = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js"() {
    import_regenerator2 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_svg_utils();
    init_parse_to_image();
    EMPTY_OBJECT = {};
    imagebitmapOptionsSupported = true;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
function getBinaryImageMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView);
}
function getPngMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  var dataView = toDataView(binaryData);
  var isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  var _getJpegMarkers = getJpegMarkers(), tableMarkers = _getJpegMarkers.tableMarkers, sofMarkers = _getJpegMarkers.sofMarkers;
  var i = 2;
  while (i + 9 < dataView.byteLength) {
    var marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  var tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (var i = 65504; i < 65520; ++i) {
    tableMarkers.add(i);
  }
  var sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}
var BIG_ENDIAN, LITTLE_ENDIAN;
var init_binary_image_api = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js"() {
    BIG_ENDIAN = false;
    LITTLE_ENDIAN = true;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
function parseToNodeImage(arrayBuffer, options) {
  var _ref = getBinaryImageMetadata(arrayBuffer) || {}, mimeType = _ref.mimeType;
  var _parseImageNode2 = global_._parseImageNode;
  assert(_parseImageNode2);
  return _parseImageNode2(arrayBuffer, mimeType, options);
}
var init_parse_to_node_image = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js"() {
    init_globals();
    init_assert();
    init_binary_image_api();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
function parseImage(_x, _x2, _x3) {
  return _parseImage.apply(this, arguments);
}
function _parseImage() {
  _parseImage = _asyncToGenerator(import_regenerator3.default.mark(function _callee(arrayBuffer, options, context) {
    var imageOptions, imageType, _ref, url, loadType, image;
    return import_regenerator3.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = options || {};
            imageOptions = options.image || {};
            imageType = imageOptions.type || "auto";
            _ref = context || {}, url = _ref.url;
            loadType = getLoadableImageType(imageType);
            _context.t0 = loadType;
            _context.next = _context.t0 === "imagebitmap" ? 8 : _context.t0 === "image" ? 12 : _context.t0 === "data" ? 16 : 20;
            break;
          case 8:
            _context.next = 10;
            return parseToImageBitmap(arrayBuffer, options, url);
          case 10:
            image = _context.sent;
            return _context.abrupt("break", 21);
          case 12:
            _context.next = 14;
            return parseToImage(arrayBuffer, options, url);
          case 14:
            image = _context.sent;
            return _context.abrupt("break", 21);
          case 16:
            _context.next = 18;
            return parseToNodeImage(arrayBuffer, options);
          case 18:
            image = _context.sent;
            return _context.abrupt("break", 21);
          case 20:
            assert(false);
          case 21:
            if (imageType === "data") {
              image = getImageData(image);
            }
            return _context.abrupt("return", image);
          case 23:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseImage.apply(this, arguments);
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}
var import_regenerator3;
var init_parse_image = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js"() {
    import_regenerator3 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_assert();
    init_image_type();
    init_parsed_image_api();
    init_parse_to_image();
    init_parse_to_image_bitmap();
    init_parse_to_node_image();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/image-loader.js
var VERSION, EXTENSIONS, MIME_TYPES, ImageLoader, image_loader_default;
var init_image_loader = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/image-loader.js"() {
    init_parse_image();
    init_binary_image_api();
    VERSION = true ? "2.3.13" : "latest";
    EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg"];
    MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
    ImageLoader = {
      id: "image",
      name: "Images",
      version: VERSION,
      mimeTypes: MIME_TYPES,
      extensions: EXTENSIONS,
      parse: parseImage,
      tests: [function(arrayBuffer) {
        return Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)));
      }],
      options: {
        image: {
          type: "auto",
          decode: true
        }
      }
    };
    image_loader_default = ImageLoader;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js
var import_regenerator4, _encodeImageNode;
var init_encode_image = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/encoders/encode-image.js"() {
    import_regenerator4 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_globals();
    init_parsed_image_api();
    _encodeImageNode = global_._encodeImageNode;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/image-writer.js
var init_image_writer = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/image-writer.js"() {
    init_encode_image();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
var init_assert2 = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
var globals2, self_2, window_2, global_2, document_2, isBrowser2, matches2, nodeVersion2;
var init_globals2 = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js"() {
    init_typeof();
    globals2 = {
      self: typeof self !== "undefined" && self,
      window: typeof window !== "undefined" && window,
      global: typeof global !== "undefined" && global,
      document: typeof document !== "undefined" && document
    };
    self_2 = globals2.self || globals2.window || globals2.global;
    window_2 = globals2.window || globals2.self || globals2.global;
    global_2 = globals2.global || globals2.self || globals2.window;
    document_2 = globals2.document || {};
    isBrowser2 = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== "object" || String(process) !== "[object process]" || process.browser;
    matches2 = typeof process !== "undefined" && process.version && process.version.match(/v([0-9]*)/);
    nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js
function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : void 0;
  var transfersSet = transfers || /* @__PURE__ */ new Set();
  if (!object) {
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
  } else if (recursive && _typeof(object) === "object") {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === void 0 ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}
var init_get_transfer_list = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-transfer-list.js"() {
    init_typeof();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js
var init_validate_loader_version = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/validate-loader-version.js"() {
    init_assert2();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-worker.js
var import_regenerator5;
var init_create_worker = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/create-worker.js"() {
    init_defineProperty();
    import_regenerator5 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_get_transfer_list();
    init_validate_loader_version();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/make-transform-iterator.js
var import_regenerator6;
var init_make_transform_iterator = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/make-transform-iterator.js"() {
    import_regenerator6 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js
function getWorkerURL(workerSource) {
  var workerName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Worker";
  assert2(typeof workerSource === "string", "worker source");
  if (workerSource.startsWith("url(") && workerSource.endsWith(")")) {
    var workerUrl = workerSource.match(/^url\((.*)\)$/)[1];
    if (workerUrl && !workerUrl.startsWith("http")) {
      return workerUrl;
    }
    workerSource = buildScript(workerUrl);
  }
  var workerURL = workerURLCache.get(workerSource);
  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    workerURL = URL.createObjectURL(blob);
    workerURLCache.set(workerSource, workerURL);
  }
  return workerURL;
}
function buildScript(workerUrl) {
  return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n}");
}
var workerURLCache;
var init_get_worker_url = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/get-worker-url.js"() {
    init_assert2();
    workerURLCache = /* @__PURE__ */ new Map();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js
function defaultOnMessage(_ref) {
  var data = _ref.data, resolve = _ref.resolve;
  resolve(data);
}
var import_regenerator7, count, WorkerThread;
var init_worker_thread = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-thread.js"() {
    import_regenerator7 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_get_worker_url();
    init_get_transfer_list();
    count = 0;
    WorkerThread = function() {
      function WorkerThread2(_ref2) {
        var source = _ref2.source, _ref2$name = _ref2.name, name = _ref2$name === void 0 ? "web-worker-".concat(count++) : _ref2$name, onMessage = _ref2.onMessage;
        _classCallCheck(this, WorkerThread2);
        var url = getWorkerURL(source, name);
        this.worker = new Worker(url, {
          name
        });
        this.name = name;
        this.onMessage = onMessage || defaultOnMessage;
      }
      _createClass(WorkerThread2, [{
        key: "process",
        value: function() {
          var _process = _asyncToGenerator(import_regenerator7.default.mark(function _callee(data) {
            var _this = this;
            return import_regenerator7.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    return _context.abrupt("return", new Promise(function(resolve, reject) {
                      _this.worker.onmessage = function(event) {
                        _this.onMessage({
                          worker: _this.worker,
                          data: event.data,
                          resolve,
                          reject
                        });
                      };
                      _this.worker.onerror = function(error) {
                        var message = "".concat(_this.name, ": WorkerThread.process() failed");
                        if (error.message) {
                          message += " ".concat(error.message, " ").concat(error.filename, ":").concat(error.lineno, ":").concat(error.colno);
                        }
                        var betterError = new Error(message);
                        console.error(error);
                        reject(betterError);
                      };
                      var transferList = getTransferList(data);
                      _this.worker.postMessage(data, transferList);
                    }));
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          function process2(_x) {
            return _process.apply(this, arguments);
          }
          return process2;
        }()
      }, {
        key: "destroy",
        value: function destroy() {
          this.worker.terminate();
          this.worker = null;
        }
      }]);
      return WorkerThread2;
    }();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js
var import_regenerator8, WorkerPool;
var init_worker_pool = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-pool.js"() {
    import_regenerator8 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_worker_thread();
    WorkerPool = function() {
      function WorkerPool2(_ref) {
        var source = _ref.source, _ref$name = _ref.name, name = _ref$name === void 0 ? "unnamed" : _ref$name, _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? 1 : _ref$maxConcurrency, onMessage = _ref.onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
        } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
        _classCallCheck(this, WorkerPool2);
        this.source = source;
        this.name = name;
        this.maxConcurrency = maxConcurrency;
        this.onMessage = onMessage;
        this.onDebug = onDebug;
        this.jobQueue = [];
        this.idleQueue = [];
        this.count = 0;
        this.isDestroyed = false;
        this.reuseWorkers = reuseWorkers;
      }
      _createClass(WorkerPool2, [{
        key: "destroy",
        value: function destroy() {
          this.idleQueue.forEach(function(worker) {
            return worker.destroy();
          });
          this.isDestroyed = true;
        }
      }, {
        key: "process",
        value: function process2(data, jobName) {
          var _this = this;
          return new Promise(function(resolve, reject) {
            _this.jobQueue.push({
              data,
              jobName,
              resolve,
              reject
            });
            _this._startQueuedJob();
          });
        }
      }, {
        key: "_startQueuedJob",
        value: function() {
          var _startQueuedJob2 = _asyncToGenerator(import_regenerator8.default.mark(function _callee() {
            var worker, job;
            return import_regenerator8.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (this.jobQueue.length) {
                      _context.next = 2;
                      break;
                    }
                    return _context.abrupt("return");
                  case 2:
                    worker = this._getAvailableWorker();
                    if (worker) {
                      _context.next = 5;
                      break;
                    }
                    return _context.abrupt("return");
                  case 5:
                    job = this.jobQueue.shift();
                    this.onDebug({
                      message: "processing",
                      worker: worker.name,
                      job: job.jobName,
                      backlog: this.jobQueue.length
                    });
                    _context.prev = 7;
                    _context.t0 = job;
                    _context.next = 11;
                    return worker.process(job.data);
                  case 11:
                    _context.t1 = _context.sent;
                    _context.t0.resolve.call(_context.t0, _context.t1);
                    _context.next = 18;
                    break;
                  case 15:
                    _context.prev = 15;
                    _context.t2 = _context["catch"](7);
                    job.reject(_context.t2);
                  case 18:
                    _context.prev = 18;
                    this._onWorkerDone(worker);
                    return _context.finish(18);
                  case 21:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[7, 15, 18, 21]]);
          }));
          function _startQueuedJob() {
            return _startQueuedJob2.apply(this, arguments);
          }
          return _startQueuedJob;
        }()
      }, {
        key: "_onWorkerDone",
        value: function _onWorkerDone(worker) {
          if (this.isDestroyed) {
            worker.destroy();
            return;
          }
          if (this.reuseWorkers) {
            this.idleQueue.push(worker);
          } else {
            worker.destroy();
            this.count--;
          }
          this._startQueuedJob();
        }
      }, {
        key: "_getAvailableWorker",
        value: function _getAvailableWorker() {
          if (this.idleQueue.length > 0) {
            return this.idleQueue.shift();
          }
          if (this.count < this.maxConcurrency) {
            this.count++;
            var name = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
            return new WorkerThread({
              source: this.source,
              onMessage: this.onMessage,
              name
            });
          }
          return null;
        }
      }]);
      return WorkerPool2;
    }();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js
function onWorkerMessage(onMessage, _ref2) {
  var worker = _ref2.worker, data = _ref2.data, resolve = _ref2.resolve, reject = _ref2.reject;
  if (onMessage) {
    onMessage({
      worker,
      data,
      resolve,
      reject
    });
    return;
  }
  switch (data.type) {
    case "done":
      resolve(data.result);
      break;
    case "error":
      reject(data.message);
      break;
    default:
  }
}
var import_regenerator9, DEFAULT_MAX_CONCURRENCY, WorkerFarm;
var init_worker_farm = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-utils/worker-farm.js"() {
    import_regenerator9 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_worker_pool();
    DEFAULT_MAX_CONCURRENCY = 5;
    WorkerFarm = function() {
      _createClass(WorkerFarm2, null, [{
        key: "isSupported",
        value: function isSupported() {
          return typeof Worker !== "undefined";
        }
      }]);
      function WorkerFarm2(_ref) {
        var _ref$maxConcurrency = _ref.maxConcurrency, maxConcurrency = _ref$maxConcurrency === void 0 ? DEFAULT_MAX_CONCURRENCY : _ref$maxConcurrency, _ref$onMessage = _ref.onMessage, onMessage = _ref$onMessage === void 0 ? null : _ref$onMessage, _ref$onDebug = _ref.onDebug, onDebug = _ref$onDebug === void 0 ? function() {
        } : _ref$onDebug, _ref$reuseWorkers = _ref.reuseWorkers, reuseWorkers = _ref$reuseWorkers === void 0 ? true : _ref$reuseWorkers;
        _classCallCheck(this, WorkerFarm2);
        this.maxConcurrency = maxConcurrency;
        this.onMessage = onMessage;
        this.onDebug = onDebug;
        this.workerPools = /* @__PURE__ */ new Map();
        this.reuseWorkers = reuseWorkers;
      }
      _createClass(WorkerFarm2, [{
        key: "setProps",
        value: function setProps(props) {
          if ("maxConcurrency" in props) {
            this.maxConcurrency = props.maxConcurrency;
          }
          if ("onDebug" in props) {
            this.onDebug = props.onDebug;
          }
          if ("reuseWorkers" in props) {
            this.reuseWorkers = props.reuseWorkers;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.workerPools.forEach(function(workerPool) {
            return workerPool.destroy();
          });
        }
      }, {
        key: "process",
        value: function() {
          var _process = _asyncToGenerator(import_regenerator9.default.mark(function _callee(workerSource, workerName, data) {
            var workerPool;
            return import_regenerator9.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    workerPool = this._getWorkerPool(workerSource, workerName);
                    return _context.abrupt("return", workerPool.process(data));
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function process2(_x, _x2, _x3) {
            return _process.apply(this, arguments);
          }
          return process2;
        }()
      }, {
        key: "_getWorkerPool",
        value: function _getWorkerPool(workerSource, workerName) {
          var workerPool = this.workerPools.get(workerName);
          if (!workerPool) {
            workerPool = new WorkerPool({
              source: workerSource,
              name: workerName,
              onMessage: onWorkerMessage.bind(null, this.onMessage),
              maxConcurrency: this.maxConcurrency,
              onDebug: this.onDebug,
              reuseWorkers: this.reuseWorkers
            });
            this.workerPools.set(workerName, workerPool);
          }
          return workerPool;
        }
      }]);
      return WorkerFarm2;
    }();
  }
});

// (disabled):node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/require-utils.node
var require_require_utils = __commonJS({
  "(disabled):node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/require-utils.node"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/library-utils/library-utils.js
var import_regenerator10, node;
var init_library_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/library-utils/library-utils.js"() {
    import_regenerator10 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_globals2();
    node = __toESM(require_require_utils());
    init_assert2();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js
var init_get_first_characters = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/get-first-characters.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js
var init_parse_json = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/parser-utils/parse-json.js"() {
    init_get_first_characters();
  }
});

// (disabled):node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer-utils.node
var require_buffer_utils = __commonJS({
  "(disabled):node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer-utils.node"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js
var node2;
var init_buffer_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/buffer-utils.js"() {
    init_typeof();
    node2 = __toESM(require_buffer_utils());
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
var node3;
var init_array_buffer_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js"() {
    init_typeof();
    init_assert2();
    node3 = __toESM(require_buffer_utils());
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js
var init_memory_copy_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-copy-utils.js"() {
    init_array_buffer_utils();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js
var init_binary_copy_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/binary-copy-utils.js"() {
    init_memory_copy_utils();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js
var init_encode_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/encode-utils.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
var init_path = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
var init_file_aliases = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/text-iterators.js
var import_regenerator11;
var init_text_iterators = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/text-iterators.js"() {
    import_regenerator11 = __toESM(require_regenerator());
    init_awaitAsyncGenerator();
    init_wrapAsyncGenerator();
    init_asyncIterator();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js
var import_regenerator12;
var init_async_iteration = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterator-utils/async-iteration.js"() {
    import_regenerator12 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_asyncIterator();
    init_array_buffer_utils();
    init_assert2();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var STAT_QUEUED_REQUESTS, STAT_ACTIVE_REQUESTS, STAT_CANCELLED_REQUESTS, STAT_QUEUED_REQUESTS_EVER, STAT_ACTIVE_REQUESTS_EVER, DEFAULT_PROPS, RequestScheduler;
var init_request_scheduler = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/request-utils/request-scheduler.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm();
    STAT_QUEUED_REQUESTS = "Queued Requests";
    STAT_ACTIVE_REQUESTS = "Active Requests";
    STAT_CANCELLED_REQUESTS = "Cancelled Requests";
    STAT_QUEUED_REQUESTS_EVER = "Queued Requests Ever";
    STAT_ACTIVE_REQUESTS_EVER = "Active Requests Ever";
    DEFAULT_PROPS = {
      id: "request-scheduler",
      throttleRequests: true,
      maxRequests: 6
    };
    RequestScheduler = function() {
      function RequestScheduler2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, RequestScheduler2);
        this.props = _objectSpread(_objectSpread({}, DEFAULT_PROPS), props);
        this.requestQueue = [];
        this.activeRequestCount = 0;
        this.requestMap = /* @__PURE__ */ new Map();
        this.stats = new Stats({
          id: props.id
        });
        this.stats.get(STAT_QUEUED_REQUESTS);
        this.stats.get(STAT_ACTIVE_REQUESTS);
        this.stats.get(STAT_CANCELLED_REQUESTS);
        this.stats.get(STAT_QUEUED_REQUESTS_EVER);
        this.stats.get(STAT_ACTIVE_REQUESTS_EVER);
        this._deferredUpdate = null;
      }
      _createClass(RequestScheduler2, [{
        key: "scheduleRequest",
        value: function scheduleRequest(handle) {
          var getPriority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
            return 0;
          };
          if (!this.props.throttleRequests) {
            return Promise.resolve({
              done: function done() {
              }
            });
          }
          if (this.requestMap.has(handle)) {
            return this.requestMap.get(handle);
          }
          var request = {
            handle,
            getPriority
          };
          var promise = new Promise(function(resolve) {
            request.resolve = resolve;
            return request;
          });
          this.requestQueue.push(request);
          this.requestMap.set(handle, promise);
          this._issueNewRequests();
          return promise;
        }
      }, {
        key: "_issueRequest",
        value: function _issueRequest(request) {
          var _this = this;
          var handle = request.handle, resolve = request.resolve;
          var isDone = false;
          var done = function done2() {
            if (!isDone) {
              isDone = true;
              _this.requestMap["delete"](handle);
              _this.activeRequestCount--;
              _this._issueNewRequests();
            }
          };
          this.activeRequestCount++;
          return resolve ? resolve({
            done
          }) : Promise.resolve({
            done
          });
        }
      }, {
        key: "_issueNewRequests",
        value: function _issueNewRequests() {
          var _this2 = this;
          if (!this._deferredUpdate) {
            this._deferredUpdate = setTimeout(function() {
              return _this2._issueNewRequestsAsync();
            }, 0);
          }
        }
      }, {
        key: "_issueNewRequestsAsync",
        value: function _issueNewRequestsAsync() {
          this._deferredUpdate = null;
          var freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
          if (freeSlots === 0) {
            return;
          }
          this._updateAllRequests();
          for (var i = 0; i < freeSlots; ++i) {
            if (this.requestQueue.length > 0) {
              var request = this.requestQueue.shift();
              this._issueRequest(request);
            }
          }
        }
      }, {
        key: "_updateAllRequests",
        value: function _updateAllRequests() {
          var requestQueue = this.requestQueue;
          for (var i = 0; i < requestQueue.length; ++i) {
            var request = requestQueue[i];
            if (!this._updateRequest(request)) {
              requestQueue.splice(i, 1);
              this.requestMap["delete"](request.handle);
              i--;
            }
          }
          requestQueue.sort(function(a, b) {
            return a.priority - b.priority;
          });
        }
      }, {
        key: "_updateRequest",
        value: function _updateRequest(request) {
          request.priority = request.getPriority(request.handle);
          if (request.priority < 0) {
            request.resolve(null);
            return false;
          }
          return true;
        }
      }]);
      return RequestScheduler2;
    }();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/process-utils.js
function getAvailablePort() {
  var defaultPort = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3e3;
  return new Promise(function(resolve, reject) {
    import_child_process.default.exec("lsof -i -P -n | grep LISTEN", function(error, stdout, stderr) {
      if (error) {
        resolve(defaultPort);
        return;
      }
      var portsInUse = [];
      var regex = /:(\d+) \(LISTEN\)/;
      stdout.split("\n").forEach(function(line) {
        var match = line.match(regex);
        if (match) {
          portsInUse.push(Number(match[1]));
        }
      });
      var port = defaultPort;
      while (portsInUse.includes(port)) {
        port++;
      }
      resolve(port);
    });
  });
}
var import_child_process;
var init_process_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/process-utils.js"() {
    import_child_process = __toESM(require_child_process());
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/child-process-proxy.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator13, import_child_process2, DEFAULT_PROCESS_OPTIONS, ChildProcessProxy;
var init_child_process_proxy = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/lib/process-utils/child-process-proxy.js"() {
    import_regenerator13 = __toESM(require_regenerator());
    init_toConsumableArray();
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    import_child_process2 = __toESM(require_child_process());
    init_assert2();
    init_process_utils();
    DEFAULT_PROCESS_OPTIONS = {
      command: null,
      arguments: [],
      portArg: null,
      port: "auto",
      basePort: 5e3,
      wait: 2e3,
      nodeSpawnOptions: {
        maxBuffer: 5e3 * 1024
      },
      onSuccess: function onSuccess(processProxy) {
        console.log("Started ".concat(processProxy.options.command));
      }
    };
    ChildProcessProxy = function() {
      function ChildProcessProxy2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$id = _ref.id, id = _ref$id === void 0 ? "browser-driver" : _ref$id;
        _classCallCheck(this, ChildProcessProxy2);
        this.id = id;
        this.childProcess = null;
        this.port = null;
      }
      _createClass(ChildProcessProxy2, [{
        key: "start",
        value: function() {
          var _start = _asyncToGenerator(import_regenerator13.default.mark(function _callee() {
            var _this = this;
            var options, args, _args = arguments;
            return import_regenerator13.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                    options = _objectSpread2(_objectSpread2({}, DEFAULT_PROCESS_OPTIONS), options);
                    assert2(options.command && typeof options.command === "string");
                    this.options = options;
                    args = _toConsumableArray(options.arguments);
                    this.port = options.port;
                    if (!options.portArg) {
                      _context.next = 12;
                      break;
                    }
                    if (!(this.port === "auto")) {
                      _context.next = 11;
                      break;
                    }
                    _context.next = 10;
                    return getAvailablePort(options.basePort);
                  case 10:
                    this.port = _context.sent;
                  case 11:
                    args.push(options.portArg, this.port);
                  case 12:
                    _context.next = 14;
                    return new Promise(function(resolve, reject) {
                      try {
                        var successTimer = setTimeout(function() {
                          if (options.onSuccess) {
                            options.onSuccess(_this);
                          }
                          resolve({});
                        }, options.wait);
                        console.log("Spawning ".concat(options.command, " ").concat(options.arguments.join(" ")));
                        _this.childProcess = import_child_process2.default.spawn(options.command, args, options.spawn);
                        _this.childProcess.stderr.on("data", function(data) {
                          console.log('Child process wrote to stderr: "'.concat(data, '".'));
                          clearTimeout(successTimer);
                          reject(new Error(data));
                        });
                        _this.childProcess.on("error", function(error) {
                          console.log("Child process errored with ".concat(error));
                          clearTimeout(successTimer);
                          reject(error);
                        });
                        _this.childProcess.on("close", function(code) {
                          console.log("Child process exited with ".concat(code));
                          _this.childProcess = null;
                        });
                      } catch (error) {
                        reject(error);
                      }
                    });
                  case 14:
                    return _context.abrupt("return", _context.sent);
                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function start() {
            return _start.apply(this, arguments);
          }
          return start;
        }()
      }, {
        key: "stop",
        value: function() {
          var _stop = _asyncToGenerator(import_regenerator13.default.mark(function _callee2() {
            return import_regenerator13.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (this.childProcess) {
                      this.childProcess.kill();
                      this.childProcess = null;
                    }
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function stop() {
            return _stop.apply(this, arguments);
          }
          return stop;
        }()
      }, {
        key: "exit",
        value: function() {
          var _exit = _asyncToGenerator(import_regenerator13.default.mark(function _callee3() {
            var statusCode, _args3 = arguments;
            return import_regenerator13.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    statusCode = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : 0;
                    _context3.prev = 1;
                    _context3.next = 4;
                    return this.stop();
                  case 4:
                    process.exit(statusCode);
                    _context3.next = 11;
                    break;
                  case 7:
                    _context3.prev = 7;
                    _context3.t0 = _context3["catch"](1);
                    console.error(_context3.t0.message || _context3.t0);
                    process.exit(1);
                  case 11:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[1, 7]]);
          }));
          function exit() {
            return _exit.apply(this, arguments);
          }
          return exit;
        }()
      }]);
      return ChildProcessProxy2;
    }();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/categories/mesh/mesh-utils.js
var init_mesh_utils = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/categories/mesh/mesh-utils.js"() {
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/index.js
var init_esm7 = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/loader-utils/dist/esm/index.js"() {
    init_assert2();
    init_globals2();
    init_create_worker();
    init_validate_loader_version();
    init_make_transform_iterator();
    init_get_transfer_list();
    init_worker_farm();
    init_worker_pool();
    init_worker_thread();
    init_library_utils();
    init_parse_json();
    init_buffer_utils();
    init_array_buffer_utils();
    init_memory_copy_utils();
    init_binary_copy_utils();
    init_encode_utils();
    init_get_first_characters();
    init_path();
    init_file_aliases();
    init_file_aliases();
    init_text_iterators();
    init_async_iteration();
    init_request_scheduler();
    init_child_process_proxy();
    init_mesh_utils();
    init_memory_copy_utils();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js
var init_generate_url = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/generate-url.js"() {
    init_defineProperty();
    init_esm7();
    init_assert();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js
var import_regenerator14;
var init_async_deep_map = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/async-deep-map.js"() {
    import_regenerator14 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_typeof();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js
var import_regenerator15;
var init_deep_load = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/deep-load.js"() {
    import_regenerator15 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_async_deep_map();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js
var import_regenerator16;
var init_load_image = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image.js"() {
    init_defineProperty();
    import_regenerator16 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_assert();
    init_parse_image();
    init_parsed_image_api();
    init_generate_url();
    init_deep_load();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-array.js
var import_regenerator17;
var init_load_image_array = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-array.js"() {
    import_regenerator17 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_parse_image();
    init_load_image();
    init_deep_load();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-cube.js
var import_regenerator18;
var init_load_image_cube = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/texture-api/load-image-cube.js"() {
    import_regenerator18 = __toESM(require_regenerator());
    init_defineProperty();
    init_asyncToGenerator();
    init_parse_image();
    init_load_image();
    init_deep_load();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/deprecated/binary-image-api-deprecated.js
var init_binary_image_api_deprecated = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/lib/deprecated/binary-image-api-deprecated.js"() {
    init_binary_image_api();
  }
});

// node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/index.js
var init_esm8 = __esm({
  "node_modules/@deck.gl/layers/node_modules/@loaders.gl/images/dist/esm/index.js"() {
    init_image_loader();
    init_image_writer();
    init_binary_image_api();
    init_image_type();
    init_parsed_image_api();
    init_load_image();
    init_load_image_array();
    init_load_image_cube();
    init_image_loader();
    init_image_type();
    init_binary_image_api_deprecated();
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function resizeImage(ctx, imageData, width, height) {
  if (width === imageData.width && height === imageData.height) {
    return imageData;
  }
  ctx.canvas.height = height;
  ctx.canvas.width = width;
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height);
  return ctx.canvas;
}
function getIconId(icon) {
  return icon && (icon.id || icon.url);
}
function resizeTexture(gl, texture, width, height) {
  var oldWidth = texture.width;
  var oldHeight = texture.height;
  var newTexture = cloneTextureFrom(texture, {
    width,
    height
  });
  copyToTexture(texture, newTexture, {
    targetY: 0,
    width: oldWidth,
    height: oldHeight
  });
  texture["delete"]();
  return newTexture;
}
function buildRowMapping(mapping, columns, yOffset) {
  for (var i = 0; i < columns.length; i++) {
    var _columns$i = columns[i], icon = _columns$i.icon, xOffset = _columns$i.xOffset;
    var id = getIconId(icon);
    mapping[id] = Object.assign({}, icon, {
      x: xOffset,
      y: yOffset
    });
  }
}
function buildMapping(_ref) {
  var icons = _ref.icons, buffer = _ref.buffer, _ref$mapping = _ref.mapping, mapping = _ref$mapping === void 0 ? {} : _ref$mapping, _ref$xOffset = _ref.xOffset, xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset, _ref$yOffset = _ref.yOffset, yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset, _ref$rowHeight = _ref.rowHeight, rowHeight = _ref$rowHeight === void 0 ? 0 : _ref$rowHeight, canvasWidth = _ref.canvasWidth;
  var columns = [];
  for (var i = 0; i < icons.length; i++) {
    var icon = icons[i];
    var id = getIconId(icon);
    if (!mapping[id]) {
      var height = icon.height, width = icon.width;
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);
        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }
      columns.push({
        icon,
        xOffset
      });
      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }
  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }
  return {
    mapping,
    rowHeight,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }
  cachedIcons = cachedIcons || {};
  var icons = {};
  var _createIterable = createIterable(data), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var object = _step.value;
      objectInfo.index++;
      var icon = getIcon(object, objectInfo);
      var id = getIconId(icon);
      if (!icon) {
        throw new Error("Icon is missing.");
      }
      if (!icon.url) {
        throw new Error("Icon url is missing.");
      }
      if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
        icons[id] = icon;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return icons;
}
var _DEFAULT_TEXTURE_PARA2, DEFAULT_CANVAS_WIDTH, DEFAULT_BUFFER, noop, DEFAULT_TEXTURE_PARAMETERS2, IconManager;
var init_icon_manager = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-manager.js"() {
    init_classCallCheck();
    init_createClass();
    init_defineProperty();
    init_esm4();
    init_esm8();
    init_esm2();
    init_esm6();
    DEFAULT_CANVAS_WIDTH = 1024;
    DEFAULT_BUFFER = 4;
    noop = function noop2() {
    };
    DEFAULT_TEXTURE_PARAMETERS2 = (_DEFAULT_TEXTURE_PARA2 = {}, _defineProperty(_DEFAULT_TEXTURE_PARA2, 10241, 9987), _defineProperty(_DEFAULT_TEXTURE_PARA2, 10240, 9729), _defineProperty(_DEFAULT_TEXTURE_PARA2, 10242, 33071), _defineProperty(_DEFAULT_TEXTURE_PARA2, 10243, 33071), _DEFAULT_TEXTURE_PARA2);
    IconManager = function() {
      function IconManager2(gl, _ref2) {
        var _ref2$onUpdate = _ref2.onUpdate, onUpdate = _ref2$onUpdate === void 0 ? noop : _ref2$onUpdate;
        _classCallCheck(this, IconManager2);
        this.gl = gl;
        this.onUpdate = onUpdate;
        this._loadOptions = null;
        this._getIcon = null;
        this._texture = null;
        this._externalTexture = null;
        this._mapping = {};
        this._pendingCount = 0;
        this._autoPacking = false;
        this._xOffset = 0;
        this._yOffset = 0;
        this._rowHeight = 0;
        this._buffer = DEFAULT_BUFFER;
        this._canvasWidth = DEFAULT_CANVAS_WIDTH;
        this._canvasHeight = 0;
        this._canvas = null;
      }
      _createClass(IconManager2, [{
        key: "finalize",
        value: function finalize() {
          if (this._texture) {
            this._texture["delete"]();
          }
        }
      }, {
        key: "getTexture",
        value: function getTexture() {
          return this._texture || this._externalTexture;
        }
      }, {
        key: "getIconMapping",
        value: function getIconMapping(icon) {
          var id = this._autoPacking ? getIconId(icon) : icon;
          return this._mapping[id] || {};
        }
      }, {
        key: "setProps",
        value: function setProps(_ref3) {
          var loadOptions = _ref3.loadOptions, autoPacking = _ref3.autoPacking, iconAtlas = _ref3.iconAtlas, iconMapping = _ref3.iconMapping, data = _ref3.data, getIcon = _ref3.getIcon;
          if (loadOptions) {
            this._loadOptions = loadOptions;
          }
          if (autoPacking !== void 0) {
            this._autoPacking = autoPacking;
          }
          if (getIcon) {
            this._getIcon = getIcon;
          }
          if (iconMapping) {
            this._mapping = iconMapping;
          }
          if (iconAtlas) {
            this._updateIconAtlas(iconAtlas);
          }
          if (this._autoPacking && (data || getIcon) && typeof document !== "undefined") {
            this._canvas = this._canvas || document.createElement("canvas");
            this._updateAutoPacking(data);
          }
        }
      }, {
        key: "_updateIconAtlas",
        value: function _updateIconAtlas(iconAtlas) {
          if (this._texture) {
            this._texture["delete"]();
            this._texture = null;
          }
          if (iconAtlas instanceof Texture2D) {
            iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS2);
            this._externalTexture = iconAtlas;
            this.onUpdate();
          } else if (iconAtlas) {
            this._texture = new Texture2D(this.gl, {
              data: iconAtlas,
              parameters: DEFAULT_TEXTURE_PARAMETERS2
            });
            this.onUpdate();
          }
        }
      }, {
        key: "_updateAutoPacking",
        value: function _updateAutoPacking(data) {
          var icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});
          if (icons.length > 0) {
            var _buildMapping = buildMapping({
              icons,
              buffer: this._buffer,
              canvasWidth: this._canvasWidth,
              mapping: this._mapping,
              rowHeight: this._rowHeight,
              xOffset: this._xOffset,
              yOffset: this._yOffset
            }), mapping = _buildMapping.mapping, xOffset = _buildMapping.xOffset, yOffset = _buildMapping.yOffset, rowHeight = _buildMapping.rowHeight, canvasHeight = _buildMapping.canvasHeight;
            this._rowHeight = rowHeight;
            this._mapping = mapping;
            this._xOffset = xOffset;
            this._yOffset = yOffset;
            this._canvasHeight = canvasHeight;
            if (!this._texture) {
              this._texture = new Texture2D(this.gl, {
                width: this._canvasWidth,
                height: this._canvasHeight,
                parameters: DEFAULT_TEXTURE_PARAMETERS2
              });
            }
            if (this._texture.height !== this._canvasHeight) {
              this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight);
            }
            this.onUpdate();
            this._loadIcons(icons);
          }
        }
      }, {
        key: "_loadIcons",
        value: function _loadIcons(icons) {
          var _this = this;
          var ctx = this._canvas.getContext("2d");
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            var _loop = function _loop2() {
              var icon = _step2.value;
              _this._pendingCount++;
              load(icon.url, image_loader_default, _this._loadOptions).then(function(imageData) {
                var id = getIconId(icon);
                var _this$_mapping$id = _this._mapping[id], x = _this$_mapping$id.x, y = _this$_mapping$id.y, width = _this$_mapping$id.width, height = _this$_mapping$id.height;
                var data = resizeImage(ctx, imageData, width, height);
                _this._texture.setSubImageData({
                  data,
                  x,
                  y,
                  width,
                  height
                });
                _this._texture.generateMipmap();
                _this.onUpdate();
              })["catch"](function(error) {
                log_default.error(error)();
              })["finally"](function() {
                _this._pendingCount--;
              });
            };
            for (var _iterator2 = icons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              _loop();
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }, {
        key: "isLoaded",
        get: function get() {
          return this._pendingCount === 0;
        }
      }]);
      return IconManager2;
    }();
  }
});

// node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js
var DEFAULT_COLOR2, defaultProps3, IconLayer;
var init_icon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/icon-layer/icon-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_icon_layer_vertex_glsl();
    init_icon_layer_fragment_glsl();
    init_icon_manager();
    DEFAULT_COLOR2 = [0, 0, 0, 255];
    defaultProps3 = {
      iconAtlas: {
        type: "object",
        value: null,
        async: true
      },
      iconMapping: {
        type: "object",
        value: {},
        async: true
      },
      sizeScale: {
        type: "number",
        value: 1,
        min: 0
      },
      billboard: true,
      sizeUnits: "pixels",
      sizeMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      sizeMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      alphaCutoff: {
        type: "number",
        value: 0.05,
        min: 0,
        max: 1
      },
      getPosition: {
        type: "accessor",
        value: function value3(x) {
          return x.position;
        }
      },
      getIcon: {
        type: "accessor",
        value: function value4(x) {
          return x.icon;
        }
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR2
      },
      getSize: {
        type: "accessor",
        value: 1
      },
      getAngle: {
        type: "accessor",
        value: 0
      },
      getPixelOffset: {
        type: "accessor",
        value: [0, 0]
      }
    };
    IconLayer = function(_Layer) {
      _inherits(IconLayer2, _Layer);
      function IconLayer2() {
        _classCallCheck(this, IconLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(IconLayer2).apply(this, arguments));
      }
      _createClass(IconLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return _get(_getPrototypeOf(IconLayer2.prototype), "getShaders", this).call(this, {
            vs: icon_layer_vertex_glsl_default,
            fs: icon_layer_fragment_glsl_default,
            modules: [project32_default, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var _this = this;
          this.state = {
            iconManager: new IconManager(this.context.gl, {
              onUpdate: function onUpdate() {
                return _this._onUpdate();
              }
            })
          };
          var attributeManager = this.getAttributeManager();
          attributeManager.addInstanced({
            instancePositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getPosition"
            },
            instanceSizes: {
              size: 1,
              transition: true,
              accessor: "getSize",
              defaultValue: 1
            },
            instanceOffsets: {
              size: 2,
              accessor: "getIcon",
              transform: this.getInstanceOffset
            },
            instanceIconFrames: {
              size: 4,
              accessor: "getIcon",
              transform: this.getInstanceIconFrame
            },
            instanceColorModes: {
              size: 1,
              type: 5121,
              accessor: "getIcon",
              transform: this.getInstanceColorMode
            },
            instanceColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getColor",
              defaultValue: DEFAULT_COLOR2
            },
            instanceAngles: {
              size: 1,
              transition: true,
              accessor: "getAngle"
            },
            instancePixelOffset: {
              size: 2,
              transition: true,
              accessor: "getPixelOffset"
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var oldProps = _ref.oldProps, props = _ref.props, changeFlags = _ref.changeFlags;
          _get(_getPrototypeOf(IconLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          var attributeManager = this.getAttributeManager();
          var iconAtlas = props.iconAtlas, iconMapping = props.iconMapping, data = props.data, getIcon = props.getIcon;
          var iconManager = this.state.iconManager;
          iconManager.setProps({
            loadOptions: props.loadOptions
          });
          var iconMappingChanged = false;
          var prePacked = iconAtlas || this.internalState.isAsyncPropLoading("iconAtlas");
          if (prePacked) {
            if (oldProps.iconAtlas !== props.iconAtlas) {
              iconManager.setProps({
                iconAtlas,
                autoPacking: false
              });
            }
            if (oldProps.iconMapping !== props.iconMapping) {
              iconManager.setProps({
                iconMapping
              });
              iconMappingChanged = true;
            }
          } else {
            iconManager.setProps({
              autoPacking: true
            });
          }
          if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon)) {
            iconManager.setProps({
              data,
              getIcon
            });
            iconMappingChanged = true;
          }
          if (iconMappingChanged) {
            attributeManager.invalidate("instanceOffsets");
            attributeManager.invalidate("instanceIconFrames");
            attributeManager.invalidate("instanceColorModes");
          }
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            attributeManager.invalidateAll();
          }
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          _get(_getPrototypeOf(IconLayer2.prototype), "finalizeState", this).call(this);
          this.state.iconManager.finalize();
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var _this$props = this.props, sizeScale = _this$props.sizeScale, sizeMinPixels = _this$props.sizeMinPixels, sizeMaxPixels = _this$props.sizeMaxPixels, sizeUnits = _this$props.sizeUnits, billboard = _this$props.billboard, alphaCutoff = _this$props.alphaCutoff;
          var iconManager = this.state.iconManager;
          var viewport = this.context.viewport;
          var iconsTexture = iconManager.getTexture();
          if (iconsTexture && iconsTexture.loaded) {
            this.state.model.setUniforms(Object.assign({}, uniforms, {
              iconsTexture,
              iconsTextureDim: [iconsTexture.width, iconsTexture.height],
              sizeScale: sizeScale * (sizeUnits === "pixels" ? viewport.metersPerPixel : 1),
              sizeMinPixels,
              sizeMaxPixels,
              billboard,
              alphaCutoff
            })).draw();
          }
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          var positions = [-1, -1, -1, 1, 1, 1, 1, -1];
          return new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 6,
              attributes: {
                positions: {
                  size: 2,
                  value: new Float32Array(positions)
                }
              }
            }),
            isInstanced: true
          }));
        }
      }, {
        key: "_onUpdate",
        value: function _onUpdate() {
          this.setNeedsRedraw();
        }
      }, {
        key: "getInstanceOffset",
        value: function getInstanceOffset(icon) {
          var rect = this.state.iconManager.getIconMapping(icon);
          return [rect.width / 2 - rect.anchorX || 0, rect.height / 2 - rect.anchorY || 0];
        }
      }, {
        key: "getInstanceColorMode",
        value: function getInstanceColorMode(icon) {
          var mapping = this.state.iconManager.getIconMapping(icon);
          return mapping.mask ? 1 : 0;
        }
      }, {
        key: "getInstanceIconFrame",
        value: function getInstanceIconFrame(icon) {
          var rect = this.state.iconManager.getIconMapping(icon);
          return [rect.x || 0, rect.y || 0, rect.width || 0, rect.height || 0];
        }
      }, {
        key: "isLoaded",
        get: function get() {
          return _get(_getPrototypeOf(IconLayer2.prototype), "isLoaded", this) && this.state.iconManager.isLoaded;
        }
      }]);
      return IconLayer2;
    }(Layer);
    IconLayer.layerName = "IconLayer";
    IconLayer.defaultProps = defaultProps3;
  }
});

// node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js
var line_layer_vertex_glsl_default;
var init_line_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-vertex.glsl.js"() {
    line_layer_vertex_glsl_default = "#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(instanceSourcePositions, instanceSourcePositions64Low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(instanceTargetPositions, instanceTargetPositions64Low, vec3(0.), target_commonspace);\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale),\n    widthMinPixels, widthMaxPixels\n  );\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js
var line_layer_fragment_glsl_default;
var init_line_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer-fragment.glsl.js"() {
    line_layer_fragment_glsl_default = "#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js
var DEFAULT_COLOR3, defaultProps4, LineLayer;
var init_line_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/line-layer/line-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_line_layer_vertex_glsl();
    init_line_layer_fragment_glsl();
    DEFAULT_COLOR3 = [0, 0, 0, 255];
    defaultProps4 = {
      getSourcePosition: {
        type: "accessor",
        value: function value5(x) {
          return x.sourcePosition;
        }
      },
      getTargetPosition: {
        type: "accessor",
        value: function value6(x) {
          return x.targetPosition;
        }
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR3
      },
      getWidth: {
        type: "accessor",
        value: 1
      },
      widthUnits: "pixels",
      widthScale: {
        type: "number",
        value: 1,
        min: 0
      },
      widthMinPixels: {
        type: "number",
        value: 0,
        min: 0
      },
      widthMaxPixels: {
        type: "number",
        value: Number.MAX_SAFE_INTEGER,
        min: 0
      }
    };
    LineLayer = function(_Layer) {
      _inherits(LineLayer2, _Layer);
      function LineLayer2() {
        _classCallCheck(this, LineLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(LineLayer2).apply(this, arguments));
      }
      _createClass(LineLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return _get(_getPrototypeOf(LineLayer2.prototype), "getShaders", this).call(this, {
            vs: line_layer_vertex_glsl_default,
            fs: line_layer_fragment_glsl_default,
            modules: [project32_default, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var attributeManager = this.getAttributeManager();
          attributeManager.addInstanced({
            instanceSourcePositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getSourcePosition"
            },
            instanceTargetPositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getTargetPosition"
            },
            instanceColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getColor",
              defaultValue: [0, 0, 0, 255]
            },
            instanceWidths: {
              size: 1,
              transition: true,
              accessor: "getWidth",
              defaultValue: 1
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          _get(_getPrototypeOf(LineLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            this.getAttributeManager().invalidateAll();
          }
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var viewport = this.context.viewport;
          var _this$props = this.props, widthUnits = _this$props.widthUnits, widthScale = _this$props.widthScale, widthMinPixels = _this$props.widthMinPixels, widthMaxPixels = _this$props.widthMaxPixels;
          var widthMultiplier = widthUnits === "pixels" ? viewport.metersPerPixel : 1;
          this.state.model.setUniforms(Object.assign({}, uniforms, {
            widthScale: widthScale * widthMultiplier,
            widthMinPixels,
            widthMaxPixels
          })).draw();
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          var positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];
          return new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 5,
              attributes: {
                positions: new Float32Array(positions)
              }
            }),
            isInstanced: true
          }));
        }
      }]);
      return LineLayer2;
    }(Layer);
    LineLayer.layerName = "LineLayer";
    LineLayer.defaultProps = defaultProps4;
  }
});

// node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js
var point_cloud_layer_vertex_glsl_default;
var init_point_cloud_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-vertex.glsl.js"() {
    point_cloud_layer_vertex_glsl_default = "#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * radiusPixels, 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js
var point_cloud_layer_fragment_glsl_default;
var init_point_cloud_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer-fragment.glsl.js"() {
    point_cloud_layer_fragment_glsl_default = "#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js
function normalizeData(data) {
  var header = data.header, attributes = data.attributes;
  if (!header || !attributes) {
    return;
  }
  data.length = header.vertexCount;
  if (attributes.POSITION) {
    attributes.instancePositions = attributes.POSITION;
  }
  if (attributes.NORMAL) {
    attributes.instanceNormals = attributes.NORMAL;
  }
  if (attributes.COLOR_0) {
    attributes.instanceColors = attributes.COLOR_0;
  }
}
var DEFAULT_COLOR4, DEFAULT_NORMAL, defaultProps5, PointCloudLayer;
var init_point_cloud_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/point-cloud-layer/point-cloud-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_point_cloud_layer_vertex_glsl();
    init_point_cloud_layer_fragment_glsl();
    DEFAULT_COLOR4 = [0, 0, 0, 255];
    DEFAULT_NORMAL = [0, 0, 1];
    defaultProps5 = {
      sizeUnits: "pixels",
      pointSize: {
        type: "number",
        min: 0,
        value: 10
      },
      getPosition: {
        type: "accessor",
        value: function value7(x) {
          return x.position;
        }
      },
      getNormal: {
        type: "accessor",
        value: DEFAULT_NORMAL
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR4
      },
      material: true,
      radiusPixels: {
        deprecatedFor: "pointSize"
      }
    };
    PointCloudLayer = function(_Layer) {
      _inherits(PointCloudLayer2, _Layer);
      function PointCloudLayer2() {
        _classCallCheck(this, PointCloudLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(PointCloudLayer2).apply(this, arguments));
      }
      _createClass(PointCloudLayer2, [{
        key: "getShaders",
        value: function getShaders(id) {
          return _get(_getPrototypeOf(PointCloudLayer2.prototype), "getShaders", this).call(this, {
            vs: point_cloud_layer_vertex_glsl_default,
            fs: point_cloud_layer_fragment_glsl_default,
            modules: [project32_default, gouraudLighting, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          this.getAttributeManager().addInstanced({
            instancePositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getPosition"
            },
            instanceNormals: {
              size: 3,
              transition: true,
              accessor: "getNormal",
              defaultValue: DEFAULT_NORMAL
            },
            instanceColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getColor",
              defaultValue: DEFAULT_COLOR4
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          _get(_getPrototypeOf(PointCloudLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            this.getAttributeManager().invalidateAll();
          }
          if (changeFlags.dataChanged) {
            normalizeData(props.data);
          }
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var viewport = this.context.viewport;
          var _this$props = this.props, pointSize = _this$props.pointSize, sizeUnits = _this$props.sizeUnits;
          var sizeMultiplier = sizeUnits === "meters" ? 1 / viewport.metersPerPixel : 1;
          this.state.model.setUniforms(Object.assign({}, uniforms, {
            radiusPixels: pointSize * sizeMultiplier
          })).draw();
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          var positions = [];
          for (var i = 0; i < 3; i++) {
            var angle = i / 3 * Math.PI * 2;
            positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
          }
          return new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 4,
              attributes: {
                positions: new Float32Array(positions)
              }
            }),
            isInstanced: true
          }));
        }
      }]);
      return PointCloudLayer2;
    }(Layer);
    PointCloudLayer.layerName = "PointCloudLayer";
    PointCloudLayer.defaultProps = defaultProps5;
  }
});

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js
var scatterplot_layer_vertex_glsl_default;
var init_scatterplot_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js"() {
    scatterplot_layer_vertex_glsl_default = "#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js
var scatterplot_layer_fragment_glsl_default;
var init_scatterplot_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js"() {
    scatterplot_layer_fragment_glsl_default = "#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = smoothedge(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter);\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js
var DEFAULT_COLOR5, defaultProps6, ScatterplotLayer;
var init_scatterplot_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_scatterplot_layer_vertex_glsl();
    init_scatterplot_layer_fragment_glsl();
    DEFAULT_COLOR5 = [0, 0, 0, 255];
    defaultProps6 = {
      radiusUnits: "meters",
      radiusScale: {
        type: "number",
        min: 0,
        value: 1
      },
      radiusMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      radiusMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      lineWidthUnits: "meters",
      lineWidthScale: {
        type: "number",
        min: 0,
        value: 1
      },
      lineWidthMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      lineWidthMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      stroked: false,
      filled: true,
      getPosition: {
        type: "accessor",
        value: function value8(x) {
          return x.position;
        }
      },
      getRadius: {
        type: "accessor",
        value: 1
      },
      getFillColor: {
        type: "accessor",
        value: DEFAULT_COLOR5
      },
      getLineColor: {
        type: "accessor",
        value: DEFAULT_COLOR5
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      strokeWidth: {
        deprecatedFor: "getLineWidth"
      },
      outline: {
        deprecatedFor: "stroked"
      },
      getColor: {
        deprecatedFor: ["getFillColor", "getLineColor"]
      }
    };
    ScatterplotLayer = function(_Layer) {
      _inherits(ScatterplotLayer2, _Layer);
      function ScatterplotLayer2() {
        _classCallCheck(this, ScatterplotLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(ScatterplotLayer2).apply(this, arguments));
      }
      _createClass(ScatterplotLayer2, [{
        key: "getShaders",
        value: function getShaders(id) {
          return _get(_getPrototypeOf(ScatterplotLayer2.prototype), "getShaders", this).call(this, {
            vs: scatterplot_layer_vertex_glsl_default,
            fs: scatterplot_layer_fragment_glsl_default,
            modules: [project32_default, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          this.getAttributeManager().addInstanced({
            instancePositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getPosition"
            },
            instanceRadius: {
              size: 1,
              transition: true,
              accessor: "getRadius",
              defaultValue: 1
            },
            instanceFillColors: {
              size: this.props.colorFormat.length,
              transition: true,
              normalized: true,
              type: 5121,
              accessor: "getFillColor",
              defaultValue: [0, 0, 0, 255]
            },
            instanceLineColors: {
              size: this.props.colorFormat.length,
              transition: true,
              normalized: true,
              type: 5121,
              accessor: "getLineColor",
              defaultValue: [0, 0, 0, 255]
            },
            instanceLineWidths: {
              size: 1,
              transition: true,
              accessor: "getLineWidth",
              defaultValue: 1
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          _get(_getPrototypeOf(ScatterplotLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            this.getAttributeManager().invalidateAll();
          }
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var viewport = this.context.viewport;
          var _this$props = this.props, radiusUnits = _this$props.radiusUnits, radiusScale = _this$props.radiusScale, radiusMinPixels = _this$props.radiusMinPixels, radiusMaxPixels = _this$props.radiusMaxPixels, stroked = _this$props.stroked, filled = _this$props.filled, lineWidthUnits = _this$props.lineWidthUnits, lineWidthScale = _this$props.lineWidthScale, lineWidthMinPixels = _this$props.lineWidthMinPixels, lineWidthMaxPixels = _this$props.lineWidthMaxPixels;
          var pointRadiusMultiplier = radiusUnits === "pixels" ? viewport.metersPerPixel : 1;
          var lineWidthMultiplier = lineWidthUnits === "pixels" ? viewport.metersPerPixel : 1;
          this.state.model.setUniforms(uniforms).setUniforms({
            stroked: stroked ? 1 : 0,
            filled,
            radiusScale: radiusScale * pointRadiusMultiplier,
            radiusMinPixels,
            radiusMaxPixels,
            lineWidthScale: lineWidthScale * lineWidthMultiplier,
            lineWidthMinPixels,
            lineWidthMaxPixels
          }).draw();
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          var positions = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0];
          return new Model(gl, Object.assign(this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 6,
              vertexCount: 4,
              attributes: {
                positions: {
                  size: 3,
                  value: new Float32Array(positions)
                }
              }
            }),
            isInstanced: true
          }));
        }
      }]);
      return ScatterplotLayer2;
    }(Layer);
    ScatterplotLayer.layerName = "ScatterplotLayer";
    ScatterplotLayer.defaultProps = defaultProps6;
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function tesselateColumn(props) {
  var radius = props.radius, _props$height = props.height, height = _props$height === void 0 ? 1 : _props$height, _props$nradial = props.nradial, nradial = _props$nradial === void 0 ? 10 : _props$nradial, vertices = props.vertices;
  log_default.assert(!vertices || vertices.length >= nradial);
  var vertsAroundEdge = nradial + 1;
  var numVertices = vertsAroundEdge * 3;
  var stepAngle = Math.PI * 2 / nradial;
  var indices = new Uint16Array(nradial * 3 * 2);
  var positions = new Float32Array(numVertices * 3);
  var normals = new Float32Array(numVertices * 3);
  var i = 0;
  for (var j = 0; j < vertsAroundEdge; j++) {
    var a = j * stepAngle;
    var vertex = vertices && vertices[j % nradial];
    var nextVertex = vertices && vertices[(j + 1) % nradial];
    var sin = Math.sin(a);
    var cos = Math.cos(a);
    for (var k = 0; k < 2; k++) {
      positions[i + 0] = vertex ? vertex[0] : cos * radius;
      positions[i + 1] = vertex ? vertex[1] : sin * radius;
      positions[i + 2] = (1 / 2 - k) * height;
      normals[i + 0] = vertex ? nextVertex[0] - vertex[0] : cos;
      normals[i + 1] = vertex ? nextVertex[1] - vertex[1] : sin;
      i += 3;
    }
  }
  for (var _j = 0; _j < vertsAroundEdge; _j++) {
    var v = Math.floor(_j / 2) * Math.sign(_j % 2 - 0.5);
    var _a = v * stepAngle;
    var _vertex = vertices && vertices[(v + nradial) % nradial];
    var _sin = Math.sin(_a);
    var _cos = Math.cos(_a);
    positions[i + 0] = _vertex ? _vertex[0] : _cos * radius;
    positions[i + 1] = _vertex ? _vertex[1] : _sin * radius;
    positions[i + 2] = height / 2;
    normals[i + 2] = 1;
    i += 3;
  }
  var index = 0;
  for (var _j2 = 0; _j2 < nradial; _j2++) {
    indices[index++] = _j2 * 2 + 0;
    indices[index++] = _j2 * 2 + 2;
    indices[index++] = _j2 * 2 + 0;
    indices[index++] = _j2 * 2 + 1;
    indices[index++] = _j2 * 2 + 1;
    indices[index++] = _j2 * 2 + 3;
  }
  return {
    indices,
    attributes: {
      POSITION: {
        size: 3,
        value: positions
      },
      NORMAL: {
        size: 3,
        value: normals
      }
    }
  };
}
var ColumnGeometry;
var init_column_geometry = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-geometry.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm6();
    init_esm4();
    ColumnGeometry = function(_Geometry) {
      _inherits(ColumnGeometry2, _Geometry);
      function ColumnGeometry2() {
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck(this, ColumnGeometry2);
        var _props$id = props.id, id = _props$id === void 0 ? uid("column-geometry") : _props$id;
        var _tesselateColumn = tesselateColumn(props), indices = _tesselateColumn.indices, attributes = _tesselateColumn.attributes;
        return _possibleConstructorReturn(this, _getPrototypeOf(ColumnGeometry2).call(this, _objectSpread3({}, props, {
          id,
          indices,
          attributes
        })));
      }
      return ColumnGeometry2;
    }(Geometry);
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js
var column_layer_vertex_glsl_default;
var init_column_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-vertex.glsl.js"() {
    column_layer_vertex_glsl_default = "\n#define SHADER_NAME column-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 normals;\n\nattribute vec3 instancePositions;\nattribute float instanceElevations;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute float instanceStrokeWidths;\n\nattribute vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nvarying vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (isStroke) {\n    float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    strokeOffsetRatio += sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec3 pos = vec3(project_size(rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js
var column_layer_fragment_glsl_default;
var init_column_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer-fragment.glsl.js"() {
    column_layer_fragment_glsl_default = "#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js
var DEFAULT_COLOR6, defaultProps7, ColumnLayer;
var init_column_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/column-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_column_geometry();
    init_column_layer_vertex_glsl();
    init_column_layer_fragment_glsl();
    DEFAULT_COLOR6 = [0, 0, 0, 255];
    defaultProps7 = {
      diskResolution: {
        type: "number",
        min: 4,
        value: 20
      },
      vertices: null,
      radius: {
        type: "number",
        min: 0,
        value: 1e3
      },
      angle: {
        type: "number",
        value: 0
      },
      offset: {
        type: "array",
        value: [0, 0]
      },
      coverage: {
        type: "number",
        min: 0,
        max: 1,
        value: 1
      },
      elevationScale: {
        type: "number",
        min: 0,
        value: 1
      },
      lineWidthUnits: "meters",
      lineWidthScale: 1,
      lineWidthMinPixels: 0,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      extruded: true,
      wireframe: false,
      filled: true,
      stroked: false,
      getPosition: {
        type: "accessor",
        value: function value9(x) {
          return x.position;
        }
      },
      getFillColor: {
        type: "accessor",
        value: DEFAULT_COLOR6
      },
      getLineColor: {
        type: "accessor",
        value: DEFAULT_COLOR6
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      material: true,
      getColor: {
        deprecatedFor: ["getFillColor", "getLineColor"]
      }
    };
    ColumnLayer = function(_Layer) {
      _inherits(ColumnLayer2, _Layer);
      function ColumnLayer2() {
        _classCallCheck(this, ColumnLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(ColumnLayer2).apply(this, arguments));
      }
      _createClass(ColumnLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return _get(_getPrototypeOf(ColumnLayer2.prototype), "getShaders", this).call(this, {
            vs: column_layer_vertex_glsl_default,
            fs: column_layer_fragment_glsl_default,
            modules: [project32_default, gouraudLighting, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var attributeManager = this.getAttributeManager();
          attributeManager.addInstanced({
            instancePositions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: true,
              accessor: "getPosition"
            },
            instanceElevations: {
              size: 1,
              transition: true,
              accessor: "getElevation"
            },
            instanceFillColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getFillColor",
              defaultValue: DEFAULT_COLOR6
            },
            instanceLineColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: true,
              accessor: "getLineColor",
              defaultValue: DEFAULT_COLOR6
            },
            instanceStrokeWidths: {
              size: 1,
              accessor: "getLineWidth",
              transition: true
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          _get(_getPrototypeOf(ColumnLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          var regenerateModels = changeFlags.extensionsChanged;
          if (regenerateModels) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            this.getAttributeManager().invalidateAll();
          }
          if (regenerateModels || props.diskResolution !== oldProps.diskResolution || props.vertices !== oldProps.vertices) {
            this._updateGeometry(props);
          }
        }
      }, {
        key: "getGeometry",
        value: function getGeometry(diskResolution, vertices) {
          var geometry = new ColumnGeometry({
            radius: 1,
            height: 2,
            vertices,
            nradial: diskResolution
          });
          var meanVertexDistance = 0;
          if (vertices) {
            for (var i = 0; i < diskResolution; i++) {
              var p = vertices[i];
              var d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
              meanVertexDistance += d / diskResolution;
            }
          } else {
            meanVertexDistance = 1;
          }
          this.setState({
            edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
          });
          return geometry;
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          return new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            isInstanced: true
          }));
        }
      }, {
        key: "_updateGeometry",
        value: function _updateGeometry(_ref2) {
          var diskResolution = _ref2.diskResolution, vertices = _ref2.vertices;
          var geometry = this.getGeometry(diskResolution, vertices);
          this.setState({
            fillVertexCount: geometry.attributes.POSITION.value.length / 3,
            wireframeVertexCount: geometry.indices.value.length
          });
          this.state.model.setProps({
            geometry
          });
        }
      }, {
        key: "draw",
        value: function draw(_ref3) {
          var uniforms = _ref3.uniforms;
          var viewport = this.context.viewport;
          var _this$props = this.props, lineWidthUnits = _this$props.lineWidthUnits, lineWidthScale = _this$props.lineWidthScale, lineWidthMinPixels = _this$props.lineWidthMinPixels, lineWidthMaxPixels = _this$props.lineWidthMaxPixels, elevationScale = _this$props.elevationScale, extruded = _this$props.extruded, filled = _this$props.filled, stroked = _this$props.stroked, wireframe = _this$props.wireframe, offset = _this$props.offset, coverage = _this$props.coverage, radius = _this$props.radius, angle = _this$props.angle;
          var _this$state = this.state, model = _this$state.model, fillVertexCount = _this$state.fillVertexCount, wireframeVertexCount = _this$state.wireframeVertexCount, edgeDistance = _this$state.edgeDistance;
          var widthMultiplier = lineWidthUnits === "pixels" ? viewport.metersPerPixel : 1;
          model.setUniforms(Object.assign({}, uniforms, {
            radius,
            angle: angle / 180 * Math.PI,
            offset,
            extruded,
            coverage,
            elevationScale,
            edgeDistance,
            widthScale: lineWidthScale * widthMultiplier,
            widthMinPixels: lineWidthMinPixels,
            widthMaxPixels: lineWidthMaxPixels
          }));
          if (extruded && wireframe) {
            model.setProps({
              isIndexed: true
            });
            model.setVertexCount(wireframeVertexCount).setDrawMode(1).setUniforms({
              isStroke: true
            }).draw();
          }
          if (filled) {
            model.setProps({
              isIndexed: false
            });
            model.setVertexCount(fillVertexCount).setDrawMode(5).setUniforms({
              isStroke: false
            }).draw();
          }
          if (!extruded && stroked) {
            model.setProps({
              isIndexed: false
            });
            model.setVertexCount(fillVertexCount * 2 / 3).setDrawMode(5).setUniforms({
              isStroke: true
            }).draw();
          }
        }
      }]);
      return ColumnLayer2;
    }(Layer);
    ColumnLayer.layerName = "ColumnLayer";
    ColumnLayer.defaultProps = defaultProps7;
  }
});

// node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js
var defaultProps8, GridCellLayer;
var init_grid_cell_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/column-layer/grid-cell-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm4();
    init_column_layer();
    defaultProps8 = {
      cellSize: {
        type: "number",
        min: 0,
        value: 1e3
      },
      offset: {
        type: "array",
        min: 0,
        value: [1, 1]
      }
    };
    GridCellLayer = function(_ColumnLayer) {
      _inherits(GridCellLayer2, _ColumnLayer);
      function GridCellLayer2() {
        _classCallCheck(this, GridCellLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(GridCellLayer2).apply(this, arguments));
      }
      _createClass(GridCellLayer2, [{
        key: "getGeometry",
        value: function getGeometry(diskResolution) {
          return new CubeGeometry();
        }
      }, {
        key: "draw",
        value: function draw(_ref) {
          var uniforms = _ref.uniforms;
          var _this$props = this.props, elevationScale = _this$props.elevationScale, extruded = _this$props.extruded, offset = _this$props.offset, coverage = _this$props.coverage, cellSize = _this$props.cellSize, angle = _this$props.angle;
          this.state.model.setUniforms(Object.assign({}, uniforms, {
            radius: cellSize / 2,
            angle,
            offset,
            extruded,
            coverage,
            elevationScale,
            edgeDistance: 1,
            isWireframe: false
          })).draw();
        }
      }]);
      return GridCellLayer2;
    }(ColumnLayer);
    GridCellLayer.layerName = "GridCellLayer";
    GridCellLayer.defaultProps = defaultProps8;
  }
});

// node_modules/@math.gl/polygon/dist/esm/polygon-utils.js
var init_polygon_utils = __esm({
  "node_modules/@math.gl/polygon/dist/esm/polygon-utils.js"() {
    init_esm3();
  }
});

// node_modules/@math.gl/polygon/dist/esm/polygon.js
var init_polygon = __esm({
  "node_modules/@math.gl/polygon/dist/esm/polygon.js"() {
    init_defineProperty();
    init_esm3();
    init_polygon_utils();
  }
});

// node_modules/@math.gl/polygon/dist/esm/earcut.js
var init_earcut = __esm({
  "node_modules/@math.gl/polygon/dist/esm/earcut.js"() {
    init_polygon_utils();
  }
});

// node_modules/@math.gl/polygon/dist/esm/utils.js
function push(target, source) {
  const size = source.length;
  const startIndex = target.length;
  if (startIndex > 0) {
    let isDuplicate = true;
    for (let i = 0; i < size; i++) {
      if (target[startIndex - size + i] !== source[i]) {
        isDuplicate = false;
        break;
      }
    }
    if (isDuplicate) {
      return false;
    }
  }
  for (let i = 0; i < size; i++) {
    target[startIndex + i] = source[i];
  }
  return true;
}
function copy(target, source) {
  const size = source.length;
  for (let i = 0; i < size; i++) {
    target[i] = source[i];
  }
}
function getPointAtIndex(positions, index, size, offset, out = []) {
  const startI = offset + index * size;
  for (let i = 0; i < size; i++) {
    out[i] = positions[startI + i];
  }
  return out;
}
var init_utils = __esm({
  "node_modules/@math.gl/polygon/dist/esm/utils.js"() {
  }
});

// node_modules/@math.gl/polygon/dist/esm/lineclip.js
function intersect(a, b, edge, bbox, out = []) {
  let t;
  let snap;
  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }
  for (let i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
  }
  return out;
}
function bitCode(p, bbox) {
  let code = 0;
  if (p[0] < bbox[0])
    code |= 1;
  else if (p[0] > bbox[2])
    code |= 2;
  if (p[1] < bbox[1])
    code |= 4;
  else if (p[1] > bbox[3])
    code |= 8;
  return code;
}
var init_lineclip = __esm({
  "node_modules/@math.gl/polygon/dist/esm/lineclip.js"() {
    init_utils();
  }
});

// node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
function cutPolylineByGrid(positions, options) {
  const {
    size = 2,
    broken = false,
    gridResolution = 10,
    gridOffset = [0, 0],
    startIndex = 0,
    endIndex = positions.length
  } = options || {};
  const numPoints = (endIndex - startIndex) / size;
  let part = [];
  const result = [part];
  const a = getPointAtIndex(positions, 0, size, startIndex);
  let b;
  let codeB;
  const cell = getGridCell(a, gridResolution, gridOffset, []);
  const scratchPoint = [];
  push(part, a);
  for (let i = 1; i < numPoints; i++) {
    b = getPointAtIndex(positions, i, size, startIndex, b);
    codeB = bitCode(b, cell);
    while (codeB) {
      intersect(a, b, codeB, cell, scratchPoint);
      const codeAlt = bitCode(scratchPoint, cell);
      if (codeAlt) {
        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);
        codeB = codeAlt;
      }
      push(part, scratchPoint);
      copy(a, scratchPoint);
      moveToNeighborCell(cell, gridResolution, codeB);
      if (broken && part.length > size) {
        part = [];
        result.push(part);
        push(part, a);
      }
      codeB = bitCode(b, cell);
    }
    push(part, b);
    copy(a, b);
  }
  return broken ? result : result[0];
}
function concatInPlace(arr1, arr2) {
  for (let i = 0; i < arr2.length; i++) {
    arr1.push(arr2[i]);
  }
  return arr1;
}
function cutPolygonByGrid(positions, holeIndices = null, options) {
  if (!positions.length) {
    return [];
  }
  const {
    size = 2,
    gridResolution = 10,
    gridOffset = [0, 0],
    edgeTypes = false
  } = options || {};
  const result = [];
  const queue = [{
    pos: positions,
    types: edgeTypes ? new Array(positions.length / size).fill(TYPE_BORDER) : null,
    holes: holeIndices || []
  }];
  const bbox = [[], []];
  let cell = [];
  while (queue.length) {
    const {
      pos,
      types,
      holes
    } = queue.shift();
    getBoundingBox(pos, size, holes[0] || pos.length, bbox);
    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);
    const code = bitCode(bbox[1], cell);
    if (code) {
      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);
      const polygonLow = {
        pos: parts[0].pos,
        types: parts[0].types,
        holes: []
      };
      const polygonHigh = {
        pos: parts[1].pos,
        types: parts[1].types,
        holes: []
      };
      queue.push(polygonLow, polygonHigh);
      for (let i = 0; i < holes.length; i++) {
        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);
        if (parts[0]) {
          polygonLow.holes.push(polygonLow.pos.length);
          polygonLow.pos = concatInPlace(polygonLow.pos, parts[0].pos);
          if (edgeTypes) {
            polygonLow.types = concatInPlace(polygonLow.types, parts[0].types);
          }
        }
        if (parts[1]) {
          polygonHigh.holes.push(polygonHigh.pos.length);
          polygonHigh.pos = concatInPlace(polygonHigh.pos, parts[1].pos);
          if (edgeTypes) {
            polygonHigh.types = concatInPlace(polygonHigh.types, parts[1].types);
          }
        }
      }
    } else {
      const polygon = {
        positions: pos
      };
      if (edgeTypes) {
        polygon.edgeTypes = types;
      }
      if (holes.length) {
        polygon.holeIndices = holes;
      }
      result.push(polygon);
    }
  }
  return result;
}
function bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {
  const numPoints = (endIndex - startIndex) / size;
  const resultLow = [];
  const resultHigh = [];
  const typesLow = [];
  const typesHigh = [];
  const scratchPoint = [];
  let p;
  let side;
  let type;
  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);
  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);
  let prevType = edgeTypes && edgeTypes[numPoints - 1];
  let lowPointCount = 0;
  let highPointCount = 0;
  for (let i = 0; i < numPoints; i++) {
    p = getPointAtIndex(positions, i, size, startIndex, p);
    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);
    type = edgeTypes && edgeTypes[startIndex / size + i];
    if (side && prevSide && prevSide !== side) {
      intersect(prev, p, edge, bbox, scratchPoint);
      push(resultLow, scratchPoint) && typesLow.push(prevType);
      push(resultHigh, scratchPoint) && typesHigh.push(prevType);
    }
    if (side <= 0) {
      push(resultLow, p) && typesLow.push(type);
      lowPointCount -= side;
    } else if (typesLow.length) {
      typesLow[typesLow.length - 1] = TYPE_INSIDE;
    }
    if (side >= 0) {
      push(resultHigh, p) && typesHigh.push(type);
      highPointCount += side;
    } else if (typesHigh.length) {
      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;
    }
    copy(prev, p);
    prevSide = side;
    prevType = type;
  }
  return [lowPointCount ? {
    pos: resultLow,
    types: edgeTypes && typesLow
  } : null, highPointCount ? {
    pos: resultHigh,
    types: edgeTypes && typesHigh
  } : null];
}
function getGridCell(p, gridResolution, gridOffset, out) {
  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
  const bottom = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
  out[0] = left;
  out[1] = bottom;
  out[2] = left + gridResolution;
  out[3] = bottom + gridResolution;
  return out;
}
function moveToNeighborCell(cell, gridResolution, edge) {
  if (edge & 8) {
    cell[1] += gridResolution;
    cell[3] += gridResolution;
  } else if (edge & 4) {
    cell[1] -= gridResolution;
    cell[3] -= gridResolution;
  } else if (edge & 2) {
    cell[0] += gridResolution;
    cell[2] += gridResolution;
  } else if (edge & 1) {
    cell[0] -= gridResolution;
    cell[2] -= gridResolution;
  }
}
function getBoundingBox(positions, size, endIndex, out) {
  let minX = Infinity;
  let maxX = -Infinity;
  let minY = Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < endIndex; i += size) {
    const x = positions[i];
    const y = positions[i + 1];
    minX = x < minX ? x : minX;
    maxX = x > maxX ? x : maxX;
    minY = y < minY ? y : minY;
    maxY = y > maxY ? y : maxY;
  }
  out[0][0] = minX;
  out[0][1] = minY;
  out[1][0] = maxX;
  out[1][1] = maxY;
  return out;
}
var TYPE_INSIDE, TYPE_BORDER;
var init_cut_by_grid = __esm({
  "node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js"() {
    init_lineclip();
    init_utils();
    TYPE_INSIDE = 0;
    TYPE_BORDER = 1;
  }
});

// node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
function cutPolylineByMercatorBounds(positions, options) {
  const {
    size = 2,
    startIndex = 0,
    endIndex = positions.length,
    normalize: normalize2 = true
  } = options || {};
  const newPositions = positions.slice(startIndex, endIndex);
  wrapLongitudesForShortestPath(newPositions, size, 0, endIndex - startIndex);
  const parts = cutPolylineByGrid(newPositions, {
    size,
    broken: true,
    gridResolution: 360,
    gridOffset: [-180, -180]
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part, size);
    }
  }
  return parts;
}
function cutPolygonByMercatorBounds(positions, holeIndices = null, options) {
  const {
    size = 2,
    normalize: normalize2 = true,
    edgeTypes = false
  } = options || {};
  holeIndices = holeIndices || [];
  const newPositions = [];
  const newHoleIndices = [];
  let srcStartIndex = 0;
  let targetIndex = 0;
  for (let ringIndex = 0; ringIndex <= holeIndices.length; ringIndex++) {
    const srcEndIndex = holeIndices[ringIndex] || positions.length;
    const targetStartIndex = targetIndex;
    const splitIndex = findSplitIndex(positions, size, srcStartIndex, srcEndIndex);
    for (let i = splitIndex; i < srcEndIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    for (let i = srcStartIndex; i < splitIndex; i++) {
      newPositions[targetIndex++] = positions[i];
    }
    wrapLongitudesForShortestPath(newPositions, size, targetStartIndex, targetIndex);
    insertPoleVertices(newPositions, size, targetStartIndex, targetIndex, options === null || options === void 0 ? void 0 : options.maxLatitude);
    srcStartIndex = srcEndIndex;
    newHoleIndices[ringIndex] = targetIndex;
  }
  newHoleIndices.pop();
  const parts = cutPolygonByGrid(newPositions, newHoleIndices, {
    size,
    gridResolution: 360,
    gridOffset: [-180, -180],
    edgeTypes
  });
  if (normalize2) {
    for (const part of parts) {
      shiftLongitudesIntoRange(part.positions, size);
    }
  }
  return parts;
}
function findSplitIndex(positions, size, startIndex, endIndex) {
  let maxLat = -1;
  let pointIndex = -1;
  for (let i = startIndex + 1; i < endIndex; i += size) {
    const lat = Math.abs(positions[i]);
    if (lat > maxLat) {
      maxLat = lat;
      pointIndex = i - 1;
    }
  }
  return pointIndex;
}
function insertPoleVertices(positions, size, startIndex, endIndex, maxLatitude = DEFAULT_MAX_LATITUDE) {
  const firstLng = positions[startIndex];
  const lastLng = positions[endIndex - size];
  if (Math.abs(firstLng - lastLng) > 180) {
    const p = getPointAtIndex(positions, 0, size, startIndex);
    p[0] += Math.round((lastLng - firstLng) / 360) * 360;
    push(positions, p);
    p[1] = Math.sign(p[1]) * maxLatitude;
    push(positions, p);
    p[0] = firstLng;
    push(positions, p);
  }
}
function wrapLongitudesForShortestPath(positions, size, startIndex, endIndex) {
  let prevLng = positions[0];
  let lng;
  for (let i = startIndex; i < endIndex; i += size) {
    lng = positions[i];
    const delta = lng - prevLng;
    if (delta > 180 || delta < -180) {
      lng -= Math.round(delta / 360) * 360;
    }
    positions[i] = prevLng = lng;
  }
}
function shiftLongitudesIntoRange(positions, size) {
  let refLng;
  const pointCount = positions.length / size;
  for (let i = 0; i < pointCount; i++) {
    refLng = positions[i * size];
    if ((refLng + 180) % 360 !== 0) {
      break;
    }
  }
  const delta = -Math.round(refLng / 360) * 360;
  if (delta === 0) {
    return;
  }
  for (let i = 0; i < pointCount; i++) {
    positions[i * size] += delta;
  }
}
var DEFAULT_MAX_LATITUDE;
var init_cut_by_mercator_bounds = __esm({
  "node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js"() {
    init_cut_by_grid();
    init_utils();
    DEFAULT_MAX_LATITUDE = 85.051129;
  }
});

// node_modules/@math.gl/polygon/dist/esm/index.js
var init_esm9 = __esm({
  "node_modules/@math.gl/polygon/dist/esm/index.js"() {
    init_polygon();
    init_polygon_utils();
    init_earcut();
    init_lineclip();
    init_cut_by_grid();
    init_cut_by_mercator_bounds();
    init_polygon();
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path.js
function normalizePath(path, size, gridResolution, wrapLongitude) {
  var flatPath = path;
  if (Array.isArray(path[0])) {
    var length = path.length * size;
    flatPath = new Array(length);
    for (var i = 0; i < path.length; i++) {
      for (var j = 0; j < size; j++) {
        flatPath[i * size + j] = path[i][j] || 0;
      }
    }
  }
  if (gridResolution) {
    return cutPolylineByGrid(flatPath, {
      size,
      gridResolution
    });
  }
  if (wrapLongitude) {
    return cutPolylineByMercatorBounds(flatPath, {
      size
    });
  }
  return flatPath;
}
var init_path2 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path.js"() {
    init_esm9();
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var START_CAP, END_CAP, INVALID, PathTesselator;
var init_path_tesselator = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_path2();
    START_CAP = 1;
    END_CAP = 2;
    INVALID = 4;
    PathTesselator = function(_Tesselator) {
      _inherits(PathTesselator2, _Tesselator);
      function PathTesselator2(opts) {
        _classCallCheck(this, PathTesselator2);
        return _possibleConstructorReturn(this, _getPrototypeOf(PathTesselator2).call(this, _objectSpread4({}, opts, {
          attributes: {
            positions: {
              size: 3,
              padding: 18,
              initialize: true,
              type: opts.fp64 ? Float64Array : Float32Array
            },
            segmentTypes: {
              size: 1,
              type: Uint8ClampedArray
            }
          }
        })));
      }
      _createClass(PathTesselator2, [{
        key: "getGeometryFromBuffer",
        value: function getGeometryFromBuffer(buffer) {
          if (this.normalize) {
            return _get(_getPrototypeOf(PathTesselator2.prototype), "getGeometryFromBuffer", this).call(this, buffer);
          }
          return function() {
            return null;
          };
        }
      }, {
        key: "normalizeGeometry",
        value: function normalizeGeometry(path) {
          if (this.normalize) {
            return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
          }
          return path;
        }
      }, {
        key: "get",
        value: function get(attributeName) {
          return this.attributes[attributeName];
        }
      }, {
        key: "getGeometrySize",
        value: function getGeometrySize(path) {
          if (Array.isArray(path[0])) {
            var size = 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = path[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var subPath = _step.value;
                size += this.getGeometrySize(subPath);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return size;
          }
          var numPoints = this.getPathLength(path);
          if (numPoints < 2) {
            return 0;
          }
          if (this.isClosed(path)) {
            return numPoints < 3 ? 0 : numPoints + 2;
          }
          return numPoints;
        }
      }, {
        key: "updateGeometryAttributes",
        value: function updateGeometryAttributes(path, context) {
          if (context.geometrySize === 0) {
            return;
          }
          if (path && Array.isArray(path[0])) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = path[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var subPath = _step2.value;
                var geometrySize = this.getGeometrySize(subPath);
                context.geometrySize = geometrySize;
                this.updateGeometryAttributes(subPath, context);
                context.vertexStart += geometrySize;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } else {
            this._updateSegmentTypes(path, context);
            this._updatePositions(path, context);
          }
        }
      }, {
        key: "_updateSegmentTypes",
        value: function _updateSegmentTypes(path, context) {
          var segmentTypes = this.attributes.segmentTypes;
          var isPathClosed = this.isClosed(path);
          var vertexStart = context.vertexStart, geometrySize = context.geometrySize;
          segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
          if (isPathClosed) {
            segmentTypes[vertexStart] = INVALID;
            segmentTypes[vertexStart + geometrySize - 2] = INVALID;
          } else {
            segmentTypes[vertexStart] += START_CAP;
            segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
          }
          segmentTypes[vertexStart + geometrySize - 1] = INVALID;
        }
      }, {
        key: "_updatePositions",
        value: function _updatePositions(path, context) {
          var positions = this.attributes.positions;
          if (!positions) {
            return;
          }
          var vertexStart = context.vertexStart, geometrySize = context.geometrySize;
          var p = new Array(3);
          for (var i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
            this.getPointOnPath(path, ptIndex, p);
            positions[i * 3] = p[0];
            positions[i * 3 + 1] = p[1];
            positions[i * 3 + 2] = p[2];
          }
        }
      }, {
        key: "getPathLength",
        value: function getPathLength(path) {
          return path.length / this.positionSize;
        }
      }, {
        key: "getPointOnPath",
        value: function getPointOnPath(path, index) {
          var target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          var positionSize = this.positionSize;
          if (index * positionSize >= path.length) {
            index += 1 - path.length / positionSize;
          }
          var i = index * positionSize;
          target[0] = path[i];
          target[1] = path[i + 1];
          target[2] = positionSize === 3 && path[i + 2] || 0;
          return target;
        }
      }, {
        key: "isClosed",
        value: function isClosed(path) {
          if (!this.normalize) {
            return this.opts.loop;
          }
          var positionSize = this.positionSize;
          var lastPointIndex = path.length - positionSize;
          return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
        }
      }]);
      return PathTesselator2;
    }(Tesselator);
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js
var path_layer_vertex_glsl_default;
var init_path_layer_vertex_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js"() {
    path_layer_vertex_glsl_default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * jointType * 4.0 * flipIfTrue(isStartCap), isJoint);\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return currPoint + offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition = instanceStartPositions;\n  geometry.worldPositionAlt = instanceEndPositions;\n  geometry.pickingColor = instancePickingColors;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec2 width = project_pixel_size_to_clipspace(widthPixels);\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      width\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    vec2 width = project_pixel_size(widthPixels);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition, width),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js
var path_layer_fragment_glsl_default;
var init_path_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js"() {
    path_layer_fragment_glsl_default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (jointType > 0.0 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (jointType == 0.0 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js
var DEFAULT_COLOR7, defaultProps9, ATTRIBUTE_TRANSITION, PathLayer;
var init_path_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_path_tesselator();
    init_path_layer_vertex_glsl();
    init_path_layer_fragment_glsl();
    DEFAULT_COLOR7 = [0, 0, 0, 255];
    defaultProps9 = {
      widthUnits: "meters",
      widthScale: {
        type: "number",
        min: 0,
        value: 1
      },
      widthMinPixels: {
        type: "number",
        min: 0,
        value: 0
      },
      widthMaxPixels: {
        type: "number",
        min: 0,
        value: Number.MAX_SAFE_INTEGER
      },
      rounded: false,
      miterLimit: {
        type: "number",
        min: 0,
        value: 4
      },
      billboard: false,
      _pathType: null,
      getPath: {
        type: "accessor",
        value: function value10(object) {
          return object.path;
        }
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR7
      },
      getWidth: {
        type: "accessor",
        value: 1
      }
    };
    ATTRIBUTE_TRANSITION = {
      enter: function enter(value16, chunk) {
        return chunk.length ? chunk.subarray(chunk.length - value16.length) : value16;
      }
    };
    PathLayer = function(_Layer) {
      _inherits(PathLayer2, _Layer);
      function PathLayer2() {
        _classCallCheck(this, PathLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(PathLayer2).apply(this, arguments));
      }
      _createClass(PathLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return _get(_getPrototypeOf(PathLayer2.prototype), "getShaders", this).call(this, {
            vs: path_layer_vertex_glsl_default,
            fs: path_layer_fragment_glsl_default,
            modules: [project32_default, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var _this = this;
          var noAlloc = true;
          var attributeManager = this.getAttributeManager();
          attributeManager.addInstanced({
            positions: {
              size: 3,
              vertexOffset: 1,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: ATTRIBUTE_TRANSITION,
              accessor: "getPath",
              update: this.calculatePositions,
              noAlloc,
              shaderAttributes: {
                instanceLeftPositions: {
                  vertexOffset: 0
                },
                instanceStartPositions: {
                  vertexOffset: 1
                },
                instanceEndPositions: {
                  vertexOffset: 2
                },
                instanceRightPositions: {
                  vertexOffset: 3
                }
              }
            },
            instanceTypes: {
              size: 1,
              type: 5121,
              update: this.calculateSegmentTypes,
              noAlloc
            },
            instanceStrokeWidths: {
              size: 1,
              accessor: "getWidth",
              transition: ATTRIBUTE_TRANSITION,
              defaultValue: 1
            },
            instanceColors: {
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              accessor: "getColor",
              transition: ATTRIBUTE_TRANSITION,
              defaultValue: DEFAULT_COLOR7
            },
            instancePickingColors: {
              size: 3,
              type: 5121,
              accessor: function accessor(object, _ref) {
                var index = _ref.index, value16 = _ref.target;
                return _this.encodePickingColor(object && object.__source ? object.__source.index : index, value16);
              }
            }
          });
          this.setState({
            pathTesselator: new PathTesselator({
              fp64: this.use64bitPositions()
            })
          });
          if (this.props.getDashArray && !this.props.extensions.length) {
            log_default.removed("getDashArray", "PathStyleExtension")();
          }
        }
      }, {
        key: "updateState",
        value: function updateState(_ref2) {
          var oldProps = _ref2.oldProps, props = _ref2.props, changeFlags = _ref2.changeFlags;
          _get(_getPrototypeOf(PathLayer2.prototype), "updateState", this).call(this, {
            props,
            oldProps,
            changeFlags
          });
          var attributeManager = this.getAttributeManager();
          var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
          if (geometryChanged) {
            var pathTesselator = this.state.pathTesselator;
            var buffers = props.data.attributes || {};
            pathTesselator.updateGeometry({
              data: props.data,
              geometryBuffer: buffers.getPath,
              buffers,
              normalize: !props._pathType,
              loop: props._pathType === "loop",
              getGeometry: props.getPath,
              positionFormat: props.positionFormat,
              wrapLongitude: props.wrapLongitude,
              resolution: this.context.viewport.resolution,
              dataChanged: changeFlags.dataChanged
            });
            this.setState({
              numInstances: pathTesselator.instanceCount,
              startIndices: pathTesselator.vertexStarts
            });
            if (!changeFlags.dataChanged) {
              attributeManager.invalidateAll();
            }
          }
          if (changeFlags.extensionsChanged) {
            var gl = this.context.gl;
            if (this.state.model) {
              this.state.model["delete"]();
            }
            this.setState({
              model: this._getModel(gl)
            });
            attributeManager.invalidateAll();
          }
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(params) {
          var info = _get(_getPrototypeOf(PathLayer2.prototype), "getPickingInfo", this).call(this, params);
          var index = info.index;
          var data = this.props.data;
          if (data[0] && data[0].__source) {
            info.object = data.find(function(d) {
              return d.__source.index === index;
            });
          }
          return info;
        }
      }, {
        key: "draw",
        value: function draw(_ref3) {
          var uniforms = _ref3.uniforms;
          var viewport = this.context.viewport;
          var _this$props = this.props, rounded = _this$props.rounded, billboard = _this$props.billboard, miterLimit = _this$props.miterLimit, widthUnits = _this$props.widthUnits, widthScale = _this$props.widthScale, widthMinPixels = _this$props.widthMinPixels, widthMaxPixels = _this$props.widthMaxPixels;
          var widthMultiplier = widthUnits === "pixels" ? viewport.metersPerPixel : 1;
          this.state.model.setUniforms(Object.assign({}, uniforms, {
            jointType: Number(rounded),
            billboard,
            widthScale: widthScale * widthMultiplier,
            miterLimit,
            widthMinPixels,
            widthMaxPixels
          })).draw();
        }
      }, {
        key: "_getModel",
        value: function _getModel(gl) {
          var SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
          var SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
          return new Model(gl, Object.assign({}, this.getShaders(), {
            id: this.props.id,
            geometry: new Geometry({
              drawMode: 4,
              attributes: {
                indices: new Uint16Array(SEGMENT_INDICES),
                positions: {
                  value: new Float32Array(SEGMENT_POSITIONS),
                  size: 2
                }
              }
            }),
            isInstanced: true
          }));
        }
      }, {
        key: "calculatePositions",
        value: function calculatePositions(attribute) {
          var pathTesselator = this.state.pathTesselator;
          attribute.startIndices = pathTesselator.vertexStarts;
          attribute.value = pathTesselator.get("positions");
        }
      }, {
        key: "calculateSegmentTypes",
        value: function calculateSegmentTypes(attribute) {
          var pathTesselator = this.state.pathTesselator;
          attribute.startIndices = pathTesselator.vertexStarts;
          attribute.value = pathTesselator.get("segmentTypes");
        }
      }, {
        key: "wrapLongitude",
        get: function get() {
          return false;
        }
      }]);
      return PathLayer2;
    }(Layer);
    PathLayer.layerName = "PathLayer";
    PathLayer.defaultProps = defaultProps9;
  }
});

// node_modules/earcut/src/earcut.js
var require_earcut = __commonJS({
  "node_modules/earcut/src/earcut.js"(exports, module) {
    "use strict";
    module.exports = earcut3;
    module.exports.default = earcut3;
    function earcut3(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) {
        for (i = start; i < end; i += dim)
          last = insertNode(i, data[i], data[i + 1], last);
      } else {
        for (i = end - dim; i >= start; i -= dim)
          last = insertNode(i, data[i], data[i + 1], last);
      }
      if (last && equals2(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start)
        return start;
      if (!end)
        end = start;
      var p = start, again;
      do {
        again = false;
        if (!p.steiner && (equals2(p, p.next) || area(p.prev, p, p.next) === 0)) {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve(ear, minX, minY, invSize);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
          triangles.push(prev.i / dim | 0);
          triangles.push(ear.i / dim | 0);
          triangles.push(next.i / dim | 0);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var p = c.next;
      while (p !== a) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, invSize) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0)
        return false;
      var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
      var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
      var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
      var p = ear.prevZ, n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals2(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim | 0);
          triangles.push(p.i / dim | 0);
          triangles.push(b.i / dim | 0);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints(p);
    }
    function splitEarcut(start, triangles, dim, minX, minY, invSize) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
            earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        outerNode = eliminateHole(queue[i], outerNode);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      var bridge = findHoleBridge(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      var bridgeReverse = splitPolygon(bridge, hole);
      filterPoints(bridgeReverse, bridgeReverse.next);
      return filterPoints(bridge, bridge.next);
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            m = p.x < p.next.x ? p : p.next;
            if (x === hx)
              return m;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    }
    function sectorContainsSector(m, p) {
      return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
    }
    function indexCurve(start, minX, minY, invSize) {
      var p = start;
      do {
        if (p.z === 0)
          p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, invSize) {
      x = (x - minX) * invSize | 0;
      y = (y - minY) * invSize | 0;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
      (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
      equals2(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals2(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      var o1 = sign(area(p1, q1, p2));
      var o2 = sign(area(p1, q1, q2));
      var o3 = sign(area(p2, q2, p1));
      var o4 = sign(area(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment(p2, q1, q2))
        return true;
      return false;
    }
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    }
    function sign(num) {
      return num > 0 ? 1 : num < 0 ? -1 : 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
          inside = !inside;
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = 0;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut3.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
          var start = holeIndices[i] * dim;
          var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
          (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
        );
      }
      return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut3.flatten = function(data) {
      var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
          for (var d = 0; d < dim; d++)
            result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js
function validate(polygon) {
  polygon = polygon && polygon.positions || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error("invalid polygon");
  }
}
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}
function isNestedRingClosed(simplePolygon) {
  var p0 = simplePolygon[0];
  var p1 = simplePolygon[simplePolygon.length - 1];
  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (var i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}
function copyNestedRing(target, targetStartIndex, simplePolygon, size) {
  var targetIndex = targetStartIndex;
  var len = simplePolygon.length;
  for (var i = 0; i < len; i++) {
    for (var j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }
  if (!isNestedRingClosed(simplePolygon)) {
    for (var _j = 0; _j < size; _j++) {
      target[targetIndex++] = simplePolygon[0][_j] || 0;
    }
  }
  return targetIndex;
}
function copyFlatRing(target, targetStartIndex, positions, size) {
  var srcStartIndex = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var srcEndIndex = arguments.length > 5 ? arguments[5] : void 0;
  srcEndIndex = srcEndIndex || positions.length;
  var srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  var targetIndex = targetStartIndex;
  for (var i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }
  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (var _i = 0; _i < size; _i++) {
      target[targetIndex++] = positions[srcStartIndex + _i];
    }
  }
  return targetIndex;
}
function normalize(polygon, positionSize) {
  validate(polygon);
  var positions = [];
  var holeIndices = [];
  if (polygon.positions) {
    var _polygon = polygon, srcPositions = _polygon.positions, srcHoleIndices = _polygon.holeIndices;
    if (srcHoleIndices) {
      var targetIndex = 0;
      for (var i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);
        holeIndices.push(targetIndex);
      }
      holeIndices.pop();
      return {
        positions,
        holeIndices
      };
    }
    polygon = srcPositions;
  }
  if (Number.isFinite(polygon[0])) {
    copyFlatRing(positions, 0, polygon, positionSize);
    return positions;
  }
  if (!isSimple(polygon)) {
    var _targetIndex = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var simplePolygon = _step.value;
        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);
        holeIndices.push(_targetIndex);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    holeIndices.pop();
    return {
      positions,
      holeIndices
    };
  }
  copyNestedRing(positions, 0, polygon, positionSize);
  return positions;
}
function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {
  var holeIndices = null;
  if (normalizedPolygon.holeIndices) {
    holeIndices = normalizedPolygon.holeIndices.map(function(positionIndex) {
      return positionIndex / positionSize;
    });
  }
  var positions = normalizedPolygon.positions || normalizedPolygon;
  if (preproject) {
    var n = positions.length;
    positions = positions.slice();
    var p = [];
    for (var i = 0; i < n; i += positionSize) {
      p[0] = positions[i];
      p[1] = positions[i + 1];
      var xy = preproject(p);
      positions[i] = xy[0];
      positions[i + 1] = xy[1];
    }
  }
  return (0, import_earcut2.default)(positions, holeIndices, positionSize);
}
var import_earcut2;
var init_polygon2 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js"() {
    import_earcut2 = __toESM(require_earcut());
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var PolygonTesselator;
var init_polygon_tesselator = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_polygon2();
    init_esm6();
    init_esm9();
    PolygonTesselator = function(_Tesselator) {
      _inherits(PolygonTesselator2, _Tesselator);
      function PolygonTesselator2(opts) {
        _classCallCheck(this, PolygonTesselator2);
        var fp64 = opts.fp64, _opts$IndexType = opts.IndexType, IndexType = _opts$IndexType === void 0 ? Uint32Array : _opts$IndexType;
        return _possibleConstructorReturn(this, _getPrototypeOf(PolygonTesselator2).call(this, _objectSpread5({}, opts, {
          attributes: {
            positions: {
              size: 3,
              type: fp64 ? Float64Array : Float32Array
            },
            vertexValid: {
              type: Uint8ClampedArray,
              size: 1
            },
            indices: {
              type: IndexType,
              size: 1
            }
          }
        })));
      }
      _createClass(PolygonTesselator2, [{
        key: "get",
        value: function get(attributeName) {
          var attributes = this.attributes;
          if (attributeName === "indices") {
            return attributes.indices && attributes.indices.subarray(0, this.vertexCount);
          }
          return attributes[attributeName];
        }
      }, {
        key: "updateGeometry",
        value: function updateGeometry(opts) {
          _get(_getPrototypeOf(PolygonTesselator2.prototype), "updateGeometry", this).call(this, opts);
          var externalIndices = this.buffers.indices;
          if (externalIndices) {
            this.vertexCount = (externalIndices.value || externalIndices).length;
          }
        }
      }, {
        key: "normalizeGeometry",
        value: function normalizeGeometry(polygon) {
          if (this.normalize) {
            polygon = normalize(polygon, this.positionSize);
            if (this.opts.resolution) {
              return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {
                size: this.positionSize,
                gridResolution: this.opts.resolution,
                edgeTypes: true
              });
            }
            if (this.opts.wrapLongitude) {
              return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {
                size: this.positionSize,
                maxLatitude: 86,
                edgeTypes: true
              });
            }
          }
          return polygon;
        }
      }, {
        key: "getGeometrySize",
        value: function getGeometrySize(polygon) {
          if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {
            var size = 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var subPolygon = _step.value;
                size += this.getGeometrySize(subPolygon);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return size;
          }
          return (polygon.positions || polygon).length / this.positionSize;
        }
      }, {
        key: "getGeometryFromBuffer",
        value: function getGeometryFromBuffer(buffer) {
          if (this.normalize || !this.buffers.indices) {
            return _get(_getPrototypeOf(PolygonTesselator2.prototype), "getGeometryFromBuffer", this).call(this, buffer);
          }
          return function() {
            return null;
          };
        }
      }, {
        key: "updateGeometryAttributes",
        value: function updateGeometryAttributes(polygon, context) {
          if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var subPolygon = _step2.value;
                var geometrySize = this.getGeometrySize(subPolygon);
                context.geometrySize = geometrySize;
                this.updateGeometryAttributes(subPolygon, context);
                context.vertexStart += geometrySize;
                context.indexStart = this.indexStarts[context.geometryIndex + 1];
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } else {
            this._updateIndices(polygon, context);
            this._updatePositions(polygon, context);
            this._updateVertexValid(polygon, context);
          }
        }
      }, {
        key: "_updateIndices",
        value: function _updateIndices(polygon, _ref) {
          var geometryIndex = _ref.geometryIndex, offset = _ref.vertexStart, indexStart = _ref.indexStart;
          var attributes = this.attributes, indexStarts = this.indexStarts, typedArrayManager = this.typedArrayManager;
          var target = attributes.indices;
          if (!target) {
            return;
          }
          var i = indexStart;
          var indices = getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);
          target = typedArrayManager.allocate(target, indexStart + indices.length, {
            copy: true
          });
          for (var j = 0; j < indices.length; j++) {
            target[i++] = indices[j] + offset;
          }
          indexStarts[geometryIndex + 1] = indexStart + indices.length;
          attributes.indices = target;
        }
      }, {
        key: "_updatePositions",
        value: function _updatePositions(polygon, _ref2) {
          var vertexStart = _ref2.vertexStart, geometrySize = _ref2.geometrySize;
          var positions = this.attributes.positions, positionSize = this.positionSize;
          if (!positions) {
            return;
          }
          var polygonPositions = polygon.positions || polygon;
          for (var i = vertexStart, j = 0; j < geometrySize; i++, j++) {
            var x = polygonPositions[j * positionSize];
            var y = polygonPositions[j * positionSize + 1];
            var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
          }
        }
      }, {
        key: "_updateVertexValid",
        value: function _updateVertexValid(polygon, _ref3) {
          var vertexStart = _ref3.vertexStart, geometrySize = _ref3.geometrySize;
          var vertexValid = this.attributes.vertexValid, positionSize = this.positionSize;
          var holeIndices = polygon && polygon.holeIndices;
          if (polygon && polygon.edgeTypes) {
            vertexValid.set(polygon.edgeTypes, vertexStart);
          } else {
            vertexValid.fill(1, vertexStart, vertexStart + geometrySize);
          }
          if (holeIndices) {
            for (var j = 0; j < holeIndices.length; j++) {
              vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
            }
          }
          vertexValid[vertexStart + geometrySize - 1] = 0;
        }
      }]);
      return PolygonTesselator2;
    }(Tesselator);
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js
var solid_polygon_layer_vertex_main_glsl_default;
var init_solid_polygon_layer_vertex_main_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js"() {
    solid_polygon_layer_vertex_main_glsl_default = "\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n  isValid = vertexValid;\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n  isValid = 1.0;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n    \n#ifdef IS_SIDE_VERTEX\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\n    normal = project_offset_normal(normal);\n#else\n    normal = vec3(0.0, 0.0, 1.0);\n#endif\n    geometry.normal = normal;\n  }\n\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js
var solid_polygon_layer_vertex_top_glsl_default;
var init_solid_polygon_layer_vertex_top_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js"() {
    init_solid_polygon_layer_vertex_main_glsl();
    solid_polygon_layer_vertex_top_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n");
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js
var solid_polygon_layer_vertex_side_glsl_default;
var init_solid_polygon_layer_vertex_side_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js"() {
    init_solid_polygon_layer_vertex_main_glsl();
    solid_polygon_layer_vertex_side_glsl_default = "#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n".concat(solid_polygon_layer_vertex_main_glsl_default, "\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = instancePositions;\n  props.positions64Low = instancePositions64Low;\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n  props.nextPositions = nextPositions;\n  props.nextPositions64Low = nextPositions64Low;\n\n  calculatePosition(props);\n}\n");
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js
var solid_polygon_layer_fragment_glsl_default;
var init_solid_polygon_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js"() {
    solid_polygon_layer_fragment_glsl_default = "#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid < 0.5) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js
var DEFAULT_COLOR8, defaultProps10, ATTRIBUTE_TRANSITION2, SolidPolygonLayer;
var init_solid_polygon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_esm4();
    init_polygon_tesselator();
    init_solid_polygon_layer_vertex_top_glsl();
    init_solid_polygon_layer_vertex_side_glsl();
    init_solid_polygon_layer_fragment_glsl();
    DEFAULT_COLOR8 = [0, 0, 0, 255];
    defaultProps10 = {
      filled: true,
      extruded: false,
      wireframe: false,
      _normalize: true,
      elevationScale: {
        type: "number",
        min: 0,
        value: 1
      },
      getPolygon: {
        type: "accessor",
        value: function value11(f) {
          return f.polygon;
        }
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      getFillColor: {
        type: "accessor",
        value: DEFAULT_COLOR8
      },
      getLineColor: {
        type: "accessor",
        value: DEFAULT_COLOR8
      },
      material: true
    };
    ATTRIBUTE_TRANSITION2 = {
      enter: function enter2(value16, chunk) {
        return chunk.length ? chunk.subarray(chunk.length - value16.length) : value16;
      }
    };
    SolidPolygonLayer = function(_Layer) {
      _inherits(SolidPolygonLayer2, _Layer);
      function SolidPolygonLayer2() {
        _classCallCheck(this, SolidPolygonLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(SolidPolygonLayer2).apply(this, arguments));
      }
      _createClass(SolidPolygonLayer2, [{
        key: "getShaders",
        value: function getShaders(vs) {
          return _get(_getPrototypeOf(SolidPolygonLayer2.prototype), "getShaders", this).call(this, {
            vs,
            fs: solid_polygon_layer_fragment_glsl_default,
            defines: {},
            modules: [project32_default, gouraudLighting, picking_default]
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var _this = this;
          var _this$context = this.context, gl = _this$context.gl, viewport = _this$context.viewport;
          var coordinateSystem = this.props.coordinateSystem;
          if (viewport.isGeospatial && coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
            coordinateSystem = COORDINATE_SYSTEM.LNGLAT;
          }
          this.setState({
            numInstances: 0,
            polygonTesselator: new PolygonTesselator({
              preproject: coordinateSystem === COORDINATE_SYSTEM.LNGLAT && viewport.projectFlat,
              fp64: this.use64bitPositions(),
              IndexType: !gl || hasFeatures(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
            })
          });
          var attributeManager = this.getAttributeManager();
          var noAlloc = true;
          attributeManager.remove(["instancePickingColors"]);
          attributeManager.add({
            indices: {
              size: 1,
              isIndexed: true,
              update: this.calculateIndices,
              noAlloc
            },
            positions: {
              size: 3,
              type: 5130,
              fp64: this.use64bitPositions(),
              transition: ATTRIBUTE_TRANSITION2,
              accessor: "getPolygon",
              update: this.calculatePositions,
              noAlloc,
              shaderAttributes: {
                positions: {
                  vertexOffset: 0,
                  divisor: 0
                },
                instancePositions: {
                  vertexOffset: 0,
                  divisor: 1
                },
                nextPositions: {
                  vertexOffset: 1,
                  divisor: 1
                }
              }
            },
            vertexValid: {
              size: 1,
              divisor: 1,
              type: 5121,
              update: this.calculateVertexValid,
              noAlloc
            },
            elevations: {
              size: 1,
              transition: ATTRIBUTE_TRANSITION2,
              accessor: "getElevation",
              shaderAttributes: {
                elevations: {
                  divisor: 0
                },
                instanceElevations: {
                  divisor: 1
                }
              }
            },
            fillColors: {
              alias: "colors",
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: ATTRIBUTE_TRANSITION2,
              accessor: "getFillColor",
              defaultValue: DEFAULT_COLOR8,
              shaderAttributes: {
                fillColors: {
                  divisor: 0
                },
                instanceFillColors: {
                  divisor: 1
                }
              }
            },
            lineColors: {
              alias: "colors",
              size: this.props.colorFormat.length,
              type: 5121,
              normalized: true,
              transition: ATTRIBUTE_TRANSITION2,
              accessor: "getLineColor",
              defaultValue: DEFAULT_COLOR8,
              shaderAttributes: {
                lineColors: {
                  divisor: 0
                },
                instanceLineColors: {
                  divisor: 1
                }
              }
            },
            pickingColors: {
              size: 3,
              type: 5121,
              accessor: function accessor(object, _ref) {
                var index = _ref.index, value16 = _ref.target;
                return _this.encodePickingColor(object && object.__source ? object.__source.index : index, value16);
              },
              shaderAttributes: {
                pickingColors: {
                  divisor: 0
                },
                instancePickingColors: {
                  divisor: 1
                }
              }
            }
          });
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(params) {
          var info = _get(_getPrototypeOf(SolidPolygonLayer2.prototype), "getPickingInfo", this).call(this, params);
          var index = info.index;
          var data = this.props.data;
          if (data[0] && data[0].__source) {
            info.object = data.find(function(d) {
              return d.__source.index === index;
            });
          }
          return info;
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var _this$props = this.props, extruded = _this$props.extruded, filled = _this$props.filled, wireframe = _this$props.wireframe, elevationScale = _this$props.elevationScale;
          var _this$state = this.state, topModel = _this$state.topModel, sideModel = _this$state.sideModel, polygonTesselator = _this$state.polygonTesselator;
          var renderUniforms = Object.assign({}, uniforms, {
            extruded: Boolean(extruded),
            elevationScale
          });
          if (sideModel) {
            sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
            sideModel.setUniforms(renderUniforms);
            if (wireframe) {
              sideModel.setDrawMode(3);
              sideModel.setUniforms({
                isWireframe: true
              }).draw();
            }
            if (filled) {
              sideModel.setDrawMode(6);
              sideModel.setUniforms({
                isWireframe: false
              }).draw();
            }
          }
          if (topModel) {
            topModel.setVertexCount(polygonTesselator.vertexCount);
            topModel.setUniforms(renderUniforms).draw();
          }
        }
      }, {
        key: "updateState",
        value: function updateState(updateParams) {
          _get(_getPrototypeOf(SolidPolygonLayer2.prototype), "updateState", this).call(this, updateParams);
          this.updateGeometry(updateParams);
          var props = updateParams.props, oldProps = updateParams.oldProps, changeFlags = updateParams.changeFlags;
          var attributeManager = this.getAttributeManager();
          var regenerateModels = changeFlags.extensionsChanged || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;
          if (regenerateModels) {
            if (this.state.models) {
              this.state.models.forEach(function(model) {
                return model["delete"]();
              });
            }
            this.setState(this._getModels(this.context.gl));
            attributeManager.invalidateAll();
          }
        }
      }, {
        key: "updateGeometry",
        value: function updateGeometry(_ref3) {
          var props = _ref3.props, oldProps = _ref3.oldProps, changeFlags = _ref3.changeFlags;
          var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
          if (geometryConfigChanged) {
            var polygonTesselator = this.state.polygonTesselator;
            var buffers = props.data.attributes || {};
            polygonTesselator.updateGeometry({
              data: props.data,
              normalize: props._normalize,
              geometryBuffer: buffers.getPolygon,
              buffers,
              getGeometry: props.getPolygon,
              positionFormat: props.positionFormat,
              wrapLongitude: props.wrapLongitude,
              resolution: this.context.viewport.resolution,
              fp64: this.use64bitPositions(),
              dataChanged: changeFlags.dataChanged
            });
            this.setState({
              numInstances: polygonTesselator.instanceCount,
              startIndices: polygonTesselator.vertexStarts
            });
            if (!changeFlags.dataChanged) {
              this.getAttributeManager().invalidateAll();
            }
          }
        }
      }, {
        key: "_getModels",
        value: function _getModels(gl) {
          var _this$props2 = this.props, id = _this$props2.id, filled = _this$props2.filled, extruded = _this$props2.extruded;
          var topModel;
          var sideModel;
          if (filled) {
            var shaders = this.getShaders(solid_polygon_layer_vertex_top_glsl_default);
            shaders.defines.NON_INSTANCED_MODEL = 1;
            topModel = new Model(gl, Object.assign({}, shaders, {
              id: "".concat(id, "-top"),
              drawMode: 4,
              attributes: {
                vertexPositions: new Float32Array([0, 1])
              },
              uniforms: {
                isWireframe: false,
                isSideVertex: false
              },
              vertexCount: 0,
              isIndexed: true
            }));
          }
          if (extruded) {
            sideModel = new Model(gl, Object.assign({}, this.getShaders(solid_polygon_layer_vertex_side_glsl_default), {
              id: "".concat(id, "-side"),
              geometry: new Geometry({
                drawMode: 1,
                vertexCount: 4,
                attributes: {
                  vertexPositions: {
                    size: 2,
                    value: new Float32Array([1, 0, 0, 0, 0, 1, 1, 1])
                  }
                }
              }),
              instanceCount: 0,
              isInstanced: 1
            }));
            sideModel.userData.excludeAttributes = {
              indices: true
            };
          }
          return {
            models: [sideModel, topModel].filter(Boolean),
            topModel,
            sideModel
          };
        }
      }, {
        key: "calculateIndices",
        value: function calculateIndices(attribute) {
          var polygonTesselator = this.state.polygonTesselator;
          attribute.startIndices = polygonTesselator.indexStarts;
          attribute.value = polygonTesselator.get("indices");
        }
      }, {
        key: "calculatePositions",
        value: function calculatePositions(attribute) {
          var polygonTesselator = this.state.polygonTesselator;
          attribute.startIndices = polygonTesselator.vertexStarts;
          attribute.value = polygonTesselator.get("positions");
        }
      }, {
        key: "calculateVertexValid",
        value: function calculateVertexValid(attribute) {
          attribute.value = this.state.polygonTesselator.get("vertexValid");
        }
      }, {
        key: "wrapLongitude",
        get: function get() {
          return false;
        }
      }]);
      return SolidPolygonLayer2;
    }(Layer);
    SolidPolygonLayer.layerName = "SolidPolygonLayer";
    SolidPolygonLayer.defaultProps = defaultProps10;
  }
});

// node_modules/@deck.gl/layers/dist/esm/utils.js
function replaceInRange(_ref) {
  var data = _ref.data, getIndex = _ref.getIndex, dataRange = _ref.dataRange, replace = _ref.replace;
  var _dataRange$startRow = dataRange.startRow, startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow, _dataRange$endRow = dataRange.endRow, endRow = _dataRange$endRow === void 0 ? Infinity : _dataRange$endRow;
  var count2 = data.length;
  var replaceStart = count2;
  var replaceEnd = count2;
  for (var i = 0; i < count2; i++) {
    var row = getIndex(data[i]);
    if (replaceStart > i && row >= startRow) {
      replaceStart = i;
    }
    if (row >= endRow) {
      replaceEnd = i;
      break;
    }
  }
  var index = replaceStart;
  var dataLengthChanged = replaceEnd - replaceStart !== replace.length;
  var endChunk = dataLengthChanged && data.slice(replaceEnd);
  for (var _i = 0; _i < replace.length; _i++) {
    data[index++] = replace[_i];
  }
  if (dataLengthChanged) {
    for (var _i2 = 0; _i2 < endChunk.length; _i2++) {
      data[index++] = endChunk[_i2];
    }
    data.length = index;
  }
  return {
    startRow: replaceStart,
    endRow: replaceStart + replace.length
  };
}
var init_utils2 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/utils.js"() {
  }
});

// node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js
var defaultLineColor, defaultFillColor, defaultProps11, PolygonLayer;
var init_polygon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/polygon-layer/polygon-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm6();
    init_solid_polygon_layer();
    init_path_layer();
    init_polygon2();
    init_utils2();
    defaultLineColor = [0, 0, 0, 255];
    defaultFillColor = [0, 0, 0, 255];
    defaultProps11 = {
      stroked: true,
      filled: true,
      extruded: false,
      elevationScale: 1,
      wireframe: false,
      _normalize: true,
      lineWidthUnits: "meters",
      lineWidthScale: 1,
      lineWidthMinPixels: 0,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      lineJointRounded: false,
      lineMiterLimit: 4,
      getPolygon: {
        type: "accessor",
        value: function value12(f) {
          return f.polygon;
        }
      },
      getFillColor: {
        type: "accessor",
        value: defaultFillColor
      },
      getLineColor: {
        type: "accessor",
        value: defaultLineColor
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      material: true
    };
    PolygonLayer = function(_CompositeLayer) {
      _inherits(PolygonLayer2, _CompositeLayer);
      function PolygonLayer2() {
        _classCallCheck(this, PolygonLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(PolygonLayer2).apply(this, arguments));
      }
      _createClass(PolygonLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          this.state = {
            paths: []
          };
          if (this.props.getLineDashArray) {
            log_default.removed("getLineDashArray", "PathStyleExtension")();
          }
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var _this = this;
          var oldProps = _ref.oldProps, props = _ref.props, changeFlags = _ref.changeFlags;
          var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);
          if (geometryChanged && Array.isArray(changeFlags.dataChanged)) {
            var paths = this.state.paths.slice();
            var pathsDiff = changeFlags.dataChanged.map(function(dataRange) {
              return replaceInRange({
                data: paths,
                getIndex: function getIndex(p) {
                  return p.__source.index;
                },
                dataRange,
                replace: _this._getPaths(dataRange)
              });
            });
            this.setState({
              paths,
              pathsDiff
            });
          } else if (geometryChanged) {
            this.setState({
              paths: this._getPaths(),
              pathsDiff: null
            });
          }
        }
      }, {
        key: "_getPaths",
        value: function _getPaths() {
          var dataRange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var _this$props = this.props, data = _this$props.data, getPolygon = _this$props.getPolygon, positionFormat = _this$props.positionFormat, _normalize = _this$props._normalize;
          var paths = [];
          var positionSize = positionFormat === "XY" ? 2 : 3;
          var startRow = dataRange.startRow, endRow = dataRange.endRow;
          var _createIterable = createIterable(data, startRow, endRow), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var object = _step.value;
              objectInfo.index++;
              var polygon = getPolygon(object, objectInfo);
              if (_normalize) {
                polygon = normalize(polygon, positionSize);
              }
              var _polygon = polygon, holeIndices = _polygon.holeIndices;
              var positions = polygon.positions || polygon;
              if (holeIndices) {
                for (var i = 0; i <= holeIndices.length; i++) {
                  var path = positions.slice(holeIndices[i - 1] || 0, holeIndices[i] || positions.length);
                  paths.push(this.getSubLayerRow({
                    path
                  }, object, objectInfo.index));
                }
              } else {
                paths.push(this.getSubLayerRow({
                  path: positions
                }, object, objectInfo.index));
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return paths;
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this$props2 = this.props, data = _this$props2.data, _dataDiff = _this$props2._dataDiff, stroked = _this$props2.stroked, filled = _this$props2.filled, extruded = _this$props2.extruded, wireframe = _this$props2.wireframe, _normalize = _this$props2._normalize, elevationScale = _this$props2.elevationScale, transitions = _this$props2.transitions, positionFormat = _this$props2.positionFormat;
          var _this$props3 = this.props, lineWidthUnits = _this$props3.lineWidthUnits, lineWidthScale = _this$props3.lineWidthScale, lineWidthMinPixels = _this$props3.lineWidthMinPixels, lineWidthMaxPixels = _this$props3.lineWidthMaxPixels, lineJointRounded = _this$props3.lineJointRounded, lineMiterLimit = _this$props3.lineMiterLimit, lineDashJustified = _this$props3.lineDashJustified;
          var _this$props4 = this.props, getFillColor = _this$props4.getFillColor, getLineColor = _this$props4.getLineColor, getLineWidth = _this$props4.getLineWidth, getLineDashArray = _this$props4.getLineDashArray, getElevation = _this$props4.getElevation, getPolygon = _this$props4.getPolygon, updateTriggers = _this$props4.updateTriggers, material = _this$props4.material;
          var _this$state = this.state, paths = _this$state.paths, pathsDiff = _this$state.pathsDiff;
          var FillLayer = this.getSubLayerClass("fill", SolidPolygonLayer);
          var StrokeLayer = this.getSubLayerClass("stroke", PathLayer);
          var polygonLayer = this.shouldRenderSubLayer("fill", paths) && new FillLayer({
            _dataDiff,
            extruded,
            elevationScale,
            filled,
            wireframe,
            _normalize,
            getElevation,
            getFillColor,
            getLineColor,
            material,
            transitions
          }, this.getSubLayerProps({
            id: "fill",
            updateTriggers: {
              getPolygon: updateTriggers.getPolygon,
              getElevation: updateTriggers.getElevation,
              getFillColor: updateTriggers.getFillColor,
              getLineColor: updateTriggers.getLineColor
            }
          }), {
            data,
            positionFormat,
            getPolygon
          });
          var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("stroke", paths) && new StrokeLayer({
            _dataDiff: pathsDiff && function() {
              return pathsDiff;
            },
            widthUnits: lineWidthUnits,
            widthScale: lineWidthScale,
            widthMinPixels: lineWidthMinPixels,
            widthMaxPixels: lineWidthMaxPixels,
            rounded: lineJointRounded,
            miterLimit: lineMiterLimit,
            dashJustified: lineDashJustified,
            _pathType: "loop",
            transitions: transitions && {
              getWidth: transitions.getLineWidth,
              getColor: transitions.getLineColor,
              getPath: transitions.getPolygon
            },
            getColor: this.getSubLayerAccessor(getLineColor),
            getWidth: this.getSubLayerAccessor(getLineWidth),
            getDashArray: this.getSubLayerAccessor(getLineDashArray)
          }, this.getSubLayerProps({
            id: "stroke",
            updateTriggers: {
              getWidth: updateTriggers.getLineWidth,
              getColor: updateTriggers.getLineColor,
              getDashArray: updateTriggers.getLineDashArray
            }
          }), {
            data: paths,
            positionFormat,
            getPath: function getPath(x) {
              return x.path;
            }
          });
          return [!extruded && polygonLayer, polygonLineLayer, extruded && polygonLayer];
        }
      }]);
      return PolygonLayer2;
    }(CompositeLayer);
    PolygonLayer.layerName = "PolygonLayer";
    PolygonLayer.defaultProps = defaultProps11;
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js
function getGeojsonFeatures(geojson) {
  if (Array.isArray(geojson)) {
    return geojson;
  }
  log_default.assert(geojson.type, "GeoJSON does not have type");
  switch (geojson.type) {
    case "Feature":
      return [geojson];
    case "FeatureCollection":
      log_default.assert(Array.isArray(geojson.features), "GeoJSON does not have features array");
      return geojson.features;
    default:
      return [{
        geometry: geojson
      }];
  }
}
function separateGeojsonFeatures(features, wrapFeature) {
  var dataRange = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };
  var _dataRange$startRow = dataRange.startRow, startRow = _dataRange$startRow === void 0 ? 0 : _dataRange$startRow, _dataRange$endRow = dataRange.endRow, endRow = _dataRange$endRow === void 0 ? features.length : _dataRange$endRow;
  for (var featureIndex = startRow; featureIndex < endRow; featureIndex++) {
    var feature = features[featureIndex];
    log_default.assert(feature && feature.geometry, "GeoJSON does not have geometry");
    var geometry = feature.geometry;
    if (geometry.type === "GeometryCollection") {
      log_default.assert(Array.isArray(geometry.geometries), "GeoJSON does not have geometries array");
      var geometries = geometry.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);
      }
    } else {
      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);
    }
  }
  return separated;
}
function separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {
  var type = geometry.type, coordinates = geometry.coordinates;
  var pointFeatures = separated.pointFeatures, lineFeatures = separated.lineFeatures, polygonFeatures = separated.polygonFeatures, polygonOutlineFeatures = separated.polygonOutlineFeatures;
  if (!validateGeometry(type, coordinates)) {
    log_default.warn("".concat(type, " coordinates are malformed"))();
    return;
  }
  switch (type) {
    case "Point":
      pointFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiPoint":
      coordinates.forEach(function(point) {
        pointFeatures.push(wrapFeature({
          geometry: {
            type: "Point",
            coordinates: point
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "LineString":
      lineFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      break;
    case "MultiLineString":
      coordinates.forEach(function(path) {
        lineFeatures.push(wrapFeature({
          geometry: {
            type: "LineString",
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "Polygon":
      polygonFeatures.push(wrapFeature({
        geometry
      }, sourceFeature, sourceFeatureIndex));
      coordinates.forEach(function(path) {
        polygonOutlineFeatures.push(wrapFeature({
          geometry: {
            type: "LineString",
            coordinates: path
          }
        }, sourceFeature, sourceFeatureIndex));
      });
      break;
    case "MultiPolygon":
      coordinates.forEach(function(polygon) {
        polygonFeatures.push(wrapFeature({
          geometry: {
            type: "Polygon",
            coordinates: polygon
          }
        }, sourceFeature, sourceFeatureIndex));
        polygon.forEach(function(path) {
          polygonOutlineFeatures.push(wrapFeature({
            geometry: {
              type: "LineString",
              coordinates: path
            }
          }, sourceFeature, sourceFeatureIndex));
        });
      });
      break;
    default:
  }
}
function validateGeometry(type, coordinates) {
  var nestLevel = COORDINATE_NEST_LEVEL[type];
  log_default.assert(nestLevel, "Unknown GeoJSON type ".concat(type));
  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }
  return coordinates && Number.isFinite(coordinates[0]);
}
var COORDINATE_NEST_LEVEL;
var init_geojson = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js"() {
    init_esm6();
    COORDINATE_NEST_LEVEL = {
      Point: 1,
      MultiPoint: 2,
      LineString: 2,
      MultiLineString: 3,
      Polygon: 3,
      MultiPolygon: 4
    };
  }
});

// node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js
function getCoordinates(f) {
  return f.geometry.coordinates;
}
var defaultLineColor2, defaultFillColor2, defaultProps12, GeoJsonLayer;
var init_geojson_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_inherits();
    init_esm6();
    init_scatterplot_layer();
    init_path_layer();
    init_solid_polygon_layer();
    init_utils2();
    init_geojson();
    defaultLineColor2 = [0, 0, 0, 255];
    defaultFillColor2 = [0, 0, 0, 255];
    defaultProps12 = {
      stroked: true,
      filled: true,
      extruded: false,
      wireframe: false,
      lineWidthUnits: "meters",
      lineWidthScale: 1,
      lineWidthMinPixels: 0,
      lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
      lineJointRounded: false,
      lineMiterLimit: 4,
      elevationScale: 1,
      pointRadiusUnits: "meters",
      pointRadiusScale: 1,
      pointRadiusMinPixels: 0,
      pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,
      getLineColor: {
        type: "accessor",
        value: defaultLineColor2
      },
      getFillColor: {
        type: "accessor",
        value: defaultFillColor2
      },
      getRadius: {
        type: "accessor",
        value: 1
      },
      getLineWidth: {
        type: "accessor",
        value: 1
      },
      getElevation: {
        type: "accessor",
        value: 1e3
      },
      material: true
    };
    GeoJsonLayer = function(_CompositeLayer) {
      _inherits(GeoJsonLayer2, _CompositeLayer);
      function GeoJsonLayer2() {
        _classCallCheck(this, GeoJsonLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(GeoJsonLayer2).apply(this, arguments));
      }
      _createClass(GeoJsonLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          this.state = {
            features: {}
          };
          if (this.props.getLineDashArray) {
            log_default.removed("getLineDashArray", "PathStyleExtension")();
          }
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, changeFlags = _ref.changeFlags;
          if (!changeFlags.dataChanged) {
            return;
          }
          var features = getGeojsonFeatures(props.data);
          var wrapFeature = this.getSubLayerRow.bind(this);
          if (Array.isArray(changeFlags.dataChanged)) {
            var oldFeatures = this.state.features;
            var newFeatures = {};
            var featuresDiff = {};
            for (var key in oldFeatures) {
              newFeatures[key] = oldFeatures[key].slice();
              featuresDiff[key] = [];
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = changeFlags.dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var dataRange = _step.value;
                var partialFeatures = separateGeojsonFeatures(features, wrapFeature, dataRange);
                for (var _key in oldFeatures) {
                  featuresDiff[_key].push(replaceInRange({
                    data: newFeatures[_key],
                    getIndex: function getIndex(f) {
                      return f.__source.index;
                    },
                    dataRange,
                    replace: partialFeatures[_key]
                  }));
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            this.setState({
              features: newFeatures,
              featuresDiff
            });
          } else {
            this.setState({
              features: separateGeojsonFeatures(features, wrapFeature),
              featuresDiff: {}
            });
          }
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this$state = this.state, features = _this$state.features, featuresDiff = _this$state.featuresDiff;
          var pointFeatures = features.pointFeatures, lineFeatures = features.lineFeatures, polygonFeatures = features.polygonFeatures, polygonOutlineFeatures = features.polygonOutlineFeatures;
          var _this$props = this.props, stroked = _this$props.stroked, filled = _this$props.filled, extruded = _this$props.extruded, wireframe = _this$props.wireframe, material = _this$props.material, transitions = _this$props.transitions;
          var _this$props2 = this.props, lineWidthUnits = _this$props2.lineWidthUnits, lineWidthScale = _this$props2.lineWidthScale, lineWidthMinPixels = _this$props2.lineWidthMinPixels, lineWidthMaxPixels = _this$props2.lineWidthMaxPixels, lineJointRounded = _this$props2.lineJointRounded, lineMiterLimit = _this$props2.lineMiterLimit, pointRadiusUnits = _this$props2.pointRadiusUnits, pointRadiusScale = _this$props2.pointRadiusScale, pointRadiusMinPixels = _this$props2.pointRadiusMinPixels, pointRadiusMaxPixels = _this$props2.pointRadiusMaxPixels, elevationScale = _this$props2.elevationScale, lineDashJustified = _this$props2.lineDashJustified;
          var _this$props3 = this.props, getLineColor = _this$props3.getLineColor, getFillColor = _this$props3.getFillColor, getRadius = _this$props3.getRadius, getLineWidth = _this$props3.getLineWidth, getLineDashArray = _this$props3.getLineDashArray, getElevation = _this$props3.getElevation, updateTriggers = _this$props3.updateTriggers;
          var PolygonFillLayer = this.getSubLayerClass("polygons-fill", SolidPolygonLayer);
          var PolygonStrokeLayer = this.getSubLayerClass("polygons-stroke", PathLayer);
          var LineStringsLayer = this.getSubLayerClass("line-strings", PathLayer);
          var PointsLayer = this.getSubLayerClass("points", ScatterplotLayer);
          var polygonFillLayer = this.shouldRenderSubLayer("polygons-fill", polygonFeatures) && new PolygonFillLayer({
            _dataDiff: featuresDiff.polygonFeatures && function() {
              return featuresDiff.polygonFeatures;
            },
            extruded,
            elevationScale,
            filled,
            wireframe,
            material,
            getElevation: this.getSubLayerAccessor(getElevation),
            getFillColor: this.getSubLayerAccessor(getFillColor),
            getLineColor: this.getSubLayerAccessor(getLineColor),
            transitions: transitions && {
              getPolygon: transitions.geometry,
              getElevation: transitions.getElevation,
              getFillColor: transitions.getFillColor,
              getLineColor: transitions.getLineColor
            }
          }, this.getSubLayerProps({
            id: "polygons-fill",
            updateTriggers: {
              getElevation: updateTriggers.getElevation,
              getFillColor: updateTriggers.getFillColor,
              getLineColor: updateTriggers.getLineColor
            }
          }), {
            data: polygonFeatures,
            getPolygon: getCoordinates
          });
          var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer("polygons-stroke", polygonOutlineFeatures) && new PolygonStrokeLayer({
            _dataDiff: featuresDiff.polygonOutlineFeatures && function() {
              return featuresDiff.polygonOutlineFeatures;
            },
            widthUnits: lineWidthUnits,
            widthScale: lineWidthScale,
            widthMinPixels: lineWidthMinPixels,
            widthMaxPixels: lineWidthMaxPixels,
            rounded: lineJointRounded,
            miterLimit: lineMiterLimit,
            dashJustified: lineDashJustified,
            getColor: this.getSubLayerAccessor(getLineColor),
            getWidth: this.getSubLayerAccessor(getLineWidth),
            getDashArray: this.getSubLayerAccessor(getLineDashArray),
            transitions: transitions && {
              getPath: transitions.geometry,
              getColor: transitions.getLineColor,
              getWidth: transitions.getLineWidth
            }
          }, this.getSubLayerProps({
            id: "polygons-stroke",
            updateTriggers: {
              getColor: updateTriggers.getLineColor,
              getWidth: updateTriggers.getLineWidth,
              getDashArray: updateTriggers.getLineDashArray
            }
          }), {
            data: polygonOutlineFeatures,
            getPath: getCoordinates
          });
          var pathLayer = this.shouldRenderSubLayer("linestrings", lineFeatures) && new LineStringsLayer({
            _dataDiff: featuresDiff.lineFeatures && function() {
              return featuresDiff.lineFeatures;
            },
            widthUnits: lineWidthUnits,
            widthScale: lineWidthScale,
            widthMinPixels: lineWidthMinPixels,
            widthMaxPixels: lineWidthMaxPixels,
            rounded: lineJointRounded,
            miterLimit: lineMiterLimit,
            dashJustified: lineDashJustified,
            getColor: this.getSubLayerAccessor(getLineColor),
            getWidth: this.getSubLayerAccessor(getLineWidth),
            getDashArray: this.getSubLayerAccessor(getLineDashArray),
            transitions: transitions && {
              getPath: transitions.geometry,
              getColor: transitions.getLineColor,
              getWidth: transitions.getLineWidth
            }
          }, this.getSubLayerProps({
            id: "line-strings",
            updateTriggers: {
              getColor: updateTriggers.getLineColor,
              getWidth: updateTriggers.getLineWidth,
              getDashArray: updateTriggers.getLineDashArray
            }
          }), {
            data: lineFeatures,
            getPath: getCoordinates
          });
          var pointLayer = this.shouldRenderSubLayer("points", pointFeatures) && new PointsLayer({
            _dataDiff: featuresDiff.pointFeatures && function() {
              return featuresDiff.pointFeatures;
            },
            stroked,
            filled,
            radiusUnits: pointRadiusUnits,
            radiusScale: pointRadiusScale,
            radiusMinPixels: pointRadiusMinPixels,
            radiusMaxPixels: pointRadiusMaxPixels,
            lineWidthUnits,
            lineWidthScale,
            lineWidthMinPixels,
            lineWidthMaxPixels,
            getFillColor: this.getSubLayerAccessor(getFillColor),
            getLineColor: this.getSubLayerAccessor(getLineColor),
            getRadius: this.getSubLayerAccessor(getRadius),
            getLineWidth: this.getSubLayerAccessor(getLineWidth),
            transitions: transitions && {
              getPosition: transitions.geometry,
              getFillColor: transitions.getFillColor,
              getLineColor: transitions.getLineColor,
              getRadius: transitions.getRadius,
              getLineWidth: transitions.getLineWidth
            }
          }, this.getSubLayerProps({
            id: "points",
            updateTriggers: {
              getFillColor: updateTriggers.getFillColor,
              getLineColor: updateTriggers.getLineColor,
              getRadius: updateTriggers.getRadius,
              getLineWidth: updateTriggers.getLineWidth
            }
          }), {
            data: pointFeatures,
            getPosition: getCoordinates,
            highlightedObjectIndex: this._getHighlightedIndex(pointFeatures)
          });
          return [!extruded && polygonFillLayer, polygonLineLayer, pathLayer, pointLayer, extruded && polygonFillLayer];
        }
      }, {
        key: "_getHighlightedIndex",
        value: function _getHighlightedIndex(data) {
          var highlightedObjectIndex = this.props.highlightedObjectIndex;
          return Number.isFinite(highlightedObjectIndex) ? data.findIndex(function(d) {
            return d.__source.index === highlightedObjectIndex;
          }) : null;
        }
      }]);
      return GeoJsonLayer2;
    }(CompositeLayer);
    GeoJsonLayer.layerName = "GeoJsonLayer";
    GeoJsonLayer.defaultProps = defaultProps12;
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js
var multi_icon_layer_fragment_glsl_default;
var init_multi_icon_layer_fragment_glsl = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js"() {
    multi_icon_layer_fragment_glsl_default = "#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float buffer;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform bool shouldDrawBackground;\nuniform vec3 backgroundColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying float vGamma;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    if (sdf) {\n      alpha = smoothstep(buffer - vGamma, buffer + vGamma, alpha);\n    }\n    float a = alpha * vColor.a;\n    \n    if (a < alphaCutoff) {\n      if (shouldDrawBackground) {\n        gl_FragColor = vec4(backgroundColor, vColor.a);\n        return;\n      } else {\n        discard;\n      }\n    }\n\n    if (shouldDrawBackground) {\n      gl_FragColor = vec4(mix(backgroundColor, vColor.rgb, alpha), vColor.a * opacity);\n    } else {\n      gl_FragColor = vec4(vColor.rgb, a * opacity);\n    }\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js
var DEFAULT_GAMMA, DEFAULT_BUFFER2, EMPTY_ARRAY, defaultProps13, MultiIconLayer;
var init_multi_icon_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/multi-icon-layer/multi-icon-layer.js"() {
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_icon_layer();
    init_multi_icon_layer_fragment_glsl();
    DEFAULT_GAMMA = 0.2;
    DEFAULT_BUFFER2 = 192 / 256;
    EMPTY_ARRAY = [];
    defaultProps13 = {
      backgroundColor: {
        type: "color",
        value: null,
        optional: true
      },
      getIconOffsets: {
        type: "accessor",
        value: function value13(x) {
          return x.offsets;
        }
      }
    };
    MultiIconLayer = function(_IconLayer) {
      _inherits(MultiIconLayer2, _IconLayer);
      function MultiIconLayer2() {
        _classCallCheck(this, MultiIconLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(MultiIconLayer2).apply(this, arguments));
      }
      _createClass(MultiIconLayer2, [{
        key: "getShaders",
        value: function getShaders() {
          return Object.assign({}, _get(_getPrototypeOf(MultiIconLayer2.prototype), "getShaders", this).call(this), {
            inject: {
              "vs:#decl": "\n  uniform float gamma;\n  varying float vGamma;\n",
              "vs:#main-end": "\n  vGamma = gamma / (sizeScale * iconSize.y);\n"
            },
            fs: multi_icon_layer_fragment_glsl_default
          });
        }
      }, {
        key: "initializeState",
        value: function initializeState() {
          var _this = this;
          _get(_getPrototypeOf(MultiIconLayer2.prototype), "initializeState", this).call(this);
          var attributeManager = this.getAttributeManager();
          attributeManager.addInstanced({
            instanceOffsets: {
              size: 2,
              accessor: "getIconOffsets"
            },
            instancePickingColors: {
              type: 5121,
              size: 3,
              accessor: function accessor(object, _ref) {
                var index = _ref.index, value16 = _ref.target;
                return _this.encodePickingColor(index, value16);
              }
            }
          });
        }
      }, {
        key: "updateState",
        value: function updateState(updateParams) {
          _get(_getPrototypeOf(MultiIconLayer2.prototype), "updateState", this).call(this, updateParams);
          var oldProps = updateParams.oldProps, props = updateParams.props;
          if (props.backgroundColor !== oldProps.backgroundColor) {
            var backgroundColor = Array.isArray(props.backgroundColor) ? props.backgroundColor.map(function(c) {
              return c / 255;
            }).slice(0, 3) : null;
            this.setState({
              backgroundColor
            });
          }
        }
      }, {
        key: "draw",
        value: function draw(_ref2) {
          var uniforms = _ref2.uniforms;
          var sdf = this.props.sdf;
          var backgroundColor = this.state.backgroundColor;
          var shouldDrawBackground = Array.isArray(backgroundColor);
          _get(_getPrototypeOf(MultiIconLayer2.prototype), "draw", this).call(this, {
            uniforms: Object.assign({}, uniforms, {
              buffer: DEFAULT_BUFFER2,
              gamma: DEFAULT_GAMMA,
              sdf: Boolean(sdf),
              backgroundColor: backgroundColor || [0, 0, 0],
              shouldDrawBackground
            })
          });
        }
      }, {
        key: "getInstanceOffset",
        value: function getInstanceOffset(icons) {
          var _this2 = this;
          return icons ? Array.from(icons).map(function(icon) {
            return _get(_getPrototypeOf(MultiIconLayer2.prototype), "getInstanceOffset", _this2).call(_this2, icon);
          }) : EMPTY_ARRAY;
        }
      }, {
        key: "getInstanceColorMode",
        value: function getInstanceColorMode(icons) {
          return 1;
        }
      }, {
        key: "getInstanceIconFrame",
        value: function getInstanceIconFrame(icons) {
          var _this3 = this;
          return icons ? Array.from(icons).map(function(icon) {
            return _get(_getPrototypeOf(MultiIconLayer2.prototype), "getInstanceIconFrame", _this3).call(_this3, icon);
          }) : EMPTY_ARRAY;
        }
      }]);
      return MultiIconLayer2;
    }(IconLayer);
    MultiIconLayer.layerName = "MultiIconLayer";
    MultiIconLayer.defaultProps = defaultProps13;
  }
});

// node_modules/@deck.gl/layers/node_modules/@mapbox/tiny-sdf/index.js
var require_tiny_sdf = __commonJS({
  "node_modules/@deck.gl/layers/node_modules/@mapbox/tiny-sdf/index.js"(exports, module) {
    "use strict";
    module.exports = TinySDF2;
    module.exports.default = TinySDF2;
    var INF = 1e20;
    function TinySDF2(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
      this.fontSize = fontSize || 24;
      this.buffer = buffer === void 0 ? 3 : buffer;
      this.cutoff = cutoff || 0.25;
      this.fontFamily = fontFamily || "sans-serif";
      this.fontWeight = fontWeight || "normal";
      this.radius = radius || 8;
      var size = this.size = this.fontSize + this.buffer * 2;
      var gridSize = size + this.buffer * 2;
      this.canvas = document.createElement("canvas");
      this.canvas.width = this.canvas.height = size;
      this.ctx = this.canvas.getContext("2d");
      this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily;
      this.ctx.textAlign = "left";
      this.ctx.fillStyle = "black";
      this.gridOuter = new Float64Array(gridSize * gridSize);
      this.gridInner = new Float64Array(gridSize * gridSize);
      this.f = new Float64Array(gridSize);
      this.z = new Float64Array(gridSize + 1);
      this.v = new Uint16Array(gridSize);
      this.useMetrics = this.ctx.measureText("A").actualBoundingBoxLeft !== void 0;
      this.middle = Math.round(size / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
    }
    function prepareGrids(imgData, width, height, glyphWidth, glyphHeight, gridOuter, gridInner) {
      gridOuter.fill(INF, 0, width * height);
      gridInner.fill(0, 0, width * height);
      var offset = (width - glyphWidth) / 2;
      for (var y = 0; y < glyphHeight; y++) {
        for (var x = 0; x < glyphWidth; x++) {
          var j = (y + offset) * width + x + offset;
          var a = imgData.data[4 * (y * glyphWidth + x) + 3] / 255;
          if (a === 1) {
            gridOuter[j] = 0;
            gridInner[j] = INF;
          } else if (a === 0) {
            gridOuter[j] = INF;
            gridInner[j] = 0;
          } else {
            var b = Math.max(0, 0.5 - a);
            var c = Math.max(0, a - 0.5);
            gridOuter[j] = b * b;
            gridInner[j] = c * c;
          }
        }
      }
    }
    function extractAlpha(alphaChannel, width, height, gridOuter, gridInner, radius, cutoff) {
      for (var i = 0; i < width * height; i++) {
        var d = Math.sqrt(gridOuter[i]) - Math.sqrt(gridInner[i]);
        alphaChannel[i] = Math.round(255 - 255 * (d / radius + cutoff));
      }
    }
    TinySDF2.prototype._draw = function(char, getMetrics) {
      var textMetrics = this.ctx.measureText(char);
      var advance = textMetrics.width;
      var doubleBuffer = 2 * this.buffer;
      var width, glyphWidth, height, glyphHeight, top;
      var imgTop, imgLeft, baselinePosition;
      if (getMetrics && this.useMetrics) {
        top = Math.floor(textMetrics.actualBoundingBoxAscent);
        baselinePosition = this.buffer + Math.ceil(textMetrics.actualBoundingBoxAscent);
        imgTop = this.buffer;
        imgLeft = this.buffer;
        glyphWidth = Math.min(
          this.size,
          Math.ceil(textMetrics.actualBoundingBoxRight - textMetrics.actualBoundingBoxLeft)
        );
        glyphHeight = Math.min(
          this.size - imgTop,
          Math.ceil(textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent)
        );
        width = glyphWidth + doubleBuffer;
        height = glyphHeight + doubleBuffer;
        this.ctx.textBaseline = "alphabetic";
      } else {
        width = glyphWidth = this.size;
        height = glyphHeight = this.size;
        top = 19 * this.fontSize / 24;
        imgTop = imgLeft = 0;
        baselinePosition = this.middle;
        this.ctx.textBaseline = "middle";
      }
      var imgData;
      if (glyphWidth && glyphHeight) {
        this.ctx.clearRect(imgLeft, imgTop, glyphWidth, glyphHeight);
        this.ctx.fillText(char, this.buffer, baselinePosition);
        imgData = this.ctx.getImageData(imgLeft, imgTop, glyphWidth, glyphHeight);
      }
      var alphaChannel = new Uint8ClampedArray(width * height);
      prepareGrids(imgData, width, height, glyphWidth, glyphHeight, this.gridOuter, this.gridInner);
      edt(this.gridOuter, width, height, this.f, this.v, this.z);
      edt(this.gridInner, width, height, this.f, this.v, this.z);
      extractAlpha(alphaChannel, width, height, this.gridOuter, this.gridInner, this.radius, this.cutoff);
      return {
        data: alphaChannel,
        metrics: {
          width: glyphWidth,
          height: glyphHeight,
          sdfWidth: width,
          sdfHeight: height,
          top,
          left: 0,
          advance
        }
      };
    };
    TinySDF2.prototype.draw = function(char) {
      return this._draw(char, false).data;
    };
    TinySDF2.prototype.drawWithMetrics = function(char) {
      return this._draw(char, true);
    };
    function edt(data, width, height, f, v, z) {
      for (var x = 0; x < width; x++)
        edt1d(data, x, width, height, f, v, z);
      for (var y = 0; y < height; y++)
        edt1d(data, y * width, 1, width, f, v, z);
    }
    function edt1d(grid, offset, stride, length, f, v, z) {
      var q, k, s, r;
      v[0] = 0;
      z[0] = -INF;
      z[1] = INF;
      for (q = 0; q < length; q++)
        f[q] = grid[offset + q * stride];
      for (q = 1, k = 0, s = 0; q < length; q++) {
        do {
          r = v[k];
          s = (f[q] - f[r] + q * q - r * r) / (q - r) / 2;
        } while (s <= z[k] && --k > -1);
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = INF;
      }
      for (q = 0, k = 0; q < length; q++) {
        while (z[k + 1] < q)
          k++;
        r = v[k];
        grid[offset + q * stride] = f[r] + (q - r) * (q - r);
      }
    }
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js
function nextPowOfTwo2(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}
function buildMapping2(_ref) {
  var characterSet = _ref.characterSet, getFontWidth = _ref.getFontWidth, fontHeight = _ref.fontHeight, buffer = _ref.buffer, maxCanvasWidth = _ref.maxCanvasWidth, _ref$mapping = _ref.mapping, mapping = _ref$mapping === void 0 ? {} : _ref$mapping, _ref$xOffset = _ref.xOffset, xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset, _ref$yOffset = _ref.yOffset, yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset;
  var row = 0;
  var x = xOffset;
  var i = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = characterSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _char = _step.value;
      if (!mapping[_char]) {
        var width = getFontWidth(_char, i++);
        if (x + width + buffer * 2 > maxCanvasWidth) {
          x = 0;
          row++;
        }
        mapping[_char] = {
          x: x + buffer,
          y: yOffset + row * (fontHeight + buffer * 2) + buffer,
          width,
          height: fontHeight
        };
        x += width + buffer * 2;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  var rowHeight = fontHeight + buffer * 2;
  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo2(yOffset + (row + 1) * rowHeight)
  };
}
function getTextWidth(text, mapping) {
  var width = 0;
  for (var i = 0; i < text.length; i++) {
    var character = text[i];
    var frameWidth = null;
    var frame = mapping && mapping[character];
    if (frame) {
      frameWidth = frame.width;
    }
    width += frameWidth;
  }
  return width;
}
function breakAll(text, maxWidth, iconMapping) {
  var rows = [];
  var rowStartCharIndex = 0;
  var rowOffsetLeft = 0;
  for (var i = 0; i < text.length; i++) {
    var textWidth = getTextWidth(text[i], iconMapping);
    if (rowOffsetLeft + textWidth > maxWidth) {
      if (rowStartCharIndex < i) {
        rows.push(text.substring(rowStartCharIndex, i));
      }
      rowStartCharIndex = i;
      rowOffsetLeft = 0;
    }
    rowOffsetLeft += textWidth;
  }
  if (rowStartCharIndex < text.length) {
    rows.push(text.substring(rowStartCharIndex));
  }
  return {
    rows,
    lastRowStartCharIndex: rowStartCharIndex,
    lastRowOffsetLeft: rowOffsetLeft
  };
}
function breakWord(text, maxWidth, iconMapping) {
  var rows = [];
  var rowStartCharIndex = 0;
  var groupStartCharIndex = 0;
  var rowOffsetLeft = 0;
  var group = null;
  for (var i = 0; i < text.length; i++) {
    if (text[i] === " ") {
      group = text[i];
      groupStartCharIndex = i + 1;
    } else if (i + 1 < text.length && text[i + 1] === " " || i + 1 === text.length) {
      group = text.substring(groupStartCharIndex, i + 1);
      groupStartCharIndex = i + 1;
    } else {
      group = null;
    }
    if (group) {
      var groupWidth = getTextWidth(group, iconMapping);
      if (rowOffsetLeft + groupWidth > maxWidth) {
        var lastGroupStartIndex = groupStartCharIndex - group.length;
        if (rowStartCharIndex < lastGroupStartIndex) {
          rows.push(text.substring(rowStartCharIndex, lastGroupStartIndex));
          rowStartCharIndex = lastGroupStartIndex;
          rowOffsetLeft = 0;
        }
        if (groupWidth > maxWidth) {
          var subGroups = breakAll(group, maxWidth, iconMapping);
          if (subGroups.rows.length > 1) {
            rows = rows.concat(subGroups.rows.slice(0, subGroups.rows.length - 1));
          }
          rowStartCharIndex = rowStartCharIndex + subGroups.lastRowStartCharIndex;
          groupWidth = subGroups.lastRowOffsetLeft;
        }
      }
      rowOffsetLeft += groupWidth;
    }
  }
  if (rowStartCharIndex < text.length) {
    rows.push(text.substring(rowStartCharIndex));
  }
  return {
    rows,
    lastRowStartCharIndex: rowStartCharIndex,
    lastRowOffsetLeft: rowOffsetLeft
  };
}
function autoWrapping(text, wordBreak, maxWidth, iconMapping) {
  if (wordBreak === "break-all") {
    return breakAll(text, maxWidth, iconMapping);
  }
  return breakWord(text, maxWidth, iconMapping);
}
function transformRow(row, iconMapping) {
  var x = 0;
  var rowHeight = 0;
  var leftOffsets = new Array(row.length);
  for (var i = 0; i < row.length; i++) {
    var character = row[i];
    var frame = iconMapping[character];
    if (frame) {
      if (!rowHeight) {
        rowHeight = frame.height;
      }
      leftOffsets[i] = x + frame.width / 2;
      x += frame.width;
    } else {
      log_default.warn("Missing character: ".concat(character))();
      leftOffsets[i] = x;
      x += MISSING_CHAR_WIDTH;
    }
  }
  return {
    leftOffsets,
    rowWidth: x,
    rowHeight
  };
}
function transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping) {
  var result = new Array(paragraph.length);
  var autoWrappingEnabled = (wordBreak === "break-word" || wordBreak === "break-all") && isFinite(maxWidth) && maxWidth > 0;
  var size = [0, 0];
  var rowOffsetTop = 0;
  var lineStartIndex = 0;
  for (var i = 0; i <= paragraph.length; i++) {
    var _char2 = paragraph[i];
    var line = void 0;
    if (_char2 === "\n" || _char2 === void 0) {
      line = paragraph.slice(lineStartIndex, i);
    }
    if (line) {
      var rows = autoWrappingEnabled ? autoWrapping(line, wordBreak, maxWidth, iconMapping).rows : [line];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = rows[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var row = _step2.value;
          var _transformRow = transformRow(row, iconMapping, lineHeight), rowWidth = _transformRow.rowWidth, rowHeight = _transformRow.rowHeight, leftOffsets = _transformRow.leftOffsets;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = leftOffsets[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var x = _step3.value;
              result[lineStartIndex++] = {
                x,
                y: rowOffsetTop + rowHeight / 2,
                rowWidth
              };
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          rowOffsetTop = rowOffsetTop + rowHeight * lineHeight;
          size[0] = autoWrappingEnabled ? maxWidth : Math.max(size[0], rowWidth);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    if (_char2 === "\n") {
      result[lineStartIndex++] = {
        x: 0,
        y: 0,
        rowWidth: 0
      };
    }
  }
  size[1] = rowOffsetTop;
  return {
    characters: result,
    size
  };
}
function getTextFromBuffer(_ref2) {
  var value16 = _ref2.value, length = _ref2.length, stride = _ref2.stride, offset = _ref2.offset, startIndices = _ref2.startIndices;
  var bytesPerElement = value16.BYTES_PER_ELEMENT;
  var elementStride = stride ? stride / bytesPerElement : 1;
  var elementOffset = offset ? offset / bytesPerElement : 0;
  var characterCount = startIndices[length] || Math.floor((value16.length - elementOffset - bytesPerElement) / elementStride) + 1;
  var texts = new Array(length);
  var codes = value16;
  if (elementStride > 1 || elementOffset > 0) {
    codes = new value16.constructor(characterCount);
    for (var i = 0; i < characterCount; i++) {
      codes[i] = value16[i * elementStride + elementOffset];
    }
  }
  for (var index = 0; index < length; index++) {
    var startIndex = startIndices[index];
    var endIndex = startIndices[index + 1] || characterCount;
    texts[index] = String.fromCodePoint.apply(null, codes.subarray(startIndex, endIndex));
  }
  return {
    texts,
    characterCount
  };
}
var MISSING_CHAR_WIDTH;
var init_utils3 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/utils.js"() {
    init_esm6();
    MISSING_CHAR_WIDTH = 32;
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js
var LRUCache;
var init_lru_cache = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/lru-cache.js"() {
    init_classCallCheck();
    init_createClass();
    LRUCache = function() {
      function LRUCache2() {
        var limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;
        _classCallCheck(this, LRUCache2);
        this.limit = limit;
        this.clear();
      }
      _createClass(LRUCache2, [{
        key: "clear",
        value: function clear() {
          this._cache = {};
          this._order = [];
        }
      }, {
        key: "get",
        value: function get(key) {
          var value16 = this._cache[key];
          if (value16) {
            this._deleteOrder(key);
            this._appendOrder(key);
          }
          return value16;
        }
      }, {
        key: "set",
        value: function set(key, value16) {
          if (!this._cache[key]) {
            if (Object.keys(this._cache).length === this.limit) {
              this["delete"](this._order[0]);
            }
            this._cache[key] = value16;
            this._appendOrder(key);
          } else {
            this["delete"](key);
            this._cache[key] = value16;
            this._appendOrder(key);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          var value16 = this._cache[key];
          if (value16) {
            this._deleteCache(key);
            this._deleteOrder(key);
          }
        }
      }, {
        key: "_deleteCache",
        value: function _deleteCache(key) {
          delete this._cache[key];
        }
      }, {
        key: "_deleteOrder",
        value: function _deleteOrder(key) {
          var index = this._order.findIndex(function(o) {
            return o === key;
          });
          if (index >= 0) {
            this._order.splice(index, 1);
          }
        }
      }, {
        key: "_appendOrder",
        value: function _appendOrder(key) {
          this._order.push(key);
        }
      }]);
      return LRUCache2;
    }();
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js
function getDefaultCharacterSet() {
  var charSet = [];
  for (var i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}
function getNewChars(key, characterSet) {
  var cachedFontAtlas = cache.get(key);
  if (!cachedFontAtlas) {
    return characterSet;
  }
  var newChars = [];
  var cachedMapping = cachedFontAtlas.mapping;
  var cachedCharSet = Object.keys(cachedMapping);
  cachedCharSet = new Set(cachedCharSet);
  var charSet = characterSet;
  if (charSet instanceof Array) {
    charSet = new Set(charSet);
  }
  charSet.forEach(function(_char) {
    if (!cachedCharSet.has(_char)) {
      newChars.push(_char);
    }
  });
  return newChars;
}
function populateAlphaChannel(alphaChannel, imageData) {
  for (var i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}
function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
  ctx.fillStyle = "#000";
  ctx.textBaseline = "baseline";
  ctx.textAlign = "left";
}
var import_tiny_sdf, DEFAULT_CHAR_SET, DEFAULT_FONT_FAMILY, DEFAULT_FONT_WEIGHT, DEFAULT_FONT_SIZE, DEFAULT_BUFFER3, DEFAULT_CUTOFF, DEFAULT_RADIUS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE, MAX_CANVAS_WIDTH, BASELINE_SCALE, HEIGHT_SCALE, CACHE_LIMIT, cache, VALID_PROPS, FontAtlasManager;
var init_font_atlas_manager = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/font-atlas-manager.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_esm4();
    import_tiny_sdf = __toESM(require_tiny_sdf());
    init_utils3();
    init_lru_cache();
    DEFAULT_CHAR_SET = getDefaultCharacterSet();
    DEFAULT_FONT_FAMILY = "Monaco, monospace";
    DEFAULT_FONT_WEIGHT = "normal";
    DEFAULT_FONT_SIZE = 64;
    DEFAULT_BUFFER3 = 2;
    DEFAULT_CUTOFF = 0.25;
    DEFAULT_RADIUS = 3;
    GL_TEXTURE_WRAP_S = 10242;
    GL_TEXTURE_WRAP_T = 10243;
    GL_CLAMP_TO_EDGE = 33071;
    MAX_CANVAS_WIDTH = 1024;
    BASELINE_SCALE = 0.9;
    HEIGHT_SCALE = 1.2;
    CACHE_LIMIT = 3;
    cache = new LRUCache(CACHE_LIMIT);
    VALID_PROPS = ["fontFamily", "fontWeight", "characterSet", "fontSize", "sdf", "buffer", "cutoff", "radius"];
    FontAtlasManager = function() {
      function FontAtlasManager2(gl) {
        _classCallCheck(this, FontAtlasManager2);
        this.gl = gl;
        this.props = {
          fontFamily: DEFAULT_FONT_FAMILY,
          fontWeight: DEFAULT_FONT_WEIGHT,
          characterSet: DEFAULT_CHAR_SET,
          fontSize: DEFAULT_FONT_SIZE,
          buffer: DEFAULT_BUFFER3,
          sdf: false,
          cutoff: DEFAULT_CUTOFF,
          radius: DEFAULT_RADIUS
        };
        this._key = null;
        this._texture = new Texture2D(this.gl);
      }
      _createClass(FontAtlasManager2, [{
        key: "finalize",
        value: function finalize() {
          this._texture["delete"]();
        }
      }, {
        key: "setProps",
        value: function setProps() {
          var _this = this;
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          VALID_PROPS.forEach(function(prop) {
            if (prop in props) {
              _this.props[prop] = props[prop];
            }
          });
          var oldKey = this._key;
          this._key = this._getKey();
          var charSet = getNewChars(this._key, this.props.characterSet);
          var cachedFontAtlas = cache.get(this._key);
          if (cachedFontAtlas && charSet.length === 0) {
            if (this._key !== oldKey) {
              this._updateTexture(cachedFontAtlas);
            }
            return;
          }
          var fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);
          this._updateTexture(fontAtlas);
          cache.set(this._key, fontAtlas);
        }
      }, {
        key: "_updateTexture",
        value: function _updateTexture(_ref) {
          var _parameters;
          var canvas = _ref.data, width = _ref.width, height = _ref.height;
          if (this._texture.width !== width || this._texture.height !== height) {
            this._texture.resize({
              width,
              height
            });
          }
          this._texture.setImageData({
            data: canvas,
            width,
            height,
            parameters: (_parameters = {}, _defineProperty(_parameters, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE), _defineProperty(_parameters, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE), _parameters)
          });
          this._texture.generateMipmap();
        }
      }, {
        key: "_generateFontAtlas",
        value: function _generateFontAtlas(key, characterSet, cachedFontAtlas) {
          var _this$props = this.props, fontFamily = _this$props.fontFamily, fontWeight = _this$props.fontWeight, fontSize = _this$props.fontSize, buffer = _this$props.buffer, sdf = _this$props.sdf, radius = _this$props.radius, cutoff = _this$props.cutoff;
          var canvas = cachedFontAtlas && cachedFontAtlas.data;
          if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.width = MAX_CANVAS_WIDTH;
          }
          var ctx = canvas.getContext("2d");
          setTextStyle(ctx, fontFamily, fontSize, fontWeight);
          var _buildMapping = buildMapping2(Object.assign({
            getFontWidth: function getFontWidth(_char2) {
              return ctx.measureText(_char2).width;
            },
            fontHeight: fontSize * HEIGHT_SCALE,
            buffer,
            characterSet,
            maxCanvasWidth: MAX_CANVAS_WIDTH
          }, cachedFontAtlas && {
            mapping: cachedFontAtlas.mapping,
            xOffset: cachedFontAtlas.xOffset,
            yOffset: cachedFontAtlas.yOffset
          })), mapping = _buildMapping.mapping, canvasHeight = _buildMapping.canvasHeight, xOffset = _buildMapping.xOffset, yOffset = _buildMapping.yOffset;
          if (canvas.height !== canvasHeight) {
            var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            canvas.height = canvasHeight;
            ctx.putImageData(imageData, 0, 0);
          }
          setTextStyle(ctx, fontFamily, fontSize, fontWeight);
          if (sdf) {
            var tinySDF = new import_tiny_sdf.default(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
            var _imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = characterSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _char3 = _step.value;
                populateAlphaChannel(tinySDF.draw(_char3), _imageData);
                ctx.putImageData(_imageData, mapping[_char3].x - buffer, mapping[_char3].y - buffer);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          } else {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = characterSet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var _char4 = _step2.value;
                ctx.fillText(_char4, mapping[_char4].x, mapping[_char4].y + fontSize * BASELINE_SCALE);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
          return {
            xOffset,
            yOffset,
            mapping,
            data: canvas,
            width: canvas.width,
            height: canvas.height
          };
        }
      }, {
        key: "_getKey",
        value: function _getKey() {
          var _this$props2 = this.props, gl = _this$props2.gl, fontFamily = _this$props2.fontFamily, fontWeight = _this$props2.fontWeight, fontSize = _this$props2.fontSize, buffer = _this$props2.buffer, sdf = _this$props2.sdf, radius = _this$props2.radius, cutoff = _this$props2.cutoff;
          if (sdf) {
            return "".concat(gl, " ").concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer, " ").concat(radius, " ").concat(cutoff);
          }
          return "".concat(gl, " ").concat(fontFamily, " ").concat(fontWeight, " ").concat(fontSize, " ").concat(buffer);
        }
      }, {
        key: "texture",
        get: function get() {
          return this._texture;
        }
      }, {
        key: "mapping",
        get: function get() {
          var data = cache.get(this._key);
          return data && data.mapping;
        }
      }, {
        key: "scale",
        get: function get() {
          return HEIGHT_SCALE;
        }
      }]);
      return FontAtlasManager2;
    }();
  }
});

// node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var DEFAULT_FONT_SETTINGS, TEXT_ANCHOR, ALIGNMENT_BASELINE, DEFAULT_COLOR9, DEFAULT_LINE_HEIGHT, FONT_SETTINGS_PROPS, defaultProps14, TextLayer;
var init_text_layer = __esm({
  "node_modules/@deck.gl/layers/dist/esm/text-layer/text-layer.js"() {
    init_slicedToArray();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_get();
    init_inherits();
    init_esm6();
    init_multi_icon_layer();
    init_font_atlas_manager();
    init_utils3();
    DEFAULT_FONT_SETTINGS = {
      fontSize: DEFAULT_FONT_SIZE,
      buffer: DEFAULT_BUFFER3,
      sdf: false,
      radius: DEFAULT_RADIUS,
      cutoff: DEFAULT_CUTOFF
    };
    TEXT_ANCHOR = {
      start: 1,
      middle: 0,
      end: -1
    };
    ALIGNMENT_BASELINE = {
      top: 1,
      center: 0,
      bottom: -1
    };
    DEFAULT_COLOR9 = [0, 0, 0, 255];
    DEFAULT_LINE_HEIGHT = 1;
    FONT_SETTINGS_PROPS = ["fontSize", "buffer", "sdf", "radius", "cutoff"];
    defaultProps14 = {
      billboard: true,
      sizeScale: 1,
      sizeUnits: "pixels",
      sizeMinPixels: 0,
      sizeMaxPixels: Number.MAX_SAFE_INTEGER,
      backgroundColor: {
        type: "color",
        value: null,
        optional: true
      },
      characterSet: DEFAULT_CHAR_SET,
      fontFamily: DEFAULT_FONT_FAMILY,
      fontWeight: DEFAULT_FONT_WEIGHT,
      lineHeight: DEFAULT_LINE_HEIGHT,
      fontSettings: {},
      wordBreak: "word-break",
      maxWidth: {
        type: "number",
        value: -1
      },
      getText: {
        type: "accessor",
        value: function value14(x) {
          return x.text;
        }
      },
      getPosition: {
        type: "accessor",
        value: function value15(x) {
          return x.position;
        }
      },
      getColor: {
        type: "accessor",
        value: DEFAULT_COLOR9
      },
      getSize: {
        type: "accessor",
        value: 32
      },
      getAngle: {
        type: "accessor",
        value: 0
      },
      getTextAnchor: {
        type: "accessor",
        value: "middle"
      },
      getAlignmentBaseline: {
        type: "accessor",
        value: "center"
      },
      getPixelOffset: {
        type: "accessor",
        value: [0, 0]
      }
    };
    TextLayer = function(_CompositeLayer) {
      _inherits(TextLayer2, _CompositeLayer);
      function TextLayer2() {
        _classCallCheck(this, TextLayer2);
        return _possibleConstructorReturn(this, _getPrototypeOf(TextLayer2).apply(this, arguments));
      }
      _createClass(TextLayer2, [{
        key: "initializeState",
        value: function initializeState() {
          this.state = {
            styleVersion: 0,
            fontAtlasManager: new FontAtlasManager(this.context.gl)
          };
        }
      }, {
        key: "updateState",
        value: function updateState(_ref) {
          var props = _ref.props, oldProps = _ref.oldProps, changeFlags = _ref.changeFlags;
          var fontChanged = this._fontChanged(oldProps, props);
          if (fontChanged) {
            this._updateFontAtlas(oldProps, props);
          }
          var styleChanged = fontChanged || props.lineHeight !== oldProps.lineHeight || props.wordBreak !== oldProps.wordBreak || props.maxWidth !== oldProps.maxWidth;
          var textChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText);
          if (textChanged) {
            this._updateText();
          }
          if (styleChanged) {
            this.setState({
              styleVersion: this.state.styleVersion + 1
            });
          }
        }
      }, {
        key: "finalizeState",
        value: function finalizeState() {
          _get(_getPrototypeOf(TextLayer2.prototype), "finalizeState", this).call(this);
          this.state.fontAtlasManager.finalize();
        }
      }, {
        key: "getPickingInfo",
        value: function getPickingInfo(_ref2) {
          var info = _ref2.info;
          return Object.assign(info, {
            object: info.index >= 0 ? this.props.data[info.index] : null
          });
        }
      }, {
        key: "_updateFontAtlas",
        value: function _updateFontAtlas(oldProps, props) {
          var characterSet = props.characterSet, fontSettings = props.fontSettings, fontFamily = props.fontFamily, fontWeight = props.fontWeight;
          var fontAtlasManager = this.state.fontAtlasManager;
          fontAtlasManager.setProps(Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {
            characterSet,
            fontFamily,
            fontWeight
          }));
          this.setNeedsRedraw(true);
        }
      }, {
        key: "_fontChanged",
        value: function _fontChanged(oldProps, props) {
          if (oldProps.fontFamily !== props.fontFamily || oldProps.characterSet !== props.characterSet || oldProps.fontWeight !== props.fontWeight) {
            return true;
          }
          if (oldProps.fontSettings === props.fontSettings) {
            return false;
          }
          var oldFontSettings = oldProps.fontSettings || {};
          var fontSettings = props.fontSettings || {};
          return FONT_SETTINGS_PROPS.some(function(prop) {
            return oldFontSettings[prop] !== fontSettings[prop];
          });
        }
      }, {
        key: "_updateText",
        value: function _updateText() {
          var data = this.props.data;
          var textBuffer = data.attributes && data.attributes.getText;
          var getText = this.props.getText;
          var startIndices = data.startIndices;
          var numInstances;
          if (textBuffer && startIndices) {
            var _getTextFromBuffer = getTextFromBuffer(_objectSpread6({}, ArrayBuffer.isView(textBuffer) ? {
              value: textBuffer
            } : textBuffer, {
              length: data.length,
              startIndices
            })), texts = _getTextFromBuffer.texts, characterCount = _getTextFromBuffer.characterCount;
            numInstances = characterCount;
            getText = function getText2(_, _ref3) {
              var index = _ref3.index;
              return texts[index];
            };
          } else {
            var _createIterable = createIterable(data), iterable = _createIterable.iterable, objectInfo = _createIterable.objectInfo;
            startIndices = [0];
            numInstances = 0;
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var object = _step.value;
                objectInfo.index++;
                var text = getText(object, objectInfo) || "";
                numInstances += text.length;
                startIndices.push(numInstances);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          this.setState({
            getText,
            startIndices,
            numInstances
          });
        }
      }, {
        key: "getIconOffsets",
        value: function getIconOffsets(object, objectInfo) {
          var iconMapping = this.state.fontAtlasManager.mapping;
          var getText = this.state.getText;
          var _this$props = this.props, wordBreak = _this$props.wordBreak, maxWidth = _this$props.maxWidth, lineHeight = _this$props.lineHeight, getTextAnchor = _this$props.getTextAnchor, getAlignmentBaseline = _this$props.getAlignmentBaseline;
          var paragraph = getText(object, objectInfo) || "";
          var _transformParagraph = transformParagraph(paragraph, lineHeight, wordBreak, maxWidth, iconMapping), characters = _transformParagraph.characters, _transformParagraph$s = _slicedToArray(_transformParagraph.size, 2), width = _transformParagraph$s[0], height = _transformParagraph$s[1];
          var anchorX = TEXT_ANCHOR[typeof getTextAnchor === "function" ? getTextAnchor(object, objectInfo) : getTextAnchor];
          var anchorY = ALIGNMENT_BASELINE[typeof getAlignmentBaseline === "function" ? getAlignmentBaseline(object, objectInfo) : getAlignmentBaseline];
          var offsets = new Array(paragraph.length * 2);
          var index = 0;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = characters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _step2$value = _step2.value, rowWidth = _step2$value.rowWidth, x = _step2$value.x, y = _step2$value.y;
              var rowOffset = (1 - anchorX) * (width - rowWidth) / 2;
              offsets[index++] = (anchorX - 1) * width / 2 + rowOffset + x;
              offsets[index++] = (anchorY - 1) * height / 2 + y;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          return offsets;
        }
      }, {
        key: "renderLayers",
        value: function renderLayers() {
          var _this$state = this.state, startIndices = _this$state.startIndices, numInstances = _this$state.numInstances, getText = _this$state.getText, _this$state$fontAtlas = _this$state.fontAtlasManager, scale = _this$state$fontAtlas.scale, texture = _this$state$fontAtlas.texture, mapping = _this$state$fontAtlas.mapping, styleVersion = _this$state.styleVersion;
          var _this$props2 = this.props, data = _this$props2.data, _dataDiff = _this$props2._dataDiff, backgroundColor = _this$props2.backgroundColor, getPosition = _this$props2.getPosition, getColor = _this$props2.getColor, getSize = _this$props2.getSize, getAngle = _this$props2.getAngle, getPixelOffset = _this$props2.getPixelOffset, billboard = _this$props2.billboard, sdf = _this$props2.sdf, sizeScale = _this$props2.sizeScale, sizeUnits = _this$props2.sizeUnits, sizeMinPixels = _this$props2.sizeMinPixels, sizeMaxPixels = _this$props2.sizeMaxPixels, transitions = _this$props2.transitions, updateTriggers = _this$props2.updateTriggers;
          var getIconOffsets = this.getIconOffsets.bind(this);
          var SubLayerClass = this.getSubLayerClass("characters", MultiIconLayer);
          return new SubLayerClass({
            sdf,
            iconAtlas: texture,
            iconMapping: mapping,
            backgroundColor,
            getPosition,
            getColor,
            getSize,
            getAngle,
            getPixelOffset,
            billboard,
            sizeScale: sizeScale * scale,
            sizeUnits,
            sizeMinPixels: sizeMinPixels * scale,
            sizeMaxPixels: sizeMaxPixels * scale,
            transitions: transitions && {
              getPosition: transitions.getPosition,
              getAngle: transitions.getAngle,
              getColor: transitions.getColor,
              getSize: transitions.getSize,
              getPixelOffset: updateTriggers.getPixelOffset
            }
          }, this.getSubLayerProps({
            id: "characters",
            updateTriggers: {
              getPosition: updateTriggers.getPosition,
              getAngle: updateTriggers.getAngle,
              getColor: updateTriggers.getColor,
              getSize: updateTriggers.getSize,
              getPixelOffset: updateTriggers.getPixelOffset,
              getIconOffsets: {
                getText: updateTriggers.getText,
                getTextAnchor: updateTriggers.getTextAnchor,
                getAlignmentBaseline: updateTriggers.getAlignmentBaseline,
                styleVersion
              }
            }
          }), {
            data,
            _dataDiff,
            startIndices,
            numInstances,
            getIconOffsets,
            getIcon: getText
          });
        }
      }]);
      return TextLayer2;
    }(CompositeLayer);
    TextLayer.layerName = "TextLayer";
    TextLayer.defaultProps = defaultProps14;
  }
});

// node_modules/@deck.gl/layers/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  ArcLayer: () => ArcLayer,
  BitmapLayer: () => BitmapLayer,
  ColumnLayer: () => ColumnLayer,
  GeoJsonLayer: () => GeoJsonLayer,
  GridCellLayer: () => GridCellLayer,
  IconLayer: () => IconLayer,
  LineLayer: () => LineLayer,
  PathLayer: () => PathLayer,
  PointCloudLayer: () => PointCloudLayer,
  PolygonLayer: () => PolygonLayer,
  ScatterplotLayer: () => ScatterplotLayer,
  SolidPolygonLayer: () => SolidPolygonLayer,
  TextLayer: () => TextLayer,
  _MultiIconLayer: () => MultiIconLayer
});
var init_esm10 = __esm({
  "node_modules/@deck.gl/layers/dist/esm/index.js"() {
    init_arc_layer();
    init_bitmap_layer();
    init_icon_layer();
    init_line_layer();
    init_point_cloud_layer();
    init_scatterplot_layer();
    init_column_layer();
    init_grid_cell_layer();
    init_path_layer();
    init_polygon_layer();
    init_geojson_layer();
    init_text_layer();
    init_solid_polygon_layer();
    init_multi_icon_layer();
  }
});

export {
  ArcLayer,
  BitmapLayer,
  IconLayer,
  LineLayer,
  PointCloudLayer,
  ScatterplotLayer,
  ColumnLayer,
  GridCellLayer,
  PathLayer,
  require_earcut,
  SolidPolygonLayer,
  PolygonLayer,
  GeoJsonLayer,
  MultiIconLayer,
  TextLayer,
  esm_exports,
  init_esm10 as init_esm
};
//# sourceMappingURL=chunk-6266TG4J.js.map
